// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: api/api.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import {
  Account,
  Block,
  BlockHeader,
  ChainParameters,
  DelegatedResource,
  DelegatedResourceAccountIndex,
  DynamicProperties,
  Exchange,
  InternalTransaction,
  MarketOrder,
  MarketOrderList,
  MarketOrderPair,
  MarketOrderPairList,
  MarketPriceList,
  MetricsInfo,
  NodeInfo,
  Permission,
  Proposal,
  Transaction,
  TransactionInfo,
  TransactionInfo_Log,
  Witness,
} from "../core/Tron.js";
import {
  AccountCreateContract,
  AccountPermissionUpdateContract,
  AccountUpdateContract,
  SetAccountIdContract,
} from "../core/contract/account_contract.js";
import {
  AssetIssueContract,
  ParticipateAssetIssueContract,
  TransferAssetContract,
  UnfreezeAssetContract,
  UpdateAssetContract,
} from "../core/contract/asset_issue_contract.js";
import {
  AccountBalanceRequest,
  AccountBalanceResponse,
  BlockBalanceTrace,
  BlockBalanceTrace_BlockIdentifier,
  CancelAllUnfreezeV2Contract,
  DelegateResourceContract,
  FreezeBalanceContract,
  FreezeBalanceV2Contract,
  TransferContract,
  UnDelegateResourceContract,
  UnfreezeBalanceContract,
  UnfreezeBalanceV2Contract,
  WithdrawBalanceContract,
  WithdrawExpireUnfreezeContract,
} from "../core/contract/balance_contract.js";
import {
  ExchangeCreateContract,
  ExchangeInjectContract,
  ExchangeTransactionContract,
  ExchangeWithdrawContract,
} from "../core/contract/exchange_contract.js";
import { MarketCancelOrderContract, MarketSellAssetContract } from "../core/contract/market_contract.js";
import {
  ProposalApproveContract,
  ProposalCreateContract,
  ProposalDeleteContract,
} from "../core/contract/proposal_contract.js";
import {
  IncrementalMerkleTree,
  IncrementalMerkleVoucher,
  IncrementalMerkleVoucherInfo,
  OutputPointInfo,
  ReceiveDescription,
  SpendDescription,
} from "../core/contract/shield_contract.js";
import {
  ClearABIContract,
  CreateSmartContract,
  SmartContract,
  SmartContractDataWrapper,
  TriggerSmartContract,
  UpdateEnergyLimitContract,
  UpdateSettingContract,
} from "../core/contract/smart_contract.js";
import {
  BuyStorageBytesContract,
  BuyStorageContract,
  SellStorageContract,
  UpdateBrokerageContract,
} from "../core/contract/storage_contract.js";
import {
  VoteWitnessContract,
  WitnessCreateContract,
  WitnessUpdateContract,
} from "../core/contract/witness_contract.js";

export const protobufPackage = "protocol";

export interface Return {
  result: boolean;
  code: Return_responseCode;
  message: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export enum Return_responseCode {
  SUCCESS = 0,
  /** SIGERROR - error in signature */
  SIGERROR = 1,
  CONTRACT_VALIDATE_ERROR = 2,
  CONTRACT_EXE_ERROR = 3,
  BANDWITH_ERROR = 4,
  DUP_TRANSACTION_ERROR = 5,
  TAPOS_ERROR = 6,
  TOO_BIG_TRANSACTION_ERROR = 7,
  TRANSACTION_EXPIRATION_ERROR = 8,
  SERVER_BUSY = 9,
  NO_CONNECTION = 10,
  NOT_ENOUGH_EFFECTIVE_CONNECTION = 11,
  BLOCK_UNSOLIDIFIED = 12,
  OTHER_ERROR = 20,
  UNRECOGNIZED = -1,
}

export function return_responseCodeFromJSON(object: any): Return_responseCode {
  switch (object) {
    case 0:
    case "SUCCESS":
      return Return_responseCode.SUCCESS;
    case 1:
    case "SIGERROR":
      return Return_responseCode.SIGERROR;
    case 2:
    case "CONTRACT_VALIDATE_ERROR":
      return Return_responseCode.CONTRACT_VALIDATE_ERROR;
    case 3:
    case "CONTRACT_EXE_ERROR":
      return Return_responseCode.CONTRACT_EXE_ERROR;
    case 4:
    case "BANDWITH_ERROR":
      return Return_responseCode.BANDWITH_ERROR;
    case 5:
    case "DUP_TRANSACTION_ERROR":
      return Return_responseCode.DUP_TRANSACTION_ERROR;
    case 6:
    case "TAPOS_ERROR":
      return Return_responseCode.TAPOS_ERROR;
    case 7:
    case "TOO_BIG_TRANSACTION_ERROR":
      return Return_responseCode.TOO_BIG_TRANSACTION_ERROR;
    case 8:
    case "TRANSACTION_EXPIRATION_ERROR":
      return Return_responseCode.TRANSACTION_EXPIRATION_ERROR;
    case 9:
    case "SERVER_BUSY":
      return Return_responseCode.SERVER_BUSY;
    case 10:
    case "NO_CONNECTION":
      return Return_responseCode.NO_CONNECTION;
    case 11:
    case "NOT_ENOUGH_EFFECTIVE_CONNECTION":
      return Return_responseCode.NOT_ENOUGH_EFFECTIVE_CONNECTION;
    case 12:
    case "BLOCK_UNSOLIDIFIED":
      return Return_responseCode.BLOCK_UNSOLIDIFIED;
    case 20:
    case "OTHER_ERROR":
      return Return_responseCode.OTHER_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Return_responseCode.UNRECOGNIZED;
  }
}

export function return_responseCodeToJSON(object: Return_responseCode): string {
  switch (object) {
    case Return_responseCode.SUCCESS:
      return "SUCCESS";
    case Return_responseCode.SIGERROR:
      return "SIGERROR";
    case Return_responseCode.CONTRACT_VALIDATE_ERROR:
      return "CONTRACT_VALIDATE_ERROR";
    case Return_responseCode.CONTRACT_EXE_ERROR:
      return "CONTRACT_EXE_ERROR";
    case Return_responseCode.BANDWITH_ERROR:
      return "BANDWITH_ERROR";
    case Return_responseCode.DUP_TRANSACTION_ERROR:
      return "DUP_TRANSACTION_ERROR";
    case Return_responseCode.TAPOS_ERROR:
      return "TAPOS_ERROR";
    case Return_responseCode.TOO_BIG_TRANSACTION_ERROR:
      return "TOO_BIG_TRANSACTION_ERROR";
    case Return_responseCode.TRANSACTION_EXPIRATION_ERROR:
      return "TRANSACTION_EXPIRATION_ERROR";
    case Return_responseCode.SERVER_BUSY:
      return "SERVER_BUSY";
    case Return_responseCode.NO_CONNECTION:
      return "NO_CONNECTION";
    case Return_responseCode.NOT_ENOUGH_EFFECTIVE_CONNECTION:
      return "NOT_ENOUGH_EFFECTIVE_CONNECTION";
    case Return_responseCode.BLOCK_UNSOLIDIFIED:
      return "BLOCK_UNSOLIDIFIED";
    case Return_responseCode.OTHER_ERROR:
      return "OTHER_ERROR";
    case Return_responseCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface BlockReference {
  blockNum: Long;
  blockHash: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface WitnessList {
  witnesses: Witness[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ProposalList {
  proposals: Proposal[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ExchangeList {
  exchanges: Exchange[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface AssetIssueList {
  assetIssue: AssetIssueContract[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface BlockList {
  block: Block[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TransactionList {
  transaction: Transaction[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TransactionIdList {
  txId: string[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface DelegatedResourceMessage {
  fromAddress: Buffer;
  toAddress: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface DelegatedResourceList {
  delegatedResource: DelegatedResource[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface GetAvailableUnfreezeCountRequestMessage {
  ownerAddress: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface GetAvailableUnfreezeCountResponseMessage {
  count: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface CanDelegatedMaxSizeRequestMessage {
  type: number;
  ownerAddress: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface CanDelegatedMaxSizeResponseMessage {
  maxSize: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface CanWithdrawUnfreezeAmountRequestMessage {
  ownerAddress: Buffer;
  timestamp: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface CanWithdrawUnfreezeAmountResponseMessage {
  amount: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface PricesResponseMessage {
  prices: string;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

/** Gossip node list */
export interface NodeList {
  nodes: Node[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

/** Gossip node */
export interface Node {
  address: Address | undefined;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

/** Gossip node address */
export interface Address {
  host: Buffer;
  port: number;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface EmptyMessage {
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface NumberMessage {
  num: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface BytesMessage {
  value: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TimeMessage {
  beginInMilliseconds: Long;
  endInMilliseconds: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface BlockReq {
  idOrNum: string;
  detail: boolean;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface BlockLimit {
  startNum: Long;
  endNum: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TransactionLimit {
  transactionId: Buffer;
  limitNum: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface AccountPaginated {
  account: Account | undefined;
  offset: Long;
  limit: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TimePaginatedMessage {
  timeMessage: TimeMessage | undefined;
  offset: Long;
  limit: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

/** deprecated */
export interface AccountNetMessage {
  freeNetUsed: Long;
  freeNetLimit: Long;
  NetUsed: Long;
  NetLimit: Long;
  assetNetUsed: { [key: string]: Long };
  assetNetLimit: { [key: string]: Long };
  TotalNetLimit: Long;
  TotalNetWeight: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface AccountNetMessage_AssetNetUsedEntry {
  key: string;
  value: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface AccountNetMessage_AssetNetLimitEntry {
  key: string;
  value: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface AccountResourceMessage {
  freeNetUsed: Long;
  freeNetLimit: Long;
  NetUsed: Long;
  NetLimit: Long;
  assetNetUsed: { [key: string]: Long };
  assetNetLimit: { [key: string]: Long };
  TotalNetLimit: Long;
  TotalNetWeight: Long;
  TotalTronPowerWeight: Long;
  tronPowerUsed: Long;
  tronPowerLimit: Long;
  EnergyUsed: Long;
  EnergyLimit: Long;
  TotalEnergyLimit: Long;
  TotalEnergyWeight: Long;
  storageUsed: Long;
  storageLimit: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface AccountResourceMessage_AssetNetUsedEntry {
  key: string;
  value: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface AccountResourceMessage_AssetNetLimitEntry {
  key: string;
  value: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface PaginatedMessage {
  offset: Long;
  limit: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TransactionExtention {
  transaction:
    | Transaction
    | undefined;
  /** transaction id =  sha256(transaction.rowdata) */
  txid: Buffer;
  constantResult: Buffer[];
  result: Return | undefined;
  energyUsed: Long;
  logs: TransactionInfo_Log[];
  internalTransactions: InternalTransaction[];
  energyPenalty: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface EstimateEnergyMessage {
  result: Return | undefined;
  energyRequired: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface BlockExtention {
  transactions: TransactionExtention[];
  blockHeader: BlockHeader | undefined;
  blockid: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface BlockListExtention {
  block: BlockExtention[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TransactionListExtention {
  transaction: TransactionExtention[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface BlockIncrementalMerkleTree {
  number: Long;
  merkleTree: IncrementalMerkleTree | undefined;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TransactionSignWeight {
  permission: Permission | undefined;
  approvedList: Buffer[];
  currentWeight: Long;
  result: TransactionSignWeight_Result | undefined;
  transaction: TransactionExtention | undefined;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TransactionSignWeight_Result {
  code: TransactionSignWeight_Result_responseCode;
  message: string;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export enum TransactionSignWeight_Result_responseCode {
  ENOUGH_PERMISSION = 0,
  /** NOT_ENOUGH_PERMISSION - error in */
  NOT_ENOUGH_PERMISSION = 1,
  SIGNATURE_FORMAT_ERROR = 2,
  COMPUTE_ADDRESS_ERROR = 3,
  /** PERMISSION_ERROR - The key is not in permission */
  PERMISSION_ERROR = 4,
  OTHER_ERROR = 20,
  UNRECOGNIZED = -1,
}

export function transactionSignWeight_Result_responseCodeFromJSON(
  object: any,
): TransactionSignWeight_Result_responseCode {
  switch (object) {
    case 0:
    case "ENOUGH_PERMISSION":
      return TransactionSignWeight_Result_responseCode.ENOUGH_PERMISSION;
    case 1:
    case "NOT_ENOUGH_PERMISSION":
      return TransactionSignWeight_Result_responseCode.NOT_ENOUGH_PERMISSION;
    case 2:
    case "SIGNATURE_FORMAT_ERROR":
      return TransactionSignWeight_Result_responseCode.SIGNATURE_FORMAT_ERROR;
    case 3:
    case "COMPUTE_ADDRESS_ERROR":
      return TransactionSignWeight_Result_responseCode.COMPUTE_ADDRESS_ERROR;
    case 4:
    case "PERMISSION_ERROR":
      return TransactionSignWeight_Result_responseCode.PERMISSION_ERROR;
    case 20:
    case "OTHER_ERROR":
      return TransactionSignWeight_Result_responseCode.OTHER_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionSignWeight_Result_responseCode.UNRECOGNIZED;
  }
}

export function transactionSignWeight_Result_responseCodeToJSON(
  object: TransactionSignWeight_Result_responseCode,
): string {
  switch (object) {
    case TransactionSignWeight_Result_responseCode.ENOUGH_PERMISSION:
      return "ENOUGH_PERMISSION";
    case TransactionSignWeight_Result_responseCode.NOT_ENOUGH_PERMISSION:
      return "NOT_ENOUGH_PERMISSION";
    case TransactionSignWeight_Result_responseCode.SIGNATURE_FORMAT_ERROR:
      return "SIGNATURE_FORMAT_ERROR";
    case TransactionSignWeight_Result_responseCode.COMPUTE_ADDRESS_ERROR:
      return "COMPUTE_ADDRESS_ERROR";
    case TransactionSignWeight_Result_responseCode.PERMISSION_ERROR:
      return "PERMISSION_ERROR";
    case TransactionSignWeight_Result_responseCode.OTHER_ERROR:
      return "OTHER_ERROR";
    case TransactionSignWeight_Result_responseCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TransactionApprovedList {
  approvedList: Buffer[];
  result: TransactionApprovedList_Result | undefined;
  transaction: TransactionExtention | undefined;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TransactionApprovedList_Result {
  code: TransactionApprovedList_Result_responseCode;
  message: string;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export enum TransactionApprovedList_Result_responseCode {
  SUCCESS = 0,
  SIGNATURE_FORMAT_ERROR = 1,
  COMPUTE_ADDRESS_ERROR = 2,
  OTHER_ERROR = 20,
  UNRECOGNIZED = -1,
}

export function transactionApprovedList_Result_responseCodeFromJSON(
  object: any,
): TransactionApprovedList_Result_responseCode {
  switch (object) {
    case 0:
    case "SUCCESS":
      return TransactionApprovedList_Result_responseCode.SUCCESS;
    case 1:
    case "SIGNATURE_FORMAT_ERROR":
      return TransactionApprovedList_Result_responseCode.SIGNATURE_FORMAT_ERROR;
    case 2:
    case "COMPUTE_ADDRESS_ERROR":
      return TransactionApprovedList_Result_responseCode.COMPUTE_ADDRESS_ERROR;
    case 20:
    case "OTHER_ERROR":
      return TransactionApprovedList_Result_responseCode.OTHER_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionApprovedList_Result_responseCode.UNRECOGNIZED;
  }
}

export function transactionApprovedList_Result_responseCodeToJSON(
  object: TransactionApprovedList_Result_responseCode,
): string {
  switch (object) {
    case TransactionApprovedList_Result_responseCode.SUCCESS:
      return "SUCCESS";
    case TransactionApprovedList_Result_responseCode.SIGNATURE_FORMAT_ERROR:
      return "SIGNATURE_FORMAT_ERROR";
    case TransactionApprovedList_Result_responseCode.COMPUTE_ADDRESS_ERROR:
      return "COMPUTE_ADDRESS_ERROR";
    case TransactionApprovedList_Result_responseCode.OTHER_ERROR:
      return "OTHER_ERROR";
    case TransactionApprovedList_Result_responseCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface IvkDecryptParameters {
  startBlockIndex: Long;
  endBlockIndex: Long;
  ivk: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface IvkDecryptAndMarkParameters {
  startBlockIndex: Long;
  endBlockIndex: Long;
  ivk: Buffer;
  ak: Buffer;
  nk: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface OvkDecryptParameters {
  startBlockIndex: Long;
  endBlockIndex: Long;
  ovk: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface DecryptNotes {
  noteTxs: DecryptNotes_NoteTx[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface DecryptNotes_NoteTx {
  note:
    | Note
    | undefined;
  /** transaction id =  sha256(transaction.rowdata) */
  txid: Buffer;
  /** the index of note in receive */
  index: number;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface DecryptNotesMarked {
  noteTxs: DecryptNotesMarked_NoteTx[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface DecryptNotesMarked_NoteTx {
  note:
    | Note
    | undefined;
  /** transaction id =  sha256(transaction.rowdata) */
  txid: Buffer;
  /** the index of note in receive */
  index: number;
  isSpend: boolean;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Note {
  value: Long;
  paymentAddress: string;
  /** random 32 */
  rcm: Buffer;
  memo: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface SpendNote {
  note:
    | Note
    | undefined;
  /** random number for spend authority signature */
  alpha: Buffer;
  voucher:
    | IncrementalMerkleVoucher
    | undefined;
  /** path for cm from leaf to root in merkle tree */
  path: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ReceiveNote {
  note: Note | undefined;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface PrivateParameters {
  transparentFromAddress: Buffer;
  ask: Buffer;
  nsk: Buffer;
  ovk: Buffer;
  fromAmount: Long;
  shieldedSpends: SpendNote[];
  shieldedReceives: ReceiveNote[];
  transparentToAddress: Buffer;
  toAmount: Long;
  /** timeout in seconds, it works only when it bigger than 0 */
  timeout: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface PrivateParametersWithoutAsk {
  transparentFromAddress: Buffer;
  ak: Buffer;
  nsk: Buffer;
  ovk: Buffer;
  fromAmount: Long;
  shieldedSpends: SpendNote[];
  shieldedReceives: ReceiveNote[];
  transparentToAddress: Buffer;
  toAmount: Long;
  /** timeout in seconds, it works only when it bigger than 0 */
  timeout: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface SpendAuthSigParameters {
  ask: Buffer;
  txHash: Buffer;
  alpha: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface NfParameters {
  note: Note | undefined;
  voucher: IncrementalMerkleVoucher | undefined;
  ak: Buffer;
  nk: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ExpandedSpendingKeyMessage {
  ask: Buffer;
  nsk: Buffer;
  ovk: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ViewingKeyMessage {
  ak: Buffer;
  nk: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface IncomingViewingKeyMessage {
  ivk: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface DiversifierMessage {
  d: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface IncomingViewingKeyDiversifierMessage {
  ivk: IncomingViewingKeyMessage | undefined;
  d: DiversifierMessage | undefined;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface PaymentAddressMessage {
  d: DiversifierMessage | undefined;
  pkD: Buffer;
  paymentAddress: string;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ShieldedAddressInfo {
  sk: Buffer;
  ask: Buffer;
  nsk: Buffer;
  ovk: Buffer;
  ak: Buffer;
  nk: Buffer;
  ivk: Buffer;
  d: Buffer;
  pkD: Buffer;
  paymentAddress: string;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface NoteParameters {
  ak: Buffer;
  nk: Buffer;
  note: Note | undefined;
  txid: Buffer;
  index: number;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface SpendResult {
  result: boolean;
  message: string;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TransactionInfoList {
  transactionInfo: TransactionInfo[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface SpendNoteTRC20 {
  note: Note | undefined;
  alpha: Buffer;
  root: Buffer;
  path: Buffer;
  pos: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface PrivateShieldedTRC20Parameters {
  ask: Buffer;
  nsk: Buffer;
  ovk: Buffer;
  fromAmount: string;
  shieldedSpends: SpendNoteTRC20[];
  shieldedReceives: ReceiveNote[];
  transparentToAddress: Buffer;
  toAmount: string;
  shieldedTRC20ContractAddress: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface PrivateShieldedTRC20ParametersWithoutAsk {
  ak: Buffer;
  nsk: Buffer;
  ovk: Buffer;
  fromAmount: string;
  shieldedSpends: SpendNoteTRC20[];
  shieldedReceives: ReceiveNote[];
  transparentToAddress: Buffer;
  toAmount: string;
  shieldedTRC20ContractAddress: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ShieldedTRC20Parameters {
  spendDescription: SpendDescription[];
  receiveDescription: ReceiveDescription[];
  bindingSignature: Buffer;
  messageHash: Buffer;
  triggerContractInput: string;
  parameterType: string;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface IvkDecryptTRC20Parameters {
  startBlockIndex: Long;
  endBlockIndex: Long;
  shieldedTRC20ContractAddress: Buffer;
  ivk: Buffer;
  ak: Buffer;
  nk: Buffer;
  events: string[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface OvkDecryptTRC20Parameters {
  startBlockIndex: Long;
  endBlockIndex: Long;
  ovk: Buffer;
  shieldedTRC20ContractAddress: Buffer;
  events: string[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface DecryptNotesTRC20 {
  noteTxs: DecryptNotesTRC20_NoteTx[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface DecryptNotesTRC20_NoteTx {
  note: Note | undefined;
  position: Long;
  isSpent: boolean;
  txid: Buffer;
  /** the index of note in txid */
  index: number;
  toAmount: string;
  transparentToAddress: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface NfTRC20Parameters {
  note: Note | undefined;
  ak: Buffer;
  nk: Buffer;
  position: Long;
  shieldedTRC20ContractAddress: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface NullifierResult {
  isSpent: boolean;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ShieldedTRC20TriggerContractParameters {
  shieldedTRC20Parameters: ShieldedTRC20Parameters | undefined;
  spendAuthoritySignature: BytesMessage[];
  amount: string;
  transparentToAddress: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

function createBaseReturn(): Return {
  return { result: false, code: 0, message: Buffer.alloc(0), _unknownFields: {} };
}

export const Return = {
  encode(message: Return, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== false) {
      writer.uint32(8).bool(message.result);
    }
    if (message.code !== 0) {
      writer.uint32(16).int32(message.code);
    }
    if (message.message.length !== 0) {
      writer.uint32(26).bytes(message.message);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Return {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReturn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Return {
    return {
      result: isSet(object.result) ? globalThis.Boolean(object.result) : false,
      code: isSet(object.code) ? return_responseCodeFromJSON(object.code) : 0,
      message: isSet(object.message) ? Buffer.from(bytesFromBase64(object.message)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Return): unknown {
    const obj: any = {};
    if (message.result !== false) {
      obj.result = message.result;
    }
    if (message.code !== 0) {
      obj.code = return_responseCodeToJSON(message.code);
    }
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Return>, I>>(base?: I): Return {
    return Return.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Return>, I>>(object: I): Return {
    const message = createBaseReturn();
    message.result = object.result ?? false;
    message.code = object.code ?? 0;
    message.message = object.message ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseBlockReference(): BlockReference {
  return { blockNum: Long.ZERO, blockHash: Buffer.alloc(0), _unknownFields: {} };
}

export const BlockReference = {
  encode(message: BlockReference, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.blockNum.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.blockNum);
    }
    if (message.blockHash.length !== 0) {
      writer.uint32(18).bytes(message.blockHash);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockReference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.blockNum = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockHash = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): BlockReference {
    return {
      blockNum: isSet(object.blockNum) ? Long.fromValue(object.blockNum) : Long.ZERO,
      blockHash: isSet(object.blockHash) ? Buffer.from(bytesFromBase64(object.blockHash)) : Buffer.alloc(0),
    };
  },

  toJSON(message: BlockReference): unknown {
    const obj: any = {};
    if (!message.blockNum.equals(Long.ZERO)) {
      obj.blockNum = (message.blockNum || Long.ZERO).toString();
    }
    if (message.blockHash.length !== 0) {
      obj.blockHash = base64FromBytes(message.blockHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockReference>, I>>(base?: I): BlockReference {
    return BlockReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockReference>, I>>(object: I): BlockReference {
    const message = createBaseBlockReference();
    message.blockNum = (object.blockNum !== undefined && object.blockNum !== null)
      ? Long.fromValue(object.blockNum)
      : Long.ZERO;
    message.blockHash = object.blockHash ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseWitnessList(): WitnessList {
  return { witnesses: [], _unknownFields: {} };
}

export const WitnessList = {
  encode(message: WitnessList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.witnesses) {
      Witness.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WitnessList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWitnessList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.witnesses.push(Witness.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): WitnessList {
    return {
      witnesses: globalThis.Array.isArray(object?.witnesses)
        ? object.witnesses.map((e: any) => Witness.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WitnessList): unknown {
    const obj: any = {};
    if (message.witnesses?.length) {
      obj.witnesses = message.witnesses.map((e) => Witness.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WitnessList>, I>>(base?: I): WitnessList {
    return WitnessList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WitnessList>, I>>(object: I): WitnessList {
    const message = createBaseWitnessList();
    message.witnesses = object.witnesses?.map((e) => Witness.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProposalList(): ProposalList {
  return { proposals: [], _unknownFields: {} };
}

export const ProposalList = {
  encode(message: ProposalList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.proposals) {
      Proposal.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProposalList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProposalList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.proposals.push(Proposal.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ProposalList {
    return {
      proposals: globalThis.Array.isArray(object?.proposals)
        ? object.proposals.map((e: any) => Proposal.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProposalList): unknown {
    const obj: any = {};
    if (message.proposals?.length) {
      obj.proposals = message.proposals.map((e) => Proposal.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProposalList>, I>>(base?: I): ProposalList {
    return ProposalList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProposalList>, I>>(object: I): ProposalList {
    const message = createBaseProposalList();
    message.proposals = object.proposals?.map((e) => Proposal.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExchangeList(): ExchangeList {
  return { exchanges: [], _unknownFields: {} };
}

export const ExchangeList = {
  encode(message: ExchangeList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.exchanges) {
      Exchange.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExchangeList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExchangeList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exchanges.push(Exchange.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ExchangeList {
    return {
      exchanges: globalThis.Array.isArray(object?.exchanges)
        ? object.exchanges.map((e: any) => Exchange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExchangeList): unknown {
    const obj: any = {};
    if (message.exchanges?.length) {
      obj.exchanges = message.exchanges.map((e) => Exchange.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExchangeList>, I>>(base?: I): ExchangeList {
    return ExchangeList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExchangeList>, I>>(object: I): ExchangeList {
    const message = createBaseExchangeList();
    message.exchanges = object.exchanges?.map((e) => Exchange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAssetIssueList(): AssetIssueList {
  return { assetIssue: [], _unknownFields: {} };
}

export const AssetIssueList = {
  encode(message: AssetIssueList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.assetIssue) {
      AssetIssueContract.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetIssueList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetIssueList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetIssue.push(AssetIssueContract.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): AssetIssueList {
    return {
      assetIssue: globalThis.Array.isArray(object?.assetIssue)
        ? object.assetIssue.map((e: any) => AssetIssueContract.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AssetIssueList): unknown {
    const obj: any = {};
    if (message.assetIssue?.length) {
      obj.assetIssue = message.assetIssue.map((e) => AssetIssueContract.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetIssueList>, I>>(base?: I): AssetIssueList {
    return AssetIssueList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetIssueList>, I>>(object: I): AssetIssueList {
    const message = createBaseAssetIssueList();
    message.assetIssue = object.assetIssue?.map((e) => AssetIssueContract.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlockList(): BlockList {
  return { block: [], _unknownFields: {} };
}

export const BlockList = {
  encode(message: BlockList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.block) {
      Block.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.block.push(Block.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): BlockList {
    return { block: globalThis.Array.isArray(object?.block) ? object.block.map((e: any) => Block.fromJSON(e)) : [] };
  },

  toJSON(message: BlockList): unknown {
    const obj: any = {};
    if (message.block?.length) {
      obj.block = message.block.map((e) => Block.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockList>, I>>(base?: I): BlockList {
    return BlockList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockList>, I>>(object: I): BlockList {
    const message = createBaseBlockList();
    message.block = object.block?.map((e) => Block.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactionList(): TransactionList {
  return { transaction: [], _unknownFields: {} };
}

export const TransactionList = {
  encode(message: TransactionList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transaction) {
      Transaction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transaction.push(Transaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionList {
    return {
      transaction: globalThis.Array.isArray(object?.transaction)
        ? object.transaction.map((e: any) => Transaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransactionList): unknown {
    const obj: any = {};
    if (message.transaction?.length) {
      obj.transaction = message.transaction.map((e) => Transaction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionList>, I>>(base?: I): TransactionList {
    return TransactionList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionList>, I>>(object: I): TransactionList {
    const message = createBaseTransactionList();
    message.transaction = object.transaction?.map((e) => Transaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactionIdList(): TransactionIdList {
  return { txId: [], _unknownFields: {} };
}

export const TransactionIdList = {
  encode(message: TransactionIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.txId) {
      writer.uint32(10).string(v!);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionIdList {
    return { txId: globalThis.Array.isArray(object?.txId) ? object.txId.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: TransactionIdList): unknown {
    const obj: any = {};
    if (message.txId?.length) {
      obj.txId = message.txId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionIdList>, I>>(base?: I): TransactionIdList {
    return TransactionIdList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionIdList>, I>>(object: I): TransactionIdList {
    const message = createBaseTransactionIdList();
    message.txId = object.txId?.map((e) => e) || [];
    return message;
  },
};

function createBaseDelegatedResourceMessage(): DelegatedResourceMessage {
  return { fromAddress: Buffer.alloc(0), toAddress: Buffer.alloc(0), _unknownFields: {} };
}

export const DelegatedResourceMessage = {
  encode(message: DelegatedResourceMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddress.length !== 0) {
      writer.uint32(10).bytes(message.fromAddress);
    }
    if (message.toAddress.length !== 0) {
      writer.uint32(18).bytes(message.toAddress);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DelegatedResourceMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegatedResourceMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fromAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toAddress = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): DelegatedResourceMessage {
    return {
      fromAddress: isSet(object.fromAddress) ? Buffer.from(bytesFromBase64(object.fromAddress)) : Buffer.alloc(0),
      toAddress: isSet(object.toAddress) ? Buffer.from(bytesFromBase64(object.toAddress)) : Buffer.alloc(0),
    };
  },

  toJSON(message: DelegatedResourceMessage): unknown {
    const obj: any = {};
    if (message.fromAddress.length !== 0) {
      obj.fromAddress = base64FromBytes(message.fromAddress);
    }
    if (message.toAddress.length !== 0) {
      obj.toAddress = base64FromBytes(message.toAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DelegatedResourceMessage>, I>>(base?: I): DelegatedResourceMessage {
    return DelegatedResourceMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DelegatedResourceMessage>, I>>(object: I): DelegatedResourceMessage {
    const message = createBaseDelegatedResourceMessage();
    message.fromAddress = object.fromAddress ?? Buffer.alloc(0);
    message.toAddress = object.toAddress ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseDelegatedResourceList(): DelegatedResourceList {
  return { delegatedResource: [], _unknownFields: {} };
}

export const DelegatedResourceList = {
  encode(message: DelegatedResourceList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.delegatedResource) {
      DelegatedResource.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DelegatedResourceList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegatedResourceList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.delegatedResource.push(DelegatedResource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): DelegatedResourceList {
    return {
      delegatedResource: globalThis.Array.isArray(object?.delegatedResource)
        ? object.delegatedResource.map((e: any) => DelegatedResource.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DelegatedResourceList): unknown {
    const obj: any = {};
    if (message.delegatedResource?.length) {
      obj.delegatedResource = message.delegatedResource.map((e) => DelegatedResource.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DelegatedResourceList>, I>>(base?: I): DelegatedResourceList {
    return DelegatedResourceList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DelegatedResourceList>, I>>(object: I): DelegatedResourceList {
    const message = createBaseDelegatedResourceList();
    message.delegatedResource = object.delegatedResource?.map((e) => DelegatedResource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAvailableUnfreezeCountRequestMessage(): GetAvailableUnfreezeCountRequestMessage {
  return { ownerAddress: Buffer.alloc(0), _unknownFields: {} };
}

export const GetAvailableUnfreezeCountRequestMessage = {
  encode(message: GetAvailableUnfreezeCountRequestMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress.length !== 0) {
      writer.uint32(10).bytes(message.ownerAddress);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAvailableUnfreezeCountRequestMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailableUnfreezeCountRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): GetAvailableUnfreezeCountRequestMessage {
    return {
      ownerAddress: isSet(object.ownerAddress) ? Buffer.from(bytesFromBase64(object.ownerAddress)) : Buffer.alloc(0),
    };
  },

  toJSON(message: GetAvailableUnfreezeCountRequestMessage): unknown {
    const obj: any = {};
    if (message.ownerAddress.length !== 0) {
      obj.ownerAddress = base64FromBytes(message.ownerAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAvailableUnfreezeCountRequestMessage>, I>>(
    base?: I,
  ): GetAvailableUnfreezeCountRequestMessage {
    return GetAvailableUnfreezeCountRequestMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAvailableUnfreezeCountRequestMessage>, I>>(
    object: I,
  ): GetAvailableUnfreezeCountRequestMessage {
    const message = createBaseGetAvailableUnfreezeCountRequestMessage();
    message.ownerAddress = object.ownerAddress ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseGetAvailableUnfreezeCountResponseMessage(): GetAvailableUnfreezeCountResponseMessage {
  return { count: Long.ZERO, _unknownFields: {} };
}

export const GetAvailableUnfreezeCountResponseMessage = {
  encode(message: GetAvailableUnfreezeCountResponseMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.count);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAvailableUnfreezeCountResponseMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailableUnfreezeCountResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): GetAvailableUnfreezeCountResponseMessage {
    return { count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO };
  },

  toJSON(message: GetAvailableUnfreezeCountResponseMessage): unknown {
    const obj: any = {};
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAvailableUnfreezeCountResponseMessage>, I>>(
    base?: I,
  ): GetAvailableUnfreezeCountResponseMessage {
    return GetAvailableUnfreezeCountResponseMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAvailableUnfreezeCountResponseMessage>, I>>(
    object: I,
  ): GetAvailableUnfreezeCountResponseMessage {
    const message = createBaseGetAvailableUnfreezeCountResponseMessage();
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    return message;
  },
};

function createBaseCanDelegatedMaxSizeRequestMessage(): CanDelegatedMaxSizeRequestMessage {
  return { type: 0, ownerAddress: Buffer.alloc(0), _unknownFields: {} };
}

export const CanDelegatedMaxSizeRequestMessage = {
  encode(message: CanDelegatedMaxSizeRequestMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.ownerAddress.length !== 0) {
      writer.uint32(18).bytes(message.ownerAddress);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CanDelegatedMaxSizeRequestMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCanDelegatedMaxSizeRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ownerAddress = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): CanDelegatedMaxSizeRequestMessage {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      ownerAddress: isSet(object.ownerAddress) ? Buffer.from(bytesFromBase64(object.ownerAddress)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CanDelegatedMaxSizeRequestMessage): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.ownerAddress.length !== 0) {
      obj.ownerAddress = base64FromBytes(message.ownerAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CanDelegatedMaxSizeRequestMessage>, I>>(
    base?: I,
  ): CanDelegatedMaxSizeRequestMessage {
    return CanDelegatedMaxSizeRequestMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CanDelegatedMaxSizeRequestMessage>, I>>(
    object: I,
  ): CanDelegatedMaxSizeRequestMessage {
    const message = createBaseCanDelegatedMaxSizeRequestMessage();
    message.type = object.type ?? 0;
    message.ownerAddress = object.ownerAddress ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCanDelegatedMaxSizeResponseMessage(): CanDelegatedMaxSizeResponseMessage {
  return { maxSize: Long.ZERO, _unknownFields: {} };
}

export const CanDelegatedMaxSizeResponseMessage = {
  encode(message: CanDelegatedMaxSizeResponseMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.maxSize.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.maxSize);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CanDelegatedMaxSizeResponseMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCanDelegatedMaxSizeResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxSize = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): CanDelegatedMaxSizeResponseMessage {
    return { maxSize: isSet(object.maxSize) ? Long.fromValue(object.maxSize) : Long.ZERO };
  },

  toJSON(message: CanDelegatedMaxSizeResponseMessage): unknown {
    const obj: any = {};
    if (!message.maxSize.equals(Long.ZERO)) {
      obj.maxSize = (message.maxSize || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CanDelegatedMaxSizeResponseMessage>, I>>(
    base?: I,
  ): CanDelegatedMaxSizeResponseMessage {
    return CanDelegatedMaxSizeResponseMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CanDelegatedMaxSizeResponseMessage>, I>>(
    object: I,
  ): CanDelegatedMaxSizeResponseMessage {
    const message = createBaseCanDelegatedMaxSizeResponseMessage();
    message.maxSize = (object.maxSize !== undefined && object.maxSize !== null)
      ? Long.fromValue(object.maxSize)
      : Long.ZERO;
    return message;
  },
};

function createBaseCanWithdrawUnfreezeAmountRequestMessage(): CanWithdrawUnfreezeAmountRequestMessage {
  return { ownerAddress: Buffer.alloc(0), timestamp: Long.ZERO, _unknownFields: {} };
}

export const CanWithdrawUnfreezeAmountRequestMessage = {
  encode(message: CanWithdrawUnfreezeAmountRequestMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress.length !== 0) {
      writer.uint32(10).bytes(message.ownerAddress);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.timestamp);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CanWithdrawUnfreezeAmountRequestMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCanWithdrawUnfreezeAmountRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): CanWithdrawUnfreezeAmountRequestMessage {
    return {
      ownerAddress: isSet(object.ownerAddress) ? Buffer.from(bytesFromBase64(object.ownerAddress)) : Buffer.alloc(0),
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
    };
  },

  toJSON(message: CanWithdrawUnfreezeAmountRequestMessage): unknown {
    const obj: any = {};
    if (message.ownerAddress.length !== 0) {
      obj.ownerAddress = base64FromBytes(message.ownerAddress);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CanWithdrawUnfreezeAmountRequestMessage>, I>>(
    base?: I,
  ): CanWithdrawUnfreezeAmountRequestMessage {
    return CanWithdrawUnfreezeAmountRequestMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CanWithdrawUnfreezeAmountRequestMessage>, I>>(
    object: I,
  ): CanWithdrawUnfreezeAmountRequestMessage {
    const message = createBaseCanWithdrawUnfreezeAmountRequestMessage();
    message.ownerAddress = object.ownerAddress ?? Buffer.alloc(0);
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    return message;
  },
};

function createBaseCanWithdrawUnfreezeAmountResponseMessage(): CanWithdrawUnfreezeAmountResponseMessage {
  return { amount: Long.ZERO, _unknownFields: {} };
}

export const CanWithdrawUnfreezeAmountResponseMessage = {
  encode(message: CanWithdrawUnfreezeAmountResponseMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.amount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.amount);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CanWithdrawUnfreezeAmountResponseMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCanWithdrawUnfreezeAmountResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.amount = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): CanWithdrawUnfreezeAmountResponseMessage {
    return { amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.ZERO };
  },

  toJSON(message: CanWithdrawUnfreezeAmountResponseMessage): unknown {
    const obj: any = {};
    if (!message.amount.equals(Long.ZERO)) {
      obj.amount = (message.amount || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CanWithdrawUnfreezeAmountResponseMessage>, I>>(
    base?: I,
  ): CanWithdrawUnfreezeAmountResponseMessage {
    return CanWithdrawUnfreezeAmountResponseMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CanWithdrawUnfreezeAmountResponseMessage>, I>>(
    object: I,
  ): CanWithdrawUnfreezeAmountResponseMessage {
    const message = createBaseCanWithdrawUnfreezeAmountResponseMessage();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.ZERO;
    return message;
  },
};

function createBasePricesResponseMessage(): PricesResponseMessage {
  return { prices: "", _unknownFields: {} };
}

export const PricesResponseMessage = {
  encode(message: PricesResponseMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.prices !== "") {
      writer.uint32(10).string(message.prices);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PricesResponseMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePricesResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prices = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): PricesResponseMessage {
    return { prices: isSet(object.prices) ? globalThis.String(object.prices) : "" };
  },

  toJSON(message: PricesResponseMessage): unknown {
    const obj: any = {};
    if (message.prices !== "") {
      obj.prices = message.prices;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PricesResponseMessage>, I>>(base?: I): PricesResponseMessage {
    return PricesResponseMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PricesResponseMessage>, I>>(object: I): PricesResponseMessage {
    const message = createBasePricesResponseMessage();
    message.prices = object.prices ?? "";
    return message;
  },
};

function createBaseNodeList(): NodeList {
  return { nodes: [], _unknownFields: {} };
}

export const NodeList = {
  encode(message: NodeList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): NodeList {
    return { nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [] };
  },

  toJSON(message: NodeList): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeList>, I>>(base?: I): NodeList {
    return NodeList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeList>, I>>(object: I): NodeList {
    const message = createBaseNodeList();
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNode(): Node {
  return { address: undefined, _unknownFields: {} };
}

export const Node = {
  encode(message: Node, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Node {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Node {
    return { address: isSet(object.address) ? Address.fromJSON(object.address) : undefined };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = Address.toJSON(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Node>, I>>(base?: I): Node {
    return Node.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Node>, I>>(object: I): Node {
    const message = createBaseNode();
    message.address = (object.address !== undefined && object.address !== null)
      ? Address.fromPartial(object.address)
      : undefined;
    return message;
  },
};

function createBaseAddress(): Address {
  return { host: Buffer.alloc(0), port: 0, _unknownFields: {} };
}

export const Address = {
  encode(message: Address, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.host.length !== 0) {
      writer.uint32(10).bytes(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Address {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.host = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      host: isSet(object.host) ? Buffer.from(bytesFromBase64(object.host)) : Buffer.alloc(0),
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.host.length !== 0) {
      obj.host = base64FromBytes(message.host);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Address>, I>>(base?: I): Address {
    return Address.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Address>, I>>(object: I): Address {
    const message = createBaseAddress();
    message.host = object.host ?? Buffer.alloc(0);
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseEmptyMessage(): EmptyMessage {
  return { _unknownFields: {} };
}

export const EmptyMessage = {
  encode(message: EmptyMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EmptyMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmptyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(_: any): EmptyMessage {
    return {};
  },

  toJSON(_: EmptyMessage): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EmptyMessage>, I>>(base?: I): EmptyMessage {
    return EmptyMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmptyMessage>, I>>(_: I): EmptyMessage {
    const message = createBaseEmptyMessage();
    return message;
  },
};

function createBaseNumberMessage(): NumberMessage {
  return { num: Long.ZERO, _unknownFields: {} };
}

export const NumberMessage = {
  encode(message: NumberMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.num.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.num);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NumberMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNumberMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.num = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): NumberMessage {
    return { num: isSet(object.num) ? Long.fromValue(object.num) : Long.ZERO };
  },

  toJSON(message: NumberMessage): unknown {
    const obj: any = {};
    if (!message.num.equals(Long.ZERO)) {
      obj.num = (message.num || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NumberMessage>, I>>(base?: I): NumberMessage {
    return NumberMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NumberMessage>, I>>(object: I): NumberMessage {
    const message = createBaseNumberMessage();
    message.num = (object.num !== undefined && object.num !== null) ? Long.fromValue(object.num) : Long.ZERO;
    return message;
  },
};

function createBaseBytesMessage(): BytesMessage {
  return { value: Buffer.alloc(0), _unknownFields: {} };
}

export const BytesMessage = {
  encode(message: BytesMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value.length !== 0) {
      writer.uint32(10).bytes(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BytesMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBytesMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): BytesMessage {
    return { value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : Buffer.alloc(0) };
  },

  toJSON(message: BytesMessage): unknown {
    const obj: any = {};
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BytesMessage>, I>>(base?: I): BytesMessage {
    return BytesMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BytesMessage>, I>>(object: I): BytesMessage {
    const message = createBaseBytesMessage();
    message.value = object.value ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseTimeMessage(): TimeMessage {
  return { beginInMilliseconds: Long.ZERO, endInMilliseconds: Long.ZERO, _unknownFields: {} };
}

export const TimeMessage = {
  encode(message: TimeMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.beginInMilliseconds.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.beginInMilliseconds);
    }
    if (!message.endInMilliseconds.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.endInMilliseconds);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TimeMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.beginInMilliseconds = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endInMilliseconds = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TimeMessage {
    return {
      beginInMilliseconds: isSet(object.beginInMilliseconds) ? Long.fromValue(object.beginInMilliseconds) : Long.ZERO,
      endInMilliseconds: isSet(object.endInMilliseconds) ? Long.fromValue(object.endInMilliseconds) : Long.ZERO,
    };
  },

  toJSON(message: TimeMessage): unknown {
    const obj: any = {};
    if (!message.beginInMilliseconds.equals(Long.ZERO)) {
      obj.beginInMilliseconds = (message.beginInMilliseconds || Long.ZERO).toString();
    }
    if (!message.endInMilliseconds.equals(Long.ZERO)) {
      obj.endInMilliseconds = (message.endInMilliseconds || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeMessage>, I>>(base?: I): TimeMessage {
    return TimeMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeMessage>, I>>(object: I): TimeMessage {
    const message = createBaseTimeMessage();
    message.beginInMilliseconds = (object.beginInMilliseconds !== undefined && object.beginInMilliseconds !== null)
      ? Long.fromValue(object.beginInMilliseconds)
      : Long.ZERO;
    message.endInMilliseconds = (object.endInMilliseconds !== undefined && object.endInMilliseconds !== null)
      ? Long.fromValue(object.endInMilliseconds)
      : Long.ZERO;
    return message;
  },
};

function createBaseBlockReq(): BlockReq {
  return { idOrNum: "", detail: false, _unknownFields: {} };
}

export const BlockReq = {
  encode(message: BlockReq, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.idOrNum !== "") {
      writer.uint32(10).string(message.idOrNum);
    }
    if (message.detail !== false) {
      writer.uint32(16).bool(message.detail);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockReq {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.idOrNum = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.detail = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): BlockReq {
    return {
      idOrNum: isSet(object.idOrNum) ? globalThis.String(object.idOrNum) : "",
      detail: isSet(object.detail) ? globalThis.Boolean(object.detail) : false,
    };
  },

  toJSON(message: BlockReq): unknown {
    const obj: any = {};
    if (message.idOrNum !== "") {
      obj.idOrNum = message.idOrNum;
    }
    if (message.detail !== false) {
      obj.detail = message.detail;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockReq>, I>>(base?: I): BlockReq {
    return BlockReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockReq>, I>>(object: I): BlockReq {
    const message = createBaseBlockReq();
    message.idOrNum = object.idOrNum ?? "";
    message.detail = object.detail ?? false;
    return message;
  },
};

function createBaseBlockLimit(): BlockLimit {
  return { startNum: Long.ZERO, endNum: Long.ZERO, _unknownFields: {} };
}

export const BlockLimit = {
  encode(message: BlockLimit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.startNum.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.startNum);
    }
    if (!message.endNum.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.endNum);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockLimit {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startNum = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endNum = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): BlockLimit {
    return {
      startNum: isSet(object.startNum) ? Long.fromValue(object.startNum) : Long.ZERO,
      endNum: isSet(object.endNum) ? Long.fromValue(object.endNum) : Long.ZERO,
    };
  },

  toJSON(message: BlockLimit): unknown {
    const obj: any = {};
    if (!message.startNum.equals(Long.ZERO)) {
      obj.startNum = (message.startNum || Long.ZERO).toString();
    }
    if (!message.endNum.equals(Long.ZERO)) {
      obj.endNum = (message.endNum || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockLimit>, I>>(base?: I): BlockLimit {
    return BlockLimit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockLimit>, I>>(object: I): BlockLimit {
    const message = createBaseBlockLimit();
    message.startNum = (object.startNum !== undefined && object.startNum !== null)
      ? Long.fromValue(object.startNum)
      : Long.ZERO;
    message.endNum = (object.endNum !== undefined && object.endNum !== null)
      ? Long.fromValue(object.endNum)
      : Long.ZERO;
    return message;
  },
};

function createBaseTransactionLimit(): TransactionLimit {
  return { transactionId: Buffer.alloc(0), limitNum: Long.ZERO, _unknownFields: {} };
}

export const TransactionLimit = {
  encode(message: TransactionLimit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.transactionId.length !== 0) {
      writer.uint32(10).bytes(message.transactionId);
    }
    if (!message.limitNum.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.limitNum);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionLimit {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limitNum = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionLimit {
    return {
      transactionId: isSet(object.transactionId) ? Buffer.from(bytesFromBase64(object.transactionId)) : Buffer.alloc(0),
      limitNum: isSet(object.limitNum) ? Long.fromValue(object.limitNum) : Long.ZERO,
    };
  },

  toJSON(message: TransactionLimit): unknown {
    const obj: any = {};
    if (message.transactionId.length !== 0) {
      obj.transactionId = base64FromBytes(message.transactionId);
    }
    if (!message.limitNum.equals(Long.ZERO)) {
      obj.limitNum = (message.limitNum || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionLimit>, I>>(base?: I): TransactionLimit {
    return TransactionLimit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionLimit>, I>>(object: I): TransactionLimit {
    const message = createBaseTransactionLimit();
    message.transactionId = object.transactionId ?? Buffer.alloc(0);
    message.limitNum = (object.limitNum !== undefined && object.limitNum !== null)
      ? Long.fromValue(object.limitNum)
      : Long.ZERO;
    return message;
  },
};

function createBaseAccountPaginated(): AccountPaginated {
  return { account: undefined, offset: Long.ZERO, limit: Long.ZERO, _unknownFields: {} };
}

export const AccountPaginated = {
  encode(message: AccountPaginated, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      Account.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (!message.offset.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.offset);
    }
    if (!message.limit.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.limit);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountPaginated {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountPaginated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = Account.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): AccountPaginated {
    return {
      account: isSet(object.account) ? Account.fromJSON(object.account) : undefined,
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.ZERO,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.ZERO,
    };
  },

  toJSON(message: AccountPaginated): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = Account.toJSON(message.account);
    }
    if (!message.offset.equals(Long.ZERO)) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (!message.limit.equals(Long.ZERO)) {
      obj.limit = (message.limit || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountPaginated>, I>>(base?: I): AccountPaginated {
    return AccountPaginated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountPaginated>, I>>(object: I): AccountPaginated {
    const message = createBaseAccountPaginated();
    message.account = (object.account !== undefined && object.account !== null)
      ? Account.fromPartial(object.account)
      : undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.ZERO;
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : Long.ZERO;
    return message;
  },
};

function createBaseTimePaginatedMessage(): TimePaginatedMessage {
  return { timeMessage: undefined, offset: Long.ZERO, limit: Long.ZERO, _unknownFields: {} };
}

export const TimePaginatedMessage = {
  encode(message: TimePaginatedMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timeMessage !== undefined) {
      TimeMessage.encode(message.timeMessage, writer.uint32(10).fork()).ldelim();
    }
    if (!message.offset.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.offset);
    }
    if (!message.limit.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.limit);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TimePaginatedMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimePaginatedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timeMessage = TimeMessage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TimePaginatedMessage {
    return {
      timeMessage: isSet(object.timeMessage) ? TimeMessage.fromJSON(object.timeMessage) : undefined,
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.ZERO,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.ZERO,
    };
  },

  toJSON(message: TimePaginatedMessage): unknown {
    const obj: any = {};
    if (message.timeMessage !== undefined) {
      obj.timeMessage = TimeMessage.toJSON(message.timeMessage);
    }
    if (!message.offset.equals(Long.ZERO)) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (!message.limit.equals(Long.ZERO)) {
      obj.limit = (message.limit || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimePaginatedMessage>, I>>(base?: I): TimePaginatedMessage {
    return TimePaginatedMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimePaginatedMessage>, I>>(object: I): TimePaginatedMessage {
    const message = createBaseTimePaginatedMessage();
    message.timeMessage = (object.timeMessage !== undefined && object.timeMessage !== null)
      ? TimeMessage.fromPartial(object.timeMessage)
      : undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.ZERO;
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : Long.ZERO;
    return message;
  },
};

function createBaseAccountNetMessage(): AccountNetMessage {
  return {
    freeNetUsed: Long.ZERO,
    freeNetLimit: Long.ZERO,
    NetUsed: Long.ZERO,
    NetLimit: Long.ZERO,
    assetNetUsed: {},
    assetNetLimit: {},
    TotalNetLimit: Long.ZERO,
    TotalNetWeight: Long.ZERO,
    _unknownFields: {},
  };
}

export const AccountNetMessage = {
  encode(message: AccountNetMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.freeNetUsed.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.freeNetUsed);
    }
    if (!message.freeNetLimit.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.freeNetLimit);
    }
    if (!message.NetUsed.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.NetUsed);
    }
    if (!message.NetLimit.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.NetLimit);
    }
    Object.entries(message.assetNetUsed).forEach(([key, value]) => {
      AccountNetMessage_AssetNetUsedEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    Object.entries(message.assetNetLimit).forEach(([key, value]) => {
      AccountNetMessage_AssetNetLimitEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).ldelim();
    });
    if (!message.TotalNetLimit.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.TotalNetLimit);
    }
    if (!message.TotalNetWeight.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.TotalNetWeight);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountNetMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountNetMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.freeNetUsed = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.freeNetLimit = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.NetUsed = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.NetLimit = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = AccountNetMessage_AssetNetUsedEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.assetNetUsed[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = AccountNetMessage_AssetNetLimitEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.assetNetLimit[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.TotalNetLimit = reader.int64() as Long;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.TotalNetWeight = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): AccountNetMessage {
    return {
      freeNetUsed: isSet(object.freeNetUsed) ? Long.fromValue(object.freeNetUsed) : Long.ZERO,
      freeNetLimit: isSet(object.freeNetLimit) ? Long.fromValue(object.freeNetLimit) : Long.ZERO,
      NetUsed: isSet(object.NetUsed) ? Long.fromValue(object.NetUsed) : Long.ZERO,
      NetLimit: isSet(object.NetLimit) ? Long.fromValue(object.NetLimit) : Long.ZERO,
      assetNetUsed: isObject(object.assetNetUsed)
        ? Object.entries(object.assetNetUsed).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
      assetNetLimit: isObject(object.assetNetLimit)
        ? Object.entries(object.assetNetLimit).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
      TotalNetLimit: isSet(object.TotalNetLimit) ? Long.fromValue(object.TotalNetLimit) : Long.ZERO,
      TotalNetWeight: isSet(object.TotalNetWeight) ? Long.fromValue(object.TotalNetWeight) : Long.ZERO,
    };
  },

  toJSON(message: AccountNetMessage): unknown {
    const obj: any = {};
    if (!message.freeNetUsed.equals(Long.ZERO)) {
      obj.freeNetUsed = (message.freeNetUsed || Long.ZERO).toString();
    }
    if (!message.freeNetLimit.equals(Long.ZERO)) {
      obj.freeNetLimit = (message.freeNetLimit || Long.ZERO).toString();
    }
    if (!message.NetUsed.equals(Long.ZERO)) {
      obj.NetUsed = (message.NetUsed || Long.ZERO).toString();
    }
    if (!message.NetLimit.equals(Long.ZERO)) {
      obj.NetLimit = (message.NetLimit || Long.ZERO).toString();
    }
    if (message.assetNetUsed) {
      const entries = Object.entries(message.assetNetUsed);
      if (entries.length > 0) {
        obj.assetNetUsed = {};
        entries.forEach(([k, v]) => {
          obj.assetNetUsed[k] = v.toString();
        });
      }
    }
    if (message.assetNetLimit) {
      const entries = Object.entries(message.assetNetLimit);
      if (entries.length > 0) {
        obj.assetNetLimit = {};
        entries.forEach(([k, v]) => {
          obj.assetNetLimit[k] = v.toString();
        });
      }
    }
    if (!message.TotalNetLimit.equals(Long.ZERO)) {
      obj.TotalNetLimit = (message.TotalNetLimit || Long.ZERO).toString();
    }
    if (!message.TotalNetWeight.equals(Long.ZERO)) {
      obj.TotalNetWeight = (message.TotalNetWeight || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountNetMessage>, I>>(base?: I): AccountNetMessage {
    return AccountNetMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountNetMessage>, I>>(object: I): AccountNetMessage {
    const message = createBaseAccountNetMessage();
    message.freeNetUsed = (object.freeNetUsed !== undefined && object.freeNetUsed !== null)
      ? Long.fromValue(object.freeNetUsed)
      : Long.ZERO;
    message.freeNetLimit = (object.freeNetLimit !== undefined && object.freeNetLimit !== null)
      ? Long.fromValue(object.freeNetLimit)
      : Long.ZERO;
    message.NetUsed = (object.NetUsed !== undefined && object.NetUsed !== null)
      ? Long.fromValue(object.NetUsed)
      : Long.ZERO;
    message.NetLimit = (object.NetLimit !== undefined && object.NetLimit !== null)
      ? Long.fromValue(object.NetLimit)
      : Long.ZERO;
    message.assetNetUsed = Object.entries(object.assetNetUsed ?? {}).reduce<{ [key: string]: Long }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Long.fromValue(value);
        }
        return acc;
      },
      {},
    );
    message.assetNetLimit = Object.entries(object.assetNetLimit ?? {}).reduce<{ [key: string]: Long }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Long.fromValue(value);
        }
        return acc;
      },
      {},
    );
    message.TotalNetLimit = (object.TotalNetLimit !== undefined && object.TotalNetLimit !== null)
      ? Long.fromValue(object.TotalNetLimit)
      : Long.ZERO;
    message.TotalNetWeight = (object.TotalNetWeight !== undefined && object.TotalNetWeight !== null)
      ? Long.fromValue(object.TotalNetWeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseAccountNetMessage_AssetNetUsedEntry(): AccountNetMessage_AssetNetUsedEntry {
  return { key: "", value: Long.ZERO, _unknownFields: {} };
}

export const AccountNetMessage_AssetNetUsedEntry = {
  encode(message: AccountNetMessage_AssetNetUsedEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountNetMessage_AssetNetUsedEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountNetMessage_AssetNetUsedEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): AccountNetMessage_AssetNetUsedEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: AccountNetMessage_AssetNetUsedEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountNetMessage_AssetNetUsedEntry>, I>>(
    base?: I,
  ): AccountNetMessage_AssetNetUsedEntry {
    return AccountNetMessage_AssetNetUsedEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountNetMessage_AssetNetUsedEntry>, I>>(
    object: I,
  ): AccountNetMessage_AssetNetUsedEntry {
    const message = createBaseAccountNetMessage_AssetNetUsedEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseAccountNetMessage_AssetNetLimitEntry(): AccountNetMessage_AssetNetLimitEntry {
  return { key: "", value: Long.ZERO, _unknownFields: {} };
}

export const AccountNetMessage_AssetNetLimitEntry = {
  encode(message: AccountNetMessage_AssetNetLimitEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountNetMessage_AssetNetLimitEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountNetMessage_AssetNetLimitEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): AccountNetMessage_AssetNetLimitEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: AccountNetMessage_AssetNetLimitEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountNetMessage_AssetNetLimitEntry>, I>>(
    base?: I,
  ): AccountNetMessage_AssetNetLimitEntry {
    return AccountNetMessage_AssetNetLimitEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountNetMessage_AssetNetLimitEntry>, I>>(
    object: I,
  ): AccountNetMessage_AssetNetLimitEntry {
    const message = createBaseAccountNetMessage_AssetNetLimitEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseAccountResourceMessage(): AccountResourceMessage {
  return {
    freeNetUsed: Long.ZERO,
    freeNetLimit: Long.ZERO,
    NetUsed: Long.ZERO,
    NetLimit: Long.ZERO,
    assetNetUsed: {},
    assetNetLimit: {},
    TotalNetLimit: Long.ZERO,
    TotalNetWeight: Long.ZERO,
    TotalTronPowerWeight: Long.ZERO,
    tronPowerUsed: Long.ZERO,
    tronPowerLimit: Long.ZERO,
    EnergyUsed: Long.ZERO,
    EnergyLimit: Long.ZERO,
    TotalEnergyLimit: Long.ZERO,
    TotalEnergyWeight: Long.ZERO,
    storageUsed: Long.ZERO,
    storageLimit: Long.ZERO,
    _unknownFields: {},
  };
}

export const AccountResourceMessage = {
  encode(message: AccountResourceMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.freeNetUsed.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.freeNetUsed);
    }
    if (!message.freeNetLimit.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.freeNetLimit);
    }
    if (!message.NetUsed.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.NetUsed);
    }
    if (!message.NetLimit.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.NetLimit);
    }
    Object.entries(message.assetNetUsed).forEach(([key, value]) => {
      AccountResourceMessage_AssetNetUsedEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    Object.entries(message.assetNetLimit).forEach(([key, value]) => {
      AccountResourceMessage_AssetNetLimitEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).ldelim();
    });
    if (!message.TotalNetLimit.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.TotalNetLimit);
    }
    if (!message.TotalNetWeight.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.TotalNetWeight);
    }
    if (!message.TotalTronPowerWeight.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.TotalTronPowerWeight);
    }
    if (!message.tronPowerUsed.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.tronPowerUsed);
    }
    if (!message.tronPowerLimit.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.tronPowerLimit);
    }
    if (!message.EnergyUsed.equals(Long.ZERO)) {
      writer.uint32(104).int64(message.EnergyUsed);
    }
    if (!message.EnergyLimit.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.EnergyLimit);
    }
    if (!message.TotalEnergyLimit.equals(Long.ZERO)) {
      writer.uint32(120).int64(message.TotalEnergyLimit);
    }
    if (!message.TotalEnergyWeight.equals(Long.ZERO)) {
      writer.uint32(128).int64(message.TotalEnergyWeight);
    }
    if (!message.storageUsed.equals(Long.ZERO)) {
      writer.uint32(168).int64(message.storageUsed);
    }
    if (!message.storageLimit.equals(Long.ZERO)) {
      writer.uint32(176).int64(message.storageLimit);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountResourceMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountResourceMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.freeNetUsed = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.freeNetLimit = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.NetUsed = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.NetLimit = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = AccountResourceMessage_AssetNetUsedEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.assetNetUsed[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = AccountResourceMessage_AssetNetLimitEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.assetNetLimit[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.TotalNetLimit = reader.int64() as Long;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.TotalNetWeight = reader.int64() as Long;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.TotalTronPowerWeight = reader.int64() as Long;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.tronPowerUsed = reader.int64() as Long;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.tronPowerLimit = reader.int64() as Long;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.EnergyUsed = reader.int64() as Long;
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.EnergyLimit = reader.int64() as Long;
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.TotalEnergyLimit = reader.int64() as Long;
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.TotalEnergyWeight = reader.int64() as Long;
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.storageUsed = reader.int64() as Long;
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.storageLimit = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): AccountResourceMessage {
    return {
      freeNetUsed: isSet(object.freeNetUsed) ? Long.fromValue(object.freeNetUsed) : Long.ZERO,
      freeNetLimit: isSet(object.freeNetLimit) ? Long.fromValue(object.freeNetLimit) : Long.ZERO,
      NetUsed: isSet(object.NetUsed) ? Long.fromValue(object.NetUsed) : Long.ZERO,
      NetLimit: isSet(object.NetLimit) ? Long.fromValue(object.NetLimit) : Long.ZERO,
      assetNetUsed: isObject(object.assetNetUsed)
        ? Object.entries(object.assetNetUsed).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
      assetNetLimit: isObject(object.assetNetLimit)
        ? Object.entries(object.assetNetLimit).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
      TotalNetLimit: isSet(object.TotalNetLimit) ? Long.fromValue(object.TotalNetLimit) : Long.ZERO,
      TotalNetWeight: isSet(object.TotalNetWeight) ? Long.fromValue(object.TotalNetWeight) : Long.ZERO,
      TotalTronPowerWeight: isSet(object.TotalTronPowerWeight)
        ? Long.fromValue(object.TotalTronPowerWeight)
        : Long.ZERO,
      tronPowerUsed: isSet(object.tronPowerUsed) ? Long.fromValue(object.tronPowerUsed) : Long.ZERO,
      tronPowerLimit: isSet(object.tronPowerLimit) ? Long.fromValue(object.tronPowerLimit) : Long.ZERO,
      EnergyUsed: isSet(object.EnergyUsed) ? Long.fromValue(object.EnergyUsed) : Long.ZERO,
      EnergyLimit: isSet(object.EnergyLimit) ? Long.fromValue(object.EnergyLimit) : Long.ZERO,
      TotalEnergyLimit: isSet(object.TotalEnergyLimit) ? Long.fromValue(object.TotalEnergyLimit) : Long.ZERO,
      TotalEnergyWeight: isSet(object.TotalEnergyWeight) ? Long.fromValue(object.TotalEnergyWeight) : Long.ZERO,
      storageUsed: isSet(object.storageUsed) ? Long.fromValue(object.storageUsed) : Long.ZERO,
      storageLimit: isSet(object.storageLimit) ? Long.fromValue(object.storageLimit) : Long.ZERO,
    };
  },

  toJSON(message: AccountResourceMessage): unknown {
    const obj: any = {};
    if (!message.freeNetUsed.equals(Long.ZERO)) {
      obj.freeNetUsed = (message.freeNetUsed || Long.ZERO).toString();
    }
    if (!message.freeNetLimit.equals(Long.ZERO)) {
      obj.freeNetLimit = (message.freeNetLimit || Long.ZERO).toString();
    }
    if (!message.NetUsed.equals(Long.ZERO)) {
      obj.NetUsed = (message.NetUsed || Long.ZERO).toString();
    }
    if (!message.NetLimit.equals(Long.ZERO)) {
      obj.NetLimit = (message.NetLimit || Long.ZERO).toString();
    }
    if (message.assetNetUsed) {
      const entries = Object.entries(message.assetNetUsed);
      if (entries.length > 0) {
        obj.assetNetUsed = {};
        entries.forEach(([k, v]) => {
          obj.assetNetUsed[k] = v.toString();
        });
      }
    }
    if (message.assetNetLimit) {
      const entries = Object.entries(message.assetNetLimit);
      if (entries.length > 0) {
        obj.assetNetLimit = {};
        entries.forEach(([k, v]) => {
          obj.assetNetLimit[k] = v.toString();
        });
      }
    }
    if (!message.TotalNetLimit.equals(Long.ZERO)) {
      obj.TotalNetLimit = (message.TotalNetLimit || Long.ZERO).toString();
    }
    if (!message.TotalNetWeight.equals(Long.ZERO)) {
      obj.TotalNetWeight = (message.TotalNetWeight || Long.ZERO).toString();
    }
    if (!message.TotalTronPowerWeight.equals(Long.ZERO)) {
      obj.TotalTronPowerWeight = (message.TotalTronPowerWeight || Long.ZERO).toString();
    }
    if (!message.tronPowerUsed.equals(Long.ZERO)) {
      obj.tronPowerUsed = (message.tronPowerUsed || Long.ZERO).toString();
    }
    if (!message.tronPowerLimit.equals(Long.ZERO)) {
      obj.tronPowerLimit = (message.tronPowerLimit || Long.ZERO).toString();
    }
    if (!message.EnergyUsed.equals(Long.ZERO)) {
      obj.EnergyUsed = (message.EnergyUsed || Long.ZERO).toString();
    }
    if (!message.EnergyLimit.equals(Long.ZERO)) {
      obj.EnergyLimit = (message.EnergyLimit || Long.ZERO).toString();
    }
    if (!message.TotalEnergyLimit.equals(Long.ZERO)) {
      obj.TotalEnergyLimit = (message.TotalEnergyLimit || Long.ZERO).toString();
    }
    if (!message.TotalEnergyWeight.equals(Long.ZERO)) {
      obj.TotalEnergyWeight = (message.TotalEnergyWeight || Long.ZERO).toString();
    }
    if (!message.storageUsed.equals(Long.ZERO)) {
      obj.storageUsed = (message.storageUsed || Long.ZERO).toString();
    }
    if (!message.storageLimit.equals(Long.ZERO)) {
      obj.storageLimit = (message.storageLimit || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountResourceMessage>, I>>(base?: I): AccountResourceMessage {
    return AccountResourceMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountResourceMessage>, I>>(object: I): AccountResourceMessage {
    const message = createBaseAccountResourceMessage();
    message.freeNetUsed = (object.freeNetUsed !== undefined && object.freeNetUsed !== null)
      ? Long.fromValue(object.freeNetUsed)
      : Long.ZERO;
    message.freeNetLimit = (object.freeNetLimit !== undefined && object.freeNetLimit !== null)
      ? Long.fromValue(object.freeNetLimit)
      : Long.ZERO;
    message.NetUsed = (object.NetUsed !== undefined && object.NetUsed !== null)
      ? Long.fromValue(object.NetUsed)
      : Long.ZERO;
    message.NetLimit = (object.NetLimit !== undefined && object.NetLimit !== null)
      ? Long.fromValue(object.NetLimit)
      : Long.ZERO;
    message.assetNetUsed = Object.entries(object.assetNetUsed ?? {}).reduce<{ [key: string]: Long }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Long.fromValue(value);
        }
        return acc;
      },
      {},
    );
    message.assetNetLimit = Object.entries(object.assetNetLimit ?? {}).reduce<{ [key: string]: Long }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Long.fromValue(value);
        }
        return acc;
      },
      {},
    );
    message.TotalNetLimit = (object.TotalNetLimit !== undefined && object.TotalNetLimit !== null)
      ? Long.fromValue(object.TotalNetLimit)
      : Long.ZERO;
    message.TotalNetWeight = (object.TotalNetWeight !== undefined && object.TotalNetWeight !== null)
      ? Long.fromValue(object.TotalNetWeight)
      : Long.ZERO;
    message.TotalTronPowerWeight = (object.TotalTronPowerWeight !== undefined && object.TotalTronPowerWeight !== null)
      ? Long.fromValue(object.TotalTronPowerWeight)
      : Long.ZERO;
    message.tronPowerUsed = (object.tronPowerUsed !== undefined && object.tronPowerUsed !== null)
      ? Long.fromValue(object.tronPowerUsed)
      : Long.ZERO;
    message.tronPowerLimit = (object.tronPowerLimit !== undefined && object.tronPowerLimit !== null)
      ? Long.fromValue(object.tronPowerLimit)
      : Long.ZERO;
    message.EnergyUsed = (object.EnergyUsed !== undefined && object.EnergyUsed !== null)
      ? Long.fromValue(object.EnergyUsed)
      : Long.ZERO;
    message.EnergyLimit = (object.EnergyLimit !== undefined && object.EnergyLimit !== null)
      ? Long.fromValue(object.EnergyLimit)
      : Long.ZERO;
    message.TotalEnergyLimit = (object.TotalEnergyLimit !== undefined && object.TotalEnergyLimit !== null)
      ? Long.fromValue(object.TotalEnergyLimit)
      : Long.ZERO;
    message.TotalEnergyWeight = (object.TotalEnergyWeight !== undefined && object.TotalEnergyWeight !== null)
      ? Long.fromValue(object.TotalEnergyWeight)
      : Long.ZERO;
    message.storageUsed = (object.storageUsed !== undefined && object.storageUsed !== null)
      ? Long.fromValue(object.storageUsed)
      : Long.ZERO;
    message.storageLimit = (object.storageLimit !== undefined && object.storageLimit !== null)
      ? Long.fromValue(object.storageLimit)
      : Long.ZERO;
    return message;
  },
};

function createBaseAccountResourceMessage_AssetNetUsedEntry(): AccountResourceMessage_AssetNetUsedEntry {
  return { key: "", value: Long.ZERO, _unknownFields: {} };
}

export const AccountResourceMessage_AssetNetUsedEntry = {
  encode(message: AccountResourceMessage_AssetNetUsedEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountResourceMessage_AssetNetUsedEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountResourceMessage_AssetNetUsedEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): AccountResourceMessage_AssetNetUsedEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: AccountResourceMessage_AssetNetUsedEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountResourceMessage_AssetNetUsedEntry>, I>>(
    base?: I,
  ): AccountResourceMessage_AssetNetUsedEntry {
    return AccountResourceMessage_AssetNetUsedEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountResourceMessage_AssetNetUsedEntry>, I>>(
    object: I,
  ): AccountResourceMessage_AssetNetUsedEntry {
    const message = createBaseAccountResourceMessage_AssetNetUsedEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseAccountResourceMessage_AssetNetLimitEntry(): AccountResourceMessage_AssetNetLimitEntry {
  return { key: "", value: Long.ZERO, _unknownFields: {} };
}

export const AccountResourceMessage_AssetNetLimitEntry = {
  encode(message: AccountResourceMessage_AssetNetLimitEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountResourceMessage_AssetNetLimitEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountResourceMessage_AssetNetLimitEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): AccountResourceMessage_AssetNetLimitEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: AccountResourceMessage_AssetNetLimitEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountResourceMessage_AssetNetLimitEntry>, I>>(
    base?: I,
  ): AccountResourceMessage_AssetNetLimitEntry {
    return AccountResourceMessage_AssetNetLimitEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountResourceMessage_AssetNetLimitEntry>, I>>(
    object: I,
  ): AccountResourceMessage_AssetNetLimitEntry {
    const message = createBaseAccountResourceMessage_AssetNetLimitEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBasePaginatedMessage(): PaginatedMessage {
  return { offset: Long.ZERO, limit: Long.ZERO, _unknownFields: {} };
}

export const PaginatedMessage = {
  encode(message: PaginatedMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.offset.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.offset);
    }
    if (!message.limit.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.limit);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PaginatedMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginatedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.offset = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): PaginatedMessage {
    return {
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.ZERO,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.ZERO,
    };
  },

  toJSON(message: PaginatedMessage): unknown {
    const obj: any = {};
    if (!message.offset.equals(Long.ZERO)) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (!message.limit.equals(Long.ZERO)) {
      obj.limit = (message.limit || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginatedMessage>, I>>(base?: I): PaginatedMessage {
    return PaginatedMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginatedMessage>, I>>(object: I): PaginatedMessage {
    const message = createBasePaginatedMessage();
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.ZERO;
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : Long.ZERO;
    return message;
  },
};

function createBaseTransactionExtention(): TransactionExtention {
  return {
    transaction: undefined,
    txid: Buffer.alloc(0),
    constantResult: [],
    result: undefined,
    energyUsed: Long.ZERO,
    logs: [],
    internalTransactions: [],
    energyPenalty: Long.ZERO,
    _unknownFields: {},
  };
}

export const TransactionExtention = {
  encode(message: TransactionExtention, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.transaction !== undefined) {
      Transaction.encode(message.transaction, writer.uint32(10).fork()).ldelim();
    }
    if (message.txid.length !== 0) {
      writer.uint32(18).bytes(message.txid);
    }
    for (const v of message.constantResult) {
      writer.uint32(26).bytes(v!);
    }
    if (message.result !== undefined) {
      Return.encode(message.result, writer.uint32(34).fork()).ldelim();
    }
    if (!message.energyUsed.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.energyUsed);
    }
    for (const v of message.logs) {
      TransactionInfo_Log.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.internalTransactions) {
      InternalTransaction.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (!message.energyPenalty.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.energyPenalty);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionExtention {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionExtention();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transaction = Transaction.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.txid = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.constantResult.push(reader.bytes() as Buffer);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.result = Return.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.energyUsed = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.logs.push(TransactionInfo_Log.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.internalTransactions.push(InternalTransaction.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.energyPenalty = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionExtention {
    return {
      transaction: isSet(object.transaction) ? Transaction.fromJSON(object.transaction) : undefined,
      txid: isSet(object.txid) ? Buffer.from(bytesFromBase64(object.txid)) : Buffer.alloc(0),
      constantResult: globalThis.Array.isArray(object?.constantResult)
        ? object.constantResult.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      result: isSet(object.result) ? Return.fromJSON(object.result) : undefined,
      energyUsed: isSet(object.energyUsed) ? Long.fromValue(object.energyUsed) : Long.ZERO,
      logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => TransactionInfo_Log.fromJSON(e)) : [],
      internalTransactions: globalThis.Array.isArray(object?.internalTransactions)
        ? object.internalTransactions.map((e: any) => InternalTransaction.fromJSON(e))
        : [],
      energyPenalty: isSet(object.energyPenalty) ? Long.fromValue(object.energyPenalty) : Long.ZERO,
    };
  },

  toJSON(message: TransactionExtention): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = Transaction.toJSON(message.transaction);
    }
    if (message.txid.length !== 0) {
      obj.txid = base64FromBytes(message.txid);
    }
    if (message.constantResult?.length) {
      obj.constantResult = message.constantResult.map((e) => base64FromBytes(e));
    }
    if (message.result !== undefined) {
      obj.result = Return.toJSON(message.result);
    }
    if (!message.energyUsed.equals(Long.ZERO)) {
      obj.energyUsed = (message.energyUsed || Long.ZERO).toString();
    }
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => TransactionInfo_Log.toJSON(e));
    }
    if (message.internalTransactions?.length) {
      obj.internalTransactions = message.internalTransactions.map((e) => InternalTransaction.toJSON(e));
    }
    if (!message.energyPenalty.equals(Long.ZERO)) {
      obj.energyPenalty = (message.energyPenalty || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionExtention>, I>>(base?: I): TransactionExtention {
    return TransactionExtention.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionExtention>, I>>(object: I): TransactionExtention {
    const message = createBaseTransactionExtention();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? Transaction.fromPartial(object.transaction)
      : undefined;
    message.txid = object.txid ?? Buffer.alloc(0);
    message.constantResult = object.constantResult?.map((e) => e) || [];
    message.result = (object.result !== undefined && object.result !== null)
      ? Return.fromPartial(object.result)
      : undefined;
    message.energyUsed = (object.energyUsed !== undefined && object.energyUsed !== null)
      ? Long.fromValue(object.energyUsed)
      : Long.ZERO;
    message.logs = object.logs?.map((e) => TransactionInfo_Log.fromPartial(e)) || [];
    message.internalTransactions = object.internalTransactions?.map((e) => InternalTransaction.fromPartial(e)) || [];
    message.energyPenalty = (object.energyPenalty !== undefined && object.energyPenalty !== null)
      ? Long.fromValue(object.energyPenalty)
      : Long.ZERO;
    return message;
  },
};

function createBaseEstimateEnergyMessage(): EstimateEnergyMessage {
  return { result: undefined, energyRequired: Long.ZERO, _unknownFields: {} };
}

export const EstimateEnergyMessage = {
  encode(message: EstimateEnergyMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      Return.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    if (!message.energyRequired.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.energyRequired);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EstimateEnergyMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEstimateEnergyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = Return.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.energyRequired = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): EstimateEnergyMessage {
    return {
      result: isSet(object.result) ? Return.fromJSON(object.result) : undefined,
      energyRequired: isSet(object.energyRequired) ? Long.fromValue(object.energyRequired) : Long.ZERO,
    };
  },

  toJSON(message: EstimateEnergyMessage): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Return.toJSON(message.result);
    }
    if (!message.energyRequired.equals(Long.ZERO)) {
      obj.energyRequired = (message.energyRequired || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EstimateEnergyMessage>, I>>(base?: I): EstimateEnergyMessage {
    return EstimateEnergyMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EstimateEnergyMessage>, I>>(object: I): EstimateEnergyMessage {
    const message = createBaseEstimateEnergyMessage();
    message.result = (object.result !== undefined && object.result !== null)
      ? Return.fromPartial(object.result)
      : undefined;
    message.energyRequired = (object.energyRequired !== undefined && object.energyRequired !== null)
      ? Long.fromValue(object.energyRequired)
      : Long.ZERO;
    return message;
  },
};

function createBaseBlockExtention(): BlockExtention {
  return { transactions: [], blockHeader: undefined, blockid: Buffer.alloc(0), _unknownFields: {} };
}

export const BlockExtention = {
  encode(message: BlockExtention, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      TransactionExtention.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.blockHeader !== undefined) {
      BlockHeader.encode(message.blockHeader, writer.uint32(18).fork()).ldelim();
    }
    if (message.blockid.length !== 0) {
      writer.uint32(26).bytes(message.blockid);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockExtention {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockExtention();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(TransactionExtention.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockHeader = BlockHeader.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blockid = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): BlockExtention {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TransactionExtention.fromJSON(e))
        : [],
      blockHeader: isSet(object.blockHeader) ? BlockHeader.fromJSON(object.blockHeader) : undefined,
      blockid: isSet(object.blockid) ? Buffer.from(bytesFromBase64(object.blockid)) : Buffer.alloc(0),
    };
  },

  toJSON(message: BlockExtention): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => TransactionExtention.toJSON(e));
    }
    if (message.blockHeader !== undefined) {
      obj.blockHeader = BlockHeader.toJSON(message.blockHeader);
    }
    if (message.blockid.length !== 0) {
      obj.blockid = base64FromBytes(message.blockid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockExtention>, I>>(base?: I): BlockExtention {
    return BlockExtention.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockExtention>, I>>(object: I): BlockExtention {
    const message = createBaseBlockExtention();
    message.transactions = object.transactions?.map((e) => TransactionExtention.fromPartial(e)) || [];
    message.blockHeader = (object.blockHeader !== undefined && object.blockHeader !== null)
      ? BlockHeader.fromPartial(object.blockHeader)
      : undefined;
    message.blockid = object.blockid ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseBlockListExtention(): BlockListExtention {
  return { block: [], _unknownFields: {} };
}

export const BlockListExtention = {
  encode(message: BlockListExtention, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.block) {
      BlockExtention.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockListExtention {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockListExtention();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.block.push(BlockExtention.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): BlockListExtention {
    return {
      block: globalThis.Array.isArray(object?.block) ? object.block.map((e: any) => BlockExtention.fromJSON(e)) : [],
    };
  },

  toJSON(message: BlockListExtention): unknown {
    const obj: any = {};
    if (message.block?.length) {
      obj.block = message.block.map((e) => BlockExtention.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockListExtention>, I>>(base?: I): BlockListExtention {
    return BlockListExtention.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockListExtention>, I>>(object: I): BlockListExtention {
    const message = createBaseBlockListExtention();
    message.block = object.block?.map((e) => BlockExtention.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactionListExtention(): TransactionListExtention {
  return { transaction: [], _unknownFields: {} };
}

export const TransactionListExtention = {
  encode(message: TransactionListExtention, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transaction) {
      TransactionExtention.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionListExtention {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionListExtention();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transaction.push(TransactionExtention.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionListExtention {
    return {
      transaction: globalThis.Array.isArray(object?.transaction)
        ? object.transaction.map((e: any) => TransactionExtention.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransactionListExtention): unknown {
    const obj: any = {};
    if (message.transaction?.length) {
      obj.transaction = message.transaction.map((e) => TransactionExtention.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionListExtention>, I>>(base?: I): TransactionListExtention {
    return TransactionListExtention.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionListExtention>, I>>(object: I): TransactionListExtention {
    const message = createBaseTransactionListExtention();
    message.transaction = object.transaction?.map((e) => TransactionExtention.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlockIncrementalMerkleTree(): BlockIncrementalMerkleTree {
  return { number: Long.ZERO, merkleTree: undefined, _unknownFields: {} };
}

export const BlockIncrementalMerkleTree = {
  encode(message: BlockIncrementalMerkleTree, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.number.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.number);
    }
    if (message.merkleTree !== undefined) {
      IncrementalMerkleTree.encode(message.merkleTree, writer.uint32(18).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockIncrementalMerkleTree {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockIncrementalMerkleTree();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.number = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.merkleTree = IncrementalMerkleTree.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): BlockIncrementalMerkleTree {
    return {
      number: isSet(object.number) ? Long.fromValue(object.number) : Long.ZERO,
      merkleTree: isSet(object.merkleTree) ? IncrementalMerkleTree.fromJSON(object.merkleTree) : undefined,
    };
  },

  toJSON(message: BlockIncrementalMerkleTree): unknown {
    const obj: any = {};
    if (!message.number.equals(Long.ZERO)) {
      obj.number = (message.number || Long.ZERO).toString();
    }
    if (message.merkleTree !== undefined) {
      obj.merkleTree = IncrementalMerkleTree.toJSON(message.merkleTree);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockIncrementalMerkleTree>, I>>(base?: I): BlockIncrementalMerkleTree {
    return BlockIncrementalMerkleTree.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockIncrementalMerkleTree>, I>>(object: I): BlockIncrementalMerkleTree {
    const message = createBaseBlockIncrementalMerkleTree();
    message.number = (object.number !== undefined && object.number !== null)
      ? Long.fromValue(object.number)
      : Long.ZERO;
    message.merkleTree = (object.merkleTree !== undefined && object.merkleTree !== null)
      ? IncrementalMerkleTree.fromPartial(object.merkleTree)
      : undefined;
    return message;
  },
};

function createBaseTransactionSignWeight(): TransactionSignWeight {
  return {
    permission: undefined,
    approvedList: [],
    currentWeight: Long.ZERO,
    result: undefined,
    transaction: undefined,
    _unknownFields: {},
  };
}

export const TransactionSignWeight = {
  encode(message: TransactionSignWeight, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.permission !== undefined) {
      Permission.encode(message.permission, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.approvedList) {
      writer.uint32(18).bytes(v!);
    }
    if (!message.currentWeight.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.currentWeight);
    }
    if (message.result !== undefined) {
      TransactionSignWeight_Result.encode(message.result, writer.uint32(34).fork()).ldelim();
    }
    if (message.transaction !== undefined) {
      TransactionExtention.encode(message.transaction, writer.uint32(42).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionSignWeight {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionSignWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.permission = Permission.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.approvedList.push(reader.bytes() as Buffer);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.currentWeight = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.result = TransactionSignWeight_Result.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transaction = TransactionExtention.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionSignWeight {
    return {
      permission: isSet(object.permission) ? Permission.fromJSON(object.permission) : undefined,
      approvedList: globalThis.Array.isArray(object?.approvedList)
        ? object.approvedList.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      currentWeight: isSet(object.currentWeight) ? Long.fromValue(object.currentWeight) : Long.ZERO,
      result: isSet(object.result) ? TransactionSignWeight_Result.fromJSON(object.result) : undefined,
      transaction: isSet(object.transaction) ? TransactionExtention.fromJSON(object.transaction) : undefined,
    };
  },

  toJSON(message: TransactionSignWeight): unknown {
    const obj: any = {};
    if (message.permission !== undefined) {
      obj.permission = Permission.toJSON(message.permission);
    }
    if (message.approvedList?.length) {
      obj.approvedList = message.approvedList.map((e) => base64FromBytes(e));
    }
    if (!message.currentWeight.equals(Long.ZERO)) {
      obj.currentWeight = (message.currentWeight || Long.ZERO).toString();
    }
    if (message.result !== undefined) {
      obj.result = TransactionSignWeight_Result.toJSON(message.result);
    }
    if (message.transaction !== undefined) {
      obj.transaction = TransactionExtention.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionSignWeight>, I>>(base?: I): TransactionSignWeight {
    return TransactionSignWeight.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionSignWeight>, I>>(object: I): TransactionSignWeight {
    const message = createBaseTransactionSignWeight();
    message.permission = (object.permission !== undefined && object.permission !== null)
      ? Permission.fromPartial(object.permission)
      : undefined;
    message.approvedList = object.approvedList?.map((e) => e) || [];
    message.currentWeight = (object.currentWeight !== undefined && object.currentWeight !== null)
      ? Long.fromValue(object.currentWeight)
      : Long.ZERO;
    message.result = (object.result !== undefined && object.result !== null)
      ? TransactionSignWeight_Result.fromPartial(object.result)
      : undefined;
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? TransactionExtention.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseTransactionSignWeight_Result(): TransactionSignWeight_Result {
  return { code: 0, message: "", _unknownFields: {} };
}

export const TransactionSignWeight_Result = {
  encode(message: TransactionSignWeight_Result, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionSignWeight_Result {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionSignWeight_Result();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionSignWeight_Result {
    return {
      code: isSet(object.code) ? transactionSignWeight_Result_responseCodeFromJSON(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: TransactionSignWeight_Result): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = transactionSignWeight_Result_responseCodeToJSON(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionSignWeight_Result>, I>>(base?: I): TransactionSignWeight_Result {
    return TransactionSignWeight_Result.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionSignWeight_Result>, I>>(object: I): TransactionSignWeight_Result {
    const message = createBaseTransactionSignWeight_Result();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseTransactionApprovedList(): TransactionApprovedList {
  return { approvedList: [], result: undefined, transaction: undefined, _unknownFields: {} };
}

export const TransactionApprovedList = {
  encode(message: TransactionApprovedList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.approvedList) {
      writer.uint32(18).bytes(v!);
    }
    if (message.result !== undefined) {
      TransactionApprovedList_Result.encode(message.result, writer.uint32(34).fork()).ldelim();
    }
    if (message.transaction !== undefined) {
      TransactionExtention.encode(message.transaction, writer.uint32(42).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionApprovedList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionApprovedList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.approvedList.push(reader.bytes() as Buffer);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.result = TransactionApprovedList_Result.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transaction = TransactionExtention.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionApprovedList {
    return {
      approvedList: globalThis.Array.isArray(object?.approvedList)
        ? object.approvedList.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      result: isSet(object.result) ? TransactionApprovedList_Result.fromJSON(object.result) : undefined,
      transaction: isSet(object.transaction) ? TransactionExtention.fromJSON(object.transaction) : undefined,
    };
  },

  toJSON(message: TransactionApprovedList): unknown {
    const obj: any = {};
    if (message.approvedList?.length) {
      obj.approvedList = message.approvedList.map((e) => base64FromBytes(e));
    }
    if (message.result !== undefined) {
      obj.result = TransactionApprovedList_Result.toJSON(message.result);
    }
    if (message.transaction !== undefined) {
      obj.transaction = TransactionExtention.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionApprovedList>, I>>(base?: I): TransactionApprovedList {
    return TransactionApprovedList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionApprovedList>, I>>(object: I): TransactionApprovedList {
    const message = createBaseTransactionApprovedList();
    message.approvedList = object.approvedList?.map((e) => e) || [];
    message.result = (object.result !== undefined && object.result !== null)
      ? TransactionApprovedList_Result.fromPartial(object.result)
      : undefined;
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? TransactionExtention.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseTransactionApprovedList_Result(): TransactionApprovedList_Result {
  return { code: 0, message: "", _unknownFields: {} };
}

export const TransactionApprovedList_Result = {
  encode(message: TransactionApprovedList_Result, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionApprovedList_Result {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionApprovedList_Result();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionApprovedList_Result {
    return {
      code: isSet(object.code) ? transactionApprovedList_Result_responseCodeFromJSON(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: TransactionApprovedList_Result): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = transactionApprovedList_Result_responseCodeToJSON(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionApprovedList_Result>, I>>(base?: I): TransactionApprovedList_Result {
    return TransactionApprovedList_Result.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionApprovedList_Result>, I>>(
    object: I,
  ): TransactionApprovedList_Result {
    const message = createBaseTransactionApprovedList_Result();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseIvkDecryptParameters(): IvkDecryptParameters {
  return { startBlockIndex: Long.ZERO, endBlockIndex: Long.ZERO, ivk: Buffer.alloc(0), _unknownFields: {} };
}

export const IvkDecryptParameters = {
  encode(message: IvkDecryptParameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.startBlockIndex.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.startBlockIndex);
    }
    if (!message.endBlockIndex.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.endBlockIndex);
    }
    if (message.ivk.length !== 0) {
      writer.uint32(26).bytes(message.ivk);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IvkDecryptParameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIvkDecryptParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startBlockIndex = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endBlockIndex = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ivk = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): IvkDecryptParameters {
    return {
      startBlockIndex: isSet(object.startBlockIndex) ? Long.fromValue(object.startBlockIndex) : Long.ZERO,
      endBlockIndex: isSet(object.endBlockIndex) ? Long.fromValue(object.endBlockIndex) : Long.ZERO,
      ivk: isSet(object.ivk) ? Buffer.from(bytesFromBase64(object.ivk)) : Buffer.alloc(0),
    };
  },

  toJSON(message: IvkDecryptParameters): unknown {
    const obj: any = {};
    if (!message.startBlockIndex.equals(Long.ZERO)) {
      obj.startBlockIndex = (message.startBlockIndex || Long.ZERO).toString();
    }
    if (!message.endBlockIndex.equals(Long.ZERO)) {
      obj.endBlockIndex = (message.endBlockIndex || Long.ZERO).toString();
    }
    if (message.ivk.length !== 0) {
      obj.ivk = base64FromBytes(message.ivk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IvkDecryptParameters>, I>>(base?: I): IvkDecryptParameters {
    return IvkDecryptParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IvkDecryptParameters>, I>>(object: I): IvkDecryptParameters {
    const message = createBaseIvkDecryptParameters();
    message.startBlockIndex = (object.startBlockIndex !== undefined && object.startBlockIndex !== null)
      ? Long.fromValue(object.startBlockIndex)
      : Long.ZERO;
    message.endBlockIndex = (object.endBlockIndex !== undefined && object.endBlockIndex !== null)
      ? Long.fromValue(object.endBlockIndex)
      : Long.ZERO;
    message.ivk = object.ivk ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseIvkDecryptAndMarkParameters(): IvkDecryptAndMarkParameters {
  return {
    startBlockIndex: Long.ZERO,
    endBlockIndex: Long.ZERO,
    ivk: Buffer.alloc(0),
    ak: Buffer.alloc(0),
    nk: Buffer.alloc(0),
    _unknownFields: {},
  };
}

export const IvkDecryptAndMarkParameters = {
  encode(message: IvkDecryptAndMarkParameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.startBlockIndex.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.startBlockIndex);
    }
    if (!message.endBlockIndex.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.endBlockIndex);
    }
    if (message.ivk.length !== 0) {
      writer.uint32(42).bytes(message.ivk);
    }
    if (message.ak.length !== 0) {
      writer.uint32(26).bytes(message.ak);
    }
    if (message.nk.length !== 0) {
      writer.uint32(34).bytes(message.nk);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IvkDecryptAndMarkParameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIvkDecryptAndMarkParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startBlockIndex = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endBlockIndex = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ivk = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ak = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nk = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): IvkDecryptAndMarkParameters {
    return {
      startBlockIndex: isSet(object.startBlockIndex) ? Long.fromValue(object.startBlockIndex) : Long.ZERO,
      endBlockIndex: isSet(object.endBlockIndex) ? Long.fromValue(object.endBlockIndex) : Long.ZERO,
      ivk: isSet(object.ivk) ? Buffer.from(bytesFromBase64(object.ivk)) : Buffer.alloc(0),
      ak: isSet(object.ak) ? Buffer.from(bytesFromBase64(object.ak)) : Buffer.alloc(0),
      nk: isSet(object.nk) ? Buffer.from(bytesFromBase64(object.nk)) : Buffer.alloc(0),
    };
  },

  toJSON(message: IvkDecryptAndMarkParameters): unknown {
    const obj: any = {};
    if (!message.startBlockIndex.equals(Long.ZERO)) {
      obj.startBlockIndex = (message.startBlockIndex || Long.ZERO).toString();
    }
    if (!message.endBlockIndex.equals(Long.ZERO)) {
      obj.endBlockIndex = (message.endBlockIndex || Long.ZERO).toString();
    }
    if (message.ivk.length !== 0) {
      obj.ivk = base64FromBytes(message.ivk);
    }
    if (message.ak.length !== 0) {
      obj.ak = base64FromBytes(message.ak);
    }
    if (message.nk.length !== 0) {
      obj.nk = base64FromBytes(message.nk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IvkDecryptAndMarkParameters>, I>>(base?: I): IvkDecryptAndMarkParameters {
    return IvkDecryptAndMarkParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IvkDecryptAndMarkParameters>, I>>(object: I): IvkDecryptAndMarkParameters {
    const message = createBaseIvkDecryptAndMarkParameters();
    message.startBlockIndex = (object.startBlockIndex !== undefined && object.startBlockIndex !== null)
      ? Long.fromValue(object.startBlockIndex)
      : Long.ZERO;
    message.endBlockIndex = (object.endBlockIndex !== undefined && object.endBlockIndex !== null)
      ? Long.fromValue(object.endBlockIndex)
      : Long.ZERO;
    message.ivk = object.ivk ?? Buffer.alloc(0);
    message.ak = object.ak ?? Buffer.alloc(0);
    message.nk = object.nk ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseOvkDecryptParameters(): OvkDecryptParameters {
  return { startBlockIndex: Long.ZERO, endBlockIndex: Long.ZERO, ovk: Buffer.alloc(0), _unknownFields: {} };
}

export const OvkDecryptParameters = {
  encode(message: OvkDecryptParameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.startBlockIndex.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.startBlockIndex);
    }
    if (!message.endBlockIndex.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.endBlockIndex);
    }
    if (message.ovk.length !== 0) {
      writer.uint32(26).bytes(message.ovk);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OvkDecryptParameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOvkDecryptParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startBlockIndex = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endBlockIndex = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ovk = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): OvkDecryptParameters {
    return {
      startBlockIndex: isSet(object.startBlockIndex) ? Long.fromValue(object.startBlockIndex) : Long.ZERO,
      endBlockIndex: isSet(object.endBlockIndex) ? Long.fromValue(object.endBlockIndex) : Long.ZERO,
      ovk: isSet(object.ovk) ? Buffer.from(bytesFromBase64(object.ovk)) : Buffer.alloc(0),
    };
  },

  toJSON(message: OvkDecryptParameters): unknown {
    const obj: any = {};
    if (!message.startBlockIndex.equals(Long.ZERO)) {
      obj.startBlockIndex = (message.startBlockIndex || Long.ZERO).toString();
    }
    if (!message.endBlockIndex.equals(Long.ZERO)) {
      obj.endBlockIndex = (message.endBlockIndex || Long.ZERO).toString();
    }
    if (message.ovk.length !== 0) {
      obj.ovk = base64FromBytes(message.ovk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OvkDecryptParameters>, I>>(base?: I): OvkDecryptParameters {
    return OvkDecryptParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OvkDecryptParameters>, I>>(object: I): OvkDecryptParameters {
    const message = createBaseOvkDecryptParameters();
    message.startBlockIndex = (object.startBlockIndex !== undefined && object.startBlockIndex !== null)
      ? Long.fromValue(object.startBlockIndex)
      : Long.ZERO;
    message.endBlockIndex = (object.endBlockIndex !== undefined && object.endBlockIndex !== null)
      ? Long.fromValue(object.endBlockIndex)
      : Long.ZERO;
    message.ovk = object.ovk ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseDecryptNotes(): DecryptNotes {
  return { noteTxs: [], _unknownFields: {} };
}

export const DecryptNotes = {
  encode(message: DecryptNotes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.noteTxs) {
      DecryptNotes_NoteTx.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DecryptNotes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptNotes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.noteTxs.push(DecryptNotes_NoteTx.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): DecryptNotes {
    return {
      noteTxs: globalThis.Array.isArray(object?.noteTxs)
        ? object.noteTxs.map((e: any) => DecryptNotes_NoteTx.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DecryptNotes): unknown {
    const obj: any = {};
    if (message.noteTxs?.length) {
      obj.noteTxs = message.noteTxs.map((e) => DecryptNotes_NoteTx.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptNotes>, I>>(base?: I): DecryptNotes {
    return DecryptNotes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptNotes>, I>>(object: I): DecryptNotes {
    const message = createBaseDecryptNotes();
    message.noteTxs = object.noteTxs?.map((e) => DecryptNotes_NoteTx.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDecryptNotes_NoteTx(): DecryptNotes_NoteTx {
  return { note: undefined, txid: Buffer.alloc(0), index: 0, _unknownFields: {} };
}

export const DecryptNotes_NoteTx = {
  encode(message: DecryptNotes_NoteTx, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(10).fork()).ldelim();
    }
    if (message.txid.length !== 0) {
      writer.uint32(18).bytes(message.txid);
    }
    if (message.index !== 0) {
      writer.uint32(24).int32(message.index);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DecryptNotes_NoteTx {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptNotes_NoteTx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.txid = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.index = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): DecryptNotes_NoteTx {
    return {
      note: isSet(object.note) ? Note.fromJSON(object.note) : undefined,
      txid: isSet(object.txid) ? Buffer.from(bytesFromBase64(object.txid)) : Buffer.alloc(0),
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: DecryptNotes_NoteTx): unknown {
    const obj: any = {};
    if (message.note !== undefined) {
      obj.note = Note.toJSON(message.note);
    }
    if (message.txid.length !== 0) {
      obj.txid = base64FromBytes(message.txid);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptNotes_NoteTx>, I>>(base?: I): DecryptNotes_NoteTx {
    return DecryptNotes_NoteTx.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptNotes_NoteTx>, I>>(object: I): DecryptNotes_NoteTx {
    const message = createBaseDecryptNotes_NoteTx();
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    message.txid = object.txid ?? Buffer.alloc(0);
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseDecryptNotesMarked(): DecryptNotesMarked {
  return { noteTxs: [], _unknownFields: {} };
}

export const DecryptNotesMarked = {
  encode(message: DecryptNotesMarked, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.noteTxs) {
      DecryptNotesMarked_NoteTx.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DecryptNotesMarked {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptNotesMarked();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.noteTxs.push(DecryptNotesMarked_NoteTx.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): DecryptNotesMarked {
    return {
      noteTxs: globalThis.Array.isArray(object?.noteTxs)
        ? object.noteTxs.map((e: any) => DecryptNotesMarked_NoteTx.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DecryptNotesMarked): unknown {
    const obj: any = {};
    if (message.noteTxs?.length) {
      obj.noteTxs = message.noteTxs.map((e) => DecryptNotesMarked_NoteTx.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptNotesMarked>, I>>(base?: I): DecryptNotesMarked {
    return DecryptNotesMarked.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptNotesMarked>, I>>(object: I): DecryptNotesMarked {
    const message = createBaseDecryptNotesMarked();
    message.noteTxs = object.noteTxs?.map((e) => DecryptNotesMarked_NoteTx.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDecryptNotesMarked_NoteTx(): DecryptNotesMarked_NoteTx {
  return { note: undefined, txid: Buffer.alloc(0), index: 0, isSpend: false, _unknownFields: {} };
}

export const DecryptNotesMarked_NoteTx = {
  encode(message: DecryptNotesMarked_NoteTx, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(10).fork()).ldelim();
    }
    if (message.txid.length !== 0) {
      writer.uint32(18).bytes(message.txid);
    }
    if (message.index !== 0) {
      writer.uint32(24).int32(message.index);
    }
    if (message.isSpend !== false) {
      writer.uint32(32).bool(message.isSpend);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DecryptNotesMarked_NoteTx {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptNotesMarked_NoteTx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.txid = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isSpend = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): DecryptNotesMarked_NoteTx {
    return {
      note: isSet(object.note) ? Note.fromJSON(object.note) : undefined,
      txid: isSet(object.txid) ? Buffer.from(bytesFromBase64(object.txid)) : Buffer.alloc(0),
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      isSpend: isSet(object.isSpend) ? globalThis.Boolean(object.isSpend) : false,
    };
  },

  toJSON(message: DecryptNotesMarked_NoteTx): unknown {
    const obj: any = {};
    if (message.note !== undefined) {
      obj.note = Note.toJSON(message.note);
    }
    if (message.txid.length !== 0) {
      obj.txid = base64FromBytes(message.txid);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.isSpend !== false) {
      obj.isSpend = message.isSpend;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptNotesMarked_NoteTx>, I>>(base?: I): DecryptNotesMarked_NoteTx {
    return DecryptNotesMarked_NoteTx.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptNotesMarked_NoteTx>, I>>(object: I): DecryptNotesMarked_NoteTx {
    const message = createBaseDecryptNotesMarked_NoteTx();
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    message.txid = object.txid ?? Buffer.alloc(0);
    message.index = object.index ?? 0;
    message.isSpend = object.isSpend ?? false;
    return message;
  },
};

function createBaseNote(): Note {
  return { value: Long.ZERO, paymentAddress: "", rcm: Buffer.alloc(0), memo: Buffer.alloc(0), _unknownFields: {} };
}

export const Note = {
  encode(message: Note, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.value);
    }
    if (message.paymentAddress !== "") {
      writer.uint32(18).string(message.paymentAddress);
    }
    if (message.rcm.length !== 0) {
      writer.uint32(26).bytes(message.rcm);
    }
    if (message.memo.length !== 0) {
      writer.uint32(34).bytes(message.memo);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Note {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.paymentAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rcm = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.memo = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Note {
    return {
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
      paymentAddress: isSet(object.paymentAddress) ? globalThis.String(object.paymentAddress) : "",
      rcm: isSet(object.rcm) ? Buffer.from(bytesFromBase64(object.rcm)) : Buffer.alloc(0),
      memo: isSet(object.memo) ? Buffer.from(bytesFromBase64(object.memo)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Note): unknown {
    const obj: any = {};
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    if (message.paymentAddress !== "") {
      obj.paymentAddress = message.paymentAddress;
    }
    if (message.rcm.length !== 0) {
      obj.rcm = base64FromBytes(message.rcm);
    }
    if (message.memo.length !== 0) {
      obj.memo = base64FromBytes(message.memo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Note>, I>>(base?: I): Note {
    return Note.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Note>, I>>(object: I): Note {
    const message = createBaseNote();
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    message.paymentAddress = object.paymentAddress ?? "";
    message.rcm = object.rcm ?? Buffer.alloc(0);
    message.memo = object.memo ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseSpendNote(): SpendNote {
  return { note: undefined, alpha: Buffer.alloc(0), voucher: undefined, path: Buffer.alloc(0), _unknownFields: {} };
}

export const SpendNote = {
  encode(message: SpendNote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(26).fork()).ldelim();
    }
    if (message.alpha.length !== 0) {
      writer.uint32(34).bytes(message.alpha);
    }
    if (message.voucher !== undefined) {
      IncrementalMerkleVoucher.encode(message.voucher, writer.uint32(42).fork()).ldelim();
    }
    if (message.path.length !== 0) {
      writer.uint32(50).bytes(message.path);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpendNote {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpendNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.alpha = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.voucher = IncrementalMerkleVoucher.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.path = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): SpendNote {
    return {
      note: isSet(object.note) ? Note.fromJSON(object.note) : undefined,
      alpha: isSet(object.alpha) ? Buffer.from(bytesFromBase64(object.alpha)) : Buffer.alloc(0),
      voucher: isSet(object.voucher) ? IncrementalMerkleVoucher.fromJSON(object.voucher) : undefined,
      path: isSet(object.path) ? Buffer.from(bytesFromBase64(object.path)) : Buffer.alloc(0),
    };
  },

  toJSON(message: SpendNote): unknown {
    const obj: any = {};
    if (message.note !== undefined) {
      obj.note = Note.toJSON(message.note);
    }
    if (message.alpha.length !== 0) {
      obj.alpha = base64FromBytes(message.alpha);
    }
    if (message.voucher !== undefined) {
      obj.voucher = IncrementalMerkleVoucher.toJSON(message.voucher);
    }
    if (message.path.length !== 0) {
      obj.path = base64FromBytes(message.path);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpendNote>, I>>(base?: I): SpendNote {
    return SpendNote.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpendNote>, I>>(object: I): SpendNote {
    const message = createBaseSpendNote();
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    message.alpha = object.alpha ?? Buffer.alloc(0);
    message.voucher = (object.voucher !== undefined && object.voucher !== null)
      ? IncrementalMerkleVoucher.fromPartial(object.voucher)
      : undefined;
    message.path = object.path ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseReceiveNote(): ReceiveNote {
  return { note: undefined, _unknownFields: {} };
}

export const ReceiveNote = {
  encode(message: ReceiveNote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReceiveNote {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiveNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ReceiveNote {
    return { note: isSet(object.note) ? Note.fromJSON(object.note) : undefined };
  },

  toJSON(message: ReceiveNote): unknown {
    const obj: any = {};
    if (message.note !== undefined) {
      obj.note = Note.toJSON(message.note);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiveNote>, I>>(base?: I): ReceiveNote {
    return ReceiveNote.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiveNote>, I>>(object: I): ReceiveNote {
    const message = createBaseReceiveNote();
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    return message;
  },
};

function createBasePrivateParameters(): PrivateParameters {
  return {
    transparentFromAddress: Buffer.alloc(0),
    ask: Buffer.alloc(0),
    nsk: Buffer.alloc(0),
    ovk: Buffer.alloc(0),
    fromAmount: Long.ZERO,
    shieldedSpends: [],
    shieldedReceives: [],
    transparentToAddress: Buffer.alloc(0),
    toAmount: Long.ZERO,
    timeout: Long.ZERO,
    _unknownFields: {},
  };
}

export const PrivateParameters = {
  encode(message: PrivateParameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.transparentFromAddress.length !== 0) {
      writer.uint32(10).bytes(message.transparentFromAddress);
    }
    if (message.ask.length !== 0) {
      writer.uint32(18).bytes(message.ask);
    }
    if (message.nsk.length !== 0) {
      writer.uint32(26).bytes(message.nsk);
    }
    if (message.ovk.length !== 0) {
      writer.uint32(34).bytes(message.ovk);
    }
    if (!message.fromAmount.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.fromAmount);
    }
    for (const v of message.shieldedSpends) {
      SpendNote.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.shieldedReceives) {
      ReceiveNote.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.transparentToAddress.length !== 0) {
      writer.uint32(66).bytes(message.transparentToAddress);
    }
    if (!message.toAmount.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.toAmount);
    }
    if (!message.timeout.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.timeout);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PrivateParameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transparentFromAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ask = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nsk = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ovk = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.fromAmount = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.shieldedSpends.push(SpendNote.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.shieldedReceives.push(ReceiveNote.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.transparentToAddress = reader.bytes() as Buffer;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.toAmount = reader.int64() as Long;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.timeout = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): PrivateParameters {
    return {
      transparentFromAddress: isSet(object.transparentFromAddress)
        ? Buffer.from(bytesFromBase64(object.transparentFromAddress))
        : Buffer.alloc(0),
      ask: isSet(object.ask) ? Buffer.from(bytesFromBase64(object.ask)) : Buffer.alloc(0),
      nsk: isSet(object.nsk) ? Buffer.from(bytesFromBase64(object.nsk)) : Buffer.alloc(0),
      ovk: isSet(object.ovk) ? Buffer.from(bytesFromBase64(object.ovk)) : Buffer.alloc(0),
      fromAmount: isSet(object.fromAmount) ? Long.fromValue(object.fromAmount) : Long.ZERO,
      shieldedSpends: globalThis.Array.isArray(object?.shieldedSpends)
        ? object.shieldedSpends.map((e: any) => SpendNote.fromJSON(e))
        : [],
      shieldedReceives: globalThis.Array.isArray(object?.shieldedReceives)
        ? object.shieldedReceives.map((e: any) => ReceiveNote.fromJSON(e))
        : [],
      transparentToAddress: isSet(object.transparentToAddress)
        ? Buffer.from(bytesFromBase64(object.transparentToAddress))
        : Buffer.alloc(0),
      toAmount: isSet(object.toAmount) ? Long.fromValue(object.toAmount) : Long.ZERO,
      timeout: isSet(object.timeout) ? Long.fromValue(object.timeout) : Long.ZERO,
    };
  },

  toJSON(message: PrivateParameters): unknown {
    const obj: any = {};
    if (message.transparentFromAddress.length !== 0) {
      obj.transparentFromAddress = base64FromBytes(message.transparentFromAddress);
    }
    if (message.ask.length !== 0) {
      obj.ask = base64FromBytes(message.ask);
    }
    if (message.nsk.length !== 0) {
      obj.nsk = base64FromBytes(message.nsk);
    }
    if (message.ovk.length !== 0) {
      obj.ovk = base64FromBytes(message.ovk);
    }
    if (!message.fromAmount.equals(Long.ZERO)) {
      obj.fromAmount = (message.fromAmount || Long.ZERO).toString();
    }
    if (message.shieldedSpends?.length) {
      obj.shieldedSpends = message.shieldedSpends.map((e) => SpendNote.toJSON(e));
    }
    if (message.shieldedReceives?.length) {
      obj.shieldedReceives = message.shieldedReceives.map((e) => ReceiveNote.toJSON(e));
    }
    if (message.transparentToAddress.length !== 0) {
      obj.transparentToAddress = base64FromBytes(message.transparentToAddress);
    }
    if (!message.toAmount.equals(Long.ZERO)) {
      obj.toAmount = (message.toAmount || Long.ZERO).toString();
    }
    if (!message.timeout.equals(Long.ZERO)) {
      obj.timeout = (message.timeout || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrivateParameters>, I>>(base?: I): PrivateParameters {
    return PrivateParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrivateParameters>, I>>(object: I): PrivateParameters {
    const message = createBasePrivateParameters();
    message.transparentFromAddress = object.transparentFromAddress ?? Buffer.alloc(0);
    message.ask = object.ask ?? Buffer.alloc(0);
    message.nsk = object.nsk ?? Buffer.alloc(0);
    message.ovk = object.ovk ?? Buffer.alloc(0);
    message.fromAmount = (object.fromAmount !== undefined && object.fromAmount !== null)
      ? Long.fromValue(object.fromAmount)
      : Long.ZERO;
    message.shieldedSpends = object.shieldedSpends?.map((e) => SpendNote.fromPartial(e)) || [];
    message.shieldedReceives = object.shieldedReceives?.map((e) => ReceiveNote.fromPartial(e)) || [];
    message.transparentToAddress = object.transparentToAddress ?? Buffer.alloc(0);
    message.toAmount = (object.toAmount !== undefined && object.toAmount !== null)
      ? Long.fromValue(object.toAmount)
      : Long.ZERO;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Long.fromValue(object.timeout)
      : Long.ZERO;
    return message;
  },
};

function createBasePrivateParametersWithoutAsk(): PrivateParametersWithoutAsk {
  return {
    transparentFromAddress: Buffer.alloc(0),
    ak: Buffer.alloc(0),
    nsk: Buffer.alloc(0),
    ovk: Buffer.alloc(0),
    fromAmount: Long.ZERO,
    shieldedSpends: [],
    shieldedReceives: [],
    transparentToAddress: Buffer.alloc(0),
    toAmount: Long.ZERO,
    timeout: Long.ZERO,
    _unknownFields: {},
  };
}

export const PrivateParametersWithoutAsk = {
  encode(message: PrivateParametersWithoutAsk, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.transparentFromAddress.length !== 0) {
      writer.uint32(10).bytes(message.transparentFromAddress);
    }
    if (message.ak.length !== 0) {
      writer.uint32(18).bytes(message.ak);
    }
    if (message.nsk.length !== 0) {
      writer.uint32(26).bytes(message.nsk);
    }
    if (message.ovk.length !== 0) {
      writer.uint32(34).bytes(message.ovk);
    }
    if (!message.fromAmount.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.fromAmount);
    }
    for (const v of message.shieldedSpends) {
      SpendNote.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.shieldedReceives) {
      ReceiveNote.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.transparentToAddress.length !== 0) {
      writer.uint32(66).bytes(message.transparentToAddress);
    }
    if (!message.toAmount.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.toAmount);
    }
    if (!message.timeout.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.timeout);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PrivateParametersWithoutAsk {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateParametersWithoutAsk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transparentFromAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ak = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nsk = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ovk = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.fromAmount = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.shieldedSpends.push(SpendNote.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.shieldedReceives.push(ReceiveNote.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.transparentToAddress = reader.bytes() as Buffer;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.toAmount = reader.int64() as Long;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.timeout = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): PrivateParametersWithoutAsk {
    return {
      transparentFromAddress: isSet(object.transparentFromAddress)
        ? Buffer.from(bytesFromBase64(object.transparentFromAddress))
        : Buffer.alloc(0),
      ak: isSet(object.ak) ? Buffer.from(bytesFromBase64(object.ak)) : Buffer.alloc(0),
      nsk: isSet(object.nsk) ? Buffer.from(bytesFromBase64(object.nsk)) : Buffer.alloc(0),
      ovk: isSet(object.ovk) ? Buffer.from(bytesFromBase64(object.ovk)) : Buffer.alloc(0),
      fromAmount: isSet(object.fromAmount) ? Long.fromValue(object.fromAmount) : Long.ZERO,
      shieldedSpends: globalThis.Array.isArray(object?.shieldedSpends)
        ? object.shieldedSpends.map((e: any) => SpendNote.fromJSON(e))
        : [],
      shieldedReceives: globalThis.Array.isArray(object?.shieldedReceives)
        ? object.shieldedReceives.map((e: any) => ReceiveNote.fromJSON(e))
        : [],
      transparentToAddress: isSet(object.transparentToAddress)
        ? Buffer.from(bytesFromBase64(object.transparentToAddress))
        : Buffer.alloc(0),
      toAmount: isSet(object.toAmount) ? Long.fromValue(object.toAmount) : Long.ZERO,
      timeout: isSet(object.timeout) ? Long.fromValue(object.timeout) : Long.ZERO,
    };
  },

  toJSON(message: PrivateParametersWithoutAsk): unknown {
    const obj: any = {};
    if (message.transparentFromAddress.length !== 0) {
      obj.transparentFromAddress = base64FromBytes(message.transparentFromAddress);
    }
    if (message.ak.length !== 0) {
      obj.ak = base64FromBytes(message.ak);
    }
    if (message.nsk.length !== 0) {
      obj.nsk = base64FromBytes(message.nsk);
    }
    if (message.ovk.length !== 0) {
      obj.ovk = base64FromBytes(message.ovk);
    }
    if (!message.fromAmount.equals(Long.ZERO)) {
      obj.fromAmount = (message.fromAmount || Long.ZERO).toString();
    }
    if (message.shieldedSpends?.length) {
      obj.shieldedSpends = message.shieldedSpends.map((e) => SpendNote.toJSON(e));
    }
    if (message.shieldedReceives?.length) {
      obj.shieldedReceives = message.shieldedReceives.map((e) => ReceiveNote.toJSON(e));
    }
    if (message.transparentToAddress.length !== 0) {
      obj.transparentToAddress = base64FromBytes(message.transparentToAddress);
    }
    if (!message.toAmount.equals(Long.ZERO)) {
      obj.toAmount = (message.toAmount || Long.ZERO).toString();
    }
    if (!message.timeout.equals(Long.ZERO)) {
      obj.timeout = (message.timeout || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrivateParametersWithoutAsk>, I>>(base?: I): PrivateParametersWithoutAsk {
    return PrivateParametersWithoutAsk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrivateParametersWithoutAsk>, I>>(object: I): PrivateParametersWithoutAsk {
    const message = createBasePrivateParametersWithoutAsk();
    message.transparentFromAddress = object.transparentFromAddress ?? Buffer.alloc(0);
    message.ak = object.ak ?? Buffer.alloc(0);
    message.nsk = object.nsk ?? Buffer.alloc(0);
    message.ovk = object.ovk ?? Buffer.alloc(0);
    message.fromAmount = (object.fromAmount !== undefined && object.fromAmount !== null)
      ? Long.fromValue(object.fromAmount)
      : Long.ZERO;
    message.shieldedSpends = object.shieldedSpends?.map((e) => SpendNote.fromPartial(e)) || [];
    message.shieldedReceives = object.shieldedReceives?.map((e) => ReceiveNote.fromPartial(e)) || [];
    message.transparentToAddress = object.transparentToAddress ?? Buffer.alloc(0);
    message.toAmount = (object.toAmount !== undefined && object.toAmount !== null)
      ? Long.fromValue(object.toAmount)
      : Long.ZERO;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Long.fromValue(object.timeout)
      : Long.ZERO;
    return message;
  },
};

function createBaseSpendAuthSigParameters(): SpendAuthSigParameters {
  return { ask: Buffer.alloc(0), txHash: Buffer.alloc(0), alpha: Buffer.alloc(0), _unknownFields: {} };
}

export const SpendAuthSigParameters = {
  encode(message: SpendAuthSigParameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ask.length !== 0) {
      writer.uint32(10).bytes(message.ask);
    }
    if (message.txHash.length !== 0) {
      writer.uint32(18).bytes(message.txHash);
    }
    if (message.alpha.length !== 0) {
      writer.uint32(26).bytes(message.alpha);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpendAuthSigParameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpendAuthSigParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ask = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.txHash = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.alpha = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): SpendAuthSigParameters {
    return {
      ask: isSet(object.ask) ? Buffer.from(bytesFromBase64(object.ask)) : Buffer.alloc(0),
      txHash: isSet(object.txHash) ? Buffer.from(bytesFromBase64(object.txHash)) : Buffer.alloc(0),
      alpha: isSet(object.alpha) ? Buffer.from(bytesFromBase64(object.alpha)) : Buffer.alloc(0),
    };
  },

  toJSON(message: SpendAuthSigParameters): unknown {
    const obj: any = {};
    if (message.ask.length !== 0) {
      obj.ask = base64FromBytes(message.ask);
    }
    if (message.txHash.length !== 0) {
      obj.txHash = base64FromBytes(message.txHash);
    }
    if (message.alpha.length !== 0) {
      obj.alpha = base64FromBytes(message.alpha);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpendAuthSigParameters>, I>>(base?: I): SpendAuthSigParameters {
    return SpendAuthSigParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpendAuthSigParameters>, I>>(object: I): SpendAuthSigParameters {
    const message = createBaseSpendAuthSigParameters();
    message.ask = object.ask ?? Buffer.alloc(0);
    message.txHash = object.txHash ?? Buffer.alloc(0);
    message.alpha = object.alpha ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseNfParameters(): NfParameters {
  return { note: undefined, voucher: undefined, ak: Buffer.alloc(0), nk: Buffer.alloc(0), _unknownFields: {} };
}

export const NfParameters = {
  encode(message: NfParameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(10).fork()).ldelim();
    }
    if (message.voucher !== undefined) {
      IncrementalMerkleVoucher.encode(message.voucher, writer.uint32(18).fork()).ldelim();
    }
    if (message.ak.length !== 0) {
      writer.uint32(26).bytes(message.ak);
    }
    if (message.nk.length !== 0) {
      writer.uint32(34).bytes(message.nk);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NfParameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNfParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.voucher = IncrementalMerkleVoucher.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ak = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nk = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): NfParameters {
    return {
      note: isSet(object.note) ? Note.fromJSON(object.note) : undefined,
      voucher: isSet(object.voucher) ? IncrementalMerkleVoucher.fromJSON(object.voucher) : undefined,
      ak: isSet(object.ak) ? Buffer.from(bytesFromBase64(object.ak)) : Buffer.alloc(0),
      nk: isSet(object.nk) ? Buffer.from(bytesFromBase64(object.nk)) : Buffer.alloc(0),
    };
  },

  toJSON(message: NfParameters): unknown {
    const obj: any = {};
    if (message.note !== undefined) {
      obj.note = Note.toJSON(message.note);
    }
    if (message.voucher !== undefined) {
      obj.voucher = IncrementalMerkleVoucher.toJSON(message.voucher);
    }
    if (message.ak.length !== 0) {
      obj.ak = base64FromBytes(message.ak);
    }
    if (message.nk.length !== 0) {
      obj.nk = base64FromBytes(message.nk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NfParameters>, I>>(base?: I): NfParameters {
    return NfParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NfParameters>, I>>(object: I): NfParameters {
    const message = createBaseNfParameters();
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    message.voucher = (object.voucher !== undefined && object.voucher !== null)
      ? IncrementalMerkleVoucher.fromPartial(object.voucher)
      : undefined;
    message.ak = object.ak ?? Buffer.alloc(0);
    message.nk = object.nk ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseExpandedSpendingKeyMessage(): ExpandedSpendingKeyMessage {
  return { ask: Buffer.alloc(0), nsk: Buffer.alloc(0), ovk: Buffer.alloc(0), _unknownFields: {} };
}

export const ExpandedSpendingKeyMessage = {
  encode(message: ExpandedSpendingKeyMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ask.length !== 0) {
      writer.uint32(10).bytes(message.ask);
    }
    if (message.nsk.length !== 0) {
      writer.uint32(18).bytes(message.nsk);
    }
    if (message.ovk.length !== 0) {
      writer.uint32(26).bytes(message.ovk);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExpandedSpendingKeyMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpandedSpendingKeyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ask = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nsk = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ovk = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ExpandedSpendingKeyMessage {
    return {
      ask: isSet(object.ask) ? Buffer.from(bytesFromBase64(object.ask)) : Buffer.alloc(0),
      nsk: isSet(object.nsk) ? Buffer.from(bytesFromBase64(object.nsk)) : Buffer.alloc(0),
      ovk: isSet(object.ovk) ? Buffer.from(bytesFromBase64(object.ovk)) : Buffer.alloc(0),
    };
  },

  toJSON(message: ExpandedSpendingKeyMessage): unknown {
    const obj: any = {};
    if (message.ask.length !== 0) {
      obj.ask = base64FromBytes(message.ask);
    }
    if (message.nsk.length !== 0) {
      obj.nsk = base64FromBytes(message.nsk);
    }
    if (message.ovk.length !== 0) {
      obj.ovk = base64FromBytes(message.ovk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExpandedSpendingKeyMessage>, I>>(base?: I): ExpandedSpendingKeyMessage {
    return ExpandedSpendingKeyMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExpandedSpendingKeyMessage>, I>>(object: I): ExpandedSpendingKeyMessage {
    const message = createBaseExpandedSpendingKeyMessage();
    message.ask = object.ask ?? Buffer.alloc(0);
    message.nsk = object.nsk ?? Buffer.alloc(0);
    message.ovk = object.ovk ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseViewingKeyMessage(): ViewingKeyMessage {
  return { ak: Buffer.alloc(0), nk: Buffer.alloc(0), _unknownFields: {} };
}

export const ViewingKeyMessage = {
  encode(message: ViewingKeyMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ak.length !== 0) {
      writer.uint32(10).bytes(message.ak);
    }
    if (message.nk.length !== 0) {
      writer.uint32(18).bytes(message.nk);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ViewingKeyMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewingKeyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ak = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nk = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ViewingKeyMessage {
    return {
      ak: isSet(object.ak) ? Buffer.from(bytesFromBase64(object.ak)) : Buffer.alloc(0),
      nk: isSet(object.nk) ? Buffer.from(bytesFromBase64(object.nk)) : Buffer.alloc(0),
    };
  },

  toJSON(message: ViewingKeyMessage): unknown {
    const obj: any = {};
    if (message.ak.length !== 0) {
      obj.ak = base64FromBytes(message.ak);
    }
    if (message.nk.length !== 0) {
      obj.nk = base64FromBytes(message.nk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ViewingKeyMessage>, I>>(base?: I): ViewingKeyMessage {
    return ViewingKeyMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ViewingKeyMessage>, I>>(object: I): ViewingKeyMessage {
    const message = createBaseViewingKeyMessage();
    message.ak = object.ak ?? Buffer.alloc(0);
    message.nk = object.nk ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseIncomingViewingKeyMessage(): IncomingViewingKeyMessage {
  return { ivk: Buffer.alloc(0), _unknownFields: {} };
}

export const IncomingViewingKeyMessage = {
  encode(message: IncomingViewingKeyMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ivk.length !== 0) {
      writer.uint32(10).bytes(message.ivk);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IncomingViewingKeyMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncomingViewingKeyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ivk = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): IncomingViewingKeyMessage {
    return { ivk: isSet(object.ivk) ? Buffer.from(bytesFromBase64(object.ivk)) : Buffer.alloc(0) };
  },

  toJSON(message: IncomingViewingKeyMessage): unknown {
    const obj: any = {};
    if (message.ivk.length !== 0) {
      obj.ivk = base64FromBytes(message.ivk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncomingViewingKeyMessage>, I>>(base?: I): IncomingViewingKeyMessage {
    return IncomingViewingKeyMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncomingViewingKeyMessage>, I>>(object: I): IncomingViewingKeyMessage {
    const message = createBaseIncomingViewingKeyMessage();
    message.ivk = object.ivk ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseDiversifierMessage(): DiversifierMessage {
  return { d: Buffer.alloc(0), _unknownFields: {} };
}

export const DiversifierMessage = {
  encode(message: DiversifierMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.d.length !== 0) {
      writer.uint32(10).bytes(message.d);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DiversifierMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiversifierMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.d = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): DiversifierMessage {
    return { d: isSet(object.d) ? Buffer.from(bytesFromBase64(object.d)) : Buffer.alloc(0) };
  },

  toJSON(message: DiversifierMessage): unknown {
    const obj: any = {};
    if (message.d.length !== 0) {
      obj.d = base64FromBytes(message.d);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiversifierMessage>, I>>(base?: I): DiversifierMessage {
    return DiversifierMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiversifierMessage>, I>>(object: I): DiversifierMessage {
    const message = createBaseDiversifierMessage();
    message.d = object.d ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseIncomingViewingKeyDiversifierMessage(): IncomingViewingKeyDiversifierMessage {
  return { ivk: undefined, d: undefined, _unknownFields: {} };
}

export const IncomingViewingKeyDiversifierMessage = {
  encode(message: IncomingViewingKeyDiversifierMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ivk !== undefined) {
      IncomingViewingKeyMessage.encode(message.ivk, writer.uint32(10).fork()).ldelim();
    }
    if (message.d !== undefined) {
      DiversifierMessage.encode(message.d, writer.uint32(18).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IncomingViewingKeyDiversifierMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncomingViewingKeyDiversifierMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ivk = IncomingViewingKeyMessage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.d = DiversifierMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): IncomingViewingKeyDiversifierMessage {
    return {
      ivk: isSet(object.ivk) ? IncomingViewingKeyMessage.fromJSON(object.ivk) : undefined,
      d: isSet(object.d) ? DiversifierMessage.fromJSON(object.d) : undefined,
    };
  },

  toJSON(message: IncomingViewingKeyDiversifierMessage): unknown {
    const obj: any = {};
    if (message.ivk !== undefined) {
      obj.ivk = IncomingViewingKeyMessage.toJSON(message.ivk);
    }
    if (message.d !== undefined) {
      obj.d = DiversifierMessage.toJSON(message.d);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncomingViewingKeyDiversifierMessage>, I>>(
    base?: I,
  ): IncomingViewingKeyDiversifierMessage {
    return IncomingViewingKeyDiversifierMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncomingViewingKeyDiversifierMessage>, I>>(
    object: I,
  ): IncomingViewingKeyDiversifierMessage {
    const message = createBaseIncomingViewingKeyDiversifierMessage();
    message.ivk = (object.ivk !== undefined && object.ivk !== null)
      ? IncomingViewingKeyMessage.fromPartial(object.ivk)
      : undefined;
    message.d = (object.d !== undefined && object.d !== null) ? DiversifierMessage.fromPartial(object.d) : undefined;
    return message;
  },
};

function createBasePaymentAddressMessage(): PaymentAddressMessage {
  return { d: undefined, pkD: Buffer.alloc(0), paymentAddress: "", _unknownFields: {} };
}

export const PaymentAddressMessage = {
  encode(message: PaymentAddressMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.d !== undefined) {
      DiversifierMessage.encode(message.d, writer.uint32(10).fork()).ldelim();
    }
    if (message.pkD.length !== 0) {
      writer.uint32(18).bytes(message.pkD);
    }
    if (message.paymentAddress !== "") {
      writer.uint32(26).string(message.paymentAddress);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PaymentAddressMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentAddressMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.d = DiversifierMessage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pkD = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.paymentAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): PaymentAddressMessage {
    return {
      d: isSet(object.d) ? DiversifierMessage.fromJSON(object.d) : undefined,
      pkD: isSet(object.pkD) ? Buffer.from(bytesFromBase64(object.pkD)) : Buffer.alloc(0),
      paymentAddress: isSet(object.paymentAddress) ? globalThis.String(object.paymentAddress) : "",
    };
  },

  toJSON(message: PaymentAddressMessage): unknown {
    const obj: any = {};
    if (message.d !== undefined) {
      obj.d = DiversifierMessage.toJSON(message.d);
    }
    if (message.pkD.length !== 0) {
      obj.pkD = base64FromBytes(message.pkD);
    }
    if (message.paymentAddress !== "") {
      obj.paymentAddress = message.paymentAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentAddressMessage>, I>>(base?: I): PaymentAddressMessage {
    return PaymentAddressMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentAddressMessage>, I>>(object: I): PaymentAddressMessage {
    const message = createBasePaymentAddressMessage();
    message.d = (object.d !== undefined && object.d !== null) ? DiversifierMessage.fromPartial(object.d) : undefined;
    message.pkD = object.pkD ?? Buffer.alloc(0);
    message.paymentAddress = object.paymentAddress ?? "";
    return message;
  },
};

function createBaseShieldedAddressInfo(): ShieldedAddressInfo {
  return {
    sk: Buffer.alloc(0),
    ask: Buffer.alloc(0),
    nsk: Buffer.alloc(0),
    ovk: Buffer.alloc(0),
    ak: Buffer.alloc(0),
    nk: Buffer.alloc(0),
    ivk: Buffer.alloc(0),
    d: Buffer.alloc(0),
    pkD: Buffer.alloc(0),
    paymentAddress: "",
    _unknownFields: {},
  };
}

export const ShieldedAddressInfo = {
  encode(message: ShieldedAddressInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sk.length !== 0) {
      writer.uint32(10).bytes(message.sk);
    }
    if (message.ask.length !== 0) {
      writer.uint32(18).bytes(message.ask);
    }
    if (message.nsk.length !== 0) {
      writer.uint32(26).bytes(message.nsk);
    }
    if (message.ovk.length !== 0) {
      writer.uint32(34).bytes(message.ovk);
    }
    if (message.ak.length !== 0) {
      writer.uint32(42).bytes(message.ak);
    }
    if (message.nk.length !== 0) {
      writer.uint32(50).bytes(message.nk);
    }
    if (message.ivk.length !== 0) {
      writer.uint32(58).bytes(message.ivk);
    }
    if (message.d.length !== 0) {
      writer.uint32(66).bytes(message.d);
    }
    if (message.pkD.length !== 0) {
      writer.uint32(74).bytes(message.pkD);
    }
    if (message.paymentAddress !== "") {
      writer.uint32(82).string(message.paymentAddress);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ShieldedAddressInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShieldedAddressInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sk = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ask = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nsk = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ovk = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ak = reader.bytes() as Buffer;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.nk = reader.bytes() as Buffer;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ivk = reader.bytes() as Buffer;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.d = reader.bytes() as Buffer;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.pkD = reader.bytes() as Buffer;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.paymentAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ShieldedAddressInfo {
    return {
      sk: isSet(object.sk) ? Buffer.from(bytesFromBase64(object.sk)) : Buffer.alloc(0),
      ask: isSet(object.ask) ? Buffer.from(bytesFromBase64(object.ask)) : Buffer.alloc(0),
      nsk: isSet(object.nsk) ? Buffer.from(bytesFromBase64(object.nsk)) : Buffer.alloc(0),
      ovk: isSet(object.ovk) ? Buffer.from(bytesFromBase64(object.ovk)) : Buffer.alloc(0),
      ak: isSet(object.ak) ? Buffer.from(bytesFromBase64(object.ak)) : Buffer.alloc(0),
      nk: isSet(object.nk) ? Buffer.from(bytesFromBase64(object.nk)) : Buffer.alloc(0),
      ivk: isSet(object.ivk) ? Buffer.from(bytesFromBase64(object.ivk)) : Buffer.alloc(0),
      d: isSet(object.d) ? Buffer.from(bytesFromBase64(object.d)) : Buffer.alloc(0),
      pkD: isSet(object.pkD) ? Buffer.from(bytesFromBase64(object.pkD)) : Buffer.alloc(0),
      paymentAddress: isSet(object.paymentAddress) ? globalThis.String(object.paymentAddress) : "",
    };
  },

  toJSON(message: ShieldedAddressInfo): unknown {
    const obj: any = {};
    if (message.sk.length !== 0) {
      obj.sk = base64FromBytes(message.sk);
    }
    if (message.ask.length !== 0) {
      obj.ask = base64FromBytes(message.ask);
    }
    if (message.nsk.length !== 0) {
      obj.nsk = base64FromBytes(message.nsk);
    }
    if (message.ovk.length !== 0) {
      obj.ovk = base64FromBytes(message.ovk);
    }
    if (message.ak.length !== 0) {
      obj.ak = base64FromBytes(message.ak);
    }
    if (message.nk.length !== 0) {
      obj.nk = base64FromBytes(message.nk);
    }
    if (message.ivk.length !== 0) {
      obj.ivk = base64FromBytes(message.ivk);
    }
    if (message.d.length !== 0) {
      obj.d = base64FromBytes(message.d);
    }
    if (message.pkD.length !== 0) {
      obj.pkD = base64FromBytes(message.pkD);
    }
    if (message.paymentAddress !== "") {
      obj.paymentAddress = message.paymentAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShieldedAddressInfo>, I>>(base?: I): ShieldedAddressInfo {
    return ShieldedAddressInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShieldedAddressInfo>, I>>(object: I): ShieldedAddressInfo {
    const message = createBaseShieldedAddressInfo();
    message.sk = object.sk ?? Buffer.alloc(0);
    message.ask = object.ask ?? Buffer.alloc(0);
    message.nsk = object.nsk ?? Buffer.alloc(0);
    message.ovk = object.ovk ?? Buffer.alloc(0);
    message.ak = object.ak ?? Buffer.alloc(0);
    message.nk = object.nk ?? Buffer.alloc(0);
    message.ivk = object.ivk ?? Buffer.alloc(0);
    message.d = object.d ?? Buffer.alloc(0);
    message.pkD = object.pkD ?? Buffer.alloc(0);
    message.paymentAddress = object.paymentAddress ?? "";
    return message;
  },
};

function createBaseNoteParameters(): NoteParameters {
  return {
    ak: Buffer.alloc(0),
    nk: Buffer.alloc(0),
    note: undefined,
    txid: Buffer.alloc(0),
    index: 0,
    _unknownFields: {},
  };
}

export const NoteParameters = {
  encode(message: NoteParameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ak.length !== 0) {
      writer.uint32(10).bytes(message.ak);
    }
    if (message.nk.length !== 0) {
      writer.uint32(18).bytes(message.nk);
    }
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(26).fork()).ldelim();
    }
    if (message.txid.length !== 0) {
      writer.uint32(34).bytes(message.txid);
    }
    if (message.index !== 0) {
      writer.uint32(40).int32(message.index);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NoteParameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoteParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ak = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nk = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.txid = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.index = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): NoteParameters {
    return {
      ak: isSet(object.ak) ? Buffer.from(bytesFromBase64(object.ak)) : Buffer.alloc(0),
      nk: isSet(object.nk) ? Buffer.from(bytesFromBase64(object.nk)) : Buffer.alloc(0),
      note: isSet(object.note) ? Note.fromJSON(object.note) : undefined,
      txid: isSet(object.txid) ? Buffer.from(bytesFromBase64(object.txid)) : Buffer.alloc(0),
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: NoteParameters): unknown {
    const obj: any = {};
    if (message.ak.length !== 0) {
      obj.ak = base64FromBytes(message.ak);
    }
    if (message.nk.length !== 0) {
      obj.nk = base64FromBytes(message.nk);
    }
    if (message.note !== undefined) {
      obj.note = Note.toJSON(message.note);
    }
    if (message.txid.length !== 0) {
      obj.txid = base64FromBytes(message.txid);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NoteParameters>, I>>(base?: I): NoteParameters {
    return NoteParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NoteParameters>, I>>(object: I): NoteParameters {
    const message = createBaseNoteParameters();
    message.ak = object.ak ?? Buffer.alloc(0);
    message.nk = object.nk ?? Buffer.alloc(0);
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    message.txid = object.txid ?? Buffer.alloc(0);
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseSpendResult(): SpendResult {
  return { result: false, message: "", _unknownFields: {} };
}

export const SpendResult = {
  encode(message: SpendResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== false) {
      writer.uint32(8).bool(message.result);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpendResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpendResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): SpendResult {
    return {
      result: isSet(object.result) ? globalThis.Boolean(object.result) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: SpendResult): unknown {
    const obj: any = {};
    if (message.result !== false) {
      obj.result = message.result;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpendResult>, I>>(base?: I): SpendResult {
    return SpendResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpendResult>, I>>(object: I): SpendResult {
    const message = createBaseSpendResult();
    message.result = object.result ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseTransactionInfoList(): TransactionInfoList {
  return { transactionInfo: [], _unknownFields: {} };
}

export const TransactionInfoList = {
  encode(message: TransactionInfoList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactionInfo) {
      TransactionInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionInfoList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfoList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactionInfo.push(TransactionInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionInfoList {
    return {
      transactionInfo: globalThis.Array.isArray(object?.transactionInfo)
        ? object.transactionInfo.map((e: any) => TransactionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransactionInfoList): unknown {
    const obj: any = {};
    if (message.transactionInfo?.length) {
      obj.transactionInfo = message.transactionInfo.map((e) => TransactionInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionInfoList>, I>>(base?: I): TransactionInfoList {
    return TransactionInfoList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionInfoList>, I>>(object: I): TransactionInfoList {
    const message = createBaseTransactionInfoList();
    message.transactionInfo = object.transactionInfo?.map((e) => TransactionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSpendNoteTRC20(): SpendNoteTRC20 {
  return {
    note: undefined,
    alpha: Buffer.alloc(0),
    root: Buffer.alloc(0),
    path: Buffer.alloc(0),
    pos: Long.ZERO,
    _unknownFields: {},
  };
}

export const SpendNoteTRC20 = {
  encode(message: SpendNoteTRC20, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(10).fork()).ldelim();
    }
    if (message.alpha.length !== 0) {
      writer.uint32(18).bytes(message.alpha);
    }
    if (message.root.length !== 0) {
      writer.uint32(26).bytes(message.root);
    }
    if (message.path.length !== 0) {
      writer.uint32(34).bytes(message.path);
    }
    if (!message.pos.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.pos);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpendNoteTRC20 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpendNoteTRC20();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.alpha = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.root = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.path = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.pos = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): SpendNoteTRC20 {
    return {
      note: isSet(object.note) ? Note.fromJSON(object.note) : undefined,
      alpha: isSet(object.alpha) ? Buffer.from(bytesFromBase64(object.alpha)) : Buffer.alloc(0),
      root: isSet(object.root) ? Buffer.from(bytesFromBase64(object.root)) : Buffer.alloc(0),
      path: isSet(object.path) ? Buffer.from(bytesFromBase64(object.path)) : Buffer.alloc(0),
      pos: isSet(object.pos) ? Long.fromValue(object.pos) : Long.ZERO,
    };
  },

  toJSON(message: SpendNoteTRC20): unknown {
    const obj: any = {};
    if (message.note !== undefined) {
      obj.note = Note.toJSON(message.note);
    }
    if (message.alpha.length !== 0) {
      obj.alpha = base64FromBytes(message.alpha);
    }
    if (message.root.length !== 0) {
      obj.root = base64FromBytes(message.root);
    }
    if (message.path.length !== 0) {
      obj.path = base64FromBytes(message.path);
    }
    if (!message.pos.equals(Long.ZERO)) {
      obj.pos = (message.pos || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpendNoteTRC20>, I>>(base?: I): SpendNoteTRC20 {
    return SpendNoteTRC20.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpendNoteTRC20>, I>>(object: I): SpendNoteTRC20 {
    const message = createBaseSpendNoteTRC20();
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    message.alpha = object.alpha ?? Buffer.alloc(0);
    message.root = object.root ?? Buffer.alloc(0);
    message.path = object.path ?? Buffer.alloc(0);
    message.pos = (object.pos !== undefined && object.pos !== null) ? Long.fromValue(object.pos) : Long.ZERO;
    return message;
  },
};

function createBasePrivateShieldedTRC20Parameters(): PrivateShieldedTRC20Parameters {
  return {
    ask: Buffer.alloc(0),
    nsk: Buffer.alloc(0),
    ovk: Buffer.alloc(0),
    fromAmount: "",
    shieldedSpends: [],
    shieldedReceives: [],
    transparentToAddress: Buffer.alloc(0),
    toAmount: "",
    shieldedTRC20ContractAddress: Buffer.alloc(0),
    _unknownFields: {},
  };
}

export const PrivateShieldedTRC20Parameters = {
  encode(message: PrivateShieldedTRC20Parameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ask.length !== 0) {
      writer.uint32(10).bytes(message.ask);
    }
    if (message.nsk.length !== 0) {
      writer.uint32(18).bytes(message.nsk);
    }
    if (message.ovk.length !== 0) {
      writer.uint32(26).bytes(message.ovk);
    }
    if (message.fromAmount !== "") {
      writer.uint32(34).string(message.fromAmount);
    }
    for (const v of message.shieldedSpends) {
      SpendNoteTRC20.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.shieldedReceives) {
      ReceiveNote.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.transparentToAddress.length !== 0) {
      writer.uint32(58).bytes(message.transparentToAddress);
    }
    if (message.toAmount !== "") {
      writer.uint32(66).string(message.toAmount);
    }
    if (message.shieldedTRC20ContractAddress.length !== 0) {
      writer.uint32(74).bytes(message.shieldedTRC20ContractAddress);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PrivateShieldedTRC20Parameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateShieldedTRC20Parameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ask = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nsk = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ovk = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fromAmount = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.shieldedSpends.push(SpendNoteTRC20.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.shieldedReceives.push(ReceiveNote.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transparentToAddress = reader.bytes() as Buffer;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.toAmount = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.shieldedTRC20ContractAddress = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): PrivateShieldedTRC20Parameters {
    return {
      ask: isSet(object.ask) ? Buffer.from(bytesFromBase64(object.ask)) : Buffer.alloc(0),
      nsk: isSet(object.nsk) ? Buffer.from(bytesFromBase64(object.nsk)) : Buffer.alloc(0),
      ovk: isSet(object.ovk) ? Buffer.from(bytesFromBase64(object.ovk)) : Buffer.alloc(0),
      fromAmount: isSet(object.fromAmount) ? globalThis.String(object.fromAmount) : "",
      shieldedSpends: globalThis.Array.isArray(object?.shieldedSpends)
        ? object.shieldedSpends.map((e: any) => SpendNoteTRC20.fromJSON(e))
        : [],
      shieldedReceives: globalThis.Array.isArray(object?.shieldedReceives)
        ? object.shieldedReceives.map((e: any) => ReceiveNote.fromJSON(e))
        : [],
      transparentToAddress: isSet(object.transparentToAddress)
        ? Buffer.from(bytesFromBase64(object.transparentToAddress))
        : Buffer.alloc(0),
      toAmount: isSet(object.toAmount) ? globalThis.String(object.toAmount) : "",
      shieldedTRC20ContractAddress: isSet(object.shieldedTRC20ContractAddress)
        ? Buffer.from(bytesFromBase64(object.shieldedTRC20ContractAddress))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: PrivateShieldedTRC20Parameters): unknown {
    const obj: any = {};
    if (message.ask.length !== 0) {
      obj.ask = base64FromBytes(message.ask);
    }
    if (message.nsk.length !== 0) {
      obj.nsk = base64FromBytes(message.nsk);
    }
    if (message.ovk.length !== 0) {
      obj.ovk = base64FromBytes(message.ovk);
    }
    if (message.fromAmount !== "") {
      obj.fromAmount = message.fromAmount;
    }
    if (message.shieldedSpends?.length) {
      obj.shieldedSpends = message.shieldedSpends.map((e) => SpendNoteTRC20.toJSON(e));
    }
    if (message.shieldedReceives?.length) {
      obj.shieldedReceives = message.shieldedReceives.map((e) => ReceiveNote.toJSON(e));
    }
    if (message.transparentToAddress.length !== 0) {
      obj.transparentToAddress = base64FromBytes(message.transparentToAddress);
    }
    if (message.toAmount !== "") {
      obj.toAmount = message.toAmount;
    }
    if (message.shieldedTRC20ContractAddress.length !== 0) {
      obj.shieldedTRC20ContractAddress = base64FromBytes(message.shieldedTRC20ContractAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrivateShieldedTRC20Parameters>, I>>(base?: I): PrivateShieldedTRC20Parameters {
    return PrivateShieldedTRC20Parameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrivateShieldedTRC20Parameters>, I>>(
    object: I,
  ): PrivateShieldedTRC20Parameters {
    const message = createBasePrivateShieldedTRC20Parameters();
    message.ask = object.ask ?? Buffer.alloc(0);
    message.nsk = object.nsk ?? Buffer.alloc(0);
    message.ovk = object.ovk ?? Buffer.alloc(0);
    message.fromAmount = object.fromAmount ?? "";
    message.shieldedSpends = object.shieldedSpends?.map((e) => SpendNoteTRC20.fromPartial(e)) || [];
    message.shieldedReceives = object.shieldedReceives?.map((e) => ReceiveNote.fromPartial(e)) || [];
    message.transparentToAddress = object.transparentToAddress ?? Buffer.alloc(0);
    message.toAmount = object.toAmount ?? "";
    message.shieldedTRC20ContractAddress = object.shieldedTRC20ContractAddress ?? Buffer.alloc(0);
    return message;
  },
};

function createBasePrivateShieldedTRC20ParametersWithoutAsk(): PrivateShieldedTRC20ParametersWithoutAsk {
  return {
    ak: Buffer.alloc(0),
    nsk: Buffer.alloc(0),
    ovk: Buffer.alloc(0),
    fromAmount: "",
    shieldedSpends: [],
    shieldedReceives: [],
    transparentToAddress: Buffer.alloc(0),
    toAmount: "",
    shieldedTRC20ContractAddress: Buffer.alloc(0),
    _unknownFields: {},
  };
}

export const PrivateShieldedTRC20ParametersWithoutAsk = {
  encode(message: PrivateShieldedTRC20ParametersWithoutAsk, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ak.length !== 0) {
      writer.uint32(10).bytes(message.ak);
    }
    if (message.nsk.length !== 0) {
      writer.uint32(18).bytes(message.nsk);
    }
    if (message.ovk.length !== 0) {
      writer.uint32(26).bytes(message.ovk);
    }
    if (message.fromAmount !== "") {
      writer.uint32(34).string(message.fromAmount);
    }
    for (const v of message.shieldedSpends) {
      SpendNoteTRC20.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.shieldedReceives) {
      ReceiveNote.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.transparentToAddress.length !== 0) {
      writer.uint32(58).bytes(message.transparentToAddress);
    }
    if (message.toAmount !== "") {
      writer.uint32(66).string(message.toAmount);
    }
    if (message.shieldedTRC20ContractAddress.length !== 0) {
      writer.uint32(74).bytes(message.shieldedTRC20ContractAddress);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PrivateShieldedTRC20ParametersWithoutAsk {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateShieldedTRC20ParametersWithoutAsk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ak = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nsk = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ovk = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fromAmount = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.shieldedSpends.push(SpendNoteTRC20.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.shieldedReceives.push(ReceiveNote.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transparentToAddress = reader.bytes() as Buffer;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.toAmount = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.shieldedTRC20ContractAddress = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): PrivateShieldedTRC20ParametersWithoutAsk {
    return {
      ak: isSet(object.ak) ? Buffer.from(bytesFromBase64(object.ak)) : Buffer.alloc(0),
      nsk: isSet(object.nsk) ? Buffer.from(bytesFromBase64(object.nsk)) : Buffer.alloc(0),
      ovk: isSet(object.ovk) ? Buffer.from(bytesFromBase64(object.ovk)) : Buffer.alloc(0),
      fromAmount: isSet(object.fromAmount) ? globalThis.String(object.fromAmount) : "",
      shieldedSpends: globalThis.Array.isArray(object?.shieldedSpends)
        ? object.shieldedSpends.map((e: any) => SpendNoteTRC20.fromJSON(e))
        : [],
      shieldedReceives: globalThis.Array.isArray(object?.shieldedReceives)
        ? object.shieldedReceives.map((e: any) => ReceiveNote.fromJSON(e))
        : [],
      transparentToAddress: isSet(object.transparentToAddress)
        ? Buffer.from(bytesFromBase64(object.transparentToAddress))
        : Buffer.alloc(0),
      toAmount: isSet(object.toAmount) ? globalThis.String(object.toAmount) : "",
      shieldedTRC20ContractAddress: isSet(object.shieldedTRC20ContractAddress)
        ? Buffer.from(bytesFromBase64(object.shieldedTRC20ContractAddress))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: PrivateShieldedTRC20ParametersWithoutAsk): unknown {
    const obj: any = {};
    if (message.ak.length !== 0) {
      obj.ak = base64FromBytes(message.ak);
    }
    if (message.nsk.length !== 0) {
      obj.nsk = base64FromBytes(message.nsk);
    }
    if (message.ovk.length !== 0) {
      obj.ovk = base64FromBytes(message.ovk);
    }
    if (message.fromAmount !== "") {
      obj.fromAmount = message.fromAmount;
    }
    if (message.shieldedSpends?.length) {
      obj.shieldedSpends = message.shieldedSpends.map((e) => SpendNoteTRC20.toJSON(e));
    }
    if (message.shieldedReceives?.length) {
      obj.shieldedReceives = message.shieldedReceives.map((e) => ReceiveNote.toJSON(e));
    }
    if (message.transparentToAddress.length !== 0) {
      obj.transparentToAddress = base64FromBytes(message.transparentToAddress);
    }
    if (message.toAmount !== "") {
      obj.toAmount = message.toAmount;
    }
    if (message.shieldedTRC20ContractAddress.length !== 0) {
      obj.shieldedTRC20ContractAddress = base64FromBytes(message.shieldedTRC20ContractAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrivateShieldedTRC20ParametersWithoutAsk>, I>>(
    base?: I,
  ): PrivateShieldedTRC20ParametersWithoutAsk {
    return PrivateShieldedTRC20ParametersWithoutAsk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrivateShieldedTRC20ParametersWithoutAsk>, I>>(
    object: I,
  ): PrivateShieldedTRC20ParametersWithoutAsk {
    const message = createBasePrivateShieldedTRC20ParametersWithoutAsk();
    message.ak = object.ak ?? Buffer.alloc(0);
    message.nsk = object.nsk ?? Buffer.alloc(0);
    message.ovk = object.ovk ?? Buffer.alloc(0);
    message.fromAmount = object.fromAmount ?? "";
    message.shieldedSpends = object.shieldedSpends?.map((e) => SpendNoteTRC20.fromPartial(e)) || [];
    message.shieldedReceives = object.shieldedReceives?.map((e) => ReceiveNote.fromPartial(e)) || [];
    message.transparentToAddress = object.transparentToAddress ?? Buffer.alloc(0);
    message.toAmount = object.toAmount ?? "";
    message.shieldedTRC20ContractAddress = object.shieldedTRC20ContractAddress ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseShieldedTRC20Parameters(): ShieldedTRC20Parameters {
  return {
    spendDescription: [],
    receiveDescription: [],
    bindingSignature: Buffer.alloc(0),
    messageHash: Buffer.alloc(0),
    triggerContractInput: "",
    parameterType: "",
    _unknownFields: {},
  };
}

export const ShieldedTRC20Parameters = {
  encode(message: ShieldedTRC20Parameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.spendDescription) {
      SpendDescription.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.receiveDescription) {
      ReceiveDescription.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.bindingSignature.length !== 0) {
      writer.uint32(26).bytes(message.bindingSignature);
    }
    if (message.messageHash.length !== 0) {
      writer.uint32(34).bytes(message.messageHash);
    }
    if (message.triggerContractInput !== "") {
      writer.uint32(42).string(message.triggerContractInput);
    }
    if (message.parameterType !== "") {
      writer.uint32(50).string(message.parameterType);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ShieldedTRC20Parameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShieldedTRC20Parameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.spendDescription.push(SpendDescription.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.receiveDescription.push(ReceiveDescription.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bindingSignature = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.messageHash = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.triggerContractInput = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.parameterType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ShieldedTRC20Parameters {
    return {
      spendDescription: globalThis.Array.isArray(object?.spendDescription)
        ? object.spendDescription.map((e: any) => SpendDescription.fromJSON(e))
        : [],
      receiveDescription: globalThis.Array.isArray(object?.receiveDescription)
        ? object.receiveDescription.map((e: any) => ReceiveDescription.fromJSON(e))
        : [],
      bindingSignature: isSet(object.bindingSignature)
        ? Buffer.from(bytesFromBase64(object.bindingSignature))
        : Buffer.alloc(0),
      messageHash: isSet(object.messageHash) ? Buffer.from(bytesFromBase64(object.messageHash)) : Buffer.alloc(0),
      triggerContractInput: isSet(object.triggerContractInput) ? globalThis.String(object.triggerContractInput) : "",
      parameterType: isSet(object.parameterType) ? globalThis.String(object.parameterType) : "",
    };
  },

  toJSON(message: ShieldedTRC20Parameters): unknown {
    const obj: any = {};
    if (message.spendDescription?.length) {
      obj.spendDescription = message.spendDescription.map((e) => SpendDescription.toJSON(e));
    }
    if (message.receiveDescription?.length) {
      obj.receiveDescription = message.receiveDescription.map((e) => ReceiveDescription.toJSON(e));
    }
    if (message.bindingSignature.length !== 0) {
      obj.bindingSignature = base64FromBytes(message.bindingSignature);
    }
    if (message.messageHash.length !== 0) {
      obj.messageHash = base64FromBytes(message.messageHash);
    }
    if (message.triggerContractInput !== "") {
      obj.triggerContractInput = message.triggerContractInput;
    }
    if (message.parameterType !== "") {
      obj.parameterType = message.parameterType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShieldedTRC20Parameters>, I>>(base?: I): ShieldedTRC20Parameters {
    return ShieldedTRC20Parameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShieldedTRC20Parameters>, I>>(object: I): ShieldedTRC20Parameters {
    const message = createBaseShieldedTRC20Parameters();
    message.spendDescription = object.spendDescription?.map((e) => SpendDescription.fromPartial(e)) || [];
    message.receiveDescription = object.receiveDescription?.map((e) => ReceiveDescription.fromPartial(e)) || [];
    message.bindingSignature = object.bindingSignature ?? Buffer.alloc(0);
    message.messageHash = object.messageHash ?? Buffer.alloc(0);
    message.triggerContractInput = object.triggerContractInput ?? "";
    message.parameterType = object.parameterType ?? "";
    return message;
  },
};

function createBaseIvkDecryptTRC20Parameters(): IvkDecryptTRC20Parameters {
  return {
    startBlockIndex: Long.ZERO,
    endBlockIndex: Long.ZERO,
    shieldedTRC20ContractAddress: Buffer.alloc(0),
    ivk: Buffer.alloc(0),
    ak: Buffer.alloc(0),
    nk: Buffer.alloc(0),
    events: [],
    _unknownFields: {},
  };
}

export const IvkDecryptTRC20Parameters = {
  encode(message: IvkDecryptTRC20Parameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.startBlockIndex.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.startBlockIndex);
    }
    if (!message.endBlockIndex.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.endBlockIndex);
    }
    if (message.shieldedTRC20ContractAddress.length !== 0) {
      writer.uint32(26).bytes(message.shieldedTRC20ContractAddress);
    }
    if (message.ivk.length !== 0) {
      writer.uint32(34).bytes(message.ivk);
    }
    if (message.ak.length !== 0) {
      writer.uint32(42).bytes(message.ak);
    }
    if (message.nk.length !== 0) {
      writer.uint32(50).bytes(message.nk);
    }
    for (const v of message.events) {
      writer.uint32(58).string(v!);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IvkDecryptTRC20Parameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIvkDecryptTRC20Parameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startBlockIndex = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endBlockIndex = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.shieldedTRC20ContractAddress = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ivk = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ak = reader.bytes() as Buffer;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.nk = reader.bytes() as Buffer;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.events.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): IvkDecryptTRC20Parameters {
    return {
      startBlockIndex: isSet(object.startBlockIndex) ? Long.fromValue(object.startBlockIndex) : Long.ZERO,
      endBlockIndex: isSet(object.endBlockIndex) ? Long.fromValue(object.endBlockIndex) : Long.ZERO,
      shieldedTRC20ContractAddress: isSet(object.shieldedTRC20ContractAddress)
        ? Buffer.from(bytesFromBase64(object.shieldedTRC20ContractAddress))
        : Buffer.alloc(0),
      ivk: isSet(object.ivk) ? Buffer.from(bytesFromBase64(object.ivk)) : Buffer.alloc(0),
      ak: isSet(object.ak) ? Buffer.from(bytesFromBase64(object.ak)) : Buffer.alloc(0),
      nk: isSet(object.nk) ? Buffer.from(bytesFromBase64(object.nk)) : Buffer.alloc(0),
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: IvkDecryptTRC20Parameters): unknown {
    const obj: any = {};
    if (!message.startBlockIndex.equals(Long.ZERO)) {
      obj.startBlockIndex = (message.startBlockIndex || Long.ZERO).toString();
    }
    if (!message.endBlockIndex.equals(Long.ZERO)) {
      obj.endBlockIndex = (message.endBlockIndex || Long.ZERO).toString();
    }
    if (message.shieldedTRC20ContractAddress.length !== 0) {
      obj.shieldedTRC20ContractAddress = base64FromBytes(message.shieldedTRC20ContractAddress);
    }
    if (message.ivk.length !== 0) {
      obj.ivk = base64FromBytes(message.ivk);
    }
    if (message.ak.length !== 0) {
      obj.ak = base64FromBytes(message.ak);
    }
    if (message.nk.length !== 0) {
      obj.nk = base64FromBytes(message.nk);
    }
    if (message.events?.length) {
      obj.events = message.events;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IvkDecryptTRC20Parameters>, I>>(base?: I): IvkDecryptTRC20Parameters {
    return IvkDecryptTRC20Parameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IvkDecryptTRC20Parameters>, I>>(object: I): IvkDecryptTRC20Parameters {
    const message = createBaseIvkDecryptTRC20Parameters();
    message.startBlockIndex = (object.startBlockIndex !== undefined && object.startBlockIndex !== null)
      ? Long.fromValue(object.startBlockIndex)
      : Long.ZERO;
    message.endBlockIndex = (object.endBlockIndex !== undefined && object.endBlockIndex !== null)
      ? Long.fromValue(object.endBlockIndex)
      : Long.ZERO;
    message.shieldedTRC20ContractAddress = object.shieldedTRC20ContractAddress ?? Buffer.alloc(0);
    message.ivk = object.ivk ?? Buffer.alloc(0);
    message.ak = object.ak ?? Buffer.alloc(0);
    message.nk = object.nk ?? Buffer.alloc(0);
    message.events = object.events?.map((e) => e) || [];
    return message;
  },
};

function createBaseOvkDecryptTRC20Parameters(): OvkDecryptTRC20Parameters {
  return {
    startBlockIndex: Long.ZERO,
    endBlockIndex: Long.ZERO,
    ovk: Buffer.alloc(0),
    shieldedTRC20ContractAddress: Buffer.alloc(0),
    events: [],
    _unknownFields: {},
  };
}

export const OvkDecryptTRC20Parameters = {
  encode(message: OvkDecryptTRC20Parameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.startBlockIndex.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.startBlockIndex);
    }
    if (!message.endBlockIndex.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.endBlockIndex);
    }
    if (message.ovk.length !== 0) {
      writer.uint32(26).bytes(message.ovk);
    }
    if (message.shieldedTRC20ContractAddress.length !== 0) {
      writer.uint32(34).bytes(message.shieldedTRC20ContractAddress);
    }
    for (const v of message.events) {
      writer.uint32(42).string(v!);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OvkDecryptTRC20Parameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOvkDecryptTRC20Parameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startBlockIndex = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endBlockIndex = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ovk = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.shieldedTRC20ContractAddress = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.events.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): OvkDecryptTRC20Parameters {
    return {
      startBlockIndex: isSet(object.startBlockIndex) ? Long.fromValue(object.startBlockIndex) : Long.ZERO,
      endBlockIndex: isSet(object.endBlockIndex) ? Long.fromValue(object.endBlockIndex) : Long.ZERO,
      ovk: isSet(object.ovk) ? Buffer.from(bytesFromBase64(object.ovk)) : Buffer.alloc(0),
      shieldedTRC20ContractAddress: isSet(object.shieldedTRC20ContractAddress)
        ? Buffer.from(bytesFromBase64(object.shieldedTRC20ContractAddress))
        : Buffer.alloc(0),
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: OvkDecryptTRC20Parameters): unknown {
    const obj: any = {};
    if (!message.startBlockIndex.equals(Long.ZERO)) {
      obj.startBlockIndex = (message.startBlockIndex || Long.ZERO).toString();
    }
    if (!message.endBlockIndex.equals(Long.ZERO)) {
      obj.endBlockIndex = (message.endBlockIndex || Long.ZERO).toString();
    }
    if (message.ovk.length !== 0) {
      obj.ovk = base64FromBytes(message.ovk);
    }
    if (message.shieldedTRC20ContractAddress.length !== 0) {
      obj.shieldedTRC20ContractAddress = base64FromBytes(message.shieldedTRC20ContractAddress);
    }
    if (message.events?.length) {
      obj.events = message.events;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OvkDecryptTRC20Parameters>, I>>(base?: I): OvkDecryptTRC20Parameters {
    return OvkDecryptTRC20Parameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OvkDecryptTRC20Parameters>, I>>(object: I): OvkDecryptTRC20Parameters {
    const message = createBaseOvkDecryptTRC20Parameters();
    message.startBlockIndex = (object.startBlockIndex !== undefined && object.startBlockIndex !== null)
      ? Long.fromValue(object.startBlockIndex)
      : Long.ZERO;
    message.endBlockIndex = (object.endBlockIndex !== undefined && object.endBlockIndex !== null)
      ? Long.fromValue(object.endBlockIndex)
      : Long.ZERO;
    message.ovk = object.ovk ?? Buffer.alloc(0);
    message.shieldedTRC20ContractAddress = object.shieldedTRC20ContractAddress ?? Buffer.alloc(0);
    message.events = object.events?.map((e) => e) || [];
    return message;
  },
};

function createBaseDecryptNotesTRC20(): DecryptNotesTRC20 {
  return { noteTxs: [], _unknownFields: {} };
}

export const DecryptNotesTRC20 = {
  encode(message: DecryptNotesTRC20, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.noteTxs) {
      DecryptNotesTRC20_NoteTx.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DecryptNotesTRC20 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptNotesTRC20();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.noteTxs.push(DecryptNotesTRC20_NoteTx.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): DecryptNotesTRC20 {
    return {
      noteTxs: globalThis.Array.isArray(object?.noteTxs)
        ? object.noteTxs.map((e: any) => DecryptNotesTRC20_NoteTx.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DecryptNotesTRC20): unknown {
    const obj: any = {};
    if (message.noteTxs?.length) {
      obj.noteTxs = message.noteTxs.map((e) => DecryptNotesTRC20_NoteTx.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptNotesTRC20>, I>>(base?: I): DecryptNotesTRC20 {
    return DecryptNotesTRC20.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptNotesTRC20>, I>>(object: I): DecryptNotesTRC20 {
    const message = createBaseDecryptNotesTRC20();
    message.noteTxs = object.noteTxs?.map((e) => DecryptNotesTRC20_NoteTx.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDecryptNotesTRC20_NoteTx(): DecryptNotesTRC20_NoteTx {
  return {
    note: undefined,
    position: Long.ZERO,
    isSpent: false,
    txid: Buffer.alloc(0),
    index: 0,
    toAmount: "",
    transparentToAddress: Buffer.alloc(0),
    _unknownFields: {},
  };
}

export const DecryptNotesTRC20_NoteTx = {
  encode(message: DecryptNotesTRC20_NoteTx, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(10).fork()).ldelim();
    }
    if (!message.position.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.position);
    }
    if (message.isSpent !== false) {
      writer.uint32(24).bool(message.isSpent);
    }
    if (message.txid.length !== 0) {
      writer.uint32(34).bytes(message.txid);
    }
    if (message.index !== 0) {
      writer.uint32(40).int32(message.index);
    }
    if (message.toAmount !== "") {
      writer.uint32(50).string(message.toAmount);
    }
    if (message.transparentToAddress.length !== 0) {
      writer.uint32(58).bytes(message.transparentToAddress);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DecryptNotesTRC20_NoteTx {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptNotesTRC20_NoteTx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.position = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isSpent = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.txid = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.toAmount = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transparentToAddress = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): DecryptNotesTRC20_NoteTx {
    return {
      note: isSet(object.note) ? Note.fromJSON(object.note) : undefined,
      position: isSet(object.position) ? Long.fromValue(object.position) : Long.ZERO,
      isSpent: isSet(object.isSpent) ? globalThis.Boolean(object.isSpent) : false,
      txid: isSet(object.txid) ? Buffer.from(bytesFromBase64(object.txid)) : Buffer.alloc(0),
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      toAmount: isSet(object.toAmount) ? globalThis.String(object.toAmount) : "",
      transparentToAddress: isSet(object.transparentToAddress)
        ? Buffer.from(bytesFromBase64(object.transparentToAddress))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: DecryptNotesTRC20_NoteTx): unknown {
    const obj: any = {};
    if (message.note !== undefined) {
      obj.note = Note.toJSON(message.note);
    }
    if (!message.position.equals(Long.ZERO)) {
      obj.position = (message.position || Long.ZERO).toString();
    }
    if (message.isSpent !== false) {
      obj.isSpent = message.isSpent;
    }
    if (message.txid.length !== 0) {
      obj.txid = base64FromBytes(message.txid);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.toAmount !== "") {
      obj.toAmount = message.toAmount;
    }
    if (message.transparentToAddress.length !== 0) {
      obj.transparentToAddress = base64FromBytes(message.transparentToAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptNotesTRC20_NoteTx>, I>>(base?: I): DecryptNotesTRC20_NoteTx {
    return DecryptNotesTRC20_NoteTx.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptNotesTRC20_NoteTx>, I>>(object: I): DecryptNotesTRC20_NoteTx {
    const message = createBaseDecryptNotesTRC20_NoteTx();
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    message.position = (object.position !== undefined && object.position !== null)
      ? Long.fromValue(object.position)
      : Long.ZERO;
    message.isSpent = object.isSpent ?? false;
    message.txid = object.txid ?? Buffer.alloc(0);
    message.index = object.index ?? 0;
    message.toAmount = object.toAmount ?? "";
    message.transparentToAddress = object.transparentToAddress ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseNfTRC20Parameters(): NfTRC20Parameters {
  return {
    note: undefined,
    ak: Buffer.alloc(0),
    nk: Buffer.alloc(0),
    position: Long.ZERO,
    shieldedTRC20ContractAddress: Buffer.alloc(0),
    _unknownFields: {},
  };
}

export const NfTRC20Parameters = {
  encode(message: NfTRC20Parameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.note !== undefined) {
      Note.encode(message.note, writer.uint32(10).fork()).ldelim();
    }
    if (message.ak.length !== 0) {
      writer.uint32(18).bytes(message.ak);
    }
    if (message.nk.length !== 0) {
      writer.uint32(26).bytes(message.nk);
    }
    if (!message.position.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.position);
    }
    if (message.shieldedTRC20ContractAddress.length !== 0) {
      writer.uint32(42).bytes(message.shieldedTRC20ContractAddress);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NfTRC20Parameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNfTRC20Parameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.note = Note.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ak = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nk = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.position = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.shieldedTRC20ContractAddress = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): NfTRC20Parameters {
    return {
      note: isSet(object.note) ? Note.fromJSON(object.note) : undefined,
      ak: isSet(object.ak) ? Buffer.from(bytesFromBase64(object.ak)) : Buffer.alloc(0),
      nk: isSet(object.nk) ? Buffer.from(bytesFromBase64(object.nk)) : Buffer.alloc(0),
      position: isSet(object.position) ? Long.fromValue(object.position) : Long.ZERO,
      shieldedTRC20ContractAddress: isSet(object.shieldedTRC20ContractAddress)
        ? Buffer.from(bytesFromBase64(object.shieldedTRC20ContractAddress))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: NfTRC20Parameters): unknown {
    const obj: any = {};
    if (message.note !== undefined) {
      obj.note = Note.toJSON(message.note);
    }
    if (message.ak.length !== 0) {
      obj.ak = base64FromBytes(message.ak);
    }
    if (message.nk.length !== 0) {
      obj.nk = base64FromBytes(message.nk);
    }
    if (!message.position.equals(Long.ZERO)) {
      obj.position = (message.position || Long.ZERO).toString();
    }
    if (message.shieldedTRC20ContractAddress.length !== 0) {
      obj.shieldedTRC20ContractAddress = base64FromBytes(message.shieldedTRC20ContractAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NfTRC20Parameters>, I>>(base?: I): NfTRC20Parameters {
    return NfTRC20Parameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NfTRC20Parameters>, I>>(object: I): NfTRC20Parameters {
    const message = createBaseNfTRC20Parameters();
    message.note = (object.note !== undefined && object.note !== null) ? Note.fromPartial(object.note) : undefined;
    message.ak = object.ak ?? Buffer.alloc(0);
    message.nk = object.nk ?? Buffer.alloc(0);
    message.position = (object.position !== undefined && object.position !== null)
      ? Long.fromValue(object.position)
      : Long.ZERO;
    message.shieldedTRC20ContractAddress = object.shieldedTRC20ContractAddress ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseNullifierResult(): NullifierResult {
  return { isSpent: false, _unknownFields: {} };
}

export const NullifierResult = {
  encode(message: NullifierResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isSpent !== false) {
      writer.uint32(8).bool(message.isSpent);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NullifierResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNullifierResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isSpent = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): NullifierResult {
    return { isSpent: isSet(object.isSpent) ? globalThis.Boolean(object.isSpent) : false };
  },

  toJSON(message: NullifierResult): unknown {
    const obj: any = {};
    if (message.isSpent !== false) {
      obj.isSpent = message.isSpent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NullifierResult>, I>>(base?: I): NullifierResult {
    return NullifierResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NullifierResult>, I>>(object: I): NullifierResult {
    const message = createBaseNullifierResult();
    message.isSpent = object.isSpent ?? false;
    return message;
  },
};

function createBaseShieldedTRC20TriggerContractParameters(): ShieldedTRC20TriggerContractParameters {
  return {
    shieldedTRC20Parameters: undefined,
    spendAuthoritySignature: [],
    amount: "",
    transparentToAddress: Buffer.alloc(0),
    _unknownFields: {},
  };
}

export const ShieldedTRC20TriggerContractParameters = {
  encode(message: ShieldedTRC20TriggerContractParameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.shieldedTRC20Parameters !== undefined) {
      ShieldedTRC20Parameters.encode(message.shieldedTRC20Parameters, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.spendAuthoritySignature) {
      BytesMessage.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.transparentToAddress.length !== 0) {
      writer.uint32(34).bytes(message.transparentToAddress);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ShieldedTRC20TriggerContractParameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShieldedTRC20TriggerContractParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.shieldedTRC20Parameters = ShieldedTRC20Parameters.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.spendAuthoritySignature.push(BytesMessage.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transparentToAddress = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ShieldedTRC20TriggerContractParameters {
    return {
      shieldedTRC20Parameters: isSet(object.shieldedTRC20Parameters)
        ? ShieldedTRC20Parameters.fromJSON(object.shieldedTRC20Parameters)
        : undefined,
      spendAuthoritySignature: globalThis.Array.isArray(object?.spendAuthoritySignature)
        ? object.spendAuthoritySignature.map((e: any) => BytesMessage.fromJSON(e))
        : [],
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      transparentToAddress: isSet(object.transparentToAddress)
        ? Buffer.from(bytesFromBase64(object.transparentToAddress))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: ShieldedTRC20TriggerContractParameters): unknown {
    const obj: any = {};
    if (message.shieldedTRC20Parameters !== undefined) {
      obj.shieldedTRC20Parameters = ShieldedTRC20Parameters.toJSON(message.shieldedTRC20Parameters);
    }
    if (message.spendAuthoritySignature?.length) {
      obj.spendAuthoritySignature = message.spendAuthoritySignature.map((e) => BytesMessage.toJSON(e));
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.transparentToAddress.length !== 0) {
      obj.transparentToAddress = base64FromBytes(message.transparentToAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShieldedTRC20TriggerContractParameters>, I>>(
    base?: I,
  ): ShieldedTRC20TriggerContractParameters {
    return ShieldedTRC20TriggerContractParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShieldedTRC20TriggerContractParameters>, I>>(
    object: I,
  ): ShieldedTRC20TriggerContractParameters {
    const message = createBaseShieldedTRC20TriggerContractParameters();
    message.shieldedTRC20Parameters =
      (object.shieldedTRC20Parameters !== undefined && object.shieldedTRC20Parameters !== null)
        ? ShieldedTRC20Parameters.fromPartial(object.shieldedTRC20Parameters)
        : undefined;
    message.spendAuthoritySignature = object.spendAuthoritySignature?.map((e) => BytesMessage.fromPartial(e)) || [];
    message.amount = object.amount ?? "";
    message.transparentToAddress = object.transparentToAddress ?? Buffer.alloc(0);
    return message;
  },
};

export type WalletService = typeof WalletService;
export const WalletService = {
  getAccount: {
    path: "/protocol.Wallet/GetAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Account) => Buffer.from(Account.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Account.decode(value),
    responseSerialize: (value: Account) => Buffer.from(Account.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Account.decode(value),
  },
  getAccountById: {
    path: "/protocol.Wallet/GetAccountById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Account) => Buffer.from(Account.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Account.decode(value),
    responseSerialize: (value: Account) => Buffer.from(Account.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Account.decode(value),
  },
  getAccountBalance: {
    path: "/protocol.Wallet/GetAccountBalance",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountBalanceRequest) => Buffer.from(AccountBalanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountBalanceRequest.decode(value),
    responseSerialize: (value: AccountBalanceResponse) => Buffer.from(AccountBalanceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AccountBalanceResponse.decode(value),
  },
  getBlockBalanceTrace: {
    path: "/protocol.Wallet/GetBlockBalanceTrace",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BlockBalanceTrace_BlockIdentifier) =>
      Buffer.from(BlockBalanceTrace_BlockIdentifier.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BlockBalanceTrace_BlockIdentifier.decode(value),
    responseSerialize: (value: BlockBalanceTrace) => Buffer.from(BlockBalanceTrace.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockBalanceTrace.decode(value),
  },
  /** Please use CreateTransaction2 instead of this function. */
  createTransaction: {
    path: "/protocol.Wallet/CreateTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TransferContract) => Buffer.from(TransferContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TransferContract.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  /** Use this function instead of CreateTransaction. */
  createTransaction2: {
    path: "/protocol.Wallet/CreateTransaction2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TransferContract) => Buffer.from(TransferContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TransferContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  broadcastTransaction: {
    path: "/protocol.Wallet/BroadcastTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Transaction.decode(value),
    responseSerialize: (value: Return) => Buffer.from(Return.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Return.decode(value),
  },
  /** Please use UpdateAccount2 instead of this function. */
  updateAccount: {
    path: "/protocol.Wallet/UpdateAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountUpdateContract) => Buffer.from(AccountUpdateContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountUpdateContract.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  setAccountId: {
    path: "/protocol.Wallet/SetAccountId",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SetAccountIdContract) => Buffer.from(SetAccountIdContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SetAccountIdContract.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  /** Use this function instead of UpdateAccount. */
  updateAccount2: {
    path: "/protocol.Wallet/UpdateAccount2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountUpdateContract) => Buffer.from(AccountUpdateContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountUpdateContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** Please use VoteWitnessAccount2 instead of this function. */
  voteWitnessAccount: {
    path: "/protocol.Wallet/VoteWitnessAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VoteWitnessContract) => Buffer.from(VoteWitnessContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VoteWitnessContract.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  /** modify the consume_user_resource_percent */
  updateSetting: {
    path: "/protocol.Wallet/UpdateSetting",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateSettingContract) => Buffer.from(UpdateSettingContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateSettingContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** modify the energy_limit */
  updateEnergyLimit: {
    path: "/protocol.Wallet/UpdateEnergyLimit",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateEnergyLimitContract) =>
      Buffer.from(UpdateEnergyLimitContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateEnergyLimitContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** Use this function instead of VoteWitnessAccount. */
  voteWitnessAccount2: {
    path: "/protocol.Wallet/VoteWitnessAccount2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VoteWitnessContract) => Buffer.from(VoteWitnessContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VoteWitnessContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** Please use CreateAssetIssue2 instead of this function. */
  createAssetIssue: {
    path: "/protocol.Wallet/CreateAssetIssue",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AssetIssueContract) => Buffer.from(AssetIssueContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AssetIssueContract.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  /** Use this function instead of CreateAssetIssue. */
  createAssetIssue2: {
    path: "/protocol.Wallet/CreateAssetIssue2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AssetIssueContract) => Buffer.from(AssetIssueContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AssetIssueContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** Please use UpdateWitness2 instead of this function. */
  updateWitness: {
    path: "/protocol.Wallet/UpdateWitness",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WitnessUpdateContract) => Buffer.from(WitnessUpdateContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WitnessUpdateContract.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  /** Use this function instead of UpdateWitness. */
  updateWitness2: {
    path: "/protocol.Wallet/UpdateWitness2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WitnessUpdateContract) => Buffer.from(WitnessUpdateContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WitnessUpdateContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** Please use CreateAccount2 instead of this function. */
  createAccount: {
    path: "/protocol.Wallet/CreateAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountCreateContract) => Buffer.from(AccountCreateContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountCreateContract.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  /** Use this function instead of CreateAccount. */
  createAccount2: {
    path: "/protocol.Wallet/CreateAccount2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountCreateContract) => Buffer.from(AccountCreateContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountCreateContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** Please use CreateWitness2 instead of this function. */
  createWitness: {
    path: "/protocol.Wallet/CreateWitness",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WitnessCreateContract) => Buffer.from(WitnessCreateContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WitnessCreateContract.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  /** Use this function instead of CreateWitness. */
  createWitness2: {
    path: "/protocol.Wallet/CreateWitness2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WitnessCreateContract) => Buffer.from(WitnessCreateContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WitnessCreateContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** Please use TransferAsset2 instead of this function. */
  transferAsset: {
    path: "/protocol.Wallet/TransferAsset",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TransferAssetContract) => Buffer.from(TransferAssetContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TransferAssetContract.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  /** Use this function instead of TransferAsset. */
  transferAsset2: {
    path: "/protocol.Wallet/TransferAsset2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TransferAssetContract) => Buffer.from(TransferAssetContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TransferAssetContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** Please use ParticipateAssetIssue2 instead of this function. */
  participateAssetIssue: {
    path: "/protocol.Wallet/ParticipateAssetIssue",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ParticipateAssetIssueContract) =>
      Buffer.from(ParticipateAssetIssueContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ParticipateAssetIssueContract.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  /** Use this function instead of ParticipateAssetIssue. */
  participateAssetIssue2: {
    path: "/protocol.Wallet/ParticipateAssetIssue2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ParticipateAssetIssueContract) =>
      Buffer.from(ParticipateAssetIssueContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ParticipateAssetIssueContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** Please use FreezeBalance2 instead of this function. */
  freezeBalance: {
    path: "/protocol.Wallet/FreezeBalance",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FreezeBalanceContract) => Buffer.from(FreezeBalanceContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FreezeBalanceContract.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  /** Use this function instead of FreezeBalance. */
  freezeBalance2: {
    path: "/protocol.Wallet/FreezeBalance2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FreezeBalanceContract) => Buffer.from(FreezeBalanceContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FreezeBalanceContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** Use this function when FreezeBalanceV2. */
  freezeBalanceV2: {
    path: "/protocol.Wallet/FreezeBalanceV2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FreezeBalanceV2Contract) => Buffer.from(FreezeBalanceV2Contract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FreezeBalanceV2Contract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** Please use UnfreezeBalance2 instead of this function. */
  unfreezeBalance: {
    path: "/protocol.Wallet/UnfreezeBalance",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UnfreezeBalanceContract) => Buffer.from(UnfreezeBalanceContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UnfreezeBalanceContract.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  /** Use this function instead of UnfreezeBalance. */
  unfreezeBalance2: {
    path: "/protocol.Wallet/UnfreezeBalance2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UnfreezeBalanceContract) => Buffer.from(UnfreezeBalanceContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UnfreezeBalanceContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** Use this function when UnfreezeBalanceV2. */
  unfreezeBalanceV2: {
    path: "/protocol.Wallet/UnfreezeBalanceV2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UnfreezeBalanceV2Contract) =>
      Buffer.from(UnfreezeBalanceV2Contract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UnfreezeBalanceV2Contract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** Please use UnfreezeAsset2 instead of this function. */
  unfreezeAsset: {
    path: "/protocol.Wallet/UnfreezeAsset",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UnfreezeAssetContract) => Buffer.from(UnfreezeAssetContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UnfreezeAssetContract.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  /** Use this function instead of UnfreezeAsset. */
  unfreezeAsset2: {
    path: "/protocol.Wallet/UnfreezeAsset2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UnfreezeAssetContract) => Buffer.from(UnfreezeAssetContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UnfreezeAssetContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** Please use WithdrawBalance2 instead of this function. */
  withdrawBalance: {
    path: "/protocol.Wallet/WithdrawBalance",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WithdrawBalanceContract) => Buffer.from(WithdrawBalanceContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WithdrawBalanceContract.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  /** Use this function instead of WithdrawBalance. */
  withdrawBalance2: {
    path: "/protocol.Wallet/WithdrawBalance2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WithdrawBalanceContract) => Buffer.from(WithdrawBalanceContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WithdrawBalanceContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  withdrawExpireUnfreeze: {
    path: "/protocol.Wallet/WithdrawExpireUnfreeze",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WithdrawExpireUnfreezeContract) =>
      Buffer.from(WithdrawExpireUnfreezeContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WithdrawExpireUnfreezeContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  delegateResource: {
    path: "/protocol.Wallet/DelegateResource",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DelegateResourceContract) => Buffer.from(DelegateResourceContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DelegateResourceContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  unDelegateResource: {
    path: "/protocol.Wallet/UnDelegateResource",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UnDelegateResourceContract) =>
      Buffer.from(UnDelegateResourceContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UnDelegateResourceContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  cancelAllUnfreezeV2: {
    path: "/protocol.Wallet/CancelAllUnfreezeV2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelAllUnfreezeV2Contract) =>
      Buffer.from(CancelAllUnfreezeV2Contract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CancelAllUnfreezeV2Contract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** Please use UpdateAsset2 instead of this function. */
  updateAsset: {
    path: "/protocol.Wallet/UpdateAsset",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateAssetContract) => Buffer.from(UpdateAssetContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateAssetContract.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  /** Use this function instead of UpdateAsset. */
  updateAsset2: {
    path: "/protocol.Wallet/UpdateAsset2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateAssetContract) => Buffer.from(UpdateAssetContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateAssetContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  proposalCreate: {
    path: "/protocol.Wallet/ProposalCreate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProposalCreateContract) => Buffer.from(ProposalCreateContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ProposalCreateContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  proposalApprove: {
    path: "/protocol.Wallet/ProposalApprove",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProposalApproveContract) => Buffer.from(ProposalApproveContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ProposalApproveContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  proposalDelete: {
    path: "/protocol.Wallet/ProposalDelete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProposalDeleteContract) => Buffer.from(ProposalDeleteContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ProposalDeleteContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  buyStorage: {
    path: "/protocol.Wallet/BuyStorage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BuyStorageContract) => Buffer.from(BuyStorageContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BuyStorageContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  buyStorageBytes: {
    path: "/protocol.Wallet/BuyStorageBytes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BuyStorageBytesContract) => Buffer.from(BuyStorageBytesContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BuyStorageBytesContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  sellStorage: {
    path: "/protocol.Wallet/SellStorage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SellStorageContract) => Buffer.from(SellStorageContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SellStorageContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  exchangeCreate: {
    path: "/protocol.Wallet/ExchangeCreate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExchangeCreateContract) => Buffer.from(ExchangeCreateContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ExchangeCreateContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  exchangeInject: {
    path: "/protocol.Wallet/ExchangeInject",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExchangeInjectContract) => Buffer.from(ExchangeInjectContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ExchangeInjectContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  exchangeWithdraw: {
    path: "/protocol.Wallet/ExchangeWithdraw",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExchangeWithdrawContract) => Buffer.from(ExchangeWithdrawContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ExchangeWithdrawContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  exchangeTransaction: {
    path: "/protocol.Wallet/ExchangeTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExchangeTransactionContract) =>
      Buffer.from(ExchangeTransactionContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ExchangeTransactionContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  marketSellAsset: {
    path: "/protocol.Wallet/MarketSellAsset",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarketSellAssetContract) => Buffer.from(MarketSellAssetContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MarketSellAssetContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  marketCancelOrder: {
    path: "/protocol.Wallet/MarketCancelOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarketCancelOrderContract) =>
      Buffer.from(MarketCancelOrderContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MarketCancelOrderContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  getMarketOrderById: {
    path: "/protocol.Wallet/GetMarketOrderById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: MarketOrder) => Buffer.from(MarketOrder.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MarketOrder.decode(value),
  },
  getMarketOrderByAccount: {
    path: "/protocol.Wallet/GetMarketOrderByAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: MarketOrderList) => Buffer.from(MarketOrderList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MarketOrderList.decode(value),
  },
  getMarketPriceByPair: {
    path: "/protocol.Wallet/GetMarketPriceByPair",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarketOrderPair) => Buffer.from(MarketOrderPair.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MarketOrderPair.decode(value),
    responseSerialize: (value: MarketPriceList) => Buffer.from(MarketPriceList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MarketPriceList.decode(value),
  },
  getMarketOrderListByPair: {
    path: "/protocol.Wallet/GetMarketOrderListByPair",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarketOrderPair) => Buffer.from(MarketOrderPair.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MarketOrderPair.decode(value),
    responseSerialize: (value: MarketOrderList) => Buffer.from(MarketOrderList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MarketOrderList.decode(value),
  },
  getMarketPairList: {
    path: "/protocol.Wallet/GetMarketPairList",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: MarketOrderPairList) => Buffer.from(MarketOrderPairList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MarketOrderPairList.decode(value),
  },
  listNodes: {
    path: "/protocol.Wallet/ListNodes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: NodeList) => Buffer.from(NodeList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NodeList.decode(value),
  },
  getAssetIssueByAccount: {
    path: "/protocol.Wallet/GetAssetIssueByAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Account) => Buffer.from(Account.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Account.decode(value),
    responseSerialize: (value: AssetIssueList) => Buffer.from(AssetIssueList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AssetIssueList.decode(value),
  },
  getAccountNet: {
    path: "/protocol.Wallet/GetAccountNet",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Account) => Buffer.from(Account.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Account.decode(value),
    responseSerialize: (value: AccountNetMessage) => Buffer.from(AccountNetMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AccountNetMessage.decode(value),
  },
  getAccountResource: {
    path: "/protocol.Wallet/GetAccountResource",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Account) => Buffer.from(Account.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Account.decode(value),
    responseSerialize: (value: AccountResourceMessage) => Buffer.from(AccountResourceMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AccountResourceMessage.decode(value),
  },
  getAssetIssueByName: {
    path: "/protocol.Wallet/GetAssetIssueByName",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: AssetIssueContract) => Buffer.from(AssetIssueContract.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AssetIssueContract.decode(value),
  },
  getAssetIssueListByName: {
    path: "/protocol.Wallet/GetAssetIssueListByName",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: AssetIssueList) => Buffer.from(AssetIssueList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AssetIssueList.decode(value),
  },
  getAssetIssueById: {
    path: "/protocol.Wallet/GetAssetIssueById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: AssetIssueContract) => Buffer.from(AssetIssueContract.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AssetIssueContract.decode(value),
  },
  /** Please use GetNowBlock2 instead of this function. */
  getNowBlock: {
    path: "/protocol.Wallet/GetNowBlock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: Block) => Buffer.from(Block.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Block.decode(value),
  },
  /** Use this function instead of GetNowBlock. */
  getNowBlock2: {
    path: "/protocol.Wallet/GetNowBlock2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: BlockExtention) => Buffer.from(BlockExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockExtention.decode(value),
  },
  /** Please use GetBlockByNum2 instead of this function. */
  getBlockByNum: {
    path: "/protocol.Wallet/GetBlockByNum",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NumberMessage.decode(value),
    responseSerialize: (value: Block) => Buffer.from(Block.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Block.decode(value),
  },
  /** Use this function instead of GetBlockByNum. */
  getBlockByNum2: {
    path: "/protocol.Wallet/GetBlockByNum2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NumberMessage.decode(value),
    responseSerialize: (value: BlockExtention) => Buffer.from(BlockExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockExtention.decode(value),
  },
  getTransactionCountByBlockNum: {
    path: "/protocol.Wallet/GetTransactionCountByBlockNum",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NumberMessage.decode(value),
    responseSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NumberMessage.decode(value),
  },
  getBlockById: {
    path: "/protocol.Wallet/GetBlockById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: Block) => Buffer.from(Block.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Block.decode(value),
  },
  /** Please use GetBlockByLimitNext2 instead of this function. */
  getBlockByLimitNext: {
    path: "/protocol.Wallet/GetBlockByLimitNext",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BlockLimit) => Buffer.from(BlockLimit.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BlockLimit.decode(value),
    responseSerialize: (value: BlockList) => Buffer.from(BlockList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockList.decode(value),
  },
  /** Use this function instead of GetBlockByLimitNext. */
  getBlockByLimitNext2: {
    path: "/protocol.Wallet/GetBlockByLimitNext2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BlockLimit) => Buffer.from(BlockLimit.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BlockLimit.decode(value),
    responseSerialize: (value: BlockListExtention) => Buffer.from(BlockListExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockListExtention.decode(value),
  },
  /** Please use GetBlockByLatestNum2 instead of this function. */
  getBlockByLatestNum: {
    path: "/protocol.Wallet/GetBlockByLatestNum",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NumberMessage.decode(value),
    responseSerialize: (value: BlockList) => Buffer.from(BlockList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockList.decode(value),
  },
  /** Use this function instead of GetBlockByLatestNum. */
  getBlockByLatestNum2: {
    path: "/protocol.Wallet/GetBlockByLatestNum2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NumberMessage.decode(value),
    responseSerialize: (value: BlockListExtention) => Buffer.from(BlockListExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockListExtention.decode(value),
  },
  getTransactionById: {
    path: "/protocol.Wallet/GetTransactionById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  deployContract: {
    path: "/protocol.Wallet/DeployContract",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateSmartContract) => Buffer.from(CreateSmartContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateSmartContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  getContract: {
    path: "/protocol.Wallet/GetContract",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: SmartContract) => Buffer.from(SmartContract.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SmartContract.decode(value),
  },
  getContractInfo: {
    path: "/protocol.Wallet/GetContractInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: SmartContractDataWrapper) =>
      Buffer.from(SmartContractDataWrapper.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SmartContractDataWrapper.decode(value),
  },
  triggerContract: {
    path: "/protocol.Wallet/TriggerContract",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TriggerSmartContract) => Buffer.from(TriggerSmartContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TriggerSmartContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  triggerConstantContract: {
    path: "/protocol.Wallet/TriggerConstantContract",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TriggerSmartContract) => Buffer.from(TriggerSmartContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TriggerSmartContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  estimateEnergy: {
    path: "/protocol.Wallet/EstimateEnergy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TriggerSmartContract) => Buffer.from(TriggerSmartContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TriggerSmartContract.decode(value),
    responseSerialize: (value: EstimateEnergyMessage) => Buffer.from(EstimateEnergyMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => EstimateEnergyMessage.decode(value),
  },
  clearContractAbi: {
    path: "/protocol.Wallet/ClearContractABI",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ClearABIContract) => Buffer.from(ClearABIContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ClearABIContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  listWitnesses: {
    path: "/protocol.Wallet/ListWitnesses",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: WitnessList) => Buffer.from(WitnessList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => WitnessList.decode(value),
  },
  getDelegatedResource: {
    path: "/protocol.Wallet/GetDelegatedResource",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DelegatedResourceMessage) => Buffer.from(DelegatedResourceMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DelegatedResourceMessage.decode(value),
    responseSerialize: (value: DelegatedResourceList) => Buffer.from(DelegatedResourceList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DelegatedResourceList.decode(value),
  },
  getDelegatedResourceV2: {
    path: "/protocol.Wallet/GetDelegatedResourceV2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DelegatedResourceMessage) => Buffer.from(DelegatedResourceMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DelegatedResourceMessage.decode(value),
    responseSerialize: (value: DelegatedResourceList) => Buffer.from(DelegatedResourceList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DelegatedResourceList.decode(value),
  },
  getDelegatedResourceAccountIndex: {
    path: "/protocol.Wallet/GetDelegatedResourceAccountIndex",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: DelegatedResourceAccountIndex) =>
      Buffer.from(DelegatedResourceAccountIndex.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DelegatedResourceAccountIndex.decode(value),
  },
  getDelegatedResourceAccountIndexV2: {
    path: "/protocol.Wallet/GetDelegatedResourceAccountIndexV2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: DelegatedResourceAccountIndex) =>
      Buffer.from(DelegatedResourceAccountIndex.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DelegatedResourceAccountIndex.decode(value),
  },
  getCanDelegatedMaxSize: {
    path: "/protocol.Wallet/GetCanDelegatedMaxSize",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CanDelegatedMaxSizeRequestMessage) =>
      Buffer.from(CanDelegatedMaxSizeRequestMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CanDelegatedMaxSizeRequestMessage.decode(value),
    responseSerialize: (value: CanDelegatedMaxSizeResponseMessage) =>
      Buffer.from(CanDelegatedMaxSizeResponseMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CanDelegatedMaxSizeResponseMessage.decode(value),
  },
  getAvailableUnfreezeCount: {
    path: "/protocol.Wallet/GetAvailableUnfreezeCount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAvailableUnfreezeCountRequestMessage) =>
      Buffer.from(GetAvailableUnfreezeCountRequestMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAvailableUnfreezeCountRequestMessage.decode(value),
    responseSerialize: (value: GetAvailableUnfreezeCountResponseMessage) =>
      Buffer.from(GetAvailableUnfreezeCountResponseMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAvailableUnfreezeCountResponseMessage.decode(value),
  },
  getCanWithdrawUnfreezeAmount: {
    path: "/protocol.Wallet/GetCanWithdrawUnfreezeAmount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CanWithdrawUnfreezeAmountRequestMessage) =>
      Buffer.from(CanWithdrawUnfreezeAmountRequestMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CanWithdrawUnfreezeAmountRequestMessage.decode(value),
    responseSerialize: (value: CanWithdrawUnfreezeAmountResponseMessage) =>
      Buffer.from(CanWithdrawUnfreezeAmountResponseMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CanWithdrawUnfreezeAmountResponseMessage.decode(value),
  },
  listProposals: {
    path: "/protocol.Wallet/ListProposals",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: ProposalList) => Buffer.from(ProposalList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ProposalList.decode(value),
  },
  getPaginatedProposalList: {
    path: "/protocol.Wallet/GetPaginatedProposalList",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PaginatedMessage) => Buffer.from(PaginatedMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PaginatedMessage.decode(value),
    responseSerialize: (value: ProposalList) => Buffer.from(ProposalList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ProposalList.decode(value),
  },
  getProposalById: {
    path: "/protocol.Wallet/GetProposalById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: Proposal) => Buffer.from(Proposal.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Proposal.decode(value),
  },
  listExchanges: {
    path: "/protocol.Wallet/ListExchanges",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: ExchangeList) => Buffer.from(ExchangeList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ExchangeList.decode(value),
  },
  getPaginatedExchangeList: {
    path: "/protocol.Wallet/GetPaginatedExchangeList",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PaginatedMessage) => Buffer.from(PaginatedMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PaginatedMessage.decode(value),
    responseSerialize: (value: ExchangeList) => Buffer.from(ExchangeList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ExchangeList.decode(value),
  },
  getExchangeById: {
    path: "/protocol.Wallet/GetExchangeById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: Exchange) => Buffer.from(Exchange.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Exchange.decode(value),
  },
  getChainParameters: {
    path: "/protocol.Wallet/GetChainParameters",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: ChainParameters) => Buffer.from(ChainParameters.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ChainParameters.decode(value),
  },
  getAssetIssueList: {
    path: "/protocol.Wallet/GetAssetIssueList",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: AssetIssueList) => Buffer.from(AssetIssueList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AssetIssueList.decode(value),
  },
  getPaginatedAssetIssueList: {
    path: "/protocol.Wallet/GetPaginatedAssetIssueList",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PaginatedMessage) => Buffer.from(PaginatedMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PaginatedMessage.decode(value),
    responseSerialize: (value: AssetIssueList) => Buffer.from(AssetIssueList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AssetIssueList.decode(value),
  },
  totalTransaction: {
    path: "/protocol.Wallet/TotalTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NumberMessage.decode(value),
  },
  getNextMaintenanceTime: {
    path: "/protocol.Wallet/GetNextMaintenanceTime",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NumberMessage.decode(value),
  },
  getTransactionInfoById: {
    path: "/protocol.Wallet/GetTransactionInfoById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: TransactionInfo) => Buffer.from(TransactionInfo.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionInfo.decode(value),
  },
  accountPermissionUpdate: {
    path: "/protocol.Wallet/AccountPermissionUpdate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountPermissionUpdateContract) =>
      Buffer.from(AccountPermissionUpdateContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountPermissionUpdateContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  getTransactionSignWeight: {
    path: "/protocol.Wallet/GetTransactionSignWeight",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Transaction.decode(value),
    responseSerialize: (value: TransactionSignWeight) => Buffer.from(TransactionSignWeight.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionSignWeight.decode(value),
  },
  getTransactionApprovedList: {
    path: "/protocol.Wallet/GetTransactionApprovedList",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Transaction.decode(value),
    responseSerialize: (value: TransactionApprovedList) => Buffer.from(TransactionApprovedList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionApprovedList.decode(value),
  },
  getNodeInfo: {
    path: "/protocol.Wallet/GetNodeInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: NodeInfo) => Buffer.from(NodeInfo.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NodeInfo.decode(value),
  },
  getRewardInfo: {
    path: "/protocol.Wallet/GetRewardInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NumberMessage.decode(value),
  },
  getBrokerageInfo: {
    path: "/protocol.Wallet/GetBrokerageInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NumberMessage.decode(value),
  },
  updateBrokerage: {
    path: "/protocol.Wallet/UpdateBrokerage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateBrokerageContract) => Buffer.from(UpdateBrokerageContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateBrokerageContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  /** for shiededTransaction */
  createShieldedTransaction: {
    path: "/protocol.Wallet/CreateShieldedTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PrivateParameters) => Buffer.from(PrivateParameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PrivateParameters.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  getMerkleTreeVoucherInfo: {
    path: "/protocol.Wallet/GetMerkleTreeVoucherInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OutputPointInfo) => Buffer.from(OutputPointInfo.encode(value).finish()),
    requestDeserialize: (value: Buffer) => OutputPointInfo.decode(value),
    responseSerialize: (value: IncrementalMerkleVoucherInfo) =>
      Buffer.from(IncrementalMerkleVoucherInfo.encode(value).finish()),
    responseDeserialize: (value: Buffer) => IncrementalMerkleVoucherInfo.decode(value),
  },
  scanNoteByIvk: {
    path: "/protocol.Wallet/ScanNoteByIvk",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: IvkDecryptParameters) => Buffer.from(IvkDecryptParameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => IvkDecryptParameters.decode(value),
    responseSerialize: (value: DecryptNotes) => Buffer.from(DecryptNotes.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DecryptNotes.decode(value),
  },
  scanAndMarkNoteByIvk: {
    path: "/protocol.Wallet/ScanAndMarkNoteByIvk",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: IvkDecryptAndMarkParameters) =>
      Buffer.from(IvkDecryptAndMarkParameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => IvkDecryptAndMarkParameters.decode(value),
    responseSerialize: (value: DecryptNotesMarked) => Buffer.from(DecryptNotesMarked.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DecryptNotesMarked.decode(value),
  },
  scanNoteByOvk: {
    path: "/protocol.Wallet/ScanNoteByOvk",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OvkDecryptParameters) => Buffer.from(OvkDecryptParameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => OvkDecryptParameters.decode(value),
    responseSerialize: (value: DecryptNotes) => Buffer.from(DecryptNotes.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DecryptNotes.decode(value),
  },
  getSpendingKey: {
    path: "/protocol.Wallet/GetSpendingKey",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BytesMessage.decode(value),
  },
  getExpandedSpendingKey: {
    path: "/protocol.Wallet/GetExpandedSpendingKey",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: ExpandedSpendingKeyMessage) =>
      Buffer.from(ExpandedSpendingKeyMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ExpandedSpendingKeyMessage.decode(value),
  },
  getAkFromAsk: {
    path: "/protocol.Wallet/GetAkFromAsk",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BytesMessage.decode(value),
  },
  getNkFromNsk: {
    path: "/protocol.Wallet/GetNkFromNsk",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BytesMessage.decode(value),
  },
  getIncomingViewingKey: {
    path: "/protocol.Wallet/GetIncomingViewingKey",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ViewingKeyMessage) => Buffer.from(ViewingKeyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ViewingKeyMessage.decode(value),
    responseSerialize: (value: IncomingViewingKeyMessage) =>
      Buffer.from(IncomingViewingKeyMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => IncomingViewingKeyMessage.decode(value),
  },
  getDiversifier: {
    path: "/protocol.Wallet/GetDiversifier",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: DiversifierMessage) => Buffer.from(DiversifierMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DiversifierMessage.decode(value),
  },
  getNewShieldedAddress: {
    path: "/protocol.Wallet/GetNewShieldedAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: ShieldedAddressInfo) => Buffer.from(ShieldedAddressInfo.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ShieldedAddressInfo.decode(value),
  },
  getZenPaymentAddress: {
    path: "/protocol.Wallet/GetZenPaymentAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: IncomingViewingKeyDiversifierMessage) =>
      Buffer.from(IncomingViewingKeyDiversifierMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => IncomingViewingKeyDiversifierMessage.decode(value),
    responseSerialize: (value: PaymentAddressMessage) => Buffer.from(PaymentAddressMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentAddressMessage.decode(value),
  },
  getRcm: {
    path: "/protocol.Wallet/GetRcm",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BytesMessage.decode(value),
  },
  isSpend: {
    path: "/protocol.Wallet/IsSpend",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NoteParameters) => Buffer.from(NoteParameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NoteParameters.decode(value),
    responseSerialize: (value: SpendResult) => Buffer.from(SpendResult.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SpendResult.decode(value),
  },
  createShieldedTransactionWithoutSpendAuthSig: {
    path: "/protocol.Wallet/CreateShieldedTransactionWithoutSpendAuthSig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PrivateParametersWithoutAsk) =>
      Buffer.from(PrivateParametersWithoutAsk.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PrivateParametersWithoutAsk.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  getShieldTransactionHash: {
    path: "/protocol.Wallet/GetShieldTransactionHash",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Transaction.decode(value),
    responseSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BytesMessage.decode(value),
  },
  createSpendAuthSig: {
    path: "/protocol.Wallet/CreateSpendAuthSig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SpendAuthSigParameters) => Buffer.from(SpendAuthSigParameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SpendAuthSigParameters.decode(value),
    responseSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BytesMessage.decode(value),
  },
  createShieldNullifier: {
    path: "/protocol.Wallet/CreateShieldNullifier",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NfParameters) => Buffer.from(NfParameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NfParameters.decode(value),
    responseSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BytesMessage.decode(value),
  },
  /** for shielded contract */
  createShieldedContractParameters: {
    path: "/protocol.Wallet/CreateShieldedContractParameters",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PrivateShieldedTRC20Parameters) =>
      Buffer.from(PrivateShieldedTRC20Parameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PrivateShieldedTRC20Parameters.decode(value),
    responseSerialize: (value: ShieldedTRC20Parameters) => Buffer.from(ShieldedTRC20Parameters.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ShieldedTRC20Parameters.decode(value),
  },
  createShieldedContractParametersWithoutAsk: {
    path: "/protocol.Wallet/CreateShieldedContractParametersWithoutAsk",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PrivateShieldedTRC20ParametersWithoutAsk) =>
      Buffer.from(PrivateShieldedTRC20ParametersWithoutAsk.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PrivateShieldedTRC20ParametersWithoutAsk.decode(value),
    responseSerialize: (value: ShieldedTRC20Parameters) => Buffer.from(ShieldedTRC20Parameters.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ShieldedTRC20Parameters.decode(value),
  },
  scanShieldedTrc20NotesByIvk: {
    path: "/protocol.Wallet/ScanShieldedTRC20NotesByIvk",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: IvkDecryptTRC20Parameters) =>
      Buffer.from(IvkDecryptTRC20Parameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => IvkDecryptTRC20Parameters.decode(value),
    responseSerialize: (value: DecryptNotesTRC20) => Buffer.from(DecryptNotesTRC20.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DecryptNotesTRC20.decode(value),
  },
  scanShieldedTrc20NotesByOvk: {
    path: "/protocol.Wallet/ScanShieldedTRC20NotesByOvk",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OvkDecryptTRC20Parameters) =>
      Buffer.from(OvkDecryptTRC20Parameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => OvkDecryptTRC20Parameters.decode(value),
    responseSerialize: (value: DecryptNotesTRC20) => Buffer.from(DecryptNotesTRC20.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DecryptNotesTRC20.decode(value),
  },
  isShieldedTrc20ContractNoteSpent: {
    path: "/protocol.Wallet/IsShieldedTRC20ContractNoteSpent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NfTRC20Parameters) => Buffer.from(NfTRC20Parameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NfTRC20Parameters.decode(value),
    responseSerialize: (value: NullifierResult) => Buffer.from(NullifierResult.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NullifierResult.decode(value),
  },
  getTriggerInputForShieldedTrc20Contract: {
    path: "/protocol.Wallet/GetTriggerInputForShieldedTRC20Contract",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ShieldedTRC20TriggerContractParameters) =>
      Buffer.from(ShieldedTRC20TriggerContractParameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ShieldedTRC20TriggerContractParameters.decode(value),
    responseSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BytesMessage.decode(value),
  },
  createCommonTransaction: {
    path: "/protocol.Wallet/CreateCommonTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Transaction.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  getTransactionInfoByBlockNum: {
    path: "/protocol.Wallet/GetTransactionInfoByBlockNum",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NumberMessage.decode(value),
    responseSerialize: (value: TransactionInfoList) => Buffer.from(TransactionInfoList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionInfoList.decode(value),
  },
  getBurnTrx: {
    path: "/protocol.Wallet/GetBurnTrx",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NumberMessage.decode(value),
  },
  getTransactionFromPending: {
    path: "/protocol.Wallet/GetTransactionFromPending",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  getTransactionListFromPending: {
    path: "/protocol.Wallet/GetTransactionListFromPending",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: TransactionIdList) => Buffer.from(TransactionIdList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionIdList.decode(value),
  },
  getPendingSize: {
    path: "/protocol.Wallet/GetPendingSize",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NumberMessage.decode(value),
  },
  getBlock: {
    path: "/protocol.Wallet/GetBlock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BlockReq) => Buffer.from(BlockReq.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BlockReq.decode(value),
    responseSerialize: (value: BlockExtention) => Buffer.from(BlockExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockExtention.decode(value),
  },
  getBandwidthPrices: {
    path: "/protocol.Wallet/GetBandwidthPrices",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: PricesResponseMessage) => Buffer.from(PricesResponseMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PricesResponseMessage.decode(value),
  },
  getEnergyPrices: {
    path: "/protocol.Wallet/GetEnergyPrices",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: PricesResponseMessage) => Buffer.from(PricesResponseMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PricesResponseMessage.decode(value),
  },
  getMemoFee: {
    path: "/protocol.Wallet/GetMemoFee",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: PricesResponseMessage) => Buffer.from(PricesResponseMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PricesResponseMessage.decode(value),
  },
} as const;

export interface WalletServer extends UntypedServiceImplementation {
  getAccount: handleUnaryCall<Account, Account>;
  getAccountById: handleUnaryCall<Account, Account>;
  getAccountBalance: handleUnaryCall<AccountBalanceRequest, AccountBalanceResponse>;
  getBlockBalanceTrace: handleUnaryCall<BlockBalanceTrace_BlockIdentifier, BlockBalanceTrace>;
  /** Please use CreateTransaction2 instead of this function. */
  createTransaction: handleUnaryCall<TransferContract, Transaction>;
  /** Use this function instead of CreateTransaction. */
  createTransaction2: handleUnaryCall<TransferContract, TransactionExtention>;
  broadcastTransaction: handleUnaryCall<Transaction, Return>;
  /** Please use UpdateAccount2 instead of this function. */
  updateAccount: handleUnaryCall<AccountUpdateContract, Transaction>;
  setAccountId: handleUnaryCall<SetAccountIdContract, Transaction>;
  /** Use this function instead of UpdateAccount. */
  updateAccount2: handleUnaryCall<AccountUpdateContract, TransactionExtention>;
  /** Please use VoteWitnessAccount2 instead of this function. */
  voteWitnessAccount: handleUnaryCall<VoteWitnessContract, Transaction>;
  /** modify the consume_user_resource_percent */
  updateSetting: handleUnaryCall<UpdateSettingContract, TransactionExtention>;
  /** modify the energy_limit */
  updateEnergyLimit: handleUnaryCall<UpdateEnergyLimitContract, TransactionExtention>;
  /** Use this function instead of VoteWitnessAccount. */
  voteWitnessAccount2: handleUnaryCall<VoteWitnessContract, TransactionExtention>;
  /** Please use CreateAssetIssue2 instead of this function. */
  createAssetIssue: handleUnaryCall<AssetIssueContract, Transaction>;
  /** Use this function instead of CreateAssetIssue. */
  createAssetIssue2: handleUnaryCall<AssetIssueContract, TransactionExtention>;
  /** Please use UpdateWitness2 instead of this function. */
  updateWitness: handleUnaryCall<WitnessUpdateContract, Transaction>;
  /** Use this function instead of UpdateWitness. */
  updateWitness2: handleUnaryCall<WitnessUpdateContract, TransactionExtention>;
  /** Please use CreateAccount2 instead of this function. */
  createAccount: handleUnaryCall<AccountCreateContract, Transaction>;
  /** Use this function instead of CreateAccount. */
  createAccount2: handleUnaryCall<AccountCreateContract, TransactionExtention>;
  /** Please use CreateWitness2 instead of this function. */
  createWitness: handleUnaryCall<WitnessCreateContract, Transaction>;
  /** Use this function instead of CreateWitness. */
  createWitness2: handleUnaryCall<WitnessCreateContract, TransactionExtention>;
  /** Please use TransferAsset2 instead of this function. */
  transferAsset: handleUnaryCall<TransferAssetContract, Transaction>;
  /** Use this function instead of TransferAsset. */
  transferAsset2: handleUnaryCall<TransferAssetContract, TransactionExtention>;
  /** Please use ParticipateAssetIssue2 instead of this function. */
  participateAssetIssue: handleUnaryCall<ParticipateAssetIssueContract, Transaction>;
  /** Use this function instead of ParticipateAssetIssue. */
  participateAssetIssue2: handleUnaryCall<ParticipateAssetIssueContract, TransactionExtention>;
  /** Please use FreezeBalance2 instead of this function. */
  freezeBalance: handleUnaryCall<FreezeBalanceContract, Transaction>;
  /** Use this function instead of FreezeBalance. */
  freezeBalance2: handleUnaryCall<FreezeBalanceContract, TransactionExtention>;
  /** Use this function when FreezeBalanceV2. */
  freezeBalanceV2: handleUnaryCall<FreezeBalanceV2Contract, TransactionExtention>;
  /** Please use UnfreezeBalance2 instead of this function. */
  unfreezeBalance: handleUnaryCall<UnfreezeBalanceContract, Transaction>;
  /** Use this function instead of UnfreezeBalance. */
  unfreezeBalance2: handleUnaryCall<UnfreezeBalanceContract, TransactionExtention>;
  /** Use this function when UnfreezeBalanceV2. */
  unfreezeBalanceV2: handleUnaryCall<UnfreezeBalanceV2Contract, TransactionExtention>;
  /** Please use UnfreezeAsset2 instead of this function. */
  unfreezeAsset: handleUnaryCall<UnfreezeAssetContract, Transaction>;
  /** Use this function instead of UnfreezeAsset. */
  unfreezeAsset2: handleUnaryCall<UnfreezeAssetContract, TransactionExtention>;
  /** Please use WithdrawBalance2 instead of this function. */
  withdrawBalance: handleUnaryCall<WithdrawBalanceContract, Transaction>;
  /** Use this function instead of WithdrawBalance. */
  withdrawBalance2: handleUnaryCall<WithdrawBalanceContract, TransactionExtention>;
  withdrawExpireUnfreeze: handleUnaryCall<WithdrawExpireUnfreezeContract, TransactionExtention>;
  delegateResource: handleUnaryCall<DelegateResourceContract, TransactionExtention>;
  unDelegateResource: handleUnaryCall<UnDelegateResourceContract, TransactionExtention>;
  cancelAllUnfreezeV2: handleUnaryCall<CancelAllUnfreezeV2Contract, TransactionExtention>;
  /** Please use UpdateAsset2 instead of this function. */
  updateAsset: handleUnaryCall<UpdateAssetContract, Transaction>;
  /** Use this function instead of UpdateAsset. */
  updateAsset2: handleUnaryCall<UpdateAssetContract, TransactionExtention>;
  proposalCreate: handleUnaryCall<ProposalCreateContract, TransactionExtention>;
  proposalApprove: handleUnaryCall<ProposalApproveContract, TransactionExtention>;
  proposalDelete: handleUnaryCall<ProposalDeleteContract, TransactionExtention>;
  buyStorage: handleUnaryCall<BuyStorageContract, TransactionExtention>;
  buyStorageBytes: handleUnaryCall<BuyStorageBytesContract, TransactionExtention>;
  sellStorage: handleUnaryCall<SellStorageContract, TransactionExtention>;
  exchangeCreate: handleUnaryCall<ExchangeCreateContract, TransactionExtention>;
  exchangeInject: handleUnaryCall<ExchangeInjectContract, TransactionExtention>;
  exchangeWithdraw: handleUnaryCall<ExchangeWithdrawContract, TransactionExtention>;
  exchangeTransaction: handleUnaryCall<ExchangeTransactionContract, TransactionExtention>;
  marketSellAsset: handleUnaryCall<MarketSellAssetContract, TransactionExtention>;
  marketCancelOrder: handleUnaryCall<MarketCancelOrderContract, TransactionExtention>;
  getMarketOrderById: handleUnaryCall<BytesMessage, MarketOrder>;
  getMarketOrderByAccount: handleUnaryCall<BytesMessage, MarketOrderList>;
  getMarketPriceByPair: handleUnaryCall<MarketOrderPair, MarketPriceList>;
  getMarketOrderListByPair: handleUnaryCall<MarketOrderPair, MarketOrderList>;
  getMarketPairList: handleUnaryCall<EmptyMessage, MarketOrderPairList>;
  listNodes: handleUnaryCall<EmptyMessage, NodeList>;
  getAssetIssueByAccount: handleUnaryCall<Account, AssetIssueList>;
  getAccountNet: handleUnaryCall<Account, AccountNetMessage>;
  getAccountResource: handleUnaryCall<Account, AccountResourceMessage>;
  getAssetIssueByName: handleUnaryCall<BytesMessage, AssetIssueContract>;
  getAssetIssueListByName: handleUnaryCall<BytesMessage, AssetIssueList>;
  getAssetIssueById: handleUnaryCall<BytesMessage, AssetIssueContract>;
  /** Please use GetNowBlock2 instead of this function. */
  getNowBlock: handleUnaryCall<EmptyMessage, Block>;
  /** Use this function instead of GetNowBlock. */
  getNowBlock2: handleUnaryCall<EmptyMessage, BlockExtention>;
  /** Please use GetBlockByNum2 instead of this function. */
  getBlockByNum: handleUnaryCall<NumberMessage, Block>;
  /** Use this function instead of GetBlockByNum. */
  getBlockByNum2: handleUnaryCall<NumberMessage, BlockExtention>;
  getTransactionCountByBlockNum: handleUnaryCall<NumberMessage, NumberMessage>;
  getBlockById: handleUnaryCall<BytesMessage, Block>;
  /** Please use GetBlockByLimitNext2 instead of this function. */
  getBlockByLimitNext: handleUnaryCall<BlockLimit, BlockList>;
  /** Use this function instead of GetBlockByLimitNext. */
  getBlockByLimitNext2: handleUnaryCall<BlockLimit, BlockListExtention>;
  /** Please use GetBlockByLatestNum2 instead of this function. */
  getBlockByLatestNum: handleUnaryCall<NumberMessage, BlockList>;
  /** Use this function instead of GetBlockByLatestNum. */
  getBlockByLatestNum2: handleUnaryCall<NumberMessage, BlockListExtention>;
  getTransactionById: handleUnaryCall<BytesMessage, Transaction>;
  deployContract: handleUnaryCall<CreateSmartContract, TransactionExtention>;
  getContract: handleUnaryCall<BytesMessage, SmartContract>;
  getContractInfo: handleUnaryCall<BytesMessage, SmartContractDataWrapper>;
  triggerContract: handleUnaryCall<TriggerSmartContract, TransactionExtention>;
  triggerConstantContract: handleUnaryCall<TriggerSmartContract, TransactionExtention>;
  estimateEnergy: handleUnaryCall<TriggerSmartContract, EstimateEnergyMessage>;
  clearContractAbi: handleUnaryCall<ClearABIContract, TransactionExtention>;
  listWitnesses: handleUnaryCall<EmptyMessage, WitnessList>;
  getDelegatedResource: handleUnaryCall<DelegatedResourceMessage, DelegatedResourceList>;
  getDelegatedResourceV2: handleUnaryCall<DelegatedResourceMessage, DelegatedResourceList>;
  getDelegatedResourceAccountIndex: handleUnaryCall<BytesMessage, DelegatedResourceAccountIndex>;
  getDelegatedResourceAccountIndexV2: handleUnaryCall<BytesMessage, DelegatedResourceAccountIndex>;
  getCanDelegatedMaxSize: handleUnaryCall<CanDelegatedMaxSizeRequestMessage, CanDelegatedMaxSizeResponseMessage>;
  getAvailableUnfreezeCount: handleUnaryCall<
    GetAvailableUnfreezeCountRequestMessage,
    GetAvailableUnfreezeCountResponseMessage
  >;
  getCanWithdrawUnfreezeAmount: handleUnaryCall<
    CanWithdrawUnfreezeAmountRequestMessage,
    CanWithdrawUnfreezeAmountResponseMessage
  >;
  listProposals: handleUnaryCall<EmptyMessage, ProposalList>;
  getPaginatedProposalList: handleUnaryCall<PaginatedMessage, ProposalList>;
  getProposalById: handleUnaryCall<BytesMessage, Proposal>;
  listExchanges: handleUnaryCall<EmptyMessage, ExchangeList>;
  getPaginatedExchangeList: handleUnaryCall<PaginatedMessage, ExchangeList>;
  getExchangeById: handleUnaryCall<BytesMessage, Exchange>;
  getChainParameters: handleUnaryCall<EmptyMessage, ChainParameters>;
  getAssetIssueList: handleUnaryCall<EmptyMessage, AssetIssueList>;
  getPaginatedAssetIssueList: handleUnaryCall<PaginatedMessage, AssetIssueList>;
  totalTransaction: handleUnaryCall<EmptyMessage, NumberMessage>;
  getNextMaintenanceTime: handleUnaryCall<EmptyMessage, NumberMessage>;
  getTransactionInfoById: handleUnaryCall<BytesMessage, TransactionInfo>;
  accountPermissionUpdate: handleUnaryCall<AccountPermissionUpdateContract, TransactionExtention>;
  getTransactionSignWeight: handleUnaryCall<Transaction, TransactionSignWeight>;
  getTransactionApprovedList: handleUnaryCall<Transaction, TransactionApprovedList>;
  getNodeInfo: handleUnaryCall<EmptyMessage, NodeInfo>;
  getRewardInfo: handleUnaryCall<BytesMessage, NumberMessage>;
  getBrokerageInfo: handleUnaryCall<BytesMessage, NumberMessage>;
  updateBrokerage: handleUnaryCall<UpdateBrokerageContract, TransactionExtention>;
  /** for shiededTransaction */
  createShieldedTransaction: handleUnaryCall<PrivateParameters, TransactionExtention>;
  getMerkleTreeVoucherInfo: handleUnaryCall<OutputPointInfo, IncrementalMerkleVoucherInfo>;
  scanNoteByIvk: handleUnaryCall<IvkDecryptParameters, DecryptNotes>;
  scanAndMarkNoteByIvk: handleUnaryCall<IvkDecryptAndMarkParameters, DecryptNotesMarked>;
  scanNoteByOvk: handleUnaryCall<OvkDecryptParameters, DecryptNotes>;
  getSpendingKey: handleUnaryCall<EmptyMessage, BytesMessage>;
  getExpandedSpendingKey: handleUnaryCall<BytesMessage, ExpandedSpendingKeyMessage>;
  getAkFromAsk: handleUnaryCall<BytesMessage, BytesMessage>;
  getNkFromNsk: handleUnaryCall<BytesMessage, BytesMessage>;
  getIncomingViewingKey: handleUnaryCall<ViewingKeyMessage, IncomingViewingKeyMessage>;
  getDiversifier: handleUnaryCall<EmptyMessage, DiversifierMessage>;
  getNewShieldedAddress: handleUnaryCall<EmptyMessage, ShieldedAddressInfo>;
  getZenPaymentAddress: handleUnaryCall<IncomingViewingKeyDiversifierMessage, PaymentAddressMessage>;
  getRcm: handleUnaryCall<EmptyMessage, BytesMessage>;
  isSpend: handleUnaryCall<NoteParameters, SpendResult>;
  createShieldedTransactionWithoutSpendAuthSig: handleUnaryCall<PrivateParametersWithoutAsk, TransactionExtention>;
  getShieldTransactionHash: handleUnaryCall<Transaction, BytesMessage>;
  createSpendAuthSig: handleUnaryCall<SpendAuthSigParameters, BytesMessage>;
  createShieldNullifier: handleUnaryCall<NfParameters, BytesMessage>;
  /** for shielded contract */
  createShieldedContractParameters: handleUnaryCall<PrivateShieldedTRC20Parameters, ShieldedTRC20Parameters>;
  createShieldedContractParametersWithoutAsk: handleUnaryCall<
    PrivateShieldedTRC20ParametersWithoutAsk,
    ShieldedTRC20Parameters
  >;
  scanShieldedTrc20NotesByIvk: handleUnaryCall<IvkDecryptTRC20Parameters, DecryptNotesTRC20>;
  scanShieldedTrc20NotesByOvk: handleUnaryCall<OvkDecryptTRC20Parameters, DecryptNotesTRC20>;
  isShieldedTrc20ContractNoteSpent: handleUnaryCall<NfTRC20Parameters, NullifierResult>;
  getTriggerInputForShieldedTrc20Contract: handleUnaryCall<ShieldedTRC20TriggerContractParameters, BytesMessage>;
  createCommonTransaction: handleUnaryCall<Transaction, TransactionExtention>;
  getTransactionInfoByBlockNum: handleUnaryCall<NumberMessage, TransactionInfoList>;
  getBurnTrx: handleUnaryCall<EmptyMessage, NumberMessage>;
  getTransactionFromPending: handleUnaryCall<BytesMessage, Transaction>;
  getTransactionListFromPending: handleUnaryCall<EmptyMessage, TransactionIdList>;
  getPendingSize: handleUnaryCall<EmptyMessage, NumberMessage>;
  getBlock: handleUnaryCall<BlockReq, BlockExtention>;
  getBandwidthPrices: handleUnaryCall<EmptyMessage, PricesResponseMessage>;
  getEnergyPrices: handleUnaryCall<EmptyMessage, PricesResponseMessage>;
  getMemoFee: handleUnaryCall<EmptyMessage, PricesResponseMessage>;
}

export interface WalletClient extends Client {
  getAccount(request: Account, callback: (error: ServiceError | null, response: Account) => void): ClientUnaryCall;
  getAccount(
    request: Account,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  getAccount(
    request: Account,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  getAccountById(request: Account, callback: (error: ServiceError | null, response: Account) => void): ClientUnaryCall;
  getAccountById(
    request: Account,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  getAccountById(
    request: Account,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  getAccountBalance(
    request: AccountBalanceRequest,
    callback: (error: ServiceError | null, response: AccountBalanceResponse) => void,
  ): ClientUnaryCall;
  getAccountBalance(
    request: AccountBalanceRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AccountBalanceResponse) => void,
  ): ClientUnaryCall;
  getAccountBalance(
    request: AccountBalanceRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AccountBalanceResponse) => void,
  ): ClientUnaryCall;
  getBlockBalanceTrace(
    request: BlockBalanceTrace_BlockIdentifier,
    callback: (error: ServiceError | null, response: BlockBalanceTrace) => void,
  ): ClientUnaryCall;
  getBlockBalanceTrace(
    request: BlockBalanceTrace_BlockIdentifier,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockBalanceTrace) => void,
  ): ClientUnaryCall;
  getBlockBalanceTrace(
    request: BlockBalanceTrace_BlockIdentifier,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockBalanceTrace) => void,
  ): ClientUnaryCall;
  /** Please use CreateTransaction2 instead of this function. */
  createTransaction(
    request: TransferContract,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  createTransaction(
    request: TransferContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  createTransaction(
    request: TransferContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  /** Use this function instead of CreateTransaction. */
  createTransaction2(
    request: TransferContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  createTransaction2(
    request: TransferContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  createTransaction2(
    request: TransferContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  broadcastTransaction(
    request: Transaction,
    callback: (error: ServiceError | null, response: Return) => void,
  ): ClientUnaryCall;
  broadcastTransaction(
    request: Transaction,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Return) => void,
  ): ClientUnaryCall;
  broadcastTransaction(
    request: Transaction,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Return) => void,
  ): ClientUnaryCall;
  /** Please use UpdateAccount2 instead of this function. */
  updateAccount(
    request: AccountUpdateContract,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  updateAccount(
    request: AccountUpdateContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  updateAccount(
    request: AccountUpdateContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  setAccountId(
    request: SetAccountIdContract,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  setAccountId(
    request: SetAccountIdContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  setAccountId(
    request: SetAccountIdContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  /** Use this function instead of UpdateAccount. */
  updateAccount2(
    request: AccountUpdateContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  updateAccount2(
    request: AccountUpdateContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  updateAccount2(
    request: AccountUpdateContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** Please use VoteWitnessAccount2 instead of this function. */
  voteWitnessAccount(
    request: VoteWitnessContract,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  voteWitnessAccount(
    request: VoteWitnessContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  voteWitnessAccount(
    request: VoteWitnessContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  /** modify the consume_user_resource_percent */
  updateSetting(
    request: UpdateSettingContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  updateSetting(
    request: UpdateSettingContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  updateSetting(
    request: UpdateSettingContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** modify the energy_limit */
  updateEnergyLimit(
    request: UpdateEnergyLimitContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  updateEnergyLimit(
    request: UpdateEnergyLimitContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  updateEnergyLimit(
    request: UpdateEnergyLimitContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** Use this function instead of VoteWitnessAccount. */
  voteWitnessAccount2(
    request: VoteWitnessContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  voteWitnessAccount2(
    request: VoteWitnessContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  voteWitnessAccount2(
    request: VoteWitnessContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** Please use CreateAssetIssue2 instead of this function. */
  createAssetIssue(
    request: AssetIssueContract,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  createAssetIssue(
    request: AssetIssueContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  createAssetIssue(
    request: AssetIssueContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  /** Use this function instead of CreateAssetIssue. */
  createAssetIssue2(
    request: AssetIssueContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  createAssetIssue2(
    request: AssetIssueContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  createAssetIssue2(
    request: AssetIssueContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** Please use UpdateWitness2 instead of this function. */
  updateWitness(
    request: WitnessUpdateContract,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  updateWitness(
    request: WitnessUpdateContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  updateWitness(
    request: WitnessUpdateContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  /** Use this function instead of UpdateWitness. */
  updateWitness2(
    request: WitnessUpdateContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  updateWitness2(
    request: WitnessUpdateContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  updateWitness2(
    request: WitnessUpdateContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** Please use CreateAccount2 instead of this function. */
  createAccount(
    request: AccountCreateContract,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  createAccount(
    request: AccountCreateContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  createAccount(
    request: AccountCreateContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  /** Use this function instead of CreateAccount. */
  createAccount2(
    request: AccountCreateContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  createAccount2(
    request: AccountCreateContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  createAccount2(
    request: AccountCreateContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** Please use CreateWitness2 instead of this function. */
  createWitness(
    request: WitnessCreateContract,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  createWitness(
    request: WitnessCreateContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  createWitness(
    request: WitnessCreateContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  /** Use this function instead of CreateWitness. */
  createWitness2(
    request: WitnessCreateContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  createWitness2(
    request: WitnessCreateContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  createWitness2(
    request: WitnessCreateContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** Please use TransferAsset2 instead of this function. */
  transferAsset(
    request: TransferAssetContract,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  transferAsset(
    request: TransferAssetContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  transferAsset(
    request: TransferAssetContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  /** Use this function instead of TransferAsset. */
  transferAsset2(
    request: TransferAssetContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  transferAsset2(
    request: TransferAssetContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  transferAsset2(
    request: TransferAssetContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** Please use ParticipateAssetIssue2 instead of this function. */
  participateAssetIssue(
    request: ParticipateAssetIssueContract,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  participateAssetIssue(
    request: ParticipateAssetIssueContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  participateAssetIssue(
    request: ParticipateAssetIssueContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  /** Use this function instead of ParticipateAssetIssue. */
  participateAssetIssue2(
    request: ParticipateAssetIssueContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  participateAssetIssue2(
    request: ParticipateAssetIssueContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  participateAssetIssue2(
    request: ParticipateAssetIssueContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** Please use FreezeBalance2 instead of this function. */
  freezeBalance(
    request: FreezeBalanceContract,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  freezeBalance(
    request: FreezeBalanceContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  freezeBalance(
    request: FreezeBalanceContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  /** Use this function instead of FreezeBalance. */
  freezeBalance2(
    request: FreezeBalanceContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  freezeBalance2(
    request: FreezeBalanceContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  freezeBalance2(
    request: FreezeBalanceContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** Use this function when FreezeBalanceV2. */
  freezeBalanceV2(
    request: FreezeBalanceV2Contract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  freezeBalanceV2(
    request: FreezeBalanceV2Contract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  freezeBalanceV2(
    request: FreezeBalanceV2Contract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** Please use UnfreezeBalance2 instead of this function. */
  unfreezeBalance(
    request: UnfreezeBalanceContract,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  unfreezeBalance(
    request: UnfreezeBalanceContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  unfreezeBalance(
    request: UnfreezeBalanceContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  /** Use this function instead of UnfreezeBalance. */
  unfreezeBalance2(
    request: UnfreezeBalanceContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  unfreezeBalance2(
    request: UnfreezeBalanceContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  unfreezeBalance2(
    request: UnfreezeBalanceContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** Use this function when UnfreezeBalanceV2. */
  unfreezeBalanceV2(
    request: UnfreezeBalanceV2Contract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  unfreezeBalanceV2(
    request: UnfreezeBalanceV2Contract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  unfreezeBalanceV2(
    request: UnfreezeBalanceV2Contract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** Please use UnfreezeAsset2 instead of this function. */
  unfreezeAsset(
    request: UnfreezeAssetContract,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  unfreezeAsset(
    request: UnfreezeAssetContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  unfreezeAsset(
    request: UnfreezeAssetContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  /** Use this function instead of UnfreezeAsset. */
  unfreezeAsset2(
    request: UnfreezeAssetContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  unfreezeAsset2(
    request: UnfreezeAssetContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  unfreezeAsset2(
    request: UnfreezeAssetContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** Please use WithdrawBalance2 instead of this function. */
  withdrawBalance(
    request: WithdrawBalanceContract,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  withdrawBalance(
    request: WithdrawBalanceContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  withdrawBalance(
    request: WithdrawBalanceContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  /** Use this function instead of WithdrawBalance. */
  withdrawBalance2(
    request: WithdrawBalanceContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  withdrawBalance2(
    request: WithdrawBalanceContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  withdrawBalance2(
    request: WithdrawBalanceContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  withdrawExpireUnfreeze(
    request: WithdrawExpireUnfreezeContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  withdrawExpireUnfreeze(
    request: WithdrawExpireUnfreezeContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  withdrawExpireUnfreeze(
    request: WithdrawExpireUnfreezeContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  delegateResource(
    request: DelegateResourceContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  delegateResource(
    request: DelegateResourceContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  delegateResource(
    request: DelegateResourceContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  unDelegateResource(
    request: UnDelegateResourceContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  unDelegateResource(
    request: UnDelegateResourceContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  unDelegateResource(
    request: UnDelegateResourceContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  cancelAllUnfreezeV2(
    request: CancelAllUnfreezeV2Contract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  cancelAllUnfreezeV2(
    request: CancelAllUnfreezeV2Contract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  cancelAllUnfreezeV2(
    request: CancelAllUnfreezeV2Contract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** Please use UpdateAsset2 instead of this function. */
  updateAsset(
    request: UpdateAssetContract,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  updateAsset(
    request: UpdateAssetContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  updateAsset(
    request: UpdateAssetContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  /** Use this function instead of UpdateAsset. */
  updateAsset2(
    request: UpdateAssetContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  updateAsset2(
    request: UpdateAssetContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  updateAsset2(
    request: UpdateAssetContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  proposalCreate(
    request: ProposalCreateContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  proposalCreate(
    request: ProposalCreateContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  proposalCreate(
    request: ProposalCreateContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  proposalApprove(
    request: ProposalApproveContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  proposalApprove(
    request: ProposalApproveContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  proposalApprove(
    request: ProposalApproveContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  proposalDelete(
    request: ProposalDeleteContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  proposalDelete(
    request: ProposalDeleteContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  proposalDelete(
    request: ProposalDeleteContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  buyStorage(
    request: BuyStorageContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  buyStorage(
    request: BuyStorageContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  buyStorage(
    request: BuyStorageContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  buyStorageBytes(
    request: BuyStorageBytesContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  buyStorageBytes(
    request: BuyStorageBytesContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  buyStorageBytes(
    request: BuyStorageBytesContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  sellStorage(
    request: SellStorageContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  sellStorage(
    request: SellStorageContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  sellStorage(
    request: SellStorageContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  exchangeCreate(
    request: ExchangeCreateContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  exchangeCreate(
    request: ExchangeCreateContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  exchangeCreate(
    request: ExchangeCreateContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  exchangeInject(
    request: ExchangeInjectContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  exchangeInject(
    request: ExchangeInjectContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  exchangeInject(
    request: ExchangeInjectContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  exchangeWithdraw(
    request: ExchangeWithdrawContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  exchangeWithdraw(
    request: ExchangeWithdrawContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  exchangeWithdraw(
    request: ExchangeWithdrawContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  exchangeTransaction(
    request: ExchangeTransactionContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  exchangeTransaction(
    request: ExchangeTransactionContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  exchangeTransaction(
    request: ExchangeTransactionContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  marketSellAsset(
    request: MarketSellAssetContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  marketSellAsset(
    request: MarketSellAssetContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  marketSellAsset(
    request: MarketSellAssetContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  marketCancelOrder(
    request: MarketCancelOrderContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  marketCancelOrder(
    request: MarketCancelOrderContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  marketCancelOrder(
    request: MarketCancelOrderContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  getMarketOrderById(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: MarketOrder) => void,
  ): ClientUnaryCall;
  getMarketOrderById(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MarketOrder) => void,
  ): ClientUnaryCall;
  getMarketOrderById(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MarketOrder) => void,
  ): ClientUnaryCall;
  getMarketOrderByAccount(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: MarketOrderList) => void,
  ): ClientUnaryCall;
  getMarketOrderByAccount(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MarketOrderList) => void,
  ): ClientUnaryCall;
  getMarketOrderByAccount(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MarketOrderList) => void,
  ): ClientUnaryCall;
  getMarketPriceByPair(
    request: MarketOrderPair,
    callback: (error: ServiceError | null, response: MarketPriceList) => void,
  ): ClientUnaryCall;
  getMarketPriceByPair(
    request: MarketOrderPair,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MarketPriceList) => void,
  ): ClientUnaryCall;
  getMarketPriceByPair(
    request: MarketOrderPair,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MarketPriceList) => void,
  ): ClientUnaryCall;
  getMarketOrderListByPair(
    request: MarketOrderPair,
    callback: (error: ServiceError | null, response: MarketOrderList) => void,
  ): ClientUnaryCall;
  getMarketOrderListByPair(
    request: MarketOrderPair,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MarketOrderList) => void,
  ): ClientUnaryCall;
  getMarketOrderListByPair(
    request: MarketOrderPair,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MarketOrderList) => void,
  ): ClientUnaryCall;
  getMarketPairList(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: MarketOrderPairList) => void,
  ): ClientUnaryCall;
  getMarketPairList(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MarketOrderPairList) => void,
  ): ClientUnaryCall;
  getMarketPairList(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MarketOrderPairList) => void,
  ): ClientUnaryCall;
  listNodes(request: EmptyMessage, callback: (error: ServiceError | null, response: NodeList) => void): ClientUnaryCall;
  listNodes(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NodeList) => void,
  ): ClientUnaryCall;
  listNodes(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NodeList) => void,
  ): ClientUnaryCall;
  getAssetIssueByAccount(
    request: Account,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getAssetIssueByAccount(
    request: Account,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getAssetIssueByAccount(
    request: Account,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getAccountNet(
    request: Account,
    callback: (error: ServiceError | null, response: AccountNetMessage) => void,
  ): ClientUnaryCall;
  getAccountNet(
    request: Account,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AccountNetMessage) => void,
  ): ClientUnaryCall;
  getAccountNet(
    request: Account,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AccountNetMessage) => void,
  ): ClientUnaryCall;
  getAccountResource(
    request: Account,
    callback: (error: ServiceError | null, response: AccountResourceMessage) => void,
  ): ClientUnaryCall;
  getAccountResource(
    request: Account,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AccountResourceMessage) => void,
  ): ClientUnaryCall;
  getAccountResource(
    request: Account,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AccountResourceMessage) => void,
  ): ClientUnaryCall;
  getAssetIssueByName(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: AssetIssueContract) => void,
  ): ClientUnaryCall;
  getAssetIssueByName(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AssetIssueContract) => void,
  ): ClientUnaryCall;
  getAssetIssueByName(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AssetIssueContract) => void,
  ): ClientUnaryCall;
  getAssetIssueListByName(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getAssetIssueListByName(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getAssetIssueListByName(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getAssetIssueById(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: AssetIssueContract) => void,
  ): ClientUnaryCall;
  getAssetIssueById(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AssetIssueContract) => void,
  ): ClientUnaryCall;
  getAssetIssueById(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AssetIssueContract) => void,
  ): ClientUnaryCall;
  /** Please use GetNowBlock2 instead of this function. */
  getNowBlock(request: EmptyMessage, callback: (error: ServiceError | null, response: Block) => void): ClientUnaryCall;
  getNowBlock(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  getNowBlock(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  /** Use this function instead of GetNowBlock. */
  getNowBlock2(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getNowBlock2(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getNowBlock2(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  /** Please use GetBlockByNum2 instead of this function. */
  getBlockByNum(
    request: NumberMessage,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  getBlockByNum(
    request: NumberMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  getBlockByNum(
    request: NumberMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  /** Use this function instead of GetBlockByNum. */
  getBlockByNum2(
    request: NumberMessage,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getBlockByNum2(
    request: NumberMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getBlockByNum2(
    request: NumberMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getTransactionCountByBlockNum(
    request: NumberMessage,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getTransactionCountByBlockNum(
    request: NumberMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getTransactionCountByBlockNum(
    request: NumberMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getBlockById(request: BytesMessage, callback: (error: ServiceError | null, response: Block) => void): ClientUnaryCall;
  getBlockById(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  getBlockById(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  /** Please use GetBlockByLimitNext2 instead of this function. */
  getBlockByLimitNext(
    request: BlockLimit,
    callback: (error: ServiceError | null, response: BlockList) => void,
  ): ClientUnaryCall;
  getBlockByLimitNext(
    request: BlockLimit,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockList) => void,
  ): ClientUnaryCall;
  getBlockByLimitNext(
    request: BlockLimit,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockList) => void,
  ): ClientUnaryCall;
  /** Use this function instead of GetBlockByLimitNext. */
  getBlockByLimitNext2(
    request: BlockLimit,
    callback: (error: ServiceError | null, response: BlockListExtention) => void,
  ): ClientUnaryCall;
  getBlockByLimitNext2(
    request: BlockLimit,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockListExtention) => void,
  ): ClientUnaryCall;
  getBlockByLimitNext2(
    request: BlockLimit,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockListExtention) => void,
  ): ClientUnaryCall;
  /** Please use GetBlockByLatestNum2 instead of this function. */
  getBlockByLatestNum(
    request: NumberMessage,
    callback: (error: ServiceError | null, response: BlockList) => void,
  ): ClientUnaryCall;
  getBlockByLatestNum(
    request: NumberMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockList) => void,
  ): ClientUnaryCall;
  getBlockByLatestNum(
    request: NumberMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockList) => void,
  ): ClientUnaryCall;
  /** Use this function instead of GetBlockByLatestNum. */
  getBlockByLatestNum2(
    request: NumberMessage,
    callback: (error: ServiceError | null, response: BlockListExtention) => void,
  ): ClientUnaryCall;
  getBlockByLatestNum2(
    request: NumberMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockListExtention) => void,
  ): ClientUnaryCall;
  getBlockByLatestNum2(
    request: NumberMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockListExtention) => void,
  ): ClientUnaryCall;
  getTransactionById(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  getTransactionById(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  getTransactionById(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  deployContract(
    request: CreateSmartContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  deployContract(
    request: CreateSmartContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  deployContract(
    request: CreateSmartContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  getContract(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: SmartContract) => void,
  ): ClientUnaryCall;
  getContract(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SmartContract) => void,
  ): ClientUnaryCall;
  getContract(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SmartContract) => void,
  ): ClientUnaryCall;
  getContractInfo(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: SmartContractDataWrapper) => void,
  ): ClientUnaryCall;
  getContractInfo(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SmartContractDataWrapper) => void,
  ): ClientUnaryCall;
  getContractInfo(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SmartContractDataWrapper) => void,
  ): ClientUnaryCall;
  triggerContract(
    request: TriggerSmartContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  triggerContract(
    request: TriggerSmartContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  triggerContract(
    request: TriggerSmartContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  triggerConstantContract(
    request: TriggerSmartContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  triggerConstantContract(
    request: TriggerSmartContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  triggerConstantContract(
    request: TriggerSmartContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  estimateEnergy(
    request: TriggerSmartContract,
    callback: (error: ServiceError | null, response: EstimateEnergyMessage) => void,
  ): ClientUnaryCall;
  estimateEnergy(
    request: TriggerSmartContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EstimateEnergyMessage) => void,
  ): ClientUnaryCall;
  estimateEnergy(
    request: TriggerSmartContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EstimateEnergyMessage) => void,
  ): ClientUnaryCall;
  clearContractAbi(
    request: ClearABIContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  clearContractAbi(
    request: ClearABIContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  clearContractAbi(
    request: ClearABIContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  listWitnesses(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: WitnessList) => void,
  ): ClientUnaryCall;
  listWitnesses(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WitnessList) => void,
  ): ClientUnaryCall;
  listWitnesses(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WitnessList) => void,
  ): ClientUnaryCall;
  getDelegatedResource(
    request: DelegatedResourceMessage,
    callback: (error: ServiceError | null, response: DelegatedResourceList) => void,
  ): ClientUnaryCall;
  getDelegatedResource(
    request: DelegatedResourceMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DelegatedResourceList) => void,
  ): ClientUnaryCall;
  getDelegatedResource(
    request: DelegatedResourceMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DelegatedResourceList) => void,
  ): ClientUnaryCall;
  getDelegatedResourceV2(
    request: DelegatedResourceMessage,
    callback: (error: ServiceError | null, response: DelegatedResourceList) => void,
  ): ClientUnaryCall;
  getDelegatedResourceV2(
    request: DelegatedResourceMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DelegatedResourceList) => void,
  ): ClientUnaryCall;
  getDelegatedResourceV2(
    request: DelegatedResourceMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DelegatedResourceList) => void,
  ): ClientUnaryCall;
  getDelegatedResourceAccountIndex(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: DelegatedResourceAccountIndex) => void,
  ): ClientUnaryCall;
  getDelegatedResourceAccountIndex(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DelegatedResourceAccountIndex) => void,
  ): ClientUnaryCall;
  getDelegatedResourceAccountIndex(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DelegatedResourceAccountIndex) => void,
  ): ClientUnaryCall;
  getDelegatedResourceAccountIndexV2(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: DelegatedResourceAccountIndex) => void,
  ): ClientUnaryCall;
  getDelegatedResourceAccountIndexV2(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DelegatedResourceAccountIndex) => void,
  ): ClientUnaryCall;
  getDelegatedResourceAccountIndexV2(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DelegatedResourceAccountIndex) => void,
  ): ClientUnaryCall;
  getCanDelegatedMaxSize(
    request: CanDelegatedMaxSizeRequestMessage,
    callback: (error: ServiceError | null, response: CanDelegatedMaxSizeResponseMessage) => void,
  ): ClientUnaryCall;
  getCanDelegatedMaxSize(
    request: CanDelegatedMaxSizeRequestMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CanDelegatedMaxSizeResponseMessage) => void,
  ): ClientUnaryCall;
  getCanDelegatedMaxSize(
    request: CanDelegatedMaxSizeRequestMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CanDelegatedMaxSizeResponseMessage) => void,
  ): ClientUnaryCall;
  getAvailableUnfreezeCount(
    request: GetAvailableUnfreezeCountRequestMessage,
    callback: (error: ServiceError | null, response: GetAvailableUnfreezeCountResponseMessage) => void,
  ): ClientUnaryCall;
  getAvailableUnfreezeCount(
    request: GetAvailableUnfreezeCountRequestMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAvailableUnfreezeCountResponseMessage) => void,
  ): ClientUnaryCall;
  getAvailableUnfreezeCount(
    request: GetAvailableUnfreezeCountRequestMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAvailableUnfreezeCountResponseMessage) => void,
  ): ClientUnaryCall;
  getCanWithdrawUnfreezeAmount(
    request: CanWithdrawUnfreezeAmountRequestMessage,
    callback: (error: ServiceError | null, response: CanWithdrawUnfreezeAmountResponseMessage) => void,
  ): ClientUnaryCall;
  getCanWithdrawUnfreezeAmount(
    request: CanWithdrawUnfreezeAmountRequestMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CanWithdrawUnfreezeAmountResponseMessage) => void,
  ): ClientUnaryCall;
  getCanWithdrawUnfreezeAmount(
    request: CanWithdrawUnfreezeAmountRequestMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CanWithdrawUnfreezeAmountResponseMessage) => void,
  ): ClientUnaryCall;
  listProposals(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: ProposalList) => void,
  ): ClientUnaryCall;
  listProposals(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ProposalList) => void,
  ): ClientUnaryCall;
  listProposals(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ProposalList) => void,
  ): ClientUnaryCall;
  getPaginatedProposalList(
    request: PaginatedMessage,
    callback: (error: ServiceError | null, response: ProposalList) => void,
  ): ClientUnaryCall;
  getPaginatedProposalList(
    request: PaginatedMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ProposalList) => void,
  ): ClientUnaryCall;
  getPaginatedProposalList(
    request: PaginatedMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ProposalList) => void,
  ): ClientUnaryCall;
  getProposalById(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: Proposal) => void,
  ): ClientUnaryCall;
  getProposalById(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Proposal) => void,
  ): ClientUnaryCall;
  getProposalById(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Proposal) => void,
  ): ClientUnaryCall;
  listExchanges(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: ExchangeList) => void,
  ): ClientUnaryCall;
  listExchanges(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ExchangeList) => void,
  ): ClientUnaryCall;
  listExchanges(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ExchangeList) => void,
  ): ClientUnaryCall;
  getPaginatedExchangeList(
    request: PaginatedMessage,
    callback: (error: ServiceError | null, response: ExchangeList) => void,
  ): ClientUnaryCall;
  getPaginatedExchangeList(
    request: PaginatedMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ExchangeList) => void,
  ): ClientUnaryCall;
  getPaginatedExchangeList(
    request: PaginatedMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ExchangeList) => void,
  ): ClientUnaryCall;
  getExchangeById(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: Exchange) => void,
  ): ClientUnaryCall;
  getExchangeById(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Exchange) => void,
  ): ClientUnaryCall;
  getExchangeById(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Exchange) => void,
  ): ClientUnaryCall;
  getChainParameters(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: ChainParameters) => void,
  ): ClientUnaryCall;
  getChainParameters(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ChainParameters) => void,
  ): ClientUnaryCall;
  getChainParameters(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ChainParameters) => void,
  ): ClientUnaryCall;
  getAssetIssueList(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getAssetIssueList(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getAssetIssueList(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getPaginatedAssetIssueList(
    request: PaginatedMessage,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getPaginatedAssetIssueList(
    request: PaginatedMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getPaginatedAssetIssueList(
    request: PaginatedMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  totalTransaction(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  totalTransaction(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  totalTransaction(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getNextMaintenanceTime(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getNextMaintenanceTime(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getNextMaintenanceTime(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getTransactionInfoById(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: TransactionInfo) => void,
  ): ClientUnaryCall;
  getTransactionInfoById(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionInfo) => void,
  ): ClientUnaryCall;
  getTransactionInfoById(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionInfo) => void,
  ): ClientUnaryCall;
  accountPermissionUpdate(
    request: AccountPermissionUpdateContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  accountPermissionUpdate(
    request: AccountPermissionUpdateContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  accountPermissionUpdate(
    request: AccountPermissionUpdateContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  getTransactionSignWeight(
    request: Transaction,
    callback: (error: ServiceError | null, response: TransactionSignWeight) => void,
  ): ClientUnaryCall;
  getTransactionSignWeight(
    request: Transaction,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionSignWeight) => void,
  ): ClientUnaryCall;
  getTransactionSignWeight(
    request: Transaction,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionSignWeight) => void,
  ): ClientUnaryCall;
  getTransactionApprovedList(
    request: Transaction,
    callback: (error: ServiceError | null, response: TransactionApprovedList) => void,
  ): ClientUnaryCall;
  getTransactionApprovedList(
    request: Transaction,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionApprovedList) => void,
  ): ClientUnaryCall;
  getTransactionApprovedList(
    request: Transaction,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionApprovedList) => void,
  ): ClientUnaryCall;
  getNodeInfo(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: NodeInfo) => void,
  ): ClientUnaryCall;
  getNodeInfo(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NodeInfo) => void,
  ): ClientUnaryCall;
  getNodeInfo(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NodeInfo) => void,
  ): ClientUnaryCall;
  getRewardInfo(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getRewardInfo(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getRewardInfo(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getBrokerageInfo(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getBrokerageInfo(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getBrokerageInfo(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  updateBrokerage(
    request: UpdateBrokerageContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  updateBrokerage(
    request: UpdateBrokerageContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  updateBrokerage(
    request: UpdateBrokerageContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  /** for shiededTransaction */
  createShieldedTransaction(
    request: PrivateParameters,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  createShieldedTransaction(
    request: PrivateParameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  createShieldedTransaction(
    request: PrivateParameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  getMerkleTreeVoucherInfo(
    request: OutputPointInfo,
    callback: (error: ServiceError | null, response: IncrementalMerkleVoucherInfo) => void,
  ): ClientUnaryCall;
  getMerkleTreeVoucherInfo(
    request: OutputPointInfo,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: IncrementalMerkleVoucherInfo) => void,
  ): ClientUnaryCall;
  getMerkleTreeVoucherInfo(
    request: OutputPointInfo,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: IncrementalMerkleVoucherInfo) => void,
  ): ClientUnaryCall;
  scanNoteByIvk(
    request: IvkDecryptParameters,
    callback: (error: ServiceError | null, response: DecryptNotes) => void,
  ): ClientUnaryCall;
  scanNoteByIvk(
    request: IvkDecryptParameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DecryptNotes) => void,
  ): ClientUnaryCall;
  scanNoteByIvk(
    request: IvkDecryptParameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DecryptNotes) => void,
  ): ClientUnaryCall;
  scanAndMarkNoteByIvk(
    request: IvkDecryptAndMarkParameters,
    callback: (error: ServiceError | null, response: DecryptNotesMarked) => void,
  ): ClientUnaryCall;
  scanAndMarkNoteByIvk(
    request: IvkDecryptAndMarkParameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DecryptNotesMarked) => void,
  ): ClientUnaryCall;
  scanAndMarkNoteByIvk(
    request: IvkDecryptAndMarkParameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DecryptNotesMarked) => void,
  ): ClientUnaryCall;
  scanNoteByOvk(
    request: OvkDecryptParameters,
    callback: (error: ServiceError | null, response: DecryptNotes) => void,
  ): ClientUnaryCall;
  scanNoteByOvk(
    request: OvkDecryptParameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DecryptNotes) => void,
  ): ClientUnaryCall;
  scanNoteByOvk(
    request: OvkDecryptParameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DecryptNotes) => void,
  ): ClientUnaryCall;
  getSpendingKey(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  getSpendingKey(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  getSpendingKey(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  getExpandedSpendingKey(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: ExpandedSpendingKeyMessage) => void,
  ): ClientUnaryCall;
  getExpandedSpendingKey(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ExpandedSpendingKeyMessage) => void,
  ): ClientUnaryCall;
  getExpandedSpendingKey(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ExpandedSpendingKeyMessage) => void,
  ): ClientUnaryCall;
  getAkFromAsk(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  getAkFromAsk(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  getAkFromAsk(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  getNkFromNsk(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  getNkFromNsk(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  getNkFromNsk(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  getIncomingViewingKey(
    request: ViewingKeyMessage,
    callback: (error: ServiceError | null, response: IncomingViewingKeyMessage) => void,
  ): ClientUnaryCall;
  getIncomingViewingKey(
    request: ViewingKeyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: IncomingViewingKeyMessage) => void,
  ): ClientUnaryCall;
  getIncomingViewingKey(
    request: ViewingKeyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: IncomingViewingKeyMessage) => void,
  ): ClientUnaryCall;
  getDiversifier(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: DiversifierMessage) => void,
  ): ClientUnaryCall;
  getDiversifier(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DiversifierMessage) => void,
  ): ClientUnaryCall;
  getDiversifier(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DiversifierMessage) => void,
  ): ClientUnaryCall;
  getNewShieldedAddress(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: ShieldedAddressInfo) => void,
  ): ClientUnaryCall;
  getNewShieldedAddress(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ShieldedAddressInfo) => void,
  ): ClientUnaryCall;
  getNewShieldedAddress(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ShieldedAddressInfo) => void,
  ): ClientUnaryCall;
  getZenPaymentAddress(
    request: IncomingViewingKeyDiversifierMessage,
    callback: (error: ServiceError | null, response: PaymentAddressMessage) => void,
  ): ClientUnaryCall;
  getZenPaymentAddress(
    request: IncomingViewingKeyDiversifierMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PaymentAddressMessage) => void,
  ): ClientUnaryCall;
  getZenPaymentAddress(
    request: IncomingViewingKeyDiversifierMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PaymentAddressMessage) => void,
  ): ClientUnaryCall;
  getRcm(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  getRcm(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  getRcm(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  isSpend(
    request: NoteParameters,
    callback: (error: ServiceError | null, response: SpendResult) => void,
  ): ClientUnaryCall;
  isSpend(
    request: NoteParameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SpendResult) => void,
  ): ClientUnaryCall;
  isSpend(
    request: NoteParameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SpendResult) => void,
  ): ClientUnaryCall;
  createShieldedTransactionWithoutSpendAuthSig(
    request: PrivateParametersWithoutAsk,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  createShieldedTransactionWithoutSpendAuthSig(
    request: PrivateParametersWithoutAsk,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  createShieldedTransactionWithoutSpendAuthSig(
    request: PrivateParametersWithoutAsk,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  getShieldTransactionHash(
    request: Transaction,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  getShieldTransactionHash(
    request: Transaction,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  getShieldTransactionHash(
    request: Transaction,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  createSpendAuthSig(
    request: SpendAuthSigParameters,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  createSpendAuthSig(
    request: SpendAuthSigParameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  createSpendAuthSig(
    request: SpendAuthSigParameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  createShieldNullifier(
    request: NfParameters,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  createShieldNullifier(
    request: NfParameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  createShieldNullifier(
    request: NfParameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  /** for shielded contract */
  createShieldedContractParameters(
    request: PrivateShieldedTRC20Parameters,
    callback: (error: ServiceError | null, response: ShieldedTRC20Parameters) => void,
  ): ClientUnaryCall;
  createShieldedContractParameters(
    request: PrivateShieldedTRC20Parameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ShieldedTRC20Parameters) => void,
  ): ClientUnaryCall;
  createShieldedContractParameters(
    request: PrivateShieldedTRC20Parameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ShieldedTRC20Parameters) => void,
  ): ClientUnaryCall;
  createShieldedContractParametersWithoutAsk(
    request: PrivateShieldedTRC20ParametersWithoutAsk,
    callback: (error: ServiceError | null, response: ShieldedTRC20Parameters) => void,
  ): ClientUnaryCall;
  createShieldedContractParametersWithoutAsk(
    request: PrivateShieldedTRC20ParametersWithoutAsk,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ShieldedTRC20Parameters) => void,
  ): ClientUnaryCall;
  createShieldedContractParametersWithoutAsk(
    request: PrivateShieldedTRC20ParametersWithoutAsk,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ShieldedTRC20Parameters) => void,
  ): ClientUnaryCall;
  scanShieldedTrc20NotesByIvk(
    request: IvkDecryptTRC20Parameters,
    callback: (error: ServiceError | null, response: DecryptNotesTRC20) => void,
  ): ClientUnaryCall;
  scanShieldedTrc20NotesByIvk(
    request: IvkDecryptTRC20Parameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DecryptNotesTRC20) => void,
  ): ClientUnaryCall;
  scanShieldedTrc20NotesByIvk(
    request: IvkDecryptTRC20Parameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DecryptNotesTRC20) => void,
  ): ClientUnaryCall;
  scanShieldedTrc20NotesByOvk(
    request: OvkDecryptTRC20Parameters,
    callback: (error: ServiceError | null, response: DecryptNotesTRC20) => void,
  ): ClientUnaryCall;
  scanShieldedTrc20NotesByOvk(
    request: OvkDecryptTRC20Parameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DecryptNotesTRC20) => void,
  ): ClientUnaryCall;
  scanShieldedTrc20NotesByOvk(
    request: OvkDecryptTRC20Parameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DecryptNotesTRC20) => void,
  ): ClientUnaryCall;
  isShieldedTrc20ContractNoteSpent(
    request: NfTRC20Parameters,
    callback: (error: ServiceError | null, response: NullifierResult) => void,
  ): ClientUnaryCall;
  isShieldedTrc20ContractNoteSpent(
    request: NfTRC20Parameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NullifierResult) => void,
  ): ClientUnaryCall;
  isShieldedTrc20ContractNoteSpent(
    request: NfTRC20Parameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NullifierResult) => void,
  ): ClientUnaryCall;
  getTriggerInputForShieldedTrc20Contract(
    request: ShieldedTRC20TriggerContractParameters,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  getTriggerInputForShieldedTrc20Contract(
    request: ShieldedTRC20TriggerContractParameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  getTriggerInputForShieldedTrc20Contract(
    request: ShieldedTRC20TriggerContractParameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BytesMessage) => void,
  ): ClientUnaryCall;
  createCommonTransaction(
    request: Transaction,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  createCommonTransaction(
    request: Transaction,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  createCommonTransaction(
    request: Transaction,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  getTransactionInfoByBlockNum(
    request: NumberMessage,
    callback: (error: ServiceError | null, response: TransactionInfoList) => void,
  ): ClientUnaryCall;
  getTransactionInfoByBlockNum(
    request: NumberMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionInfoList) => void,
  ): ClientUnaryCall;
  getTransactionInfoByBlockNum(
    request: NumberMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionInfoList) => void,
  ): ClientUnaryCall;
  getBurnTrx(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getBurnTrx(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getBurnTrx(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getTransactionFromPending(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  getTransactionFromPending(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  getTransactionFromPending(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  getTransactionListFromPending(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: TransactionIdList) => void,
  ): ClientUnaryCall;
  getTransactionListFromPending(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionIdList) => void,
  ): ClientUnaryCall;
  getTransactionListFromPending(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionIdList) => void,
  ): ClientUnaryCall;
  getPendingSize(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getPendingSize(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getPendingSize(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getBlock(
    request: BlockReq,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getBlock(
    request: BlockReq,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getBlock(
    request: BlockReq,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getBandwidthPrices(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: PricesResponseMessage) => void,
  ): ClientUnaryCall;
  getBandwidthPrices(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PricesResponseMessage) => void,
  ): ClientUnaryCall;
  getBandwidthPrices(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PricesResponseMessage) => void,
  ): ClientUnaryCall;
  getEnergyPrices(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: PricesResponseMessage) => void,
  ): ClientUnaryCall;
  getEnergyPrices(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PricesResponseMessage) => void,
  ): ClientUnaryCall;
  getEnergyPrices(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PricesResponseMessage) => void,
  ): ClientUnaryCall;
  getMemoFee(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: PricesResponseMessage) => void,
  ): ClientUnaryCall;
  getMemoFee(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PricesResponseMessage) => void,
  ): ClientUnaryCall;
  getMemoFee(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PricesResponseMessage) => void,
  ): ClientUnaryCall;
}

export const WalletClient = makeGenericClientConstructor(WalletService, "protocol.Wallet") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): WalletClient;
  service: typeof WalletService;
  serviceName: string;
};

export type WalletSolidityService = typeof WalletSolidityService;
export const WalletSolidityService = {
  getAccount: {
    path: "/protocol.WalletSolidity/GetAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Account) => Buffer.from(Account.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Account.decode(value),
    responseSerialize: (value: Account) => Buffer.from(Account.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Account.decode(value),
  },
  getAccountById: {
    path: "/protocol.WalletSolidity/GetAccountById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Account) => Buffer.from(Account.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Account.decode(value),
    responseSerialize: (value: Account) => Buffer.from(Account.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Account.decode(value),
  },
  listWitnesses: {
    path: "/protocol.WalletSolidity/ListWitnesses",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: WitnessList) => Buffer.from(WitnessList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => WitnessList.decode(value),
  },
  getAssetIssueList: {
    path: "/protocol.WalletSolidity/GetAssetIssueList",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: AssetIssueList) => Buffer.from(AssetIssueList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AssetIssueList.decode(value),
  },
  getPaginatedAssetIssueList: {
    path: "/protocol.WalletSolidity/GetPaginatedAssetIssueList",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PaginatedMessage) => Buffer.from(PaginatedMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PaginatedMessage.decode(value),
    responseSerialize: (value: AssetIssueList) => Buffer.from(AssetIssueList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AssetIssueList.decode(value),
  },
  getAssetIssueByName: {
    path: "/protocol.WalletSolidity/GetAssetIssueByName",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: AssetIssueContract) => Buffer.from(AssetIssueContract.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AssetIssueContract.decode(value),
  },
  getAssetIssueListByName: {
    path: "/protocol.WalletSolidity/GetAssetIssueListByName",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: AssetIssueList) => Buffer.from(AssetIssueList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AssetIssueList.decode(value),
  },
  getAssetIssueById: {
    path: "/protocol.WalletSolidity/GetAssetIssueById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: AssetIssueContract) => Buffer.from(AssetIssueContract.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AssetIssueContract.decode(value),
  },
  /** Please use GetNowBlock2 instead of this function. */
  getNowBlock: {
    path: "/protocol.WalletSolidity/GetNowBlock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: Block) => Buffer.from(Block.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Block.decode(value),
  },
  /** Use this function instead of GetNowBlock. */
  getNowBlock2: {
    path: "/protocol.WalletSolidity/GetNowBlock2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: BlockExtention) => Buffer.from(BlockExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockExtention.decode(value),
  },
  /** Please use GetBlockByNum2 instead of this function. */
  getBlockByNum: {
    path: "/protocol.WalletSolidity/GetBlockByNum",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NumberMessage.decode(value),
    responseSerialize: (value: Block) => Buffer.from(Block.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Block.decode(value),
  },
  /** Use this function instead of GetBlockByNum. */
  getBlockByNum2: {
    path: "/protocol.WalletSolidity/GetBlockByNum2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NumberMessage.decode(value),
    responseSerialize: (value: BlockExtention) => Buffer.from(BlockExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockExtention.decode(value),
  },
  getTransactionCountByBlockNum: {
    path: "/protocol.WalletSolidity/GetTransactionCountByBlockNum",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NumberMessage.decode(value),
    responseSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NumberMessage.decode(value),
  },
  getDelegatedResource: {
    path: "/protocol.WalletSolidity/GetDelegatedResource",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DelegatedResourceMessage) => Buffer.from(DelegatedResourceMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DelegatedResourceMessage.decode(value),
    responseSerialize: (value: DelegatedResourceList) => Buffer.from(DelegatedResourceList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DelegatedResourceList.decode(value),
  },
  getDelegatedResourceV2: {
    path: "/protocol.WalletSolidity/GetDelegatedResourceV2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DelegatedResourceMessage) => Buffer.from(DelegatedResourceMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DelegatedResourceMessage.decode(value),
    responseSerialize: (value: DelegatedResourceList) => Buffer.from(DelegatedResourceList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DelegatedResourceList.decode(value),
  },
  getDelegatedResourceAccountIndex: {
    path: "/protocol.WalletSolidity/GetDelegatedResourceAccountIndex",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: DelegatedResourceAccountIndex) =>
      Buffer.from(DelegatedResourceAccountIndex.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DelegatedResourceAccountIndex.decode(value),
  },
  getDelegatedResourceAccountIndexV2: {
    path: "/protocol.WalletSolidity/GetDelegatedResourceAccountIndexV2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: DelegatedResourceAccountIndex) =>
      Buffer.from(DelegatedResourceAccountIndex.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DelegatedResourceAccountIndex.decode(value),
  },
  getCanDelegatedMaxSize: {
    path: "/protocol.WalletSolidity/GetCanDelegatedMaxSize",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CanDelegatedMaxSizeRequestMessage) =>
      Buffer.from(CanDelegatedMaxSizeRequestMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CanDelegatedMaxSizeRequestMessage.decode(value),
    responseSerialize: (value: CanDelegatedMaxSizeResponseMessage) =>
      Buffer.from(CanDelegatedMaxSizeResponseMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CanDelegatedMaxSizeResponseMessage.decode(value),
  },
  getAvailableUnfreezeCount: {
    path: "/protocol.WalletSolidity/GetAvailableUnfreezeCount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAvailableUnfreezeCountRequestMessage) =>
      Buffer.from(GetAvailableUnfreezeCountRequestMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAvailableUnfreezeCountRequestMessage.decode(value),
    responseSerialize: (value: GetAvailableUnfreezeCountResponseMessage) =>
      Buffer.from(GetAvailableUnfreezeCountResponseMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAvailableUnfreezeCountResponseMessage.decode(value),
  },
  getCanWithdrawUnfreezeAmount: {
    path: "/protocol.WalletSolidity/GetCanWithdrawUnfreezeAmount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CanWithdrawUnfreezeAmountRequestMessage) =>
      Buffer.from(CanWithdrawUnfreezeAmountRequestMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CanWithdrawUnfreezeAmountRequestMessage.decode(value),
    responseSerialize: (value: CanWithdrawUnfreezeAmountResponseMessage) =>
      Buffer.from(CanWithdrawUnfreezeAmountResponseMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CanWithdrawUnfreezeAmountResponseMessage.decode(value),
  },
  getExchangeById: {
    path: "/protocol.WalletSolidity/GetExchangeById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: Exchange) => Buffer.from(Exchange.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Exchange.decode(value),
  },
  listExchanges: {
    path: "/protocol.WalletSolidity/ListExchanges",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: ExchangeList) => Buffer.from(ExchangeList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ExchangeList.decode(value),
  },
  getTransactionById: {
    path: "/protocol.WalletSolidity/GetTransactionById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: Transaction) => Buffer.from(Transaction.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Transaction.decode(value),
  },
  getTransactionInfoById: {
    path: "/protocol.WalletSolidity/GetTransactionInfoById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: TransactionInfo) => Buffer.from(TransactionInfo.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionInfo.decode(value),
  },
  getMerkleTreeVoucherInfo: {
    path: "/protocol.WalletSolidity/GetMerkleTreeVoucherInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OutputPointInfo) => Buffer.from(OutputPointInfo.encode(value).finish()),
    requestDeserialize: (value: Buffer) => OutputPointInfo.decode(value),
    responseSerialize: (value: IncrementalMerkleVoucherInfo) =>
      Buffer.from(IncrementalMerkleVoucherInfo.encode(value).finish()),
    responseDeserialize: (value: Buffer) => IncrementalMerkleVoucherInfo.decode(value),
  },
  scanNoteByIvk: {
    path: "/protocol.WalletSolidity/ScanNoteByIvk",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: IvkDecryptParameters) => Buffer.from(IvkDecryptParameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => IvkDecryptParameters.decode(value),
    responseSerialize: (value: DecryptNotes) => Buffer.from(DecryptNotes.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DecryptNotes.decode(value),
  },
  scanAndMarkNoteByIvk: {
    path: "/protocol.WalletSolidity/ScanAndMarkNoteByIvk",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: IvkDecryptAndMarkParameters) =>
      Buffer.from(IvkDecryptAndMarkParameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => IvkDecryptAndMarkParameters.decode(value),
    responseSerialize: (value: DecryptNotesMarked) => Buffer.from(DecryptNotesMarked.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DecryptNotesMarked.decode(value),
  },
  scanNoteByOvk: {
    path: "/protocol.WalletSolidity/ScanNoteByOvk",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OvkDecryptParameters) => Buffer.from(OvkDecryptParameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => OvkDecryptParameters.decode(value),
    responseSerialize: (value: DecryptNotes) => Buffer.from(DecryptNotes.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DecryptNotes.decode(value),
  },
  isSpend: {
    path: "/protocol.WalletSolidity/IsSpend",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NoteParameters) => Buffer.from(NoteParameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NoteParameters.decode(value),
    responseSerialize: (value: SpendResult) => Buffer.from(SpendResult.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SpendResult.decode(value),
  },
  scanShieldedTrc20NotesByIvk: {
    path: "/protocol.WalletSolidity/ScanShieldedTRC20NotesByIvk",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: IvkDecryptTRC20Parameters) =>
      Buffer.from(IvkDecryptTRC20Parameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => IvkDecryptTRC20Parameters.decode(value),
    responseSerialize: (value: DecryptNotesTRC20) => Buffer.from(DecryptNotesTRC20.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DecryptNotesTRC20.decode(value),
  },
  scanShieldedTrc20NotesByOvk: {
    path: "/protocol.WalletSolidity/ScanShieldedTRC20NotesByOvk",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OvkDecryptTRC20Parameters) =>
      Buffer.from(OvkDecryptTRC20Parameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => OvkDecryptTRC20Parameters.decode(value),
    responseSerialize: (value: DecryptNotesTRC20) => Buffer.from(DecryptNotesTRC20.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DecryptNotesTRC20.decode(value),
  },
  isShieldedTrc20ContractNoteSpent: {
    path: "/protocol.WalletSolidity/IsShieldedTRC20ContractNoteSpent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NfTRC20Parameters) => Buffer.from(NfTRC20Parameters.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NfTRC20Parameters.decode(value),
    responseSerialize: (value: NullifierResult) => Buffer.from(NullifierResult.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NullifierResult.decode(value),
  },
  getRewardInfo: {
    path: "/protocol.WalletSolidity/GetRewardInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NumberMessage.decode(value),
  },
  getBrokerageInfo: {
    path: "/protocol.WalletSolidity/GetBrokerageInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NumberMessage.decode(value),
  },
  triggerConstantContract: {
    path: "/protocol.WalletSolidity/TriggerConstantContract",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TriggerSmartContract) => Buffer.from(TriggerSmartContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TriggerSmartContract.decode(value),
    responseSerialize: (value: TransactionExtention) => Buffer.from(TransactionExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionExtention.decode(value),
  },
  estimateEnergy: {
    path: "/protocol.WalletSolidity/EstimateEnergy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TriggerSmartContract) => Buffer.from(TriggerSmartContract.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TriggerSmartContract.decode(value),
    responseSerialize: (value: EstimateEnergyMessage) => Buffer.from(EstimateEnergyMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => EstimateEnergyMessage.decode(value),
  },
  getTransactionInfoByBlockNum: {
    path: "/protocol.WalletSolidity/GetTransactionInfoByBlockNum",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NumberMessage.decode(value),
    responseSerialize: (value: TransactionInfoList) => Buffer.from(TransactionInfoList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionInfoList.decode(value),
  },
  getMarketOrderById: {
    path: "/protocol.WalletSolidity/GetMarketOrderById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: MarketOrder) => Buffer.from(MarketOrder.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MarketOrder.decode(value),
  },
  getMarketOrderByAccount: {
    path: "/protocol.WalletSolidity/GetMarketOrderByAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BytesMessage) => Buffer.from(BytesMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BytesMessage.decode(value),
    responseSerialize: (value: MarketOrderList) => Buffer.from(MarketOrderList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MarketOrderList.decode(value),
  },
  getMarketPriceByPair: {
    path: "/protocol.WalletSolidity/GetMarketPriceByPair",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarketOrderPair) => Buffer.from(MarketOrderPair.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MarketOrderPair.decode(value),
    responseSerialize: (value: MarketPriceList) => Buffer.from(MarketPriceList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MarketPriceList.decode(value),
  },
  getMarketOrderListByPair: {
    path: "/protocol.WalletSolidity/GetMarketOrderListByPair",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarketOrderPair) => Buffer.from(MarketOrderPair.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MarketOrderPair.decode(value),
    responseSerialize: (value: MarketOrderList) => Buffer.from(MarketOrderList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MarketOrderList.decode(value),
  },
  getMarketPairList: {
    path: "/protocol.WalletSolidity/GetMarketPairList",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: MarketOrderPairList) => Buffer.from(MarketOrderPairList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MarketOrderPairList.decode(value),
  },
  getBurnTrx: {
    path: "/protocol.WalletSolidity/GetBurnTrx",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NumberMessage.decode(value),
  },
  getBlock: {
    path: "/protocol.WalletSolidity/GetBlock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BlockReq) => Buffer.from(BlockReq.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BlockReq.decode(value),
    responseSerialize: (value: BlockExtention) => Buffer.from(BlockExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockExtention.decode(value),
  },
  getBandwidthPrices: {
    path: "/protocol.WalletSolidity/GetBandwidthPrices",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: PricesResponseMessage) => Buffer.from(PricesResponseMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PricesResponseMessage.decode(value),
  },
  getEnergyPrices: {
    path: "/protocol.WalletSolidity/GetEnergyPrices",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: PricesResponseMessage) => Buffer.from(PricesResponseMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PricesResponseMessage.decode(value),
  },
} as const;

export interface WalletSolidityServer extends UntypedServiceImplementation {
  getAccount: handleUnaryCall<Account, Account>;
  getAccountById: handleUnaryCall<Account, Account>;
  listWitnesses: handleUnaryCall<EmptyMessage, WitnessList>;
  getAssetIssueList: handleUnaryCall<EmptyMessage, AssetIssueList>;
  getPaginatedAssetIssueList: handleUnaryCall<PaginatedMessage, AssetIssueList>;
  getAssetIssueByName: handleUnaryCall<BytesMessage, AssetIssueContract>;
  getAssetIssueListByName: handleUnaryCall<BytesMessage, AssetIssueList>;
  getAssetIssueById: handleUnaryCall<BytesMessage, AssetIssueContract>;
  /** Please use GetNowBlock2 instead of this function. */
  getNowBlock: handleUnaryCall<EmptyMessage, Block>;
  /** Use this function instead of GetNowBlock. */
  getNowBlock2: handleUnaryCall<EmptyMessage, BlockExtention>;
  /** Please use GetBlockByNum2 instead of this function. */
  getBlockByNum: handleUnaryCall<NumberMessage, Block>;
  /** Use this function instead of GetBlockByNum. */
  getBlockByNum2: handleUnaryCall<NumberMessage, BlockExtention>;
  getTransactionCountByBlockNum: handleUnaryCall<NumberMessage, NumberMessage>;
  getDelegatedResource: handleUnaryCall<DelegatedResourceMessage, DelegatedResourceList>;
  getDelegatedResourceV2: handleUnaryCall<DelegatedResourceMessage, DelegatedResourceList>;
  getDelegatedResourceAccountIndex: handleUnaryCall<BytesMessage, DelegatedResourceAccountIndex>;
  getDelegatedResourceAccountIndexV2: handleUnaryCall<BytesMessage, DelegatedResourceAccountIndex>;
  getCanDelegatedMaxSize: handleUnaryCall<CanDelegatedMaxSizeRequestMessage, CanDelegatedMaxSizeResponseMessage>;
  getAvailableUnfreezeCount: handleUnaryCall<
    GetAvailableUnfreezeCountRequestMessage,
    GetAvailableUnfreezeCountResponseMessage
  >;
  getCanWithdrawUnfreezeAmount: handleUnaryCall<
    CanWithdrawUnfreezeAmountRequestMessage,
    CanWithdrawUnfreezeAmountResponseMessage
  >;
  getExchangeById: handleUnaryCall<BytesMessage, Exchange>;
  listExchanges: handleUnaryCall<EmptyMessage, ExchangeList>;
  getTransactionById: handleUnaryCall<BytesMessage, Transaction>;
  getTransactionInfoById: handleUnaryCall<BytesMessage, TransactionInfo>;
  getMerkleTreeVoucherInfo: handleUnaryCall<OutputPointInfo, IncrementalMerkleVoucherInfo>;
  scanNoteByIvk: handleUnaryCall<IvkDecryptParameters, DecryptNotes>;
  scanAndMarkNoteByIvk: handleUnaryCall<IvkDecryptAndMarkParameters, DecryptNotesMarked>;
  scanNoteByOvk: handleUnaryCall<OvkDecryptParameters, DecryptNotes>;
  isSpend: handleUnaryCall<NoteParameters, SpendResult>;
  scanShieldedTrc20NotesByIvk: handleUnaryCall<IvkDecryptTRC20Parameters, DecryptNotesTRC20>;
  scanShieldedTrc20NotesByOvk: handleUnaryCall<OvkDecryptTRC20Parameters, DecryptNotesTRC20>;
  isShieldedTrc20ContractNoteSpent: handleUnaryCall<NfTRC20Parameters, NullifierResult>;
  getRewardInfo: handleUnaryCall<BytesMessage, NumberMessage>;
  getBrokerageInfo: handleUnaryCall<BytesMessage, NumberMessage>;
  triggerConstantContract: handleUnaryCall<TriggerSmartContract, TransactionExtention>;
  estimateEnergy: handleUnaryCall<TriggerSmartContract, EstimateEnergyMessage>;
  getTransactionInfoByBlockNum: handleUnaryCall<NumberMessage, TransactionInfoList>;
  getMarketOrderById: handleUnaryCall<BytesMessage, MarketOrder>;
  getMarketOrderByAccount: handleUnaryCall<BytesMessage, MarketOrderList>;
  getMarketPriceByPair: handleUnaryCall<MarketOrderPair, MarketPriceList>;
  getMarketOrderListByPair: handleUnaryCall<MarketOrderPair, MarketOrderList>;
  getMarketPairList: handleUnaryCall<EmptyMessage, MarketOrderPairList>;
  getBurnTrx: handleUnaryCall<EmptyMessage, NumberMessage>;
  getBlock: handleUnaryCall<BlockReq, BlockExtention>;
  getBandwidthPrices: handleUnaryCall<EmptyMessage, PricesResponseMessage>;
  getEnergyPrices: handleUnaryCall<EmptyMessage, PricesResponseMessage>;
}

export interface WalletSolidityClient extends Client {
  getAccount(request: Account, callback: (error: ServiceError | null, response: Account) => void): ClientUnaryCall;
  getAccount(
    request: Account,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  getAccount(
    request: Account,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  getAccountById(request: Account, callback: (error: ServiceError | null, response: Account) => void): ClientUnaryCall;
  getAccountById(
    request: Account,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  getAccountById(
    request: Account,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  listWitnesses(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: WitnessList) => void,
  ): ClientUnaryCall;
  listWitnesses(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WitnessList) => void,
  ): ClientUnaryCall;
  listWitnesses(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WitnessList) => void,
  ): ClientUnaryCall;
  getAssetIssueList(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getAssetIssueList(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getAssetIssueList(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getPaginatedAssetIssueList(
    request: PaginatedMessage,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getPaginatedAssetIssueList(
    request: PaginatedMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getPaginatedAssetIssueList(
    request: PaginatedMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getAssetIssueByName(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: AssetIssueContract) => void,
  ): ClientUnaryCall;
  getAssetIssueByName(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AssetIssueContract) => void,
  ): ClientUnaryCall;
  getAssetIssueByName(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AssetIssueContract) => void,
  ): ClientUnaryCall;
  getAssetIssueListByName(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getAssetIssueListByName(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getAssetIssueListByName(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AssetIssueList) => void,
  ): ClientUnaryCall;
  getAssetIssueById(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: AssetIssueContract) => void,
  ): ClientUnaryCall;
  getAssetIssueById(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AssetIssueContract) => void,
  ): ClientUnaryCall;
  getAssetIssueById(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AssetIssueContract) => void,
  ): ClientUnaryCall;
  /** Please use GetNowBlock2 instead of this function. */
  getNowBlock(request: EmptyMessage, callback: (error: ServiceError | null, response: Block) => void): ClientUnaryCall;
  getNowBlock(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  getNowBlock(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  /** Use this function instead of GetNowBlock. */
  getNowBlock2(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getNowBlock2(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getNowBlock2(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  /** Please use GetBlockByNum2 instead of this function. */
  getBlockByNum(
    request: NumberMessage,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  getBlockByNum(
    request: NumberMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  getBlockByNum(
    request: NumberMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  /** Use this function instead of GetBlockByNum. */
  getBlockByNum2(
    request: NumberMessage,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getBlockByNum2(
    request: NumberMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getBlockByNum2(
    request: NumberMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getTransactionCountByBlockNum(
    request: NumberMessage,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getTransactionCountByBlockNum(
    request: NumberMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getTransactionCountByBlockNum(
    request: NumberMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getDelegatedResource(
    request: DelegatedResourceMessage,
    callback: (error: ServiceError | null, response: DelegatedResourceList) => void,
  ): ClientUnaryCall;
  getDelegatedResource(
    request: DelegatedResourceMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DelegatedResourceList) => void,
  ): ClientUnaryCall;
  getDelegatedResource(
    request: DelegatedResourceMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DelegatedResourceList) => void,
  ): ClientUnaryCall;
  getDelegatedResourceV2(
    request: DelegatedResourceMessage,
    callback: (error: ServiceError | null, response: DelegatedResourceList) => void,
  ): ClientUnaryCall;
  getDelegatedResourceV2(
    request: DelegatedResourceMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DelegatedResourceList) => void,
  ): ClientUnaryCall;
  getDelegatedResourceV2(
    request: DelegatedResourceMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DelegatedResourceList) => void,
  ): ClientUnaryCall;
  getDelegatedResourceAccountIndex(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: DelegatedResourceAccountIndex) => void,
  ): ClientUnaryCall;
  getDelegatedResourceAccountIndex(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DelegatedResourceAccountIndex) => void,
  ): ClientUnaryCall;
  getDelegatedResourceAccountIndex(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DelegatedResourceAccountIndex) => void,
  ): ClientUnaryCall;
  getDelegatedResourceAccountIndexV2(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: DelegatedResourceAccountIndex) => void,
  ): ClientUnaryCall;
  getDelegatedResourceAccountIndexV2(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DelegatedResourceAccountIndex) => void,
  ): ClientUnaryCall;
  getDelegatedResourceAccountIndexV2(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DelegatedResourceAccountIndex) => void,
  ): ClientUnaryCall;
  getCanDelegatedMaxSize(
    request: CanDelegatedMaxSizeRequestMessage,
    callback: (error: ServiceError | null, response: CanDelegatedMaxSizeResponseMessage) => void,
  ): ClientUnaryCall;
  getCanDelegatedMaxSize(
    request: CanDelegatedMaxSizeRequestMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CanDelegatedMaxSizeResponseMessage) => void,
  ): ClientUnaryCall;
  getCanDelegatedMaxSize(
    request: CanDelegatedMaxSizeRequestMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CanDelegatedMaxSizeResponseMessage) => void,
  ): ClientUnaryCall;
  getAvailableUnfreezeCount(
    request: GetAvailableUnfreezeCountRequestMessage,
    callback: (error: ServiceError | null, response: GetAvailableUnfreezeCountResponseMessage) => void,
  ): ClientUnaryCall;
  getAvailableUnfreezeCount(
    request: GetAvailableUnfreezeCountRequestMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAvailableUnfreezeCountResponseMessage) => void,
  ): ClientUnaryCall;
  getAvailableUnfreezeCount(
    request: GetAvailableUnfreezeCountRequestMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAvailableUnfreezeCountResponseMessage) => void,
  ): ClientUnaryCall;
  getCanWithdrawUnfreezeAmount(
    request: CanWithdrawUnfreezeAmountRequestMessage,
    callback: (error: ServiceError | null, response: CanWithdrawUnfreezeAmountResponseMessage) => void,
  ): ClientUnaryCall;
  getCanWithdrawUnfreezeAmount(
    request: CanWithdrawUnfreezeAmountRequestMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CanWithdrawUnfreezeAmountResponseMessage) => void,
  ): ClientUnaryCall;
  getCanWithdrawUnfreezeAmount(
    request: CanWithdrawUnfreezeAmountRequestMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CanWithdrawUnfreezeAmountResponseMessage) => void,
  ): ClientUnaryCall;
  getExchangeById(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: Exchange) => void,
  ): ClientUnaryCall;
  getExchangeById(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Exchange) => void,
  ): ClientUnaryCall;
  getExchangeById(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Exchange) => void,
  ): ClientUnaryCall;
  listExchanges(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: ExchangeList) => void,
  ): ClientUnaryCall;
  listExchanges(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ExchangeList) => void,
  ): ClientUnaryCall;
  listExchanges(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ExchangeList) => void,
  ): ClientUnaryCall;
  getTransactionById(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  getTransactionById(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  getTransactionById(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Transaction) => void,
  ): ClientUnaryCall;
  getTransactionInfoById(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: TransactionInfo) => void,
  ): ClientUnaryCall;
  getTransactionInfoById(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionInfo) => void,
  ): ClientUnaryCall;
  getTransactionInfoById(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionInfo) => void,
  ): ClientUnaryCall;
  getMerkleTreeVoucherInfo(
    request: OutputPointInfo,
    callback: (error: ServiceError | null, response: IncrementalMerkleVoucherInfo) => void,
  ): ClientUnaryCall;
  getMerkleTreeVoucherInfo(
    request: OutputPointInfo,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: IncrementalMerkleVoucherInfo) => void,
  ): ClientUnaryCall;
  getMerkleTreeVoucherInfo(
    request: OutputPointInfo,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: IncrementalMerkleVoucherInfo) => void,
  ): ClientUnaryCall;
  scanNoteByIvk(
    request: IvkDecryptParameters,
    callback: (error: ServiceError | null, response: DecryptNotes) => void,
  ): ClientUnaryCall;
  scanNoteByIvk(
    request: IvkDecryptParameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DecryptNotes) => void,
  ): ClientUnaryCall;
  scanNoteByIvk(
    request: IvkDecryptParameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DecryptNotes) => void,
  ): ClientUnaryCall;
  scanAndMarkNoteByIvk(
    request: IvkDecryptAndMarkParameters,
    callback: (error: ServiceError | null, response: DecryptNotesMarked) => void,
  ): ClientUnaryCall;
  scanAndMarkNoteByIvk(
    request: IvkDecryptAndMarkParameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DecryptNotesMarked) => void,
  ): ClientUnaryCall;
  scanAndMarkNoteByIvk(
    request: IvkDecryptAndMarkParameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DecryptNotesMarked) => void,
  ): ClientUnaryCall;
  scanNoteByOvk(
    request: OvkDecryptParameters,
    callback: (error: ServiceError | null, response: DecryptNotes) => void,
  ): ClientUnaryCall;
  scanNoteByOvk(
    request: OvkDecryptParameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DecryptNotes) => void,
  ): ClientUnaryCall;
  scanNoteByOvk(
    request: OvkDecryptParameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DecryptNotes) => void,
  ): ClientUnaryCall;
  isSpend(
    request: NoteParameters,
    callback: (error: ServiceError | null, response: SpendResult) => void,
  ): ClientUnaryCall;
  isSpend(
    request: NoteParameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SpendResult) => void,
  ): ClientUnaryCall;
  isSpend(
    request: NoteParameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SpendResult) => void,
  ): ClientUnaryCall;
  scanShieldedTrc20NotesByIvk(
    request: IvkDecryptTRC20Parameters,
    callback: (error: ServiceError | null, response: DecryptNotesTRC20) => void,
  ): ClientUnaryCall;
  scanShieldedTrc20NotesByIvk(
    request: IvkDecryptTRC20Parameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DecryptNotesTRC20) => void,
  ): ClientUnaryCall;
  scanShieldedTrc20NotesByIvk(
    request: IvkDecryptTRC20Parameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DecryptNotesTRC20) => void,
  ): ClientUnaryCall;
  scanShieldedTrc20NotesByOvk(
    request: OvkDecryptTRC20Parameters,
    callback: (error: ServiceError | null, response: DecryptNotesTRC20) => void,
  ): ClientUnaryCall;
  scanShieldedTrc20NotesByOvk(
    request: OvkDecryptTRC20Parameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DecryptNotesTRC20) => void,
  ): ClientUnaryCall;
  scanShieldedTrc20NotesByOvk(
    request: OvkDecryptTRC20Parameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DecryptNotesTRC20) => void,
  ): ClientUnaryCall;
  isShieldedTrc20ContractNoteSpent(
    request: NfTRC20Parameters,
    callback: (error: ServiceError | null, response: NullifierResult) => void,
  ): ClientUnaryCall;
  isShieldedTrc20ContractNoteSpent(
    request: NfTRC20Parameters,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NullifierResult) => void,
  ): ClientUnaryCall;
  isShieldedTrc20ContractNoteSpent(
    request: NfTRC20Parameters,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NullifierResult) => void,
  ): ClientUnaryCall;
  getRewardInfo(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getRewardInfo(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getRewardInfo(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getBrokerageInfo(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getBrokerageInfo(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getBrokerageInfo(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  triggerConstantContract(
    request: TriggerSmartContract,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  triggerConstantContract(
    request: TriggerSmartContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  triggerConstantContract(
    request: TriggerSmartContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionExtention) => void,
  ): ClientUnaryCall;
  estimateEnergy(
    request: TriggerSmartContract,
    callback: (error: ServiceError | null, response: EstimateEnergyMessage) => void,
  ): ClientUnaryCall;
  estimateEnergy(
    request: TriggerSmartContract,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EstimateEnergyMessage) => void,
  ): ClientUnaryCall;
  estimateEnergy(
    request: TriggerSmartContract,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EstimateEnergyMessage) => void,
  ): ClientUnaryCall;
  getTransactionInfoByBlockNum(
    request: NumberMessage,
    callback: (error: ServiceError | null, response: TransactionInfoList) => void,
  ): ClientUnaryCall;
  getTransactionInfoByBlockNum(
    request: NumberMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionInfoList) => void,
  ): ClientUnaryCall;
  getTransactionInfoByBlockNum(
    request: NumberMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionInfoList) => void,
  ): ClientUnaryCall;
  getMarketOrderById(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: MarketOrder) => void,
  ): ClientUnaryCall;
  getMarketOrderById(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MarketOrder) => void,
  ): ClientUnaryCall;
  getMarketOrderById(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MarketOrder) => void,
  ): ClientUnaryCall;
  getMarketOrderByAccount(
    request: BytesMessage,
    callback: (error: ServiceError | null, response: MarketOrderList) => void,
  ): ClientUnaryCall;
  getMarketOrderByAccount(
    request: BytesMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MarketOrderList) => void,
  ): ClientUnaryCall;
  getMarketOrderByAccount(
    request: BytesMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MarketOrderList) => void,
  ): ClientUnaryCall;
  getMarketPriceByPair(
    request: MarketOrderPair,
    callback: (error: ServiceError | null, response: MarketPriceList) => void,
  ): ClientUnaryCall;
  getMarketPriceByPair(
    request: MarketOrderPair,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MarketPriceList) => void,
  ): ClientUnaryCall;
  getMarketPriceByPair(
    request: MarketOrderPair,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MarketPriceList) => void,
  ): ClientUnaryCall;
  getMarketOrderListByPair(
    request: MarketOrderPair,
    callback: (error: ServiceError | null, response: MarketOrderList) => void,
  ): ClientUnaryCall;
  getMarketOrderListByPair(
    request: MarketOrderPair,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MarketOrderList) => void,
  ): ClientUnaryCall;
  getMarketOrderListByPair(
    request: MarketOrderPair,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MarketOrderList) => void,
  ): ClientUnaryCall;
  getMarketPairList(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: MarketOrderPairList) => void,
  ): ClientUnaryCall;
  getMarketPairList(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MarketOrderPairList) => void,
  ): ClientUnaryCall;
  getMarketPairList(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MarketOrderPairList) => void,
  ): ClientUnaryCall;
  getBurnTrx(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getBurnTrx(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getBurnTrx(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NumberMessage) => void,
  ): ClientUnaryCall;
  getBlock(
    request: BlockReq,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getBlock(
    request: BlockReq,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getBlock(
    request: BlockReq,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockExtention) => void,
  ): ClientUnaryCall;
  getBandwidthPrices(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: PricesResponseMessage) => void,
  ): ClientUnaryCall;
  getBandwidthPrices(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PricesResponseMessage) => void,
  ): ClientUnaryCall;
  getBandwidthPrices(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PricesResponseMessage) => void,
  ): ClientUnaryCall;
  getEnergyPrices(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: PricesResponseMessage) => void,
  ): ClientUnaryCall;
  getEnergyPrices(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PricesResponseMessage) => void,
  ): ClientUnaryCall;
  getEnergyPrices(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PricesResponseMessage) => void,
  ): ClientUnaryCall;
}

export const WalletSolidityClient = makeGenericClientConstructor(
  WalletSolidityService,
  "protocol.WalletSolidity",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): WalletSolidityClient;
  service: typeof WalletSolidityService;
  serviceName: string;
};

export type WalletExtensionService = typeof WalletExtensionService;
export const WalletExtensionService = {
  /** Please use GetTransactionsFromThis2 instead of this function. */
  getTransactionsFromThis: {
    path: "/protocol.WalletExtension/GetTransactionsFromThis",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountPaginated) => Buffer.from(AccountPaginated.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountPaginated.decode(value),
    responseSerialize: (value: TransactionList) => Buffer.from(TransactionList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionList.decode(value),
  },
  /** Use this function instead of GetTransactionsFromThis. */
  getTransactionsFromThis2: {
    path: "/protocol.WalletExtension/GetTransactionsFromThis2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountPaginated) => Buffer.from(AccountPaginated.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountPaginated.decode(value),
    responseSerialize: (value: TransactionListExtention) =>
      Buffer.from(TransactionListExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionListExtention.decode(value),
  },
  /** Please use GetTransactionsToThis2 instead of this function. */
  getTransactionsToThis: {
    path: "/protocol.WalletExtension/GetTransactionsToThis",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountPaginated) => Buffer.from(AccountPaginated.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountPaginated.decode(value),
    responseSerialize: (value: TransactionList) => Buffer.from(TransactionList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionList.decode(value),
  },
  /** Use this function instead of GetTransactionsToThis. */
  getTransactionsToThis2: {
    path: "/protocol.WalletExtension/GetTransactionsToThis2",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AccountPaginated) => Buffer.from(AccountPaginated.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AccountPaginated.decode(value),
    responseSerialize: (value: TransactionListExtention) =>
      Buffer.from(TransactionListExtention.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TransactionListExtention.decode(value),
  },
} as const;

export interface WalletExtensionServer extends UntypedServiceImplementation {
  /** Please use GetTransactionsFromThis2 instead of this function. */
  getTransactionsFromThis: handleUnaryCall<AccountPaginated, TransactionList>;
  /** Use this function instead of GetTransactionsFromThis. */
  getTransactionsFromThis2: handleUnaryCall<AccountPaginated, TransactionListExtention>;
  /** Please use GetTransactionsToThis2 instead of this function. */
  getTransactionsToThis: handleUnaryCall<AccountPaginated, TransactionList>;
  /** Use this function instead of GetTransactionsToThis. */
  getTransactionsToThis2: handleUnaryCall<AccountPaginated, TransactionListExtention>;
}

export interface WalletExtensionClient extends Client {
  /** Please use GetTransactionsFromThis2 instead of this function. */
  getTransactionsFromThis(
    request: AccountPaginated,
    callback: (error: ServiceError | null, response: TransactionList) => void,
  ): ClientUnaryCall;
  getTransactionsFromThis(
    request: AccountPaginated,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionList) => void,
  ): ClientUnaryCall;
  getTransactionsFromThis(
    request: AccountPaginated,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionList) => void,
  ): ClientUnaryCall;
  /** Use this function instead of GetTransactionsFromThis. */
  getTransactionsFromThis2(
    request: AccountPaginated,
    callback: (error: ServiceError | null, response: TransactionListExtention) => void,
  ): ClientUnaryCall;
  getTransactionsFromThis2(
    request: AccountPaginated,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionListExtention) => void,
  ): ClientUnaryCall;
  getTransactionsFromThis2(
    request: AccountPaginated,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionListExtention) => void,
  ): ClientUnaryCall;
  /** Please use GetTransactionsToThis2 instead of this function. */
  getTransactionsToThis(
    request: AccountPaginated,
    callback: (error: ServiceError | null, response: TransactionList) => void,
  ): ClientUnaryCall;
  getTransactionsToThis(
    request: AccountPaginated,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionList) => void,
  ): ClientUnaryCall;
  getTransactionsToThis(
    request: AccountPaginated,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionList) => void,
  ): ClientUnaryCall;
  /** Use this function instead of GetTransactionsToThis. */
  getTransactionsToThis2(
    request: AccountPaginated,
    callback: (error: ServiceError | null, response: TransactionListExtention) => void,
  ): ClientUnaryCall;
  getTransactionsToThis2(
    request: AccountPaginated,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TransactionListExtention) => void,
  ): ClientUnaryCall;
  getTransactionsToThis2(
    request: AccountPaginated,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TransactionListExtention) => void,
  ): ClientUnaryCall;
}

export const WalletExtensionClient = makeGenericClientConstructor(
  WalletExtensionService,
  "protocol.WalletExtension",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): WalletExtensionClient;
  service: typeof WalletExtensionService;
  serviceName: string;
};

/** the api of tron's db */
export type DatabaseService = typeof DatabaseService;
export const DatabaseService = {
  /** for tapos */
  getBlockReference: {
    path: "/protocol.Database/getBlockReference",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: BlockReference) => Buffer.from(BlockReference.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockReference.decode(value),
  },
  getDynamicProperties: {
    path: "/protocol.Database/GetDynamicProperties",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: DynamicProperties) => Buffer.from(DynamicProperties.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DynamicProperties.decode(value),
  },
  getNowBlock: {
    path: "/protocol.Database/GetNowBlock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: Block) => Buffer.from(Block.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Block.decode(value),
  },
  getBlockByNum: {
    path: "/protocol.Database/GetBlockByNum",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NumberMessage) => Buffer.from(NumberMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => NumberMessage.decode(value),
    responseSerialize: (value: Block) => Buffer.from(Block.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Block.decode(value),
  },
} as const;

export interface DatabaseServer extends UntypedServiceImplementation {
  /** for tapos */
  getBlockReference: handleUnaryCall<EmptyMessage, BlockReference>;
  getDynamicProperties: handleUnaryCall<EmptyMessage, DynamicProperties>;
  getNowBlock: handleUnaryCall<EmptyMessage, Block>;
  getBlockByNum: handleUnaryCall<NumberMessage, Block>;
}

export interface DatabaseClient extends Client {
  /** for tapos */
  getBlockReference(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: BlockReference) => void,
  ): ClientUnaryCall;
  getBlockReference(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockReference) => void,
  ): ClientUnaryCall;
  getBlockReference(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockReference) => void,
  ): ClientUnaryCall;
  getDynamicProperties(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: DynamicProperties) => void,
  ): ClientUnaryCall;
  getDynamicProperties(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DynamicProperties) => void,
  ): ClientUnaryCall;
  getDynamicProperties(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DynamicProperties) => void,
  ): ClientUnaryCall;
  getNowBlock(request: EmptyMessage, callback: (error: ServiceError | null, response: Block) => void): ClientUnaryCall;
  getNowBlock(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  getNowBlock(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  getBlockByNum(
    request: NumberMessage,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  getBlockByNum(
    request: NumberMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
  getBlockByNum(
    request: NumberMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Block) => void,
  ): ClientUnaryCall;
}

export const DatabaseClient = makeGenericClientConstructor(DatabaseService, "protocol.Database") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): DatabaseClient;
  service: typeof DatabaseService;
  serviceName: string;
};

export type MonitorService = typeof MonitorService;
export const MonitorService = {
  getStatsInfo: {
    path: "/protocol.Monitor/GetStatsInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyMessage) => Buffer.from(EmptyMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EmptyMessage.decode(value),
    responseSerialize: (value: MetricsInfo) => Buffer.from(MetricsInfo.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MetricsInfo.decode(value),
  },
} as const;

export interface MonitorServer extends UntypedServiceImplementation {
  getStatsInfo: handleUnaryCall<EmptyMessage, MetricsInfo>;
}

export interface MonitorClient extends Client {
  getStatsInfo(
    request: EmptyMessage,
    callback: (error: ServiceError | null, response: MetricsInfo) => void,
  ): ClientUnaryCall;
  getStatsInfo(
    request: EmptyMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MetricsInfo) => void,
  ): ClientUnaryCall;
  getStatsInfo(
    request: EmptyMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MetricsInfo) => void,
  ): ClientUnaryCall;
}

export const MonitorClient = makeGenericClientConstructor(MonitorService, "protocol.Monitor") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): MonitorClient;
  service: typeof MonitorService;
  serviceName: string;
};

/** the api of tron's network such as node list. */
export type NetworkService = typeof NetworkService;
export const NetworkService = {} as const;

export interface NetworkServer extends UntypedServiceImplementation {
}

export interface NetworkClient extends Client {
}

export const NetworkClient = makeGenericClientConstructor(NetworkService, "protocol.Network") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): NetworkClient;
  service: typeof NetworkService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
