// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: core/contract/asset_issue_contract.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";

export const protobufPackage = "protocol";

export interface AssetIssueContract {
  id: string;
  ownerAddress: Buffer;
  name: Buffer;
  abbr: Buffer;
  totalSupply: Long;
  frozenSupply: AssetIssueContract_FrozenSupply[];
  trxNum: number;
  precision: number;
  num: number;
  startTime: Long;
  endTime: Long;
  /** useless */
  order: Long;
  voteScore: number;
  description: Buffer;
  url: Buffer;
  freeAssetNetLimit: Long;
  publicFreeAssetNetLimit: Long;
  publicFreeAssetNetUsage: Long;
  publicLatestFreeNetTime: Long;
}

export interface AssetIssueContract_FrozenSupply {
  frozenAmount: Long;
  frozenDays: Long;
}

export interface TransferAssetContract {
  /** this field is token name before the proposal ALLOW_SAME_TOKEN_NAME is active, otherwise it is token id and token is should be in string format. */
  assetName: Buffer;
  ownerAddress: Buffer;
  toAddress: Buffer;
  amount: Long;
}

export interface UnfreezeAssetContract {
  ownerAddress: Buffer;
}

export interface UpdateAssetContract {
  ownerAddress: Buffer;
  description: Buffer;
  url: Buffer;
  newLimit: Long;
  newPublicLimit: Long;
}

export interface ParticipateAssetIssueContract {
  ownerAddress: Buffer;
  toAddress: Buffer;
  /** this field is token name before the proposal ALLOW_SAME_TOKEN_NAME is active, otherwise it is token id and token is should be in string format. */
  assetName: Buffer;
  /** the amount of drops */
  amount: Long;
}

function createBaseAssetIssueContract(): AssetIssueContract {
  return {
    id: "",
    ownerAddress: Buffer.alloc(0),
    name: Buffer.alloc(0),
    abbr: Buffer.alloc(0),
    totalSupply: Long.ZERO,
    frozenSupply: [],
    trxNum: 0,
    precision: 0,
    num: 0,
    startTime: Long.ZERO,
    endTime: Long.ZERO,
    order: Long.ZERO,
    voteScore: 0,
    description: Buffer.alloc(0),
    url: Buffer.alloc(0),
    freeAssetNetLimit: Long.ZERO,
    publicFreeAssetNetLimit: Long.ZERO,
    publicFreeAssetNetUsage: Long.ZERO,
    publicLatestFreeNetTime: Long.ZERO,
  };
}

export const AssetIssueContract = {
  encode(message: AssetIssueContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(330).string(message.id);
    }
    if (message.ownerAddress.length !== 0) {
      writer.uint32(10).bytes(message.ownerAddress);
    }
    if (message.name.length !== 0) {
      writer.uint32(18).bytes(message.name);
    }
    if (message.abbr.length !== 0) {
      writer.uint32(26).bytes(message.abbr);
    }
    if (!message.totalSupply.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.totalSupply);
    }
    for (const v of message.frozenSupply) {
      AssetIssueContract_FrozenSupply.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.trxNum !== 0) {
      writer.uint32(48).int32(message.trxNum);
    }
    if (message.precision !== 0) {
      writer.uint32(56).int32(message.precision);
    }
    if (message.num !== 0) {
      writer.uint32(64).int32(message.num);
    }
    if (!message.startTime.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.startTime);
    }
    if (!message.endTime.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.endTime);
    }
    if (!message.order.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.order);
    }
    if (message.voteScore !== 0) {
      writer.uint32(128).int32(message.voteScore);
    }
    if (message.description.length !== 0) {
      writer.uint32(162).bytes(message.description);
    }
    if (message.url.length !== 0) {
      writer.uint32(170).bytes(message.url);
    }
    if (!message.freeAssetNetLimit.equals(Long.ZERO)) {
      writer.uint32(176).int64(message.freeAssetNetLimit);
    }
    if (!message.publicFreeAssetNetLimit.equals(Long.ZERO)) {
      writer.uint32(184).int64(message.publicFreeAssetNetLimit);
    }
    if (!message.publicFreeAssetNetUsage.equals(Long.ZERO)) {
      writer.uint32(192).int64(message.publicFreeAssetNetUsage);
    }
    if (!message.publicLatestFreeNetTime.equals(Long.ZERO)) {
      writer.uint32(200).int64(message.publicLatestFreeNetTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetIssueContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetIssueContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 41:
          if (tag !== 330) {
            break;
          }

          message.id = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.abbr = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalSupply = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.frozenSupply.push(AssetIssueContract_FrozenSupply.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.trxNum = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.precision = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.num = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.startTime = reader.int64() as Long;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.endTime = reader.int64() as Long;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.order = reader.int64() as Long;
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.voteScore = reader.int32();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.description = reader.bytes() as Buffer;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.url = reader.bytes() as Buffer;
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.freeAssetNetLimit = reader.int64() as Long;
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.publicFreeAssetNetLimit = reader.int64() as Long;
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.publicFreeAssetNetUsage = reader.int64() as Long;
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.publicLatestFreeNetTime = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetIssueContract {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      ownerAddress: isSet(object.ownerAddress) ? Buffer.from(bytesFromBase64(object.ownerAddress)) : Buffer.alloc(0),
      name: isSet(object.name) ? Buffer.from(bytesFromBase64(object.name)) : Buffer.alloc(0),
      abbr: isSet(object.abbr) ? Buffer.from(bytesFromBase64(object.abbr)) : Buffer.alloc(0),
      totalSupply: isSet(object.totalSupply) ? Long.fromValue(object.totalSupply) : Long.ZERO,
      frozenSupply: globalThis.Array.isArray(object?.frozenSupply)
        ? object.frozenSupply.map((e: any) => AssetIssueContract_FrozenSupply.fromJSON(e))
        : [],
      trxNum: isSet(object.trxNum) ? globalThis.Number(object.trxNum) : 0,
      precision: isSet(object.precision) ? globalThis.Number(object.precision) : 0,
      num: isSet(object.num) ? globalThis.Number(object.num) : 0,
      startTime: isSet(object.startTime) ? Long.fromValue(object.startTime) : Long.ZERO,
      endTime: isSet(object.endTime) ? Long.fromValue(object.endTime) : Long.ZERO,
      order: isSet(object.order) ? Long.fromValue(object.order) : Long.ZERO,
      voteScore: isSet(object.voteScore) ? globalThis.Number(object.voteScore) : 0,
      description: isSet(object.description) ? Buffer.from(bytesFromBase64(object.description)) : Buffer.alloc(0),
      url: isSet(object.url) ? Buffer.from(bytesFromBase64(object.url)) : Buffer.alloc(0),
      freeAssetNetLimit: isSet(object.freeAssetNetLimit) ? Long.fromValue(object.freeAssetNetLimit) : Long.ZERO,
      publicFreeAssetNetLimit: isSet(object.publicFreeAssetNetLimit)
        ? Long.fromValue(object.publicFreeAssetNetLimit)
        : Long.ZERO,
      publicFreeAssetNetUsage: isSet(object.publicFreeAssetNetUsage)
        ? Long.fromValue(object.publicFreeAssetNetUsage)
        : Long.ZERO,
      publicLatestFreeNetTime: isSet(object.publicLatestFreeNetTime)
        ? Long.fromValue(object.publicLatestFreeNetTime)
        : Long.ZERO,
    };
  },

  toJSON(message: AssetIssueContract): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.ownerAddress.length !== 0) {
      obj.ownerAddress = base64FromBytes(message.ownerAddress);
    }
    if (message.name.length !== 0) {
      obj.name = base64FromBytes(message.name);
    }
    if (message.abbr.length !== 0) {
      obj.abbr = base64FromBytes(message.abbr);
    }
    if (!message.totalSupply.equals(Long.ZERO)) {
      obj.totalSupply = (message.totalSupply || Long.ZERO).toString();
    }
    if (message.frozenSupply?.length) {
      obj.frozenSupply = message.frozenSupply.map((e) => AssetIssueContract_FrozenSupply.toJSON(e));
    }
    if (message.trxNum !== 0) {
      obj.trxNum = Math.round(message.trxNum);
    }
    if (message.precision !== 0) {
      obj.precision = Math.round(message.precision);
    }
    if (message.num !== 0) {
      obj.num = Math.round(message.num);
    }
    if (!message.startTime.equals(Long.ZERO)) {
      obj.startTime = (message.startTime || Long.ZERO).toString();
    }
    if (!message.endTime.equals(Long.ZERO)) {
      obj.endTime = (message.endTime || Long.ZERO).toString();
    }
    if (!message.order.equals(Long.ZERO)) {
      obj.order = (message.order || Long.ZERO).toString();
    }
    if (message.voteScore !== 0) {
      obj.voteScore = Math.round(message.voteScore);
    }
    if (message.description.length !== 0) {
      obj.description = base64FromBytes(message.description);
    }
    if (message.url.length !== 0) {
      obj.url = base64FromBytes(message.url);
    }
    if (!message.freeAssetNetLimit.equals(Long.ZERO)) {
      obj.freeAssetNetLimit = (message.freeAssetNetLimit || Long.ZERO).toString();
    }
    if (!message.publicFreeAssetNetLimit.equals(Long.ZERO)) {
      obj.publicFreeAssetNetLimit = (message.publicFreeAssetNetLimit || Long.ZERO).toString();
    }
    if (!message.publicFreeAssetNetUsage.equals(Long.ZERO)) {
      obj.publicFreeAssetNetUsage = (message.publicFreeAssetNetUsage || Long.ZERO).toString();
    }
    if (!message.publicLatestFreeNetTime.equals(Long.ZERO)) {
      obj.publicLatestFreeNetTime = (message.publicLatestFreeNetTime || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetIssueContract>, I>>(base?: I): AssetIssueContract {
    return AssetIssueContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetIssueContract>, I>>(object: I): AssetIssueContract {
    const message = createBaseAssetIssueContract();
    message.id = object.id ?? "";
    message.ownerAddress = object.ownerAddress ?? Buffer.alloc(0);
    message.name = object.name ?? Buffer.alloc(0);
    message.abbr = object.abbr ?? Buffer.alloc(0);
    message.totalSupply = (object.totalSupply !== undefined && object.totalSupply !== null)
      ? Long.fromValue(object.totalSupply)
      : Long.ZERO;
    message.frozenSupply = object.frozenSupply?.map((e) => AssetIssueContract_FrozenSupply.fromPartial(e)) || [];
    message.trxNum = object.trxNum ?? 0;
    message.precision = object.precision ?? 0;
    message.num = object.num ?? 0;
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? Long.fromValue(object.startTime)
      : Long.ZERO;
    message.endTime = (object.endTime !== undefined && object.endTime !== null)
      ? Long.fromValue(object.endTime)
      : Long.ZERO;
    message.order = (object.order !== undefined && object.order !== null) ? Long.fromValue(object.order) : Long.ZERO;
    message.voteScore = object.voteScore ?? 0;
    message.description = object.description ?? Buffer.alloc(0);
    message.url = object.url ?? Buffer.alloc(0);
    message.freeAssetNetLimit = (object.freeAssetNetLimit !== undefined && object.freeAssetNetLimit !== null)
      ? Long.fromValue(object.freeAssetNetLimit)
      : Long.ZERO;
    message.publicFreeAssetNetLimit =
      (object.publicFreeAssetNetLimit !== undefined && object.publicFreeAssetNetLimit !== null)
        ? Long.fromValue(object.publicFreeAssetNetLimit)
        : Long.ZERO;
    message.publicFreeAssetNetUsage =
      (object.publicFreeAssetNetUsage !== undefined && object.publicFreeAssetNetUsage !== null)
        ? Long.fromValue(object.publicFreeAssetNetUsage)
        : Long.ZERO;
    message.publicLatestFreeNetTime =
      (object.publicLatestFreeNetTime !== undefined && object.publicLatestFreeNetTime !== null)
        ? Long.fromValue(object.publicLatestFreeNetTime)
        : Long.ZERO;
    return message;
  },
};

function createBaseAssetIssueContract_FrozenSupply(): AssetIssueContract_FrozenSupply {
  return { frozenAmount: Long.ZERO, frozenDays: Long.ZERO };
}

export const AssetIssueContract_FrozenSupply = {
  encode(message: AssetIssueContract_FrozenSupply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.frozenAmount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.frozenAmount);
    }
    if (!message.frozenDays.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.frozenDays);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetIssueContract_FrozenSupply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetIssueContract_FrozenSupply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.frozenAmount = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.frozenDays = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetIssueContract_FrozenSupply {
    return {
      frozenAmount: isSet(object.frozenAmount) ? Long.fromValue(object.frozenAmount) : Long.ZERO,
      frozenDays: isSet(object.frozenDays) ? Long.fromValue(object.frozenDays) : Long.ZERO,
    };
  },

  toJSON(message: AssetIssueContract_FrozenSupply): unknown {
    const obj: any = {};
    if (!message.frozenAmount.equals(Long.ZERO)) {
      obj.frozenAmount = (message.frozenAmount || Long.ZERO).toString();
    }
    if (!message.frozenDays.equals(Long.ZERO)) {
      obj.frozenDays = (message.frozenDays || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetIssueContract_FrozenSupply>, I>>(base?: I): AssetIssueContract_FrozenSupply {
    return AssetIssueContract_FrozenSupply.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetIssueContract_FrozenSupply>, I>>(
    object: I,
  ): AssetIssueContract_FrozenSupply {
    const message = createBaseAssetIssueContract_FrozenSupply();
    message.frozenAmount = (object.frozenAmount !== undefined && object.frozenAmount !== null)
      ? Long.fromValue(object.frozenAmount)
      : Long.ZERO;
    message.frozenDays = (object.frozenDays !== undefined && object.frozenDays !== null)
      ? Long.fromValue(object.frozenDays)
      : Long.ZERO;
    return message;
  },
};

function createBaseTransferAssetContract(): TransferAssetContract {
  return { assetName: Buffer.alloc(0), ownerAddress: Buffer.alloc(0), toAddress: Buffer.alloc(0), amount: Long.ZERO };
}

export const TransferAssetContract = {
  encode(message: TransferAssetContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetName.length !== 0) {
      writer.uint32(10).bytes(message.assetName);
    }
    if (message.ownerAddress.length !== 0) {
      writer.uint32(18).bytes(message.ownerAddress);
    }
    if (message.toAddress.length !== 0) {
      writer.uint32(26).bytes(message.toAddress);
    }
    if (!message.amount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransferAssetContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferAssetContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetName = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ownerAddress = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.toAddress = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amount = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferAssetContract {
    return {
      assetName: isSet(object.assetName) ? Buffer.from(bytesFromBase64(object.assetName)) : Buffer.alloc(0),
      ownerAddress: isSet(object.ownerAddress) ? Buffer.from(bytesFromBase64(object.ownerAddress)) : Buffer.alloc(0),
      toAddress: isSet(object.toAddress) ? Buffer.from(bytesFromBase64(object.toAddress)) : Buffer.alloc(0),
      amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.ZERO,
    };
  },

  toJSON(message: TransferAssetContract): unknown {
    const obj: any = {};
    if (message.assetName.length !== 0) {
      obj.assetName = base64FromBytes(message.assetName);
    }
    if (message.ownerAddress.length !== 0) {
      obj.ownerAddress = base64FromBytes(message.ownerAddress);
    }
    if (message.toAddress.length !== 0) {
      obj.toAddress = base64FromBytes(message.toAddress);
    }
    if (!message.amount.equals(Long.ZERO)) {
      obj.amount = (message.amount || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferAssetContract>, I>>(base?: I): TransferAssetContract {
    return TransferAssetContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferAssetContract>, I>>(object: I): TransferAssetContract {
    const message = createBaseTransferAssetContract();
    message.assetName = object.assetName ?? Buffer.alloc(0);
    message.ownerAddress = object.ownerAddress ?? Buffer.alloc(0);
    message.toAddress = object.toAddress ?? Buffer.alloc(0);
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.ZERO;
    return message;
  },
};

function createBaseUnfreezeAssetContract(): UnfreezeAssetContract {
  return { ownerAddress: Buffer.alloc(0) };
}

export const UnfreezeAssetContract = {
  encode(message: UnfreezeAssetContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress.length !== 0) {
      writer.uint32(10).bytes(message.ownerAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnfreezeAssetContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnfreezeAssetContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnfreezeAssetContract {
    return {
      ownerAddress: isSet(object.ownerAddress) ? Buffer.from(bytesFromBase64(object.ownerAddress)) : Buffer.alloc(0),
    };
  },

  toJSON(message: UnfreezeAssetContract): unknown {
    const obj: any = {};
    if (message.ownerAddress.length !== 0) {
      obj.ownerAddress = base64FromBytes(message.ownerAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnfreezeAssetContract>, I>>(base?: I): UnfreezeAssetContract {
    return UnfreezeAssetContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnfreezeAssetContract>, I>>(object: I): UnfreezeAssetContract {
    const message = createBaseUnfreezeAssetContract();
    message.ownerAddress = object.ownerAddress ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseUpdateAssetContract(): UpdateAssetContract {
  return {
    ownerAddress: Buffer.alloc(0),
    description: Buffer.alloc(0),
    url: Buffer.alloc(0),
    newLimit: Long.ZERO,
    newPublicLimit: Long.ZERO,
  };
}

export const UpdateAssetContract = {
  encode(message: UpdateAssetContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress.length !== 0) {
      writer.uint32(10).bytes(message.ownerAddress);
    }
    if (message.description.length !== 0) {
      writer.uint32(18).bytes(message.description);
    }
    if (message.url.length !== 0) {
      writer.uint32(26).bytes(message.url);
    }
    if (!message.newLimit.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.newLimit);
    }
    if (!message.newPublicLimit.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.newPublicLimit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateAssetContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAssetContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.url = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.newLimit = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.newPublicLimit = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAssetContract {
    return {
      ownerAddress: isSet(object.ownerAddress) ? Buffer.from(bytesFromBase64(object.ownerAddress)) : Buffer.alloc(0),
      description: isSet(object.description) ? Buffer.from(bytesFromBase64(object.description)) : Buffer.alloc(0),
      url: isSet(object.url) ? Buffer.from(bytesFromBase64(object.url)) : Buffer.alloc(0),
      newLimit: isSet(object.newLimit) ? Long.fromValue(object.newLimit) : Long.ZERO,
      newPublicLimit: isSet(object.newPublicLimit) ? Long.fromValue(object.newPublicLimit) : Long.ZERO,
    };
  },

  toJSON(message: UpdateAssetContract): unknown {
    const obj: any = {};
    if (message.ownerAddress.length !== 0) {
      obj.ownerAddress = base64FromBytes(message.ownerAddress);
    }
    if (message.description.length !== 0) {
      obj.description = base64FromBytes(message.description);
    }
    if (message.url.length !== 0) {
      obj.url = base64FromBytes(message.url);
    }
    if (!message.newLimit.equals(Long.ZERO)) {
      obj.newLimit = (message.newLimit || Long.ZERO).toString();
    }
    if (!message.newPublicLimit.equals(Long.ZERO)) {
      obj.newPublicLimit = (message.newPublicLimit || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateAssetContract>, I>>(base?: I): UpdateAssetContract {
    return UpdateAssetContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateAssetContract>, I>>(object: I): UpdateAssetContract {
    const message = createBaseUpdateAssetContract();
    message.ownerAddress = object.ownerAddress ?? Buffer.alloc(0);
    message.description = object.description ?? Buffer.alloc(0);
    message.url = object.url ?? Buffer.alloc(0);
    message.newLimit = (object.newLimit !== undefined && object.newLimit !== null)
      ? Long.fromValue(object.newLimit)
      : Long.ZERO;
    message.newPublicLimit = (object.newPublicLimit !== undefined && object.newPublicLimit !== null)
      ? Long.fromValue(object.newPublicLimit)
      : Long.ZERO;
    return message;
  },
};

function createBaseParticipateAssetIssueContract(): ParticipateAssetIssueContract {
  return { ownerAddress: Buffer.alloc(0), toAddress: Buffer.alloc(0), assetName: Buffer.alloc(0), amount: Long.ZERO };
}

export const ParticipateAssetIssueContract = {
  encode(message: ParticipateAssetIssueContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress.length !== 0) {
      writer.uint32(10).bytes(message.ownerAddress);
    }
    if (message.toAddress.length !== 0) {
      writer.uint32(18).bytes(message.toAddress);
    }
    if (message.assetName.length !== 0) {
      writer.uint32(26).bytes(message.assetName);
    }
    if (!message.amount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ParticipateAssetIssueContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParticipateAssetIssueContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toAddress = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.assetName = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amount = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParticipateAssetIssueContract {
    return {
      ownerAddress: isSet(object.ownerAddress) ? Buffer.from(bytesFromBase64(object.ownerAddress)) : Buffer.alloc(0),
      toAddress: isSet(object.toAddress) ? Buffer.from(bytesFromBase64(object.toAddress)) : Buffer.alloc(0),
      assetName: isSet(object.assetName) ? Buffer.from(bytesFromBase64(object.assetName)) : Buffer.alloc(0),
      amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.ZERO,
    };
  },

  toJSON(message: ParticipateAssetIssueContract): unknown {
    const obj: any = {};
    if (message.ownerAddress.length !== 0) {
      obj.ownerAddress = base64FromBytes(message.ownerAddress);
    }
    if (message.toAddress.length !== 0) {
      obj.toAddress = base64FromBytes(message.toAddress);
    }
    if (message.assetName.length !== 0) {
      obj.assetName = base64FromBytes(message.assetName);
    }
    if (!message.amount.equals(Long.ZERO)) {
      obj.amount = (message.amount || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParticipateAssetIssueContract>, I>>(base?: I): ParticipateAssetIssueContract {
    return ParticipateAssetIssueContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParticipateAssetIssueContract>, I>>(
    object: I,
  ): ParticipateAssetIssueContract {
    const message = createBaseParticipateAssetIssueContract();
    message.ownerAddress = object.ownerAddress ?? Buffer.alloc(0);
    message.toAddress = object.toAddress ?? Buffer.alloc(0);
    message.assetName = object.assetName ?? Buffer.alloc(0);
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.ZERO;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
