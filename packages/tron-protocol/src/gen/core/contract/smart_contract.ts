// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: core/contract/smart_contract.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";

export const protobufPackage = "protocol";

export interface SmartContract {
  originAddress: Buffer;
  contractAddress: Buffer;
  abi: SmartContract_ABI | undefined;
  bytecode: Buffer;
  callValue: Long;
  consumeUserResourcePercent: Long;
  name: string;
  originEnergyLimit: Long;
  codeHash: Buffer;
  trxHash: Buffer;
  version: number;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface SmartContract_ABI {
  entrys: SmartContract_ABI_Entry[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface SmartContract_ABI_Entry {
  anonymous: boolean;
  constant: boolean;
  name: string;
  inputs: SmartContract_ABI_Entry_Param[];
  outputs: SmartContract_ABI_Entry_Param[];
  type: SmartContract_ABI_Entry_EntryType;
  payable: boolean;
  stateMutability: SmartContract_ABI_Entry_StateMutabilityType;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export enum SmartContract_ABI_Entry_EntryType {
  UnknownEntryType = 0,
  Constructor = 1,
  Function = 2,
  Event = 3,
  Fallback = 4,
  Receive = 5,
  Error = 6,
  UNRECOGNIZED = -1,
}

export function smartContract_ABI_Entry_EntryTypeFromJSON(object: any): SmartContract_ABI_Entry_EntryType {
  switch (object) {
    case 0:
    case "UnknownEntryType":
      return SmartContract_ABI_Entry_EntryType.UnknownEntryType;
    case 1:
    case "Constructor":
      return SmartContract_ABI_Entry_EntryType.Constructor;
    case 2:
    case "Function":
      return SmartContract_ABI_Entry_EntryType.Function;
    case 3:
    case "Event":
      return SmartContract_ABI_Entry_EntryType.Event;
    case 4:
    case "Fallback":
      return SmartContract_ABI_Entry_EntryType.Fallback;
    case 5:
    case "Receive":
      return SmartContract_ABI_Entry_EntryType.Receive;
    case 6:
    case "Error":
      return SmartContract_ABI_Entry_EntryType.Error;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SmartContract_ABI_Entry_EntryType.UNRECOGNIZED;
  }
}

export function smartContract_ABI_Entry_EntryTypeToJSON(object: SmartContract_ABI_Entry_EntryType): string {
  switch (object) {
    case SmartContract_ABI_Entry_EntryType.UnknownEntryType:
      return "UnknownEntryType";
    case SmartContract_ABI_Entry_EntryType.Constructor:
      return "Constructor";
    case SmartContract_ABI_Entry_EntryType.Function:
      return "Function";
    case SmartContract_ABI_Entry_EntryType.Event:
      return "Event";
    case SmartContract_ABI_Entry_EntryType.Fallback:
      return "Fallback";
    case SmartContract_ABI_Entry_EntryType.Receive:
      return "Receive";
    case SmartContract_ABI_Entry_EntryType.Error:
      return "Error";
    case SmartContract_ABI_Entry_EntryType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SmartContract_ABI_Entry_StateMutabilityType {
  UnknownMutabilityType = 0,
  Pure = 1,
  View = 2,
  Nonpayable = 3,
  Payable = 4,
  UNRECOGNIZED = -1,
}

export function smartContract_ABI_Entry_StateMutabilityTypeFromJSON(
  object: any,
): SmartContract_ABI_Entry_StateMutabilityType {
  switch (object) {
    case 0:
    case "UnknownMutabilityType":
      return SmartContract_ABI_Entry_StateMutabilityType.UnknownMutabilityType;
    case 1:
    case "Pure":
      return SmartContract_ABI_Entry_StateMutabilityType.Pure;
    case 2:
    case "View":
      return SmartContract_ABI_Entry_StateMutabilityType.View;
    case 3:
    case "Nonpayable":
      return SmartContract_ABI_Entry_StateMutabilityType.Nonpayable;
    case 4:
    case "Payable":
      return SmartContract_ABI_Entry_StateMutabilityType.Payable;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SmartContract_ABI_Entry_StateMutabilityType.UNRECOGNIZED;
  }
}

export function smartContract_ABI_Entry_StateMutabilityTypeToJSON(
  object: SmartContract_ABI_Entry_StateMutabilityType,
): string {
  switch (object) {
    case SmartContract_ABI_Entry_StateMutabilityType.UnknownMutabilityType:
      return "UnknownMutabilityType";
    case SmartContract_ABI_Entry_StateMutabilityType.Pure:
      return "Pure";
    case SmartContract_ABI_Entry_StateMutabilityType.View:
      return "View";
    case SmartContract_ABI_Entry_StateMutabilityType.Nonpayable:
      return "Nonpayable";
    case SmartContract_ABI_Entry_StateMutabilityType.Payable:
      return "Payable";
    case SmartContract_ABI_Entry_StateMutabilityType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SmartContract_ABI_Entry_Param {
  indexed: boolean;
  name: string;
  /** SolidityType type = 3; */
  type: string;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ContractState {
  energyUsage: Long;
  energyFactor: Long;
  updateCycle: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface CreateSmartContract {
  ownerAddress: Buffer;
  newContract: SmartContract | undefined;
  callTokenValue: Long;
  tokenId: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TriggerSmartContract {
  ownerAddress: Buffer;
  contractAddress: Buffer;
  callValue: Long;
  data: Buffer;
  callTokenValue: Long;
  tokenId: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ClearABIContract {
  ownerAddress: Buffer;
  contractAddress: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface UpdateSettingContract {
  ownerAddress: Buffer;
  contractAddress: Buffer;
  consumeUserResourcePercent: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface UpdateEnergyLimitContract {
  ownerAddress: Buffer;
  contractAddress: Buffer;
  originEnergyLimit: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface SmartContractDataWrapper {
  smartContract: SmartContract | undefined;
  runtimecode: Buffer;
  contractState: ContractState | undefined;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

function createBaseSmartContract(): SmartContract {
  return {
    originAddress: Buffer.alloc(0),
    contractAddress: Buffer.alloc(0),
    abi: undefined,
    bytecode: Buffer.alloc(0),
    callValue: Long.ZERO,
    consumeUserResourcePercent: Long.ZERO,
    name: "",
    originEnergyLimit: Long.ZERO,
    codeHash: Buffer.alloc(0),
    trxHash: Buffer.alloc(0),
    version: 0,
    _unknownFields: {},
  };
}

export const SmartContract = {
  encode(message: SmartContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.originAddress.length !== 0) {
      writer.uint32(10).bytes(message.originAddress);
    }
    if (message.contractAddress.length !== 0) {
      writer.uint32(18).bytes(message.contractAddress);
    }
    if (message.abi !== undefined) {
      SmartContract_ABI.encode(message.abi, writer.uint32(26).fork()).ldelim();
    }
    if (message.bytecode.length !== 0) {
      writer.uint32(34).bytes(message.bytecode);
    }
    if (!message.callValue.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.callValue);
    }
    if (!message.consumeUserResourcePercent.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.consumeUserResourcePercent);
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    if (!message.originEnergyLimit.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.originEnergyLimit);
    }
    if (message.codeHash.length !== 0) {
      writer.uint32(74).bytes(message.codeHash);
    }
    if (message.trxHash.length !== 0) {
      writer.uint32(82).bytes(message.trxHash);
    }
    if (message.version !== 0) {
      writer.uint32(88).int32(message.version);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SmartContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmartContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.originAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contractAddress = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.abi = SmartContract_ABI.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bytecode = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.callValue = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.consumeUserResourcePercent = reader.int64() as Long;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.originEnergyLimit = reader.int64() as Long;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.codeHash = reader.bytes() as Buffer;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.trxHash = reader.bytes() as Buffer;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): SmartContract {
    return {
      originAddress: isSet(object.originAddress) ? Buffer.from(bytesFromBase64(object.originAddress)) : Buffer.alloc(0),
      contractAddress: isSet(object.contractAddress)
        ? Buffer.from(bytesFromBase64(object.contractAddress))
        : Buffer.alloc(0),
      abi: isSet(object.abi) ? SmartContract_ABI.fromJSON(object.abi) : undefined,
      bytecode: isSet(object.bytecode) ? Buffer.from(bytesFromBase64(object.bytecode)) : Buffer.alloc(0),
      callValue: isSet(object.callValue) ? Long.fromValue(object.callValue) : Long.ZERO,
      consumeUserResourcePercent: isSet(object.consumeUserResourcePercent)
        ? Long.fromValue(object.consumeUserResourcePercent)
        : Long.ZERO,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      originEnergyLimit: isSet(object.originEnergyLimit) ? Long.fromValue(object.originEnergyLimit) : Long.ZERO,
      codeHash: isSet(object.codeHash) ? Buffer.from(bytesFromBase64(object.codeHash)) : Buffer.alloc(0),
      trxHash: isSet(object.trxHash) ? Buffer.from(bytesFromBase64(object.trxHash)) : Buffer.alloc(0),
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: SmartContract): unknown {
    const obj: any = {};
    if (message.originAddress.length !== 0) {
      obj.originAddress = base64FromBytes(message.originAddress);
    }
    if (message.contractAddress.length !== 0) {
      obj.contractAddress = base64FromBytes(message.contractAddress);
    }
    if (message.abi !== undefined) {
      obj.abi = SmartContract_ABI.toJSON(message.abi);
    }
    if (message.bytecode.length !== 0) {
      obj.bytecode = base64FromBytes(message.bytecode);
    }
    if (!message.callValue.equals(Long.ZERO)) {
      obj.callValue = (message.callValue || Long.ZERO).toString();
    }
    if (!message.consumeUserResourcePercent.equals(Long.ZERO)) {
      obj.consumeUserResourcePercent = (message.consumeUserResourcePercent || Long.ZERO).toString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.originEnergyLimit.equals(Long.ZERO)) {
      obj.originEnergyLimit = (message.originEnergyLimit || Long.ZERO).toString();
    }
    if (message.codeHash.length !== 0) {
      obj.codeHash = base64FromBytes(message.codeHash);
    }
    if (message.trxHash.length !== 0) {
      obj.trxHash = base64FromBytes(message.trxHash);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SmartContract>, I>>(base?: I): SmartContract {
    return SmartContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SmartContract>, I>>(object: I): SmartContract {
    const message = createBaseSmartContract();
    message.originAddress = object.originAddress ?? Buffer.alloc(0);
    message.contractAddress = object.contractAddress ?? Buffer.alloc(0);
    message.abi = (object.abi !== undefined && object.abi !== null)
      ? SmartContract_ABI.fromPartial(object.abi)
      : undefined;
    message.bytecode = object.bytecode ?? Buffer.alloc(0);
    message.callValue = (object.callValue !== undefined && object.callValue !== null)
      ? Long.fromValue(object.callValue)
      : Long.ZERO;
    message.consumeUserResourcePercent =
      (object.consumeUserResourcePercent !== undefined && object.consumeUserResourcePercent !== null)
        ? Long.fromValue(object.consumeUserResourcePercent)
        : Long.ZERO;
    message.name = object.name ?? "";
    message.originEnergyLimit = (object.originEnergyLimit !== undefined && object.originEnergyLimit !== null)
      ? Long.fromValue(object.originEnergyLimit)
      : Long.ZERO;
    message.codeHash = object.codeHash ?? Buffer.alloc(0);
    message.trxHash = object.trxHash ?? Buffer.alloc(0);
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseSmartContract_ABI(): SmartContract_ABI {
  return { entrys: [], _unknownFields: {} };
}

export const SmartContract_ABI = {
  encode(message: SmartContract_ABI, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.entrys) {
      SmartContract_ABI_Entry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SmartContract_ABI {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmartContract_ABI();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entrys.push(SmartContract_ABI_Entry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): SmartContract_ABI {
    return {
      entrys: globalThis.Array.isArray(object?.entrys)
        ? object.entrys.map((e: any) => SmartContract_ABI_Entry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SmartContract_ABI): unknown {
    const obj: any = {};
    if (message.entrys?.length) {
      obj.entrys = message.entrys.map((e) => SmartContract_ABI_Entry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SmartContract_ABI>, I>>(base?: I): SmartContract_ABI {
    return SmartContract_ABI.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SmartContract_ABI>, I>>(object: I): SmartContract_ABI {
    const message = createBaseSmartContract_ABI();
    message.entrys = object.entrys?.map((e) => SmartContract_ABI_Entry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSmartContract_ABI_Entry(): SmartContract_ABI_Entry {
  return {
    anonymous: false,
    constant: false,
    name: "",
    inputs: [],
    outputs: [],
    type: 0,
    payable: false,
    stateMutability: 0,
    _unknownFields: {},
  };
}

export const SmartContract_ABI_Entry = {
  encode(message: SmartContract_ABI_Entry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.anonymous !== false) {
      writer.uint32(8).bool(message.anonymous);
    }
    if (message.constant !== false) {
      writer.uint32(16).bool(message.constant);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    for (const v of message.inputs) {
      SmartContract_ABI_Entry_Param.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.outputs) {
      SmartContract_ABI_Entry_Param.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    if (message.payable !== false) {
      writer.uint32(56).bool(message.payable);
    }
    if (message.stateMutability !== 0) {
      writer.uint32(64).int32(message.stateMutability);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SmartContract_ABI_Entry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmartContract_ABI_Entry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.anonymous = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.constant = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.inputs.push(SmartContract_ABI_Entry_Param.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.outputs.push(SmartContract_ABI_Entry_Param.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.payable = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.stateMutability = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): SmartContract_ABI_Entry {
    return {
      anonymous: isSet(object.anonymous) ? globalThis.Boolean(object.anonymous) : false,
      constant: isSet(object.constant) ? globalThis.Boolean(object.constant) : false,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      inputs: globalThis.Array.isArray(object?.inputs)
        ? object.inputs.map((e: any) => SmartContract_ABI_Entry_Param.fromJSON(e))
        : [],
      outputs: globalThis.Array.isArray(object?.outputs)
        ? object.outputs.map((e: any) => SmartContract_ABI_Entry_Param.fromJSON(e))
        : [],
      type: isSet(object.type) ? smartContract_ABI_Entry_EntryTypeFromJSON(object.type) : 0,
      payable: isSet(object.payable) ? globalThis.Boolean(object.payable) : false,
      stateMutability: isSet(object.stateMutability)
        ? smartContract_ABI_Entry_StateMutabilityTypeFromJSON(object.stateMutability)
        : 0,
    };
  },

  toJSON(message: SmartContract_ABI_Entry): unknown {
    const obj: any = {};
    if (message.anonymous !== false) {
      obj.anonymous = message.anonymous;
    }
    if (message.constant !== false) {
      obj.constant = message.constant;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => SmartContract_ABI_Entry_Param.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => SmartContract_ABI_Entry_Param.toJSON(e));
    }
    if (message.type !== 0) {
      obj.type = smartContract_ABI_Entry_EntryTypeToJSON(message.type);
    }
    if (message.payable !== false) {
      obj.payable = message.payable;
    }
    if (message.stateMutability !== 0) {
      obj.stateMutability = smartContract_ABI_Entry_StateMutabilityTypeToJSON(message.stateMutability);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SmartContract_ABI_Entry>, I>>(base?: I): SmartContract_ABI_Entry {
    return SmartContract_ABI_Entry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SmartContract_ABI_Entry>, I>>(object: I): SmartContract_ABI_Entry {
    const message = createBaseSmartContract_ABI_Entry();
    message.anonymous = object.anonymous ?? false;
    message.constant = object.constant ?? false;
    message.name = object.name ?? "";
    message.inputs = object.inputs?.map((e) => SmartContract_ABI_Entry_Param.fromPartial(e)) || [];
    message.outputs = object.outputs?.map((e) => SmartContract_ABI_Entry_Param.fromPartial(e)) || [];
    message.type = object.type ?? 0;
    message.payable = object.payable ?? false;
    message.stateMutability = object.stateMutability ?? 0;
    return message;
  },
};

function createBaseSmartContract_ABI_Entry_Param(): SmartContract_ABI_Entry_Param {
  return { indexed: false, name: "", type: "", _unknownFields: {} };
}

export const SmartContract_ABI_Entry_Param = {
  encode(message: SmartContract_ABI_Entry_Param, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.indexed !== false) {
      writer.uint32(8).bool(message.indexed);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SmartContract_ABI_Entry_Param {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmartContract_ABI_Entry_Param();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.indexed = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): SmartContract_ABI_Entry_Param {
    return {
      indexed: isSet(object.indexed) ? globalThis.Boolean(object.indexed) : false,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: SmartContract_ABI_Entry_Param): unknown {
    const obj: any = {};
    if (message.indexed !== false) {
      obj.indexed = message.indexed;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SmartContract_ABI_Entry_Param>, I>>(base?: I): SmartContract_ABI_Entry_Param {
    return SmartContract_ABI_Entry_Param.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SmartContract_ABI_Entry_Param>, I>>(
    object: I,
  ): SmartContract_ABI_Entry_Param {
    const message = createBaseSmartContract_ABI_Entry_Param();
    message.indexed = object.indexed ?? false;
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseContractState(): ContractState {
  return { energyUsage: Long.ZERO, energyFactor: Long.ZERO, updateCycle: Long.ZERO, _unknownFields: {} };
}

export const ContractState = {
  encode(message: ContractState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.energyUsage.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.energyUsage);
    }
    if (!message.energyFactor.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.energyFactor);
    }
    if (!message.updateCycle.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.updateCycle);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ContractState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.energyUsage = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.energyFactor = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.updateCycle = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ContractState {
    return {
      energyUsage: isSet(object.energyUsage) ? Long.fromValue(object.energyUsage) : Long.ZERO,
      energyFactor: isSet(object.energyFactor) ? Long.fromValue(object.energyFactor) : Long.ZERO,
      updateCycle: isSet(object.updateCycle) ? Long.fromValue(object.updateCycle) : Long.ZERO,
    };
  },

  toJSON(message: ContractState): unknown {
    const obj: any = {};
    if (!message.energyUsage.equals(Long.ZERO)) {
      obj.energyUsage = (message.energyUsage || Long.ZERO).toString();
    }
    if (!message.energyFactor.equals(Long.ZERO)) {
      obj.energyFactor = (message.energyFactor || Long.ZERO).toString();
    }
    if (!message.updateCycle.equals(Long.ZERO)) {
      obj.updateCycle = (message.updateCycle || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContractState>, I>>(base?: I): ContractState {
    return ContractState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContractState>, I>>(object: I): ContractState {
    const message = createBaseContractState();
    message.energyUsage = (object.energyUsage !== undefined && object.energyUsage !== null)
      ? Long.fromValue(object.energyUsage)
      : Long.ZERO;
    message.energyFactor = (object.energyFactor !== undefined && object.energyFactor !== null)
      ? Long.fromValue(object.energyFactor)
      : Long.ZERO;
    message.updateCycle = (object.updateCycle !== undefined && object.updateCycle !== null)
      ? Long.fromValue(object.updateCycle)
      : Long.ZERO;
    return message;
  },
};

function createBaseCreateSmartContract(): CreateSmartContract {
  return {
    ownerAddress: Buffer.alloc(0),
    newContract: undefined,
    callTokenValue: Long.ZERO,
    tokenId: Long.ZERO,
    _unknownFields: {},
  };
}

export const CreateSmartContract = {
  encode(message: CreateSmartContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress.length !== 0) {
      writer.uint32(10).bytes(message.ownerAddress);
    }
    if (message.newContract !== undefined) {
      SmartContract.encode(message.newContract, writer.uint32(18).fork()).ldelim();
    }
    if (!message.callTokenValue.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.callTokenValue);
    }
    if (!message.tokenId.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.tokenId);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSmartContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSmartContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.newContract = SmartContract.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.callTokenValue = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.tokenId = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): CreateSmartContract {
    return {
      ownerAddress: isSet(object.ownerAddress) ? Buffer.from(bytesFromBase64(object.ownerAddress)) : Buffer.alloc(0),
      newContract: isSet(object.newContract) ? SmartContract.fromJSON(object.newContract) : undefined,
      callTokenValue: isSet(object.callTokenValue) ? Long.fromValue(object.callTokenValue) : Long.ZERO,
      tokenId: isSet(object.tokenId) ? Long.fromValue(object.tokenId) : Long.ZERO,
    };
  },

  toJSON(message: CreateSmartContract): unknown {
    const obj: any = {};
    if (message.ownerAddress.length !== 0) {
      obj.ownerAddress = base64FromBytes(message.ownerAddress);
    }
    if (message.newContract !== undefined) {
      obj.newContract = SmartContract.toJSON(message.newContract);
    }
    if (!message.callTokenValue.equals(Long.ZERO)) {
      obj.callTokenValue = (message.callTokenValue || Long.ZERO).toString();
    }
    if (!message.tokenId.equals(Long.ZERO)) {
      obj.tokenId = (message.tokenId || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSmartContract>, I>>(base?: I): CreateSmartContract {
    return CreateSmartContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSmartContract>, I>>(object: I): CreateSmartContract {
    const message = createBaseCreateSmartContract();
    message.ownerAddress = object.ownerAddress ?? Buffer.alloc(0);
    message.newContract = (object.newContract !== undefined && object.newContract !== null)
      ? SmartContract.fromPartial(object.newContract)
      : undefined;
    message.callTokenValue = (object.callTokenValue !== undefined && object.callTokenValue !== null)
      ? Long.fromValue(object.callTokenValue)
      : Long.ZERO;
    message.tokenId = (object.tokenId !== undefined && object.tokenId !== null)
      ? Long.fromValue(object.tokenId)
      : Long.ZERO;
    return message;
  },
};

function createBaseTriggerSmartContract(): TriggerSmartContract {
  return {
    ownerAddress: Buffer.alloc(0),
    contractAddress: Buffer.alloc(0),
    callValue: Long.ZERO,
    data: Buffer.alloc(0),
    callTokenValue: Long.ZERO,
    tokenId: Long.ZERO,
    _unknownFields: {},
  };
}

export const TriggerSmartContract = {
  encode(message: TriggerSmartContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress.length !== 0) {
      writer.uint32(10).bytes(message.ownerAddress);
    }
    if (message.contractAddress.length !== 0) {
      writer.uint32(18).bytes(message.contractAddress);
    }
    if (!message.callValue.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.callValue);
    }
    if (message.data.length !== 0) {
      writer.uint32(34).bytes(message.data);
    }
    if (!message.callTokenValue.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.callTokenValue);
    }
    if (!message.tokenId.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.tokenId);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TriggerSmartContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTriggerSmartContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contractAddress = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.callValue = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.callTokenValue = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.tokenId = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TriggerSmartContract {
    return {
      ownerAddress: isSet(object.ownerAddress) ? Buffer.from(bytesFromBase64(object.ownerAddress)) : Buffer.alloc(0),
      contractAddress: isSet(object.contractAddress)
        ? Buffer.from(bytesFromBase64(object.contractAddress))
        : Buffer.alloc(0),
      callValue: isSet(object.callValue) ? Long.fromValue(object.callValue) : Long.ZERO,
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      callTokenValue: isSet(object.callTokenValue) ? Long.fromValue(object.callTokenValue) : Long.ZERO,
      tokenId: isSet(object.tokenId) ? Long.fromValue(object.tokenId) : Long.ZERO,
    };
  },

  toJSON(message: TriggerSmartContract): unknown {
    const obj: any = {};
    if (message.ownerAddress.length !== 0) {
      obj.ownerAddress = base64FromBytes(message.ownerAddress);
    }
    if (message.contractAddress.length !== 0) {
      obj.contractAddress = base64FromBytes(message.contractAddress);
    }
    if (!message.callValue.equals(Long.ZERO)) {
      obj.callValue = (message.callValue || Long.ZERO).toString();
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (!message.callTokenValue.equals(Long.ZERO)) {
      obj.callTokenValue = (message.callTokenValue || Long.ZERO).toString();
    }
    if (!message.tokenId.equals(Long.ZERO)) {
      obj.tokenId = (message.tokenId || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TriggerSmartContract>, I>>(base?: I): TriggerSmartContract {
    return TriggerSmartContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TriggerSmartContract>, I>>(object: I): TriggerSmartContract {
    const message = createBaseTriggerSmartContract();
    message.ownerAddress = object.ownerAddress ?? Buffer.alloc(0);
    message.contractAddress = object.contractAddress ?? Buffer.alloc(0);
    message.callValue = (object.callValue !== undefined && object.callValue !== null)
      ? Long.fromValue(object.callValue)
      : Long.ZERO;
    message.data = object.data ?? Buffer.alloc(0);
    message.callTokenValue = (object.callTokenValue !== undefined && object.callTokenValue !== null)
      ? Long.fromValue(object.callTokenValue)
      : Long.ZERO;
    message.tokenId = (object.tokenId !== undefined && object.tokenId !== null)
      ? Long.fromValue(object.tokenId)
      : Long.ZERO;
    return message;
  },
};

function createBaseClearABIContract(): ClearABIContract {
  return { ownerAddress: Buffer.alloc(0), contractAddress: Buffer.alloc(0), _unknownFields: {} };
}

export const ClearABIContract = {
  encode(message: ClearABIContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress.length !== 0) {
      writer.uint32(10).bytes(message.ownerAddress);
    }
    if (message.contractAddress.length !== 0) {
      writer.uint32(18).bytes(message.contractAddress);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClearABIContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearABIContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contractAddress = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ClearABIContract {
    return {
      ownerAddress: isSet(object.ownerAddress) ? Buffer.from(bytesFromBase64(object.ownerAddress)) : Buffer.alloc(0),
      contractAddress: isSet(object.contractAddress)
        ? Buffer.from(bytesFromBase64(object.contractAddress))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: ClearABIContract): unknown {
    const obj: any = {};
    if (message.ownerAddress.length !== 0) {
      obj.ownerAddress = base64FromBytes(message.ownerAddress);
    }
    if (message.contractAddress.length !== 0) {
      obj.contractAddress = base64FromBytes(message.contractAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearABIContract>, I>>(base?: I): ClearABIContract {
    return ClearABIContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearABIContract>, I>>(object: I): ClearABIContract {
    const message = createBaseClearABIContract();
    message.ownerAddress = object.ownerAddress ?? Buffer.alloc(0);
    message.contractAddress = object.contractAddress ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseUpdateSettingContract(): UpdateSettingContract {
  return {
    ownerAddress: Buffer.alloc(0),
    contractAddress: Buffer.alloc(0),
    consumeUserResourcePercent: Long.ZERO,
    _unknownFields: {},
  };
}

export const UpdateSettingContract = {
  encode(message: UpdateSettingContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress.length !== 0) {
      writer.uint32(10).bytes(message.ownerAddress);
    }
    if (message.contractAddress.length !== 0) {
      writer.uint32(18).bytes(message.contractAddress);
    }
    if (!message.consumeUserResourcePercent.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.consumeUserResourcePercent);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSettingContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSettingContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contractAddress = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.consumeUserResourcePercent = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateSettingContract {
    return {
      ownerAddress: isSet(object.ownerAddress) ? Buffer.from(bytesFromBase64(object.ownerAddress)) : Buffer.alloc(0),
      contractAddress: isSet(object.contractAddress)
        ? Buffer.from(bytesFromBase64(object.contractAddress))
        : Buffer.alloc(0),
      consumeUserResourcePercent: isSet(object.consumeUserResourcePercent)
        ? Long.fromValue(object.consumeUserResourcePercent)
        : Long.ZERO,
    };
  },

  toJSON(message: UpdateSettingContract): unknown {
    const obj: any = {};
    if (message.ownerAddress.length !== 0) {
      obj.ownerAddress = base64FromBytes(message.ownerAddress);
    }
    if (message.contractAddress.length !== 0) {
      obj.contractAddress = base64FromBytes(message.contractAddress);
    }
    if (!message.consumeUserResourcePercent.equals(Long.ZERO)) {
      obj.consumeUserResourcePercent = (message.consumeUserResourcePercent || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSettingContract>, I>>(base?: I): UpdateSettingContract {
    return UpdateSettingContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSettingContract>, I>>(object: I): UpdateSettingContract {
    const message = createBaseUpdateSettingContract();
    message.ownerAddress = object.ownerAddress ?? Buffer.alloc(0);
    message.contractAddress = object.contractAddress ?? Buffer.alloc(0);
    message.consumeUserResourcePercent =
      (object.consumeUserResourcePercent !== undefined && object.consumeUserResourcePercent !== null)
        ? Long.fromValue(object.consumeUserResourcePercent)
        : Long.ZERO;
    return message;
  },
};

function createBaseUpdateEnergyLimitContract(): UpdateEnergyLimitContract {
  return {
    ownerAddress: Buffer.alloc(0),
    contractAddress: Buffer.alloc(0),
    originEnergyLimit: Long.ZERO,
    _unknownFields: {},
  };
}

export const UpdateEnergyLimitContract = {
  encode(message: UpdateEnergyLimitContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress.length !== 0) {
      writer.uint32(10).bytes(message.ownerAddress);
    }
    if (message.contractAddress.length !== 0) {
      writer.uint32(18).bytes(message.contractAddress);
    }
    if (!message.originEnergyLimit.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.originEnergyLimit);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateEnergyLimitContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEnergyLimitContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contractAddress = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.originEnergyLimit = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateEnergyLimitContract {
    return {
      ownerAddress: isSet(object.ownerAddress) ? Buffer.from(bytesFromBase64(object.ownerAddress)) : Buffer.alloc(0),
      contractAddress: isSet(object.contractAddress)
        ? Buffer.from(bytesFromBase64(object.contractAddress))
        : Buffer.alloc(0),
      originEnergyLimit: isSet(object.originEnergyLimit) ? Long.fromValue(object.originEnergyLimit) : Long.ZERO,
    };
  },

  toJSON(message: UpdateEnergyLimitContract): unknown {
    const obj: any = {};
    if (message.ownerAddress.length !== 0) {
      obj.ownerAddress = base64FromBytes(message.ownerAddress);
    }
    if (message.contractAddress.length !== 0) {
      obj.contractAddress = base64FromBytes(message.contractAddress);
    }
    if (!message.originEnergyLimit.equals(Long.ZERO)) {
      obj.originEnergyLimit = (message.originEnergyLimit || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateEnergyLimitContract>, I>>(base?: I): UpdateEnergyLimitContract {
    return UpdateEnergyLimitContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateEnergyLimitContract>, I>>(object: I): UpdateEnergyLimitContract {
    const message = createBaseUpdateEnergyLimitContract();
    message.ownerAddress = object.ownerAddress ?? Buffer.alloc(0);
    message.contractAddress = object.contractAddress ?? Buffer.alloc(0);
    message.originEnergyLimit = (object.originEnergyLimit !== undefined && object.originEnergyLimit !== null)
      ? Long.fromValue(object.originEnergyLimit)
      : Long.ZERO;
    return message;
  },
};

function createBaseSmartContractDataWrapper(): SmartContractDataWrapper {
  return { smartContract: undefined, runtimecode: Buffer.alloc(0), contractState: undefined, _unknownFields: {} };
}

export const SmartContractDataWrapper = {
  encode(message: SmartContractDataWrapper, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.smartContract !== undefined) {
      SmartContract.encode(message.smartContract, writer.uint32(10).fork()).ldelim();
    }
    if (message.runtimecode.length !== 0) {
      writer.uint32(18).bytes(message.runtimecode);
    }
    if (message.contractState !== undefined) {
      ContractState.encode(message.contractState, writer.uint32(26).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SmartContractDataWrapper {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmartContractDataWrapper();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.smartContract = SmartContract.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.runtimecode = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contractState = ContractState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): SmartContractDataWrapper {
    return {
      smartContract: isSet(object.smartContract) ? SmartContract.fromJSON(object.smartContract) : undefined,
      runtimecode: isSet(object.runtimecode) ? Buffer.from(bytesFromBase64(object.runtimecode)) : Buffer.alloc(0),
      contractState: isSet(object.contractState) ? ContractState.fromJSON(object.contractState) : undefined,
    };
  },

  toJSON(message: SmartContractDataWrapper): unknown {
    const obj: any = {};
    if (message.smartContract !== undefined) {
      obj.smartContract = SmartContract.toJSON(message.smartContract);
    }
    if (message.runtimecode.length !== 0) {
      obj.runtimecode = base64FromBytes(message.runtimecode);
    }
    if (message.contractState !== undefined) {
      obj.contractState = ContractState.toJSON(message.contractState);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SmartContractDataWrapper>, I>>(base?: I): SmartContractDataWrapper {
    return SmartContractDataWrapper.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SmartContractDataWrapper>, I>>(object: I): SmartContractDataWrapper {
    const message = createBaseSmartContractDataWrapper();
    message.smartContract = (object.smartContract !== undefined && object.smartContract !== null)
      ? SmartContract.fromPartial(object.smartContract)
      : undefined;
    message.runtimecode = object.runtimecode ?? Buffer.alloc(0);
    message.contractState = (object.contractState !== undefined && object.contractState !== null)
      ? ContractState.fromPartial(object.contractState)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
