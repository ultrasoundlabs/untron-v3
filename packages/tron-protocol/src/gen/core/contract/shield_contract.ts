// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: core/contract/shield_contract.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";

export const protobufPackage = "protocol";

export interface AuthenticationPath {
  value: boolean[];
}

export interface MerklePath {
  authenticationPaths: AuthenticationPath[];
  index: boolean[];
  rt: Buffer;
}

export interface OutputPoint {
  hash: Buffer;
  index: number;
}

export interface OutputPointInfo {
  outPoints: OutputPoint[];
  blockNum: number;
}

export interface PedersenHash {
  content: Buffer;
}

export interface IncrementalMerkleTree {
  left: PedersenHash | undefined;
  right: PedersenHash | undefined;
  parents: PedersenHash[];
}

export interface IncrementalMerkleVoucher {
  tree: IncrementalMerkleTree | undefined;
  filled: PedersenHash[];
  cursor: IncrementalMerkleTree | undefined;
  cursorDepth: Long;
  rt: Buffer;
  outputPoint: OutputPoint | undefined;
}

export interface IncrementalMerkleVoucherInfo {
  vouchers: IncrementalMerkleVoucher[];
  paths: Buffer[];
}

export interface SpendDescription {
  valueCommitment: Buffer;
  /** merkle root */
  anchor: Buffer;
  /** used for check double spend */
  nullifier: Buffer;
  /** used for check spend authority signature */
  rk: Buffer;
  zkproof: Buffer;
  spendAuthoritySignature: Buffer;
}

export interface ReceiveDescription {
  valueCommitment: Buffer;
  noteCommitment: Buffer;
  /** for Encryption */
  epk: Buffer;
  /** Encryption for incoming, decrypt it with ivk */
  cEnc: Buffer;
  /** Encryption for audit, decrypt it with ovk */
  cOut: Buffer;
  zkproof: Buffer;
}

export interface ShieldedTransferContract {
  /** transparent address */
  transparentFromAddress: Buffer;
  fromAmount: Long;
  spendDescription: SpendDescription[];
  receiveDescription: ReceiveDescription[];
  bindingSignature: Buffer;
  /** transparent address */
  transparentToAddress: Buffer;
  /** the amount to transparent to_address */
  toAmount: Long;
}

function createBaseAuthenticationPath(): AuthenticationPath {
  return { value: [] };
}

export const AuthenticationPath = {
  encode(message: AuthenticationPath, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.value) {
      writer.bool(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthenticationPath {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationPath();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.value.push(reader.bool());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.value.push(reader.bool());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticationPath {
    return {
      value: globalThis.Array.isArray(object?.value) ? object.value.map((e: any) => globalThis.Boolean(e)) : [],
    };
  },

  toJSON(message: AuthenticationPath): unknown {
    const obj: any = {};
    if (message.value?.length) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticationPath>, I>>(base?: I): AuthenticationPath {
    return AuthenticationPath.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticationPath>, I>>(object: I): AuthenticationPath {
    const message = createBaseAuthenticationPath();
    message.value = object.value?.map((e) => e) || [];
    return message;
  },
};

function createBaseMerklePath(): MerklePath {
  return { authenticationPaths: [], index: [], rt: Buffer.alloc(0) };
}

export const MerklePath = {
  encode(message: MerklePath, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.authenticationPaths) {
      AuthenticationPath.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).fork();
    for (const v of message.index) {
      writer.bool(v);
    }
    writer.ldelim();
    if (message.rt.length !== 0) {
      writer.uint32(26).bytes(message.rt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MerklePath {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMerklePath();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.authenticationPaths.push(AuthenticationPath.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag === 16) {
            message.index.push(reader.bool());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.index.push(reader.bool());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rt = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MerklePath {
    return {
      authenticationPaths: globalThis.Array.isArray(object?.authenticationPaths)
        ? object.authenticationPaths.map((e: any) => AuthenticationPath.fromJSON(e))
        : [],
      index: globalThis.Array.isArray(object?.index) ? object.index.map((e: any) => globalThis.Boolean(e)) : [],
      rt: isSet(object.rt) ? Buffer.from(bytesFromBase64(object.rt)) : Buffer.alloc(0),
    };
  },

  toJSON(message: MerklePath): unknown {
    const obj: any = {};
    if (message.authenticationPaths?.length) {
      obj.authenticationPaths = message.authenticationPaths.map((e) => AuthenticationPath.toJSON(e));
    }
    if (message.index?.length) {
      obj.index = message.index;
    }
    if (message.rt.length !== 0) {
      obj.rt = base64FromBytes(message.rt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MerklePath>, I>>(base?: I): MerklePath {
    return MerklePath.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MerklePath>, I>>(object: I): MerklePath {
    const message = createBaseMerklePath();
    message.authenticationPaths = object.authenticationPaths?.map((e) => AuthenticationPath.fromPartial(e)) || [];
    message.index = object.index?.map((e) => e) || [];
    message.rt = object.rt ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseOutputPoint(): OutputPoint {
  return { hash: Buffer.alloc(0), index: 0 };
}

export const OutputPoint = {
  encode(message: OutputPoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    if (message.index !== 0) {
      writer.uint32(16).int32(message.index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OutputPoint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.index = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputPoint {
    return {
      hash: isSet(object.hash) ? Buffer.from(bytesFromBase64(object.hash)) : Buffer.alloc(0),
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: OutputPoint): unknown {
    const obj: any = {};
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputPoint>, I>>(base?: I): OutputPoint {
    return OutputPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputPoint>, I>>(object: I): OutputPoint {
    const message = createBaseOutputPoint();
    message.hash = object.hash ?? Buffer.alloc(0);
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseOutputPointInfo(): OutputPointInfo {
  return { outPoints: [], blockNum: 0 };
}

export const OutputPointInfo = {
  encode(message: OutputPointInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.outPoints) {
      OutputPoint.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.blockNum !== 0) {
      writer.uint32(16).int32(message.blockNum);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OutputPointInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputPointInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.outPoints.push(OutputPoint.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.blockNum = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputPointInfo {
    return {
      outPoints: globalThis.Array.isArray(object?.outPoints)
        ? object.outPoints.map((e: any) => OutputPoint.fromJSON(e))
        : [],
      blockNum: isSet(object.blockNum) ? globalThis.Number(object.blockNum) : 0,
    };
  },

  toJSON(message: OutputPointInfo): unknown {
    const obj: any = {};
    if (message.outPoints?.length) {
      obj.outPoints = message.outPoints.map((e) => OutputPoint.toJSON(e));
    }
    if (message.blockNum !== 0) {
      obj.blockNum = Math.round(message.blockNum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputPointInfo>, I>>(base?: I): OutputPointInfo {
    return OutputPointInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputPointInfo>, I>>(object: I): OutputPointInfo {
    const message = createBaseOutputPointInfo();
    message.outPoints = object.outPoints?.map((e) => OutputPoint.fromPartial(e)) || [];
    message.blockNum = object.blockNum ?? 0;
    return message;
  },
};

function createBasePedersenHash(): PedersenHash {
  return { content: Buffer.alloc(0) };
}

export const PedersenHash = {
  encode(message: PedersenHash, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.content.length !== 0) {
      writer.uint32(10).bytes(message.content);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PedersenHash {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePedersenHash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PedersenHash {
    return { content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : Buffer.alloc(0) };
  },

  toJSON(message: PedersenHash): unknown {
    const obj: any = {};
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PedersenHash>, I>>(base?: I): PedersenHash {
    return PedersenHash.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PedersenHash>, I>>(object: I): PedersenHash {
    const message = createBasePedersenHash();
    message.content = object.content ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseIncrementalMerkleTree(): IncrementalMerkleTree {
  return { left: undefined, right: undefined, parents: [] };
}

export const IncrementalMerkleTree = {
  encode(message: IncrementalMerkleTree, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.left !== undefined) {
      PedersenHash.encode(message.left, writer.uint32(10).fork()).ldelim();
    }
    if (message.right !== undefined) {
      PedersenHash.encode(message.right, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.parents) {
      PedersenHash.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IncrementalMerkleTree {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncrementalMerkleTree();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.left = PedersenHash.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.right = PedersenHash.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parents.push(PedersenHash.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncrementalMerkleTree {
    return {
      left: isSet(object.left) ? PedersenHash.fromJSON(object.left) : undefined,
      right: isSet(object.right) ? PedersenHash.fromJSON(object.right) : undefined,
      parents: globalThis.Array.isArray(object?.parents)
        ? object.parents.map((e: any) => PedersenHash.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IncrementalMerkleTree): unknown {
    const obj: any = {};
    if (message.left !== undefined) {
      obj.left = PedersenHash.toJSON(message.left);
    }
    if (message.right !== undefined) {
      obj.right = PedersenHash.toJSON(message.right);
    }
    if (message.parents?.length) {
      obj.parents = message.parents.map((e) => PedersenHash.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncrementalMerkleTree>, I>>(base?: I): IncrementalMerkleTree {
    return IncrementalMerkleTree.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncrementalMerkleTree>, I>>(object: I): IncrementalMerkleTree {
    const message = createBaseIncrementalMerkleTree();
    message.left = (object.left !== undefined && object.left !== null)
      ? PedersenHash.fromPartial(object.left)
      : undefined;
    message.right = (object.right !== undefined && object.right !== null)
      ? PedersenHash.fromPartial(object.right)
      : undefined;
    message.parents = object.parents?.map((e) => PedersenHash.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIncrementalMerkleVoucher(): IncrementalMerkleVoucher {
  return {
    tree: undefined,
    filled: [],
    cursor: undefined,
    cursorDepth: Long.ZERO,
    rt: Buffer.alloc(0),
    outputPoint: undefined,
  };
}

export const IncrementalMerkleVoucher = {
  encode(message: IncrementalMerkleVoucher, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tree !== undefined) {
      IncrementalMerkleTree.encode(message.tree, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.filled) {
      PedersenHash.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.cursor !== undefined) {
      IncrementalMerkleTree.encode(message.cursor, writer.uint32(26).fork()).ldelim();
    }
    if (!message.cursorDepth.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.cursorDepth);
    }
    if (message.rt.length !== 0) {
      writer.uint32(42).bytes(message.rt);
    }
    if (message.outputPoint !== undefined) {
      OutputPoint.encode(message.outputPoint, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IncrementalMerkleVoucher {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncrementalMerkleVoucher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tree = IncrementalMerkleTree.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filled.push(PedersenHash.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = IncrementalMerkleTree.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.cursorDepth = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rt = reader.bytes() as Buffer;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.outputPoint = OutputPoint.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncrementalMerkleVoucher {
    return {
      tree: isSet(object.tree) ? IncrementalMerkleTree.fromJSON(object.tree) : undefined,
      filled: globalThis.Array.isArray(object?.filled) ? object.filled.map((e: any) => PedersenHash.fromJSON(e)) : [],
      cursor: isSet(object.cursor) ? IncrementalMerkleTree.fromJSON(object.cursor) : undefined,
      cursorDepth: isSet(object.cursorDepth) ? Long.fromValue(object.cursorDepth) : Long.ZERO,
      rt: isSet(object.rt) ? Buffer.from(bytesFromBase64(object.rt)) : Buffer.alloc(0),
      outputPoint: isSet(object.outputPoint) ? OutputPoint.fromJSON(object.outputPoint) : undefined,
    };
  },

  toJSON(message: IncrementalMerkleVoucher): unknown {
    const obj: any = {};
    if (message.tree !== undefined) {
      obj.tree = IncrementalMerkleTree.toJSON(message.tree);
    }
    if (message.filled?.length) {
      obj.filled = message.filled.map((e) => PedersenHash.toJSON(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = IncrementalMerkleTree.toJSON(message.cursor);
    }
    if (!message.cursorDepth.equals(Long.ZERO)) {
      obj.cursorDepth = (message.cursorDepth || Long.ZERO).toString();
    }
    if (message.rt.length !== 0) {
      obj.rt = base64FromBytes(message.rt);
    }
    if (message.outputPoint !== undefined) {
      obj.outputPoint = OutputPoint.toJSON(message.outputPoint);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncrementalMerkleVoucher>, I>>(base?: I): IncrementalMerkleVoucher {
    return IncrementalMerkleVoucher.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncrementalMerkleVoucher>, I>>(object: I): IncrementalMerkleVoucher {
    const message = createBaseIncrementalMerkleVoucher();
    message.tree = (object.tree !== undefined && object.tree !== null)
      ? IncrementalMerkleTree.fromPartial(object.tree)
      : undefined;
    message.filled = object.filled?.map((e) => PedersenHash.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? IncrementalMerkleTree.fromPartial(object.cursor)
      : undefined;
    message.cursorDepth = (object.cursorDepth !== undefined && object.cursorDepth !== null)
      ? Long.fromValue(object.cursorDepth)
      : Long.ZERO;
    message.rt = object.rt ?? Buffer.alloc(0);
    message.outputPoint = (object.outputPoint !== undefined && object.outputPoint !== null)
      ? OutputPoint.fromPartial(object.outputPoint)
      : undefined;
    return message;
  },
};

function createBaseIncrementalMerkleVoucherInfo(): IncrementalMerkleVoucherInfo {
  return { vouchers: [], paths: [] };
}

export const IncrementalMerkleVoucherInfo = {
  encode(message: IncrementalMerkleVoucherInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.vouchers) {
      IncrementalMerkleVoucher.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.paths) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IncrementalMerkleVoucherInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncrementalMerkleVoucherInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vouchers.push(IncrementalMerkleVoucher.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.paths.push(reader.bytes() as Buffer);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncrementalMerkleVoucherInfo {
    return {
      vouchers: globalThis.Array.isArray(object?.vouchers)
        ? object.vouchers.map((e: any) => IncrementalMerkleVoucher.fromJSON(e))
        : [],
      paths: globalThis.Array.isArray(object?.paths)
        ? object.paths.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
    };
  },

  toJSON(message: IncrementalMerkleVoucherInfo): unknown {
    const obj: any = {};
    if (message.vouchers?.length) {
      obj.vouchers = message.vouchers.map((e) => IncrementalMerkleVoucher.toJSON(e));
    }
    if (message.paths?.length) {
      obj.paths = message.paths.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncrementalMerkleVoucherInfo>, I>>(base?: I): IncrementalMerkleVoucherInfo {
    return IncrementalMerkleVoucherInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncrementalMerkleVoucherInfo>, I>>(object: I): IncrementalMerkleVoucherInfo {
    const message = createBaseIncrementalMerkleVoucherInfo();
    message.vouchers = object.vouchers?.map((e) => IncrementalMerkleVoucher.fromPartial(e)) || [];
    message.paths = object.paths?.map((e) => e) || [];
    return message;
  },
};

function createBaseSpendDescription(): SpendDescription {
  return {
    valueCommitment: Buffer.alloc(0),
    anchor: Buffer.alloc(0),
    nullifier: Buffer.alloc(0),
    rk: Buffer.alloc(0),
    zkproof: Buffer.alloc(0),
    spendAuthoritySignature: Buffer.alloc(0),
  };
}

export const SpendDescription = {
  encode(message: SpendDescription, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.valueCommitment.length !== 0) {
      writer.uint32(10).bytes(message.valueCommitment);
    }
    if (message.anchor.length !== 0) {
      writer.uint32(18).bytes(message.anchor);
    }
    if (message.nullifier.length !== 0) {
      writer.uint32(26).bytes(message.nullifier);
    }
    if (message.rk.length !== 0) {
      writer.uint32(34).bytes(message.rk);
    }
    if (message.zkproof.length !== 0) {
      writer.uint32(42).bytes(message.zkproof);
    }
    if (message.spendAuthoritySignature.length !== 0) {
      writer.uint32(50).bytes(message.spendAuthoritySignature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpendDescription {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpendDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.valueCommitment = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.anchor = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nullifier = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rk = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.zkproof = reader.bytes() as Buffer;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.spendAuthoritySignature = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpendDescription {
    return {
      valueCommitment: isSet(object.valueCommitment)
        ? Buffer.from(bytesFromBase64(object.valueCommitment))
        : Buffer.alloc(0),
      anchor: isSet(object.anchor) ? Buffer.from(bytesFromBase64(object.anchor)) : Buffer.alloc(0),
      nullifier: isSet(object.nullifier) ? Buffer.from(bytesFromBase64(object.nullifier)) : Buffer.alloc(0),
      rk: isSet(object.rk) ? Buffer.from(bytesFromBase64(object.rk)) : Buffer.alloc(0),
      zkproof: isSet(object.zkproof) ? Buffer.from(bytesFromBase64(object.zkproof)) : Buffer.alloc(0),
      spendAuthoritySignature: isSet(object.spendAuthoritySignature)
        ? Buffer.from(bytesFromBase64(object.spendAuthoritySignature))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: SpendDescription): unknown {
    const obj: any = {};
    if (message.valueCommitment.length !== 0) {
      obj.valueCommitment = base64FromBytes(message.valueCommitment);
    }
    if (message.anchor.length !== 0) {
      obj.anchor = base64FromBytes(message.anchor);
    }
    if (message.nullifier.length !== 0) {
      obj.nullifier = base64FromBytes(message.nullifier);
    }
    if (message.rk.length !== 0) {
      obj.rk = base64FromBytes(message.rk);
    }
    if (message.zkproof.length !== 0) {
      obj.zkproof = base64FromBytes(message.zkproof);
    }
    if (message.spendAuthoritySignature.length !== 0) {
      obj.spendAuthoritySignature = base64FromBytes(message.spendAuthoritySignature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpendDescription>, I>>(base?: I): SpendDescription {
    return SpendDescription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpendDescription>, I>>(object: I): SpendDescription {
    const message = createBaseSpendDescription();
    message.valueCommitment = object.valueCommitment ?? Buffer.alloc(0);
    message.anchor = object.anchor ?? Buffer.alloc(0);
    message.nullifier = object.nullifier ?? Buffer.alloc(0);
    message.rk = object.rk ?? Buffer.alloc(0);
    message.zkproof = object.zkproof ?? Buffer.alloc(0);
    message.spendAuthoritySignature = object.spendAuthoritySignature ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseReceiveDescription(): ReceiveDescription {
  return {
    valueCommitment: Buffer.alloc(0),
    noteCommitment: Buffer.alloc(0),
    epk: Buffer.alloc(0),
    cEnc: Buffer.alloc(0),
    cOut: Buffer.alloc(0),
    zkproof: Buffer.alloc(0),
  };
}

export const ReceiveDescription = {
  encode(message: ReceiveDescription, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.valueCommitment.length !== 0) {
      writer.uint32(10).bytes(message.valueCommitment);
    }
    if (message.noteCommitment.length !== 0) {
      writer.uint32(18).bytes(message.noteCommitment);
    }
    if (message.epk.length !== 0) {
      writer.uint32(26).bytes(message.epk);
    }
    if (message.cEnc.length !== 0) {
      writer.uint32(34).bytes(message.cEnc);
    }
    if (message.cOut.length !== 0) {
      writer.uint32(42).bytes(message.cOut);
    }
    if (message.zkproof.length !== 0) {
      writer.uint32(50).bytes(message.zkproof);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReceiveDescription {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceiveDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.valueCommitment = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.noteCommitment = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.epk = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cEnc = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cOut = reader.bytes() as Buffer;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.zkproof = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceiveDescription {
    return {
      valueCommitment: isSet(object.valueCommitment)
        ? Buffer.from(bytesFromBase64(object.valueCommitment))
        : Buffer.alloc(0),
      noteCommitment: isSet(object.noteCommitment)
        ? Buffer.from(bytesFromBase64(object.noteCommitment))
        : Buffer.alloc(0),
      epk: isSet(object.epk) ? Buffer.from(bytesFromBase64(object.epk)) : Buffer.alloc(0),
      cEnc: isSet(object.cEnc) ? Buffer.from(bytesFromBase64(object.cEnc)) : Buffer.alloc(0),
      cOut: isSet(object.cOut) ? Buffer.from(bytesFromBase64(object.cOut)) : Buffer.alloc(0),
      zkproof: isSet(object.zkproof) ? Buffer.from(bytesFromBase64(object.zkproof)) : Buffer.alloc(0),
    };
  },

  toJSON(message: ReceiveDescription): unknown {
    const obj: any = {};
    if (message.valueCommitment.length !== 0) {
      obj.valueCommitment = base64FromBytes(message.valueCommitment);
    }
    if (message.noteCommitment.length !== 0) {
      obj.noteCommitment = base64FromBytes(message.noteCommitment);
    }
    if (message.epk.length !== 0) {
      obj.epk = base64FromBytes(message.epk);
    }
    if (message.cEnc.length !== 0) {
      obj.cEnc = base64FromBytes(message.cEnc);
    }
    if (message.cOut.length !== 0) {
      obj.cOut = base64FromBytes(message.cOut);
    }
    if (message.zkproof.length !== 0) {
      obj.zkproof = base64FromBytes(message.zkproof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceiveDescription>, I>>(base?: I): ReceiveDescription {
    return ReceiveDescription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceiveDescription>, I>>(object: I): ReceiveDescription {
    const message = createBaseReceiveDescription();
    message.valueCommitment = object.valueCommitment ?? Buffer.alloc(0);
    message.noteCommitment = object.noteCommitment ?? Buffer.alloc(0);
    message.epk = object.epk ?? Buffer.alloc(0);
    message.cEnc = object.cEnc ?? Buffer.alloc(0);
    message.cOut = object.cOut ?? Buffer.alloc(0);
    message.zkproof = object.zkproof ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseShieldedTransferContract(): ShieldedTransferContract {
  return {
    transparentFromAddress: Buffer.alloc(0),
    fromAmount: Long.ZERO,
    spendDescription: [],
    receiveDescription: [],
    bindingSignature: Buffer.alloc(0),
    transparentToAddress: Buffer.alloc(0),
    toAmount: Long.ZERO,
  };
}

export const ShieldedTransferContract = {
  encode(message: ShieldedTransferContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.transparentFromAddress.length !== 0) {
      writer.uint32(10).bytes(message.transparentFromAddress);
    }
    if (!message.fromAmount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.fromAmount);
    }
    for (const v of message.spendDescription) {
      SpendDescription.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.receiveDescription) {
      ReceiveDescription.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.bindingSignature.length !== 0) {
      writer.uint32(42).bytes(message.bindingSignature);
    }
    if (message.transparentToAddress.length !== 0) {
      writer.uint32(50).bytes(message.transparentToAddress);
    }
    if (!message.toAmount.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.toAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ShieldedTransferContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShieldedTransferContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transparentFromAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fromAmount = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.spendDescription.push(SpendDescription.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.receiveDescription.push(ReceiveDescription.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bindingSignature = reader.bytes() as Buffer;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transparentToAddress = reader.bytes() as Buffer;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.toAmount = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShieldedTransferContract {
    return {
      transparentFromAddress: isSet(object.transparentFromAddress)
        ? Buffer.from(bytesFromBase64(object.transparentFromAddress))
        : Buffer.alloc(0),
      fromAmount: isSet(object.fromAmount) ? Long.fromValue(object.fromAmount) : Long.ZERO,
      spendDescription: globalThis.Array.isArray(object?.spendDescription)
        ? object.spendDescription.map((e: any) => SpendDescription.fromJSON(e))
        : [],
      receiveDescription: globalThis.Array.isArray(object?.receiveDescription)
        ? object.receiveDescription.map((e: any) => ReceiveDescription.fromJSON(e))
        : [],
      bindingSignature: isSet(object.bindingSignature)
        ? Buffer.from(bytesFromBase64(object.bindingSignature))
        : Buffer.alloc(0),
      transparentToAddress: isSet(object.transparentToAddress)
        ? Buffer.from(bytesFromBase64(object.transparentToAddress))
        : Buffer.alloc(0),
      toAmount: isSet(object.toAmount) ? Long.fromValue(object.toAmount) : Long.ZERO,
    };
  },

  toJSON(message: ShieldedTransferContract): unknown {
    const obj: any = {};
    if (message.transparentFromAddress.length !== 0) {
      obj.transparentFromAddress = base64FromBytes(message.transparentFromAddress);
    }
    if (!message.fromAmount.equals(Long.ZERO)) {
      obj.fromAmount = (message.fromAmount || Long.ZERO).toString();
    }
    if (message.spendDescription?.length) {
      obj.spendDescription = message.spendDescription.map((e) => SpendDescription.toJSON(e));
    }
    if (message.receiveDescription?.length) {
      obj.receiveDescription = message.receiveDescription.map((e) => ReceiveDescription.toJSON(e));
    }
    if (message.bindingSignature.length !== 0) {
      obj.bindingSignature = base64FromBytes(message.bindingSignature);
    }
    if (message.transparentToAddress.length !== 0) {
      obj.transparentToAddress = base64FromBytes(message.transparentToAddress);
    }
    if (!message.toAmount.equals(Long.ZERO)) {
      obj.toAmount = (message.toAmount || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShieldedTransferContract>, I>>(base?: I): ShieldedTransferContract {
    return ShieldedTransferContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShieldedTransferContract>, I>>(object: I): ShieldedTransferContract {
    const message = createBaseShieldedTransferContract();
    message.transparentFromAddress = object.transparentFromAddress ?? Buffer.alloc(0);
    message.fromAmount = (object.fromAmount !== undefined && object.fromAmount !== null)
      ? Long.fromValue(object.fromAmount)
      : Long.ZERO;
    message.spendDescription = object.spendDescription?.map((e) => SpendDescription.fromPartial(e)) || [];
    message.receiveDescription = object.receiveDescription?.map((e) => ReceiveDescription.fromPartial(e)) || [];
    message.bindingSignature = object.bindingSignature ?? Buffer.alloc(0);
    message.transparentToAddress = object.transparentToAddress ?? Buffer.alloc(0);
    message.toAmount = (object.toAmount !== undefined && object.toAmount !== null)
      ? Long.fromValue(object.toAmount)
      : Long.ZERO;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
