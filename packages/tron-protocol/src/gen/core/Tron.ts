// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: core/Tron.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { Any } from "../google/protobuf/any.js";
import { Endpoint } from "./Discover.js";
import { ResourceCode, resourceCodeFromJSON, resourceCodeToJSON } from "./contract/common.js";

export const protobufPackage = "protocol";

export enum AccountType {
  Normal = 0,
  AssetIssue = 1,
  Contract = 2,
  UNRECOGNIZED = -1,
}

export function accountTypeFromJSON(object: any): AccountType {
  switch (object) {
    case 0:
    case "Normal":
      return AccountType.Normal;
    case 1:
    case "AssetIssue":
      return AccountType.AssetIssue;
    case 2:
    case "Contract":
      return AccountType.Contract;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccountType.UNRECOGNIZED;
  }
}

export function accountTypeToJSON(object: AccountType): string {
  switch (object) {
    case AccountType.Normal:
      return "Normal";
    case AccountType.AssetIssue:
      return "AssetIssue";
    case AccountType.Contract:
      return "Contract";
    case AccountType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ReasonCode {
  REQUESTED = 0,
  BAD_PROTOCOL = 2,
  TOO_MANY_PEERS = 4,
  DUPLICATE_PEER = 5,
  INCOMPATIBLE_PROTOCOL = 6,
  RANDOM_ELIMINATION = 7,
  PEER_QUITING = 8,
  UNEXPECTED_IDENTITY = 9,
  LOCAL_IDENTITY = 10,
  PING_TIMEOUT = 11,
  USER_REASON = 16,
  RESET = 17,
  SYNC_FAIL = 18,
  FETCH_FAIL = 19,
  BAD_TX = 20,
  BAD_BLOCK = 21,
  FORKED = 22,
  UNLINKABLE = 23,
  INCOMPATIBLE_VERSION = 24,
  INCOMPATIBLE_CHAIN = 25,
  TIME_OUT = 32,
  CONNECT_FAIL = 33,
  TOO_MANY_PEERS_WITH_SAME_IP = 34,
  LIGHT_NODE_SYNC_FAIL = 35,
  BELOW_THAN_ME = 36,
  NOT_WITNESS = 37,
  NO_SUCH_MESSAGE = 38,
  UNKNOWN = 255,
  UNRECOGNIZED = -1,
}

export function reasonCodeFromJSON(object: any): ReasonCode {
  switch (object) {
    case 0:
    case "REQUESTED":
      return ReasonCode.REQUESTED;
    case 2:
    case "BAD_PROTOCOL":
      return ReasonCode.BAD_PROTOCOL;
    case 4:
    case "TOO_MANY_PEERS":
      return ReasonCode.TOO_MANY_PEERS;
    case 5:
    case "DUPLICATE_PEER":
      return ReasonCode.DUPLICATE_PEER;
    case 6:
    case "INCOMPATIBLE_PROTOCOL":
      return ReasonCode.INCOMPATIBLE_PROTOCOL;
    case 7:
    case "RANDOM_ELIMINATION":
      return ReasonCode.RANDOM_ELIMINATION;
    case 8:
    case "PEER_QUITING":
      return ReasonCode.PEER_QUITING;
    case 9:
    case "UNEXPECTED_IDENTITY":
      return ReasonCode.UNEXPECTED_IDENTITY;
    case 10:
    case "LOCAL_IDENTITY":
      return ReasonCode.LOCAL_IDENTITY;
    case 11:
    case "PING_TIMEOUT":
      return ReasonCode.PING_TIMEOUT;
    case 16:
    case "USER_REASON":
      return ReasonCode.USER_REASON;
    case 17:
    case "RESET":
      return ReasonCode.RESET;
    case 18:
    case "SYNC_FAIL":
      return ReasonCode.SYNC_FAIL;
    case 19:
    case "FETCH_FAIL":
      return ReasonCode.FETCH_FAIL;
    case 20:
    case "BAD_TX":
      return ReasonCode.BAD_TX;
    case 21:
    case "BAD_BLOCK":
      return ReasonCode.BAD_BLOCK;
    case 22:
    case "FORKED":
      return ReasonCode.FORKED;
    case 23:
    case "UNLINKABLE":
      return ReasonCode.UNLINKABLE;
    case 24:
    case "INCOMPATIBLE_VERSION":
      return ReasonCode.INCOMPATIBLE_VERSION;
    case 25:
    case "INCOMPATIBLE_CHAIN":
      return ReasonCode.INCOMPATIBLE_CHAIN;
    case 32:
    case "TIME_OUT":
      return ReasonCode.TIME_OUT;
    case 33:
    case "CONNECT_FAIL":
      return ReasonCode.CONNECT_FAIL;
    case 34:
    case "TOO_MANY_PEERS_WITH_SAME_IP":
      return ReasonCode.TOO_MANY_PEERS_WITH_SAME_IP;
    case 35:
    case "LIGHT_NODE_SYNC_FAIL":
      return ReasonCode.LIGHT_NODE_SYNC_FAIL;
    case 36:
    case "BELOW_THAN_ME":
      return ReasonCode.BELOW_THAN_ME;
    case 37:
    case "NOT_WITNESS":
      return ReasonCode.NOT_WITNESS;
    case 38:
    case "NO_SUCH_MESSAGE":
      return ReasonCode.NO_SUCH_MESSAGE;
    case 255:
    case "UNKNOWN":
      return ReasonCode.UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReasonCode.UNRECOGNIZED;
  }
}

export function reasonCodeToJSON(object: ReasonCode): string {
  switch (object) {
    case ReasonCode.REQUESTED:
      return "REQUESTED";
    case ReasonCode.BAD_PROTOCOL:
      return "BAD_PROTOCOL";
    case ReasonCode.TOO_MANY_PEERS:
      return "TOO_MANY_PEERS";
    case ReasonCode.DUPLICATE_PEER:
      return "DUPLICATE_PEER";
    case ReasonCode.INCOMPATIBLE_PROTOCOL:
      return "INCOMPATIBLE_PROTOCOL";
    case ReasonCode.RANDOM_ELIMINATION:
      return "RANDOM_ELIMINATION";
    case ReasonCode.PEER_QUITING:
      return "PEER_QUITING";
    case ReasonCode.UNEXPECTED_IDENTITY:
      return "UNEXPECTED_IDENTITY";
    case ReasonCode.LOCAL_IDENTITY:
      return "LOCAL_IDENTITY";
    case ReasonCode.PING_TIMEOUT:
      return "PING_TIMEOUT";
    case ReasonCode.USER_REASON:
      return "USER_REASON";
    case ReasonCode.RESET:
      return "RESET";
    case ReasonCode.SYNC_FAIL:
      return "SYNC_FAIL";
    case ReasonCode.FETCH_FAIL:
      return "FETCH_FAIL";
    case ReasonCode.BAD_TX:
      return "BAD_TX";
    case ReasonCode.BAD_BLOCK:
      return "BAD_BLOCK";
    case ReasonCode.FORKED:
      return "FORKED";
    case ReasonCode.UNLINKABLE:
      return "UNLINKABLE";
    case ReasonCode.INCOMPATIBLE_VERSION:
      return "INCOMPATIBLE_VERSION";
    case ReasonCode.INCOMPATIBLE_CHAIN:
      return "INCOMPATIBLE_CHAIN";
    case ReasonCode.TIME_OUT:
      return "TIME_OUT";
    case ReasonCode.CONNECT_FAIL:
      return "CONNECT_FAIL";
    case ReasonCode.TOO_MANY_PEERS_WITH_SAME_IP:
      return "TOO_MANY_PEERS_WITH_SAME_IP";
    case ReasonCode.LIGHT_NODE_SYNC_FAIL:
      return "LIGHT_NODE_SYNC_FAIL";
    case ReasonCode.BELOW_THAN_ME:
      return "BELOW_THAN_ME";
    case ReasonCode.NOT_WITNESS:
      return "NOT_WITNESS";
    case ReasonCode.NO_SUCH_MESSAGE:
      return "NO_SUCH_MESSAGE";
    case ReasonCode.UNKNOWN:
      return "UNKNOWN";
    case ReasonCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** AccountId, (name, address) use name, (null, address) use address, (name, null) use name, */
export interface AccountId {
  name: Buffer;
  address: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

/** vote message */
export interface Vote {
  /** the super rep address */
  voteAddress: Buffer;
  /** the vote num to this super rep. */
  voteCount: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

/** Proposal */
export interface Proposal {
  proposalId: Long;
  proposerAddress: Buffer;
  parameters: Map<Long, Long>;
  expirationTime: Long;
  createTime: Long;
  approvals: Buffer[];
  state: Proposal_State;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export enum Proposal_State {
  PENDING = 0,
  DISAPPROVED = 1,
  APPROVED = 2,
  CANCELED = 3,
  UNRECOGNIZED = -1,
}

export function proposal_StateFromJSON(object: any): Proposal_State {
  switch (object) {
    case 0:
    case "PENDING":
      return Proposal_State.PENDING;
    case 1:
    case "DISAPPROVED":
      return Proposal_State.DISAPPROVED;
    case 2:
    case "APPROVED":
      return Proposal_State.APPROVED;
    case 3:
    case "CANCELED":
      return Proposal_State.CANCELED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Proposal_State.UNRECOGNIZED;
  }
}

export function proposal_StateToJSON(object: Proposal_State): string {
  switch (object) {
    case Proposal_State.PENDING:
      return "PENDING";
    case Proposal_State.DISAPPROVED:
      return "DISAPPROVED";
    case Proposal_State.APPROVED:
      return "APPROVED";
    case Proposal_State.CANCELED:
      return "CANCELED";
    case Proposal_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Proposal_ParametersEntry {
  key: Long;
  value: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

/** Exchange */
export interface Exchange {
  exchangeId: Long;
  creatorAddress: Buffer;
  createTime: Long;
  firstTokenId: Buffer;
  firstTokenBalance: Long;
  secondTokenId: Buffer;
  secondTokenBalance: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

/** market */
export interface MarketOrder {
  orderId: Buffer;
  ownerAddress: Buffer;
  createTime: Long;
  sellTokenId: Buffer;
  sellTokenQuantity: Long;
  buyTokenId: Buffer;
  /** min to receive */
  buyTokenQuantity: Long;
  sellTokenQuantityRemain: Long;
  /**
   * When state != ACTIVE and sell_token_quantity_return !=0,
   * it means that some sell tokens are returned to the account due to insufficient remaining amount
   */
  sellTokenQuantityReturn: Long;
  state: MarketOrder_State;
  prev: Buffer;
  next: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export enum MarketOrder_State {
  ACTIVE = 0,
  INACTIVE = 1,
  CANCELED = 2,
  UNRECOGNIZED = -1,
}

export function marketOrder_StateFromJSON(object: any): MarketOrder_State {
  switch (object) {
    case 0:
    case "ACTIVE":
      return MarketOrder_State.ACTIVE;
    case 1:
    case "INACTIVE":
      return MarketOrder_State.INACTIVE;
    case 2:
    case "CANCELED":
      return MarketOrder_State.CANCELED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MarketOrder_State.UNRECOGNIZED;
  }
}

export function marketOrder_StateToJSON(object: MarketOrder_State): string {
  switch (object) {
    case MarketOrder_State.ACTIVE:
      return "ACTIVE";
    case MarketOrder_State.INACTIVE:
      return "INACTIVE";
    case MarketOrder_State.CANCELED:
      return "CANCELED";
    case MarketOrder_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface MarketOrderList {
  orders: MarketOrder[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MarketOrderPairList {
  orderPair: MarketOrderPair[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MarketOrderPair {
  sellTokenId: Buffer;
  buyTokenId: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MarketAccountOrder {
  ownerAddress: Buffer;
  /** order_id list */
  orders: Buffer[];
  /** active count */
  count: Long;
  totalCount: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MarketPrice {
  sellTokenQuantity: Long;
  buyTokenQuantity: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MarketPriceList {
  sellTokenId: Buffer;
  buyTokenId: Buffer;
  prices: MarketPrice[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MarketOrderIdList {
  head: Buffer;
  tail: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ChainParameters {
  chainParameter: ChainParameters_ChainParameter[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ChainParameters_ChainParameter {
  key: string;
  value: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

/** Account */
export interface Account {
  /** account nick name */
  accountName: Buffer;
  type: AccountType;
  /** the create address */
  address: Buffer;
  /** the trx balance */
  balance: Long;
  /** the votes */
  votes: Vote[];
  /** the other asset owned by this account */
  asset: { [key: string]: Long };
  /** the other asset owned by this accountï¼Œkey is assetId */
  assetV2: { [key: string]: Long };
  /** the frozen balance for bandwidth */
  frozen: Account_Frozen[];
  /** bandwidth, get from frozen */
  netUsage: Long;
  /** Frozen balance provided by other accounts to this account */
  acquiredDelegatedFrozenBalanceForBandwidth: Long;
  /** Freeze and provide balances to other accounts */
  delegatedFrozenBalanceForBandwidth: Long;
  oldTronPower: Long;
  tronPower: Account_Frozen | undefined;
  assetOptimized: boolean;
  /** this account create time */
  createTime: Long;
  /** this last operation time, including transfer, voting and so on. //FIXME fix grammar */
  latestOprationTime: Long;
  /** witness block producing allowance */
  allowance: Long;
  /** last withdraw time */
  latestWithdrawTime: Long;
  /** not used so far */
  code: Buffer;
  isWitness: boolean;
  isCommittee: boolean;
  /** frozen asset(for asset issuer) */
  frozenSupply: Account_Frozen[];
  /** asset_issued_name */
  assetIssuedName: Buffer;
  assetIssuedID: Buffer;
  latestAssetOperationTime: { [key: string]: Long };
  latestAssetOperationTimeV2: { [key: string]: Long };
  freeNetUsage: Long;
  freeAssetNetUsage: { [key: string]: Long };
  freeAssetNetUsageV2: { [key: string]: Long };
  latestConsumeTime: Long;
  latestConsumeFreeTime: Long;
  /** the identity of this account, case insensitive */
  accountId: Buffer;
  netWindowSize: Long;
  netWindowOptimized: boolean;
  accountResource: Account_AccountResource | undefined;
  codeHash: Buffer;
  ownerPermission: Permission | undefined;
  witnessPermission: Permission | undefined;
  activePermission: Permission[];
  frozenV2: Account_FreezeV2[];
  unfrozenV2: Account_UnFreezeV2[];
  delegatedFrozenV2BalanceForBandwidth: Long;
  acquiredDelegatedFrozenV2BalanceForBandwidth: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

/** frozen balance */
export interface Account_Frozen {
  /** the frozen trx balance */
  frozenBalance: Long;
  /** the expire time */
  expireTime: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Account_AssetEntry {
  key: string;
  value: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Account_AssetV2Entry {
  key: string;
  value: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Account_LatestAssetOperationTimeEntry {
  key: string;
  value: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Account_LatestAssetOperationTimeV2Entry {
  key: string;
  value: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Account_FreeAssetNetUsageEntry {
  key: string;
  value: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Account_FreeAssetNetUsageV2Entry {
  key: string;
  value: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Account_AccountResource {
  /** energy resource, get from frozen */
  energyUsage: Long;
  /** the frozen balance for energy */
  frozenBalanceForEnergy: Account_Frozen | undefined;
  latestConsumeTimeForEnergy: Long;
  /** Frozen balance provided by other accounts to this account */
  acquiredDelegatedFrozenBalanceForEnergy: Long;
  /** Frozen balances provided to other accounts */
  delegatedFrozenBalanceForEnergy: Long;
  /** storage resource, get from market */
  storageLimit: Long;
  storageUsage: Long;
  latestExchangeStorageTime: Long;
  energyWindowSize: Long;
  delegatedFrozenV2BalanceForEnergy: Long;
  acquiredDelegatedFrozenV2BalanceForEnergy: Long;
  energyWindowOptimized: boolean;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Account_FreezeV2 {
  type: ResourceCode;
  amount: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Account_UnFreezeV2 {
  type: ResourceCode;
  unfreezeAmount: Long;
  unfreezeExpireTime: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Key {
  address: Buffer;
  weight: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface DelegatedResource {
  from: Buffer;
  to: Buffer;
  frozenBalanceForBandwidth: Long;
  frozenBalanceForEnergy: Long;
  expireTimeForBandwidth: Long;
  expireTimeForEnergy: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface authority {
  account: AccountId | undefined;
  permissionName: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Permission {
  type: Permission_PermissionType;
  /** Owner id=0, Witness id=1, Active id start by 2 */
  id: number;
  permissionName: string;
  threshold: Long;
  parentId: number;
  /** 1 bit 1 contract */
  operations: Buffer;
  keys: Key[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export enum Permission_PermissionType {
  Owner = 0,
  Witness = 1,
  Active = 2,
  UNRECOGNIZED = -1,
}

export function permission_PermissionTypeFromJSON(object: any): Permission_PermissionType {
  switch (object) {
    case 0:
    case "Owner":
      return Permission_PermissionType.Owner;
    case 1:
    case "Witness":
      return Permission_PermissionType.Witness;
    case 2:
    case "Active":
      return Permission_PermissionType.Active;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Permission_PermissionType.UNRECOGNIZED;
  }
}

export function permission_PermissionTypeToJSON(object: Permission_PermissionType): string {
  switch (object) {
    case Permission_PermissionType.Owner:
      return "Owner";
    case Permission_PermissionType.Witness:
      return "Witness";
    case Permission_PermissionType.Active:
      return "Active";
    case Permission_PermissionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Witness */
export interface Witness {
  address: Buffer;
  voteCount: Long;
  pubKey: Buffer;
  url: string;
  totalProduced: Long;
  totalMissed: Long;
  latestBlockNum: Long;
  latestSlotNum: Long;
  isJobs: boolean;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

/** Vote Change */
export interface Votes {
  address: Buffer;
  oldVotes: Vote[];
  newVotes: Vote[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TXOutput {
  value: Long;
  pubKeyHash: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TXInput {
  rawData: TXInput_raw | undefined;
  signature: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TXInput_raw {
  txID: Buffer;
  vout: Long;
  pubKey: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TXOutputs {
  outputs: TXOutput[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ResourceReceipt {
  energyUsage: Long;
  energyFee: Long;
  originEnergyUsage: Long;
  energyUsageTotal: Long;
  netUsage: Long;
  netFee: Long;
  result: Transaction_Result_contractResult;
  energyPenaltyTotal: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MarketOrderDetail {
  makerOrderId: Buffer;
  takerOrderId: Buffer;
  fillSellQuantity: Long;
  fillBuyQuantity: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Transaction {
  rawData:
    | Transaction_raw
    | undefined;
  /** only support size = 1,  repeated list here for muti-sig extension */
  signature: Buffer[];
  ret: Transaction_Result[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Transaction_Contract {
  type: Transaction_Contract_ContractType;
  parameter: Any | undefined;
  provider: Buffer;
  ContractName: Buffer;
  PermissionId: number;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export enum Transaction_Contract_ContractType {
  AccountCreateContract = 0,
  TransferContract = 1,
  TransferAssetContract = 2,
  VoteAssetContract = 3,
  VoteWitnessContract = 4,
  WitnessCreateContract = 5,
  AssetIssueContract = 6,
  WitnessUpdateContract = 8,
  ParticipateAssetIssueContract = 9,
  AccountUpdateContract = 10,
  FreezeBalanceContract = 11,
  UnfreezeBalanceContract = 12,
  WithdrawBalanceContract = 13,
  UnfreezeAssetContract = 14,
  UpdateAssetContract = 15,
  ProposalCreateContract = 16,
  ProposalApproveContract = 17,
  ProposalDeleteContract = 18,
  SetAccountIdContract = 19,
  CustomContract = 20,
  CreateSmartContract = 30,
  TriggerSmartContract = 31,
  GetContract = 32,
  UpdateSettingContract = 33,
  ExchangeCreateContract = 41,
  ExchangeInjectContract = 42,
  ExchangeWithdrawContract = 43,
  ExchangeTransactionContract = 44,
  UpdateEnergyLimitContract = 45,
  AccountPermissionUpdateContract = 46,
  ClearABIContract = 48,
  UpdateBrokerageContract = 49,
  ShieldedTransferContract = 51,
  MarketSellAssetContract = 52,
  MarketCancelOrderContract = 53,
  FreezeBalanceV2Contract = 54,
  UnfreezeBalanceV2Contract = 55,
  WithdrawExpireUnfreezeContract = 56,
  DelegateResourceContract = 57,
  UnDelegateResourceContract = 58,
  CancelAllUnfreezeV2Contract = 59,
  UNRECOGNIZED = -1,
}

export function transaction_Contract_ContractTypeFromJSON(object: any): Transaction_Contract_ContractType {
  switch (object) {
    case 0:
    case "AccountCreateContract":
      return Transaction_Contract_ContractType.AccountCreateContract;
    case 1:
    case "TransferContract":
      return Transaction_Contract_ContractType.TransferContract;
    case 2:
    case "TransferAssetContract":
      return Transaction_Contract_ContractType.TransferAssetContract;
    case 3:
    case "VoteAssetContract":
      return Transaction_Contract_ContractType.VoteAssetContract;
    case 4:
    case "VoteWitnessContract":
      return Transaction_Contract_ContractType.VoteWitnessContract;
    case 5:
    case "WitnessCreateContract":
      return Transaction_Contract_ContractType.WitnessCreateContract;
    case 6:
    case "AssetIssueContract":
      return Transaction_Contract_ContractType.AssetIssueContract;
    case 8:
    case "WitnessUpdateContract":
      return Transaction_Contract_ContractType.WitnessUpdateContract;
    case 9:
    case "ParticipateAssetIssueContract":
      return Transaction_Contract_ContractType.ParticipateAssetIssueContract;
    case 10:
    case "AccountUpdateContract":
      return Transaction_Contract_ContractType.AccountUpdateContract;
    case 11:
    case "FreezeBalanceContract":
      return Transaction_Contract_ContractType.FreezeBalanceContract;
    case 12:
    case "UnfreezeBalanceContract":
      return Transaction_Contract_ContractType.UnfreezeBalanceContract;
    case 13:
    case "WithdrawBalanceContract":
      return Transaction_Contract_ContractType.WithdrawBalanceContract;
    case 14:
    case "UnfreezeAssetContract":
      return Transaction_Contract_ContractType.UnfreezeAssetContract;
    case 15:
    case "UpdateAssetContract":
      return Transaction_Contract_ContractType.UpdateAssetContract;
    case 16:
    case "ProposalCreateContract":
      return Transaction_Contract_ContractType.ProposalCreateContract;
    case 17:
    case "ProposalApproveContract":
      return Transaction_Contract_ContractType.ProposalApproveContract;
    case 18:
    case "ProposalDeleteContract":
      return Transaction_Contract_ContractType.ProposalDeleteContract;
    case 19:
    case "SetAccountIdContract":
      return Transaction_Contract_ContractType.SetAccountIdContract;
    case 20:
    case "CustomContract":
      return Transaction_Contract_ContractType.CustomContract;
    case 30:
    case "CreateSmartContract":
      return Transaction_Contract_ContractType.CreateSmartContract;
    case 31:
    case "TriggerSmartContract":
      return Transaction_Contract_ContractType.TriggerSmartContract;
    case 32:
    case "GetContract":
      return Transaction_Contract_ContractType.GetContract;
    case 33:
    case "UpdateSettingContract":
      return Transaction_Contract_ContractType.UpdateSettingContract;
    case 41:
    case "ExchangeCreateContract":
      return Transaction_Contract_ContractType.ExchangeCreateContract;
    case 42:
    case "ExchangeInjectContract":
      return Transaction_Contract_ContractType.ExchangeInjectContract;
    case 43:
    case "ExchangeWithdrawContract":
      return Transaction_Contract_ContractType.ExchangeWithdrawContract;
    case 44:
    case "ExchangeTransactionContract":
      return Transaction_Contract_ContractType.ExchangeTransactionContract;
    case 45:
    case "UpdateEnergyLimitContract":
      return Transaction_Contract_ContractType.UpdateEnergyLimitContract;
    case 46:
    case "AccountPermissionUpdateContract":
      return Transaction_Contract_ContractType.AccountPermissionUpdateContract;
    case 48:
    case "ClearABIContract":
      return Transaction_Contract_ContractType.ClearABIContract;
    case 49:
    case "UpdateBrokerageContract":
      return Transaction_Contract_ContractType.UpdateBrokerageContract;
    case 51:
    case "ShieldedTransferContract":
      return Transaction_Contract_ContractType.ShieldedTransferContract;
    case 52:
    case "MarketSellAssetContract":
      return Transaction_Contract_ContractType.MarketSellAssetContract;
    case 53:
    case "MarketCancelOrderContract":
      return Transaction_Contract_ContractType.MarketCancelOrderContract;
    case 54:
    case "FreezeBalanceV2Contract":
      return Transaction_Contract_ContractType.FreezeBalanceV2Contract;
    case 55:
    case "UnfreezeBalanceV2Contract":
      return Transaction_Contract_ContractType.UnfreezeBalanceV2Contract;
    case 56:
    case "WithdrawExpireUnfreezeContract":
      return Transaction_Contract_ContractType.WithdrawExpireUnfreezeContract;
    case 57:
    case "DelegateResourceContract":
      return Transaction_Contract_ContractType.DelegateResourceContract;
    case 58:
    case "UnDelegateResourceContract":
      return Transaction_Contract_ContractType.UnDelegateResourceContract;
    case 59:
    case "CancelAllUnfreezeV2Contract":
      return Transaction_Contract_ContractType.CancelAllUnfreezeV2Contract;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Transaction_Contract_ContractType.UNRECOGNIZED;
  }
}

export function transaction_Contract_ContractTypeToJSON(object: Transaction_Contract_ContractType): string {
  switch (object) {
    case Transaction_Contract_ContractType.AccountCreateContract:
      return "AccountCreateContract";
    case Transaction_Contract_ContractType.TransferContract:
      return "TransferContract";
    case Transaction_Contract_ContractType.TransferAssetContract:
      return "TransferAssetContract";
    case Transaction_Contract_ContractType.VoteAssetContract:
      return "VoteAssetContract";
    case Transaction_Contract_ContractType.VoteWitnessContract:
      return "VoteWitnessContract";
    case Transaction_Contract_ContractType.WitnessCreateContract:
      return "WitnessCreateContract";
    case Transaction_Contract_ContractType.AssetIssueContract:
      return "AssetIssueContract";
    case Transaction_Contract_ContractType.WitnessUpdateContract:
      return "WitnessUpdateContract";
    case Transaction_Contract_ContractType.ParticipateAssetIssueContract:
      return "ParticipateAssetIssueContract";
    case Transaction_Contract_ContractType.AccountUpdateContract:
      return "AccountUpdateContract";
    case Transaction_Contract_ContractType.FreezeBalanceContract:
      return "FreezeBalanceContract";
    case Transaction_Contract_ContractType.UnfreezeBalanceContract:
      return "UnfreezeBalanceContract";
    case Transaction_Contract_ContractType.WithdrawBalanceContract:
      return "WithdrawBalanceContract";
    case Transaction_Contract_ContractType.UnfreezeAssetContract:
      return "UnfreezeAssetContract";
    case Transaction_Contract_ContractType.UpdateAssetContract:
      return "UpdateAssetContract";
    case Transaction_Contract_ContractType.ProposalCreateContract:
      return "ProposalCreateContract";
    case Transaction_Contract_ContractType.ProposalApproveContract:
      return "ProposalApproveContract";
    case Transaction_Contract_ContractType.ProposalDeleteContract:
      return "ProposalDeleteContract";
    case Transaction_Contract_ContractType.SetAccountIdContract:
      return "SetAccountIdContract";
    case Transaction_Contract_ContractType.CustomContract:
      return "CustomContract";
    case Transaction_Contract_ContractType.CreateSmartContract:
      return "CreateSmartContract";
    case Transaction_Contract_ContractType.TriggerSmartContract:
      return "TriggerSmartContract";
    case Transaction_Contract_ContractType.GetContract:
      return "GetContract";
    case Transaction_Contract_ContractType.UpdateSettingContract:
      return "UpdateSettingContract";
    case Transaction_Contract_ContractType.ExchangeCreateContract:
      return "ExchangeCreateContract";
    case Transaction_Contract_ContractType.ExchangeInjectContract:
      return "ExchangeInjectContract";
    case Transaction_Contract_ContractType.ExchangeWithdrawContract:
      return "ExchangeWithdrawContract";
    case Transaction_Contract_ContractType.ExchangeTransactionContract:
      return "ExchangeTransactionContract";
    case Transaction_Contract_ContractType.UpdateEnergyLimitContract:
      return "UpdateEnergyLimitContract";
    case Transaction_Contract_ContractType.AccountPermissionUpdateContract:
      return "AccountPermissionUpdateContract";
    case Transaction_Contract_ContractType.ClearABIContract:
      return "ClearABIContract";
    case Transaction_Contract_ContractType.UpdateBrokerageContract:
      return "UpdateBrokerageContract";
    case Transaction_Contract_ContractType.ShieldedTransferContract:
      return "ShieldedTransferContract";
    case Transaction_Contract_ContractType.MarketSellAssetContract:
      return "MarketSellAssetContract";
    case Transaction_Contract_ContractType.MarketCancelOrderContract:
      return "MarketCancelOrderContract";
    case Transaction_Contract_ContractType.FreezeBalanceV2Contract:
      return "FreezeBalanceV2Contract";
    case Transaction_Contract_ContractType.UnfreezeBalanceV2Contract:
      return "UnfreezeBalanceV2Contract";
    case Transaction_Contract_ContractType.WithdrawExpireUnfreezeContract:
      return "WithdrawExpireUnfreezeContract";
    case Transaction_Contract_ContractType.DelegateResourceContract:
      return "DelegateResourceContract";
    case Transaction_Contract_ContractType.UnDelegateResourceContract:
      return "UnDelegateResourceContract";
    case Transaction_Contract_ContractType.CancelAllUnfreezeV2Contract:
      return "CancelAllUnfreezeV2Contract";
    case Transaction_Contract_ContractType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Transaction_Result {
  fee: Long;
  ret: Transaction_Result_code;
  contractRet: Transaction_Result_contractResult;
  assetIssueID: string;
  withdrawAmount: Long;
  unfreezeAmount: Long;
  exchangeReceivedAmount: Long;
  exchangeInjectAnotherAmount: Long;
  exchangeWithdrawAnotherAmount: Long;
  exchangeId: Long;
  shieldedTransactionFee: Long;
  orderId: Buffer;
  orderDetails: MarketOrderDetail[];
  withdrawExpireAmount: Long;
  cancelUnfreezeV2Amount: { [key: string]: Long };
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export enum Transaction_Result_code {
  SUCESS = 0,
  FAILED = 1,
  UNRECOGNIZED = -1,
}

export function transaction_Result_codeFromJSON(object: any): Transaction_Result_code {
  switch (object) {
    case 0:
    case "SUCESS":
      return Transaction_Result_code.SUCESS;
    case 1:
    case "FAILED":
      return Transaction_Result_code.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Transaction_Result_code.UNRECOGNIZED;
  }
}

export function transaction_Result_codeToJSON(object: Transaction_Result_code): string {
  switch (object) {
    case Transaction_Result_code.SUCESS:
      return "SUCESS";
    case Transaction_Result_code.FAILED:
      return "FAILED";
    case Transaction_Result_code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Transaction_Result_contractResult {
  DEFAULT = 0,
  SUCCESS = 1,
  REVERT = 2,
  BAD_JUMP_DESTINATION = 3,
  OUT_OF_MEMORY = 4,
  PRECOMPILED_CONTRACT = 5,
  STACK_TOO_SMALL = 6,
  STACK_TOO_LARGE = 7,
  ILLEGAL_OPERATION = 8,
  STACK_OVERFLOW = 9,
  OUT_OF_ENERGY = 10,
  OUT_OF_TIME = 11,
  JVM_STACK_OVER_FLOW = 12,
  UNKNOWN = 13,
  TRANSFER_FAILED = 14,
  /** INVALID_CODE - please fill in the order according to the serial number */
  INVALID_CODE = 15,
  UNRECOGNIZED = -1,
}

export function transaction_Result_contractResultFromJSON(object: any): Transaction_Result_contractResult {
  switch (object) {
    case 0:
    case "DEFAULT":
      return Transaction_Result_contractResult.DEFAULT;
    case 1:
    case "SUCCESS":
      return Transaction_Result_contractResult.SUCCESS;
    case 2:
    case "REVERT":
      return Transaction_Result_contractResult.REVERT;
    case 3:
    case "BAD_JUMP_DESTINATION":
      return Transaction_Result_contractResult.BAD_JUMP_DESTINATION;
    case 4:
    case "OUT_OF_MEMORY":
      return Transaction_Result_contractResult.OUT_OF_MEMORY;
    case 5:
    case "PRECOMPILED_CONTRACT":
      return Transaction_Result_contractResult.PRECOMPILED_CONTRACT;
    case 6:
    case "STACK_TOO_SMALL":
      return Transaction_Result_contractResult.STACK_TOO_SMALL;
    case 7:
    case "STACK_TOO_LARGE":
      return Transaction_Result_contractResult.STACK_TOO_LARGE;
    case 8:
    case "ILLEGAL_OPERATION":
      return Transaction_Result_contractResult.ILLEGAL_OPERATION;
    case 9:
    case "STACK_OVERFLOW":
      return Transaction_Result_contractResult.STACK_OVERFLOW;
    case 10:
    case "OUT_OF_ENERGY":
      return Transaction_Result_contractResult.OUT_OF_ENERGY;
    case 11:
    case "OUT_OF_TIME":
      return Transaction_Result_contractResult.OUT_OF_TIME;
    case 12:
    case "JVM_STACK_OVER_FLOW":
      return Transaction_Result_contractResult.JVM_STACK_OVER_FLOW;
    case 13:
    case "UNKNOWN":
      return Transaction_Result_contractResult.UNKNOWN;
    case 14:
    case "TRANSFER_FAILED":
      return Transaction_Result_contractResult.TRANSFER_FAILED;
    case 15:
    case "INVALID_CODE":
      return Transaction_Result_contractResult.INVALID_CODE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Transaction_Result_contractResult.UNRECOGNIZED;
  }
}

export function transaction_Result_contractResultToJSON(object: Transaction_Result_contractResult): string {
  switch (object) {
    case Transaction_Result_contractResult.DEFAULT:
      return "DEFAULT";
    case Transaction_Result_contractResult.SUCCESS:
      return "SUCCESS";
    case Transaction_Result_contractResult.REVERT:
      return "REVERT";
    case Transaction_Result_contractResult.BAD_JUMP_DESTINATION:
      return "BAD_JUMP_DESTINATION";
    case Transaction_Result_contractResult.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case Transaction_Result_contractResult.PRECOMPILED_CONTRACT:
      return "PRECOMPILED_CONTRACT";
    case Transaction_Result_contractResult.STACK_TOO_SMALL:
      return "STACK_TOO_SMALL";
    case Transaction_Result_contractResult.STACK_TOO_LARGE:
      return "STACK_TOO_LARGE";
    case Transaction_Result_contractResult.ILLEGAL_OPERATION:
      return "ILLEGAL_OPERATION";
    case Transaction_Result_contractResult.STACK_OVERFLOW:
      return "STACK_OVERFLOW";
    case Transaction_Result_contractResult.OUT_OF_ENERGY:
      return "OUT_OF_ENERGY";
    case Transaction_Result_contractResult.OUT_OF_TIME:
      return "OUT_OF_TIME";
    case Transaction_Result_contractResult.JVM_STACK_OVER_FLOW:
      return "JVM_STACK_OVER_FLOW";
    case Transaction_Result_contractResult.UNKNOWN:
      return "UNKNOWN";
    case Transaction_Result_contractResult.TRANSFER_FAILED:
      return "TRANSFER_FAILED";
    case Transaction_Result_contractResult.INVALID_CODE:
      return "INVALID_CODE";
    case Transaction_Result_contractResult.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Transaction_Result_CancelUnfreezeV2AmountEntry {
  key: string;
  value: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Transaction_raw {
  refBlockBytes: Buffer;
  refBlockNum: Long;
  refBlockHash: Buffer;
  expiration: Long;
  auths: authority[];
  /** data not used */
  data: Buffer;
  /** only support size = 1,  repeated list here for extension */
  contract: Transaction_Contract[];
  /** scripts not used */
  scripts: Buffer;
  timestamp: Long;
  feeLimit: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TransactionInfo {
  id: Buffer;
  fee: Long;
  blockNumber: Long;
  blockTimeStamp: Long;
  contractResult: Buffer[];
  contractAddress: Buffer;
  receipt: ResourceReceipt | undefined;
  log: TransactionInfo_Log[];
  result: TransactionInfo_code;
  resMessage: Buffer;
  assetIssueID: string;
  withdrawAmount: Long;
  unfreezeAmount: Long;
  internalTransactions: InternalTransaction[];
  exchangeReceivedAmount: Long;
  exchangeInjectAnotherAmount: Long;
  exchangeWithdrawAnotherAmount: Long;
  exchangeId: Long;
  shieldedTransactionFee: Long;
  orderId: Buffer;
  orderDetails: MarketOrderDetail[];
  packingFee: Long;
  withdrawExpireAmount: Long;
  cancelUnfreezeV2Amount: { [key: string]: Long };
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export enum TransactionInfo_code {
  SUCESS = 0,
  FAILED = 1,
  UNRECOGNIZED = -1,
}

export function transactionInfo_codeFromJSON(object: any): TransactionInfo_code {
  switch (object) {
    case 0:
    case "SUCESS":
      return TransactionInfo_code.SUCESS;
    case 1:
    case "FAILED":
      return TransactionInfo_code.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionInfo_code.UNRECOGNIZED;
  }
}

export function transactionInfo_codeToJSON(object: TransactionInfo_code): string {
  switch (object) {
    case TransactionInfo_code.SUCESS:
      return "SUCESS";
    case TransactionInfo_code.FAILED:
      return "FAILED";
    case TransactionInfo_code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TransactionInfo_Log {
  address: Buffer;
  topics: Buffer[];
  data: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TransactionInfo_CancelUnfreezeV2AmountEntry {
  key: string;
  value: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface TransactionRet {
  blockNumber: Long;
  blockTimeStamp: Long;
  transactioninfo: TransactionInfo[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Transactions {
  transactions: Transaction[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface BlockHeader {
  rawData: BlockHeader_raw | undefined;
  witnessSignature: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface BlockHeader_raw {
  timestamp: Long;
  txTrieRoot: Buffer;
  parentHash: Buffer;
  /**
   * bytes nonce = 5;
   * bytes difficulty = 6;
   */
  number: Long;
  witnessId: Long;
  witnessAddress: Buffer;
  version: number;
  accountStateRoot: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

/** block */
export interface Block {
  transactions: Transaction[];
  blockHeader: BlockHeader | undefined;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ChainInventory {
  ids: ChainInventory_BlockId[];
  remainNum: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ChainInventory_BlockId {
  hash: Buffer;
  number: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

/** Inventory */
export interface BlockInventory {
  ids: BlockInventory_BlockId[];
  type: BlockInventory_Type;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export enum BlockInventory_Type {
  SYNC = 0,
  ADVTISE = 1,
  FETCH = 2,
  UNRECOGNIZED = -1,
}

export function blockInventory_TypeFromJSON(object: any): BlockInventory_Type {
  switch (object) {
    case 0:
    case "SYNC":
      return BlockInventory_Type.SYNC;
    case 1:
    case "ADVTISE":
      return BlockInventory_Type.ADVTISE;
    case 2:
    case "FETCH":
      return BlockInventory_Type.FETCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockInventory_Type.UNRECOGNIZED;
  }
}

export function blockInventory_TypeToJSON(object: BlockInventory_Type): string {
  switch (object) {
    case BlockInventory_Type.SYNC:
      return "SYNC";
    case BlockInventory_Type.ADVTISE:
      return "ADVTISE";
    case BlockInventory_Type.FETCH:
      return "FETCH";
    case BlockInventory_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface BlockInventory_BlockId {
  hash: Buffer;
  number: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface Inventory {
  type: Inventory_InventoryType;
  ids: Buffer[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export enum Inventory_InventoryType {
  TRX = 0,
  BLOCK = 1,
  UNRECOGNIZED = -1,
}

export function inventory_InventoryTypeFromJSON(object: any): Inventory_InventoryType {
  switch (object) {
    case 0:
    case "TRX":
      return Inventory_InventoryType.TRX;
    case 1:
    case "BLOCK":
      return Inventory_InventoryType.BLOCK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Inventory_InventoryType.UNRECOGNIZED;
  }
}

export function inventory_InventoryTypeToJSON(object: Inventory_InventoryType): string {
  switch (object) {
    case Inventory_InventoryType.TRX:
      return "TRX";
    case Inventory_InventoryType.BLOCK:
      return "BLOCK";
    case Inventory_InventoryType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Items {
  type: Items_ItemType;
  blocks: Block[];
  blockHeaders: BlockHeader[];
  transactions: Transaction[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export enum Items_ItemType {
  ERR = 0,
  TRX = 1,
  BLOCK = 2,
  BLOCKHEADER = 3,
  UNRECOGNIZED = -1,
}

export function items_ItemTypeFromJSON(object: any): Items_ItemType {
  switch (object) {
    case 0:
    case "ERR":
      return Items_ItemType.ERR;
    case 1:
    case "TRX":
      return Items_ItemType.TRX;
    case 2:
    case "BLOCK":
      return Items_ItemType.BLOCK;
    case 3:
    case "BLOCKHEADER":
      return Items_ItemType.BLOCKHEADER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Items_ItemType.UNRECOGNIZED;
  }
}

export function items_ItemTypeToJSON(object: Items_ItemType): string {
  switch (object) {
    case Items_ItemType.ERR:
      return "ERR";
    case Items_ItemType.TRX:
      return "TRX";
    case Items_ItemType.BLOCK:
      return "BLOCK";
    case Items_ItemType.BLOCKHEADER:
      return "BLOCKHEADER";
    case Items_ItemType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** DynamicProperties */
export interface DynamicProperties {
  lastSolidityBlockNum: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface DisconnectMessage {
  reason: ReasonCode;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface HelloMessage {
  from: Endpoint | undefined;
  version: number;
  timestamp: Long;
  genesisBlockId: HelloMessage_BlockId | undefined;
  solidBlockId: HelloMessage_BlockId | undefined;
  headBlockId: HelloMessage_BlockId | undefined;
  address: Buffer;
  signature: Buffer;
  nodeType: number;
  lowestBlockNum: Long;
  codeVersion: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface HelloMessage_BlockId {
  hash: Buffer;
  number: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface InternalTransaction {
  /**
   * internalTransaction identity, the root InternalTransaction hash
   * should equals to root transaction id.
   */
  hash: Buffer;
  /** the one send trx (TBD: or token) via function */
  callerAddress: Buffer;
  /** the one recieve trx (TBD: or token) via function */
  transferToAddress: Buffer;
  callValueInfo: InternalTransaction_CallValueInfo[];
  note: Buffer;
  rejected: boolean;
  extra: string;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface InternalTransaction_CallValueInfo {
  /** trx (TBD: or token) value */
  callValue: Long;
  /** TBD: tokenName, trx should be empty */
  tokenId: string;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface DelegatedResourceAccountIndex {
  account: Buffer;
  fromAccounts: Buffer[];
  toAccounts: Buffer[];
  timestamp: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface NodeInfo {
  beginSyncNum: Long;
  block: string;
  solidityBlock: string;
  /** connect information */
  currentConnectCount: number;
  activeConnectCount: number;
  passiveConnectCount: number;
  totalFlow: Long;
  peerInfoList: NodeInfo_PeerInfo[];
  configNodeInfo: NodeInfo_ConfigNodeInfo | undefined;
  machineInfo: NodeInfo_MachineInfo | undefined;
  cheatWitnessInfoMap: { [key: string]: string };
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface NodeInfo_CheatWitnessInfoMapEntry {
  key: string;
  value: string;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface NodeInfo_PeerInfo {
  lastSyncBlock: string;
  remainNum: Long;
  lastBlockUpdateTime: Long;
  syncFlag: boolean;
  headBlockTimeWeBothHave: Long;
  needSyncFromPeer: boolean;
  needSyncFromUs: boolean;
  host: string;
  port: number;
  nodeId: string;
  connectTime: Long;
  avgLatency: number;
  syncToFetchSize: number;
  syncToFetchSizePeekNum: Long;
  syncBlockRequestedSize: number;
  unFetchSynNum: Long;
  blockInPorcSize: number;
  headBlockWeBothHave: string;
  isActive: boolean;
  score: number;
  nodeCount: number;
  inFlow: Long;
  disconnectTimes: number;
  localDisconnectReason: string;
  remoteDisconnectReason: string;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface NodeInfo_ConfigNodeInfo {
  codeVersion: string;
  p2pVersion: string;
  listenPort: number;
  discoverEnable: boolean;
  activeNodeSize: number;
  passiveNodeSize: number;
  sendNodeSize: number;
  maxConnectCount: number;
  sameIpMaxConnectCount: number;
  backupListenPort: number;
  backupMemberSize: number;
  backupPriority: number;
  dbVersion: number;
  minParticipationRate: number;
  supportConstant: boolean;
  minTimeRatio: number;
  maxTimeRatio: number;
  allowCreationOfContracts: Long;
  allowAdaptiveEnergy: Long;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface NodeInfo_MachineInfo {
  threadCount: number;
  deadLockThreadCount: number;
  cpuCount: number;
  totalMemory: Long;
  freeMemory: Long;
  cpuRate: number;
  javaVersion: string;
  osName: string;
  jvmTotalMemory: Long;
  jvmFreeMemory: Long;
  processCpuRate: number;
  memoryDescInfoList: NodeInfo_MachineInfo_MemoryDescInfo[];
  deadLockThreadInfoList: NodeInfo_MachineInfo_DeadLockThreadInfo[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface NodeInfo_MachineInfo_MemoryDescInfo {
  name: string;
  initSize: Long;
  useSize: Long;
  maxSize: Long;
  useRate: number;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface NodeInfo_MachineInfo_DeadLockThreadInfo {
  name: string;
  lockName: string;
  lockOwner: string;
  state: string;
  blockTime: Long;
  waitTime: Long;
  stackTrace: string;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MetricsInfo {
  interval: Long;
  node: MetricsInfo_NodeInfo | undefined;
  blockchain: MetricsInfo_BlockChainInfo | undefined;
  net: MetricsInfo_NetInfo | undefined;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MetricsInfo_NodeInfo {
  ip: string;
  nodeType: number;
  version: string;
  backupStatus: number;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MetricsInfo_BlockChainInfo {
  headBlockNum: Long;
  headBlockTimestamp: Long;
  headBlockHash: string;
  forkCount: number;
  failForkCount: number;
  blockProcessTime: MetricsInfo_RateInfo | undefined;
  tps: MetricsInfo_RateInfo | undefined;
  transactionCacheSize: number;
  missedTransaction: MetricsInfo_RateInfo | undefined;
  witnesses: MetricsInfo_BlockChainInfo_Witness[];
  failProcessBlockNum: Long;
  failProcessBlockReason: string;
  dupWitness: MetricsInfo_BlockChainInfo_DupWitness[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MetricsInfo_BlockChainInfo_Witness {
  address: string;
  version: number;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MetricsInfo_BlockChainInfo_DupWitness {
  address: string;
  blockNum: Long;
  count: number;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MetricsInfo_RateInfo {
  count: Long;
  meanRate: number;
  oneMinuteRate: number;
  fiveMinuteRate: number;
  fifteenMinuteRate: number;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MetricsInfo_NetInfo {
  errorProtoCount: number;
  api: MetricsInfo_NetInfo_ApiInfo | undefined;
  connectionCount: number;
  validConnectionCount: number;
  tcpInTraffic: MetricsInfo_RateInfo | undefined;
  tcpOutTraffic: MetricsInfo_RateInfo | undefined;
  disconnectionCount: number;
  disconnectionDetail: MetricsInfo_NetInfo_DisconnectionDetailInfo[];
  udpInTraffic: MetricsInfo_RateInfo | undefined;
  udpOutTraffic: MetricsInfo_RateInfo | undefined;
  latency: MetricsInfo_NetInfo_LatencyInfo | undefined;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MetricsInfo_NetInfo_ApiInfo {
  qps: MetricsInfo_RateInfo | undefined;
  failQps: MetricsInfo_RateInfo | undefined;
  outTraffic: MetricsInfo_RateInfo | undefined;
  detail: MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo {
  name: string;
  qps: MetricsInfo_RateInfo | undefined;
  failQps: MetricsInfo_RateInfo | undefined;
  outTraffic: MetricsInfo_RateInfo | undefined;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MetricsInfo_NetInfo_DisconnectionDetailInfo {
  reason: string;
  count: number;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MetricsInfo_NetInfo_LatencyInfo {
  top99: number;
  top95: number;
  top75: number;
  totalCount: number;
  delay1S: number;
  delay2S: number;
  delay3S: number;
  detail: MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo {
  witness: string;
  top99: number;
  top95: number;
  top75: number;
  count: number;
  delay1S: number;
  delay2S: number;
  delay3S: number;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface PBFTMessage {
  rawData: PBFTMessage_Raw | undefined;
  signature: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export enum PBFTMessage_MsgType {
  VIEW_CHANGE = 0,
  REQUEST = 1,
  PREPREPARE = 2,
  PREPARE = 3,
  COMMIT = 4,
  UNRECOGNIZED = -1,
}

export function pBFTMessage_MsgTypeFromJSON(object: any): PBFTMessage_MsgType {
  switch (object) {
    case 0:
    case "VIEW_CHANGE":
      return PBFTMessage_MsgType.VIEW_CHANGE;
    case 1:
    case "REQUEST":
      return PBFTMessage_MsgType.REQUEST;
    case 2:
    case "PREPREPARE":
      return PBFTMessage_MsgType.PREPREPARE;
    case 3:
    case "PREPARE":
      return PBFTMessage_MsgType.PREPARE;
    case 4:
    case "COMMIT":
      return PBFTMessage_MsgType.COMMIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PBFTMessage_MsgType.UNRECOGNIZED;
  }
}

export function pBFTMessage_MsgTypeToJSON(object: PBFTMessage_MsgType): string {
  switch (object) {
    case PBFTMessage_MsgType.VIEW_CHANGE:
      return "VIEW_CHANGE";
    case PBFTMessage_MsgType.REQUEST:
      return "REQUEST";
    case PBFTMessage_MsgType.PREPREPARE:
      return "PREPREPARE";
    case PBFTMessage_MsgType.PREPARE:
      return "PREPARE";
    case PBFTMessage_MsgType.COMMIT:
      return "COMMIT";
    case PBFTMessage_MsgType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PBFTMessage_DataType {
  BLOCK = 0,
  SRL = 1,
  UNRECOGNIZED = -1,
}

export function pBFTMessage_DataTypeFromJSON(object: any): PBFTMessage_DataType {
  switch (object) {
    case 0:
    case "BLOCK":
      return PBFTMessage_DataType.BLOCK;
    case 1:
    case "SRL":
      return PBFTMessage_DataType.SRL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PBFTMessage_DataType.UNRECOGNIZED;
  }
}

export function pBFTMessage_DataTypeToJSON(object: PBFTMessage_DataType): string {
  switch (object) {
    case PBFTMessage_DataType.BLOCK:
      return "BLOCK";
    case PBFTMessage_DataType.SRL:
      return "SRL";
    case PBFTMessage_DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PBFTMessage_Raw {
  msgType: PBFTMessage_MsgType;
  dataType: PBFTMessage_DataType;
  viewN: Long;
  epoch: Long;
  data: Buffer;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface PBFTCommitResult {
  data: Buffer;
  signature: Buffer[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface SRL {
  srAddress: Buffer[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

function createBaseAccountId(): AccountId {
  return { name: Buffer.alloc(0), address: Buffer.alloc(0), _unknownFields: {} };
}

export const AccountId = {
  encode(message: AccountId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name.length !== 0) {
      writer.uint32(10).bytes(message.name);
    }
    if (message.address.length !== 0) {
      writer.uint32(18).bytes(message.address);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): AccountId {
    return {
      name: isSet(object.name) ? Buffer.from(bytesFromBase64(object.name)) : Buffer.alloc(0),
      address: isSet(object.address) ? Buffer.from(bytesFromBase64(object.address)) : Buffer.alloc(0),
    };
  },

  toJSON(message: AccountId): unknown {
    const obj: any = {};
    if (message.name.length !== 0) {
      obj.name = base64FromBytes(message.name);
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountId>, I>>(base?: I): AccountId {
    return AccountId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountId>, I>>(object: I): AccountId {
    const message = createBaseAccountId();
    message.name = object.name ?? Buffer.alloc(0);
    message.address = object.address ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseVote(): Vote {
  return { voteAddress: Buffer.alloc(0), voteCount: Long.ZERO, _unknownFields: {} };
}

export const Vote = {
  encode(message: Vote, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.voteAddress.length !== 0) {
      writer.uint32(10).bytes(message.voteAddress);
    }
    if (!message.voteCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.voteCount);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Vote {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.voteAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.voteCount = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Vote {
    return {
      voteAddress: isSet(object.voteAddress) ? Buffer.from(bytesFromBase64(object.voteAddress)) : Buffer.alloc(0),
      voteCount: isSet(object.voteCount) ? Long.fromValue(object.voteCount) : Long.ZERO,
    };
  },

  toJSON(message: Vote): unknown {
    const obj: any = {};
    if (message.voteAddress.length !== 0) {
      obj.voteAddress = base64FromBytes(message.voteAddress);
    }
    if (!message.voteCount.equals(Long.ZERO)) {
      obj.voteCount = (message.voteCount || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vote>, I>>(base?: I): Vote {
    return Vote.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vote>, I>>(object: I): Vote {
    const message = createBaseVote();
    message.voteAddress = object.voteAddress ?? Buffer.alloc(0);
    message.voteCount = (object.voteCount !== undefined && object.voteCount !== null)
      ? Long.fromValue(object.voteCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseProposal(): Proposal {
  return {
    proposalId: Long.ZERO,
    proposerAddress: Buffer.alloc(0),
    parameters: new Map(),
    expirationTime: Long.ZERO,
    createTime: Long.ZERO,
    approvals: [],
    state: 0,
    _unknownFields: {},
  };
}

export const Proposal = {
  encode(message: Proposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.proposalId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.proposalId);
    }
    if (message.proposerAddress.length !== 0) {
      writer.uint32(18).bytes(message.proposerAddress);
    }
    message.parameters.forEach((value, key) => {
      Proposal_ParametersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (!message.expirationTime.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.expirationTime);
    }
    if (!message.createTime.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.createTime);
    }
    for (const v of message.approvals) {
      writer.uint32(50).bytes(v!);
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Proposal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.proposalId = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.proposerAddress = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Proposal_ParametersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.parameters.set(entry3.key, entry3.value);
          }
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.expirationTime = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.createTime = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.approvals.push(reader.bytes() as Buffer);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Proposal {
    return {
      proposalId: isSet(object.proposalId) ? Long.fromValue(object.proposalId) : Long.ZERO,
      proposerAddress: isSet(object.proposerAddress)
        ? Buffer.from(bytesFromBase64(object.proposerAddress))
        : Buffer.alloc(0),
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<Map<Long, Long>>((acc, [key, value]) => {
          acc.set(Long.fromValue(key), Long.fromValue(value as Long | string));
          return acc;
        }, new Map())
        : new Map(),
      expirationTime: isSet(object.expirationTime) ? Long.fromValue(object.expirationTime) : Long.ZERO,
      createTime: isSet(object.createTime) ? Long.fromValue(object.createTime) : Long.ZERO,
      approvals: globalThis.Array.isArray(object?.approvals)
        ? object.approvals.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      state: isSet(object.state) ? proposal_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: Proposal): unknown {
    const obj: any = {};
    if (!message.proposalId.equals(Long.ZERO)) {
      obj.proposalId = (message.proposalId || Long.ZERO).toString();
    }
    if (message.proposerAddress.length !== 0) {
      obj.proposerAddress = base64FromBytes(message.proposerAddress);
    }
    if (message.parameters?.size) {
      obj.parameters = {};
      message.parameters.forEach((v, k) => {
        obj.parameters[longToNumber(k)] = v.toString();
      });
    }
    if (!message.expirationTime.equals(Long.ZERO)) {
      obj.expirationTime = (message.expirationTime || Long.ZERO).toString();
    }
    if (!message.createTime.equals(Long.ZERO)) {
      obj.createTime = (message.createTime || Long.ZERO).toString();
    }
    if (message.approvals?.length) {
      obj.approvals = message.approvals.map((e) => base64FromBytes(e));
    }
    if (message.state !== 0) {
      obj.state = proposal_StateToJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Proposal>, I>>(base?: I): Proposal {
    return Proposal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Proposal>, I>>(object: I): Proposal {
    const message = createBaseProposal();
    message.proposalId = (object.proposalId !== undefined && object.proposalId !== null)
      ? Long.fromValue(object.proposalId)
      : Long.ZERO;
    message.proposerAddress = object.proposerAddress ?? Buffer.alloc(0);
    message.parameters = (() => {
      const m = new Map();
      (object.parameters as Map<Long, Long> ?? new Map()).forEach((value, key) => {
        if (value !== undefined) {
          m.set(key, Long.fromValue(value));
        }
      });
      return m;
    })();
    message.expirationTime = (object.expirationTime !== undefined && object.expirationTime !== null)
      ? Long.fromValue(object.expirationTime)
      : Long.ZERO;
    message.createTime = (object.createTime !== undefined && object.createTime !== null)
      ? Long.fromValue(object.createTime)
      : Long.ZERO;
    message.approvals = object.approvals?.map((e) => e) || [];
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseProposal_ParametersEntry(): Proposal_ParametersEntry {
  return { key: Long.ZERO, value: Long.ZERO, _unknownFields: {} };
}

export const Proposal_ParametersEntry = {
  encode(message: Proposal_ParametersEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.key.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Proposal_ParametersEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProposal_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Proposal_ParametersEntry {
    return {
      key: isSet(object.key) ? Long.fromValue(object.key) : Long.ZERO,
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: Proposal_ParametersEntry): unknown {
    const obj: any = {};
    if (!message.key.equals(Long.ZERO)) {
      obj.key = (message.key || Long.ZERO).toString();
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Proposal_ParametersEntry>, I>>(base?: I): Proposal_ParametersEntry {
    return Proposal_ParametersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Proposal_ParametersEntry>, I>>(object: I): Proposal_ParametersEntry {
    const message = createBaseProposal_ParametersEntry();
    message.key = (object.key !== undefined && object.key !== null) ? Long.fromValue(object.key) : Long.ZERO;
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseExchange(): Exchange {
  return {
    exchangeId: Long.ZERO,
    creatorAddress: Buffer.alloc(0),
    createTime: Long.ZERO,
    firstTokenId: Buffer.alloc(0),
    firstTokenBalance: Long.ZERO,
    secondTokenId: Buffer.alloc(0),
    secondTokenBalance: Long.ZERO,
    _unknownFields: {},
  };
}

export const Exchange = {
  encode(message: Exchange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.exchangeId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.exchangeId);
    }
    if (message.creatorAddress.length !== 0) {
      writer.uint32(18).bytes(message.creatorAddress);
    }
    if (!message.createTime.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.createTime);
    }
    if (message.firstTokenId.length !== 0) {
      writer.uint32(50).bytes(message.firstTokenId);
    }
    if (!message.firstTokenBalance.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.firstTokenBalance);
    }
    if (message.secondTokenId.length !== 0) {
      writer.uint32(66).bytes(message.secondTokenId);
    }
    if (!message.secondTokenBalance.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.secondTokenBalance);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Exchange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExchange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.exchangeId = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.creatorAddress = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.createTime = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.firstTokenId = reader.bytes() as Buffer;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.firstTokenBalance = reader.int64() as Long;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.secondTokenId = reader.bytes() as Buffer;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.secondTokenBalance = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Exchange {
    return {
      exchangeId: isSet(object.exchangeId) ? Long.fromValue(object.exchangeId) : Long.ZERO,
      creatorAddress: isSet(object.creatorAddress)
        ? Buffer.from(bytesFromBase64(object.creatorAddress))
        : Buffer.alloc(0),
      createTime: isSet(object.createTime) ? Long.fromValue(object.createTime) : Long.ZERO,
      firstTokenId: isSet(object.firstTokenId) ? Buffer.from(bytesFromBase64(object.firstTokenId)) : Buffer.alloc(0),
      firstTokenBalance: isSet(object.firstTokenBalance) ? Long.fromValue(object.firstTokenBalance) : Long.ZERO,
      secondTokenId: isSet(object.secondTokenId) ? Buffer.from(bytesFromBase64(object.secondTokenId)) : Buffer.alloc(0),
      secondTokenBalance: isSet(object.secondTokenBalance) ? Long.fromValue(object.secondTokenBalance) : Long.ZERO,
    };
  },

  toJSON(message: Exchange): unknown {
    const obj: any = {};
    if (!message.exchangeId.equals(Long.ZERO)) {
      obj.exchangeId = (message.exchangeId || Long.ZERO).toString();
    }
    if (message.creatorAddress.length !== 0) {
      obj.creatorAddress = base64FromBytes(message.creatorAddress);
    }
    if (!message.createTime.equals(Long.ZERO)) {
      obj.createTime = (message.createTime || Long.ZERO).toString();
    }
    if (message.firstTokenId.length !== 0) {
      obj.firstTokenId = base64FromBytes(message.firstTokenId);
    }
    if (!message.firstTokenBalance.equals(Long.ZERO)) {
      obj.firstTokenBalance = (message.firstTokenBalance || Long.ZERO).toString();
    }
    if (message.secondTokenId.length !== 0) {
      obj.secondTokenId = base64FromBytes(message.secondTokenId);
    }
    if (!message.secondTokenBalance.equals(Long.ZERO)) {
      obj.secondTokenBalance = (message.secondTokenBalance || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Exchange>, I>>(base?: I): Exchange {
    return Exchange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Exchange>, I>>(object: I): Exchange {
    const message = createBaseExchange();
    message.exchangeId = (object.exchangeId !== undefined && object.exchangeId !== null)
      ? Long.fromValue(object.exchangeId)
      : Long.ZERO;
    message.creatorAddress = object.creatorAddress ?? Buffer.alloc(0);
    message.createTime = (object.createTime !== undefined && object.createTime !== null)
      ? Long.fromValue(object.createTime)
      : Long.ZERO;
    message.firstTokenId = object.firstTokenId ?? Buffer.alloc(0);
    message.firstTokenBalance = (object.firstTokenBalance !== undefined && object.firstTokenBalance !== null)
      ? Long.fromValue(object.firstTokenBalance)
      : Long.ZERO;
    message.secondTokenId = object.secondTokenId ?? Buffer.alloc(0);
    message.secondTokenBalance = (object.secondTokenBalance !== undefined && object.secondTokenBalance !== null)
      ? Long.fromValue(object.secondTokenBalance)
      : Long.ZERO;
    return message;
  },
};

function createBaseMarketOrder(): MarketOrder {
  return {
    orderId: Buffer.alloc(0),
    ownerAddress: Buffer.alloc(0),
    createTime: Long.ZERO,
    sellTokenId: Buffer.alloc(0),
    sellTokenQuantity: Long.ZERO,
    buyTokenId: Buffer.alloc(0),
    buyTokenQuantity: Long.ZERO,
    sellTokenQuantityRemain: Long.ZERO,
    sellTokenQuantityReturn: Long.ZERO,
    state: 0,
    prev: Buffer.alloc(0),
    next: Buffer.alloc(0),
    _unknownFields: {},
  };
}

export const MarketOrder = {
  encode(message: MarketOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderId.length !== 0) {
      writer.uint32(10).bytes(message.orderId);
    }
    if (message.ownerAddress.length !== 0) {
      writer.uint32(18).bytes(message.ownerAddress);
    }
    if (!message.createTime.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.createTime);
    }
    if (message.sellTokenId.length !== 0) {
      writer.uint32(34).bytes(message.sellTokenId);
    }
    if (!message.sellTokenQuantity.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.sellTokenQuantity);
    }
    if (message.buyTokenId.length !== 0) {
      writer.uint32(50).bytes(message.buyTokenId);
    }
    if (!message.buyTokenQuantity.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.buyTokenQuantity);
    }
    if (!message.sellTokenQuantityRemain.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.sellTokenQuantityRemain);
    }
    if (!message.sellTokenQuantityReturn.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.sellTokenQuantityReturn);
    }
    if (message.state !== 0) {
      writer.uint32(88).int32(message.state);
    }
    if (message.prev.length !== 0) {
      writer.uint32(98).bytes(message.prev);
    }
    if (message.next.length !== 0) {
      writer.uint32(106).bytes(message.next);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketOrder {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ownerAddress = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.createTime = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sellTokenId = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.sellTokenQuantity = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.buyTokenId = reader.bytes() as Buffer;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.buyTokenQuantity = reader.int64() as Long;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.sellTokenQuantityRemain = reader.int64() as Long;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.sellTokenQuantityReturn = reader.int64() as Long;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.prev = reader.bytes() as Buffer;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.next = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MarketOrder {
    return {
      orderId: isSet(object.orderId) ? Buffer.from(bytesFromBase64(object.orderId)) : Buffer.alloc(0),
      ownerAddress: isSet(object.ownerAddress) ? Buffer.from(bytesFromBase64(object.ownerAddress)) : Buffer.alloc(0),
      createTime: isSet(object.createTime) ? Long.fromValue(object.createTime) : Long.ZERO,
      sellTokenId: isSet(object.sellTokenId) ? Buffer.from(bytesFromBase64(object.sellTokenId)) : Buffer.alloc(0),
      sellTokenQuantity: isSet(object.sellTokenQuantity) ? Long.fromValue(object.sellTokenQuantity) : Long.ZERO,
      buyTokenId: isSet(object.buyTokenId) ? Buffer.from(bytesFromBase64(object.buyTokenId)) : Buffer.alloc(0),
      buyTokenQuantity: isSet(object.buyTokenQuantity) ? Long.fromValue(object.buyTokenQuantity) : Long.ZERO,
      sellTokenQuantityRemain: isSet(object.sellTokenQuantityRemain)
        ? Long.fromValue(object.sellTokenQuantityRemain)
        : Long.ZERO,
      sellTokenQuantityReturn: isSet(object.sellTokenQuantityReturn)
        ? Long.fromValue(object.sellTokenQuantityReturn)
        : Long.ZERO,
      state: isSet(object.state) ? marketOrder_StateFromJSON(object.state) : 0,
      prev: isSet(object.prev) ? Buffer.from(bytesFromBase64(object.prev)) : Buffer.alloc(0),
      next: isSet(object.next) ? Buffer.from(bytesFromBase64(object.next)) : Buffer.alloc(0),
    };
  },

  toJSON(message: MarketOrder): unknown {
    const obj: any = {};
    if (message.orderId.length !== 0) {
      obj.orderId = base64FromBytes(message.orderId);
    }
    if (message.ownerAddress.length !== 0) {
      obj.ownerAddress = base64FromBytes(message.ownerAddress);
    }
    if (!message.createTime.equals(Long.ZERO)) {
      obj.createTime = (message.createTime || Long.ZERO).toString();
    }
    if (message.sellTokenId.length !== 0) {
      obj.sellTokenId = base64FromBytes(message.sellTokenId);
    }
    if (!message.sellTokenQuantity.equals(Long.ZERO)) {
      obj.sellTokenQuantity = (message.sellTokenQuantity || Long.ZERO).toString();
    }
    if (message.buyTokenId.length !== 0) {
      obj.buyTokenId = base64FromBytes(message.buyTokenId);
    }
    if (!message.buyTokenQuantity.equals(Long.ZERO)) {
      obj.buyTokenQuantity = (message.buyTokenQuantity || Long.ZERO).toString();
    }
    if (!message.sellTokenQuantityRemain.equals(Long.ZERO)) {
      obj.sellTokenQuantityRemain = (message.sellTokenQuantityRemain || Long.ZERO).toString();
    }
    if (!message.sellTokenQuantityReturn.equals(Long.ZERO)) {
      obj.sellTokenQuantityReturn = (message.sellTokenQuantityReturn || Long.ZERO).toString();
    }
    if (message.state !== 0) {
      obj.state = marketOrder_StateToJSON(message.state);
    }
    if (message.prev.length !== 0) {
      obj.prev = base64FromBytes(message.prev);
    }
    if (message.next.length !== 0) {
      obj.next = base64FromBytes(message.next);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketOrder>, I>>(base?: I): MarketOrder {
    return MarketOrder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketOrder>, I>>(object: I): MarketOrder {
    const message = createBaseMarketOrder();
    message.orderId = object.orderId ?? Buffer.alloc(0);
    message.ownerAddress = object.ownerAddress ?? Buffer.alloc(0);
    message.createTime = (object.createTime !== undefined && object.createTime !== null)
      ? Long.fromValue(object.createTime)
      : Long.ZERO;
    message.sellTokenId = object.sellTokenId ?? Buffer.alloc(0);
    message.sellTokenQuantity = (object.sellTokenQuantity !== undefined && object.sellTokenQuantity !== null)
      ? Long.fromValue(object.sellTokenQuantity)
      : Long.ZERO;
    message.buyTokenId = object.buyTokenId ?? Buffer.alloc(0);
    message.buyTokenQuantity = (object.buyTokenQuantity !== undefined && object.buyTokenQuantity !== null)
      ? Long.fromValue(object.buyTokenQuantity)
      : Long.ZERO;
    message.sellTokenQuantityRemain =
      (object.sellTokenQuantityRemain !== undefined && object.sellTokenQuantityRemain !== null)
        ? Long.fromValue(object.sellTokenQuantityRemain)
        : Long.ZERO;
    message.sellTokenQuantityReturn =
      (object.sellTokenQuantityReturn !== undefined && object.sellTokenQuantityReturn !== null)
        ? Long.fromValue(object.sellTokenQuantityReturn)
        : Long.ZERO;
    message.state = object.state ?? 0;
    message.prev = object.prev ?? Buffer.alloc(0);
    message.next = object.next ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseMarketOrderList(): MarketOrderList {
  return { orders: [], _unknownFields: {} };
}

export const MarketOrderList = {
  encode(message: MarketOrderList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orders) {
      MarketOrder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketOrderList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketOrderList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orders.push(MarketOrder.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MarketOrderList {
    return {
      orders: globalThis.Array.isArray(object?.orders) ? object.orders.map((e: any) => MarketOrder.fromJSON(e)) : [],
    };
  },

  toJSON(message: MarketOrderList): unknown {
    const obj: any = {};
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => MarketOrder.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketOrderList>, I>>(base?: I): MarketOrderList {
    return MarketOrderList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketOrderList>, I>>(object: I): MarketOrderList {
    const message = createBaseMarketOrderList();
    message.orders = object.orders?.map((e) => MarketOrder.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMarketOrderPairList(): MarketOrderPairList {
  return { orderPair: [], _unknownFields: {} };
}

export const MarketOrderPairList = {
  encode(message: MarketOrderPairList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orderPair) {
      MarketOrderPair.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketOrderPairList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketOrderPairList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orderPair.push(MarketOrderPair.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MarketOrderPairList {
    return {
      orderPair: globalThis.Array.isArray(object?.orderPair)
        ? object.orderPair.map((e: any) => MarketOrderPair.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MarketOrderPairList): unknown {
    const obj: any = {};
    if (message.orderPair?.length) {
      obj.orderPair = message.orderPair.map((e) => MarketOrderPair.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketOrderPairList>, I>>(base?: I): MarketOrderPairList {
    return MarketOrderPairList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketOrderPairList>, I>>(object: I): MarketOrderPairList {
    const message = createBaseMarketOrderPairList();
    message.orderPair = object.orderPair?.map((e) => MarketOrderPair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMarketOrderPair(): MarketOrderPair {
  return { sellTokenId: Buffer.alloc(0), buyTokenId: Buffer.alloc(0), _unknownFields: {} };
}

export const MarketOrderPair = {
  encode(message: MarketOrderPair, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sellTokenId.length !== 0) {
      writer.uint32(10).bytes(message.sellTokenId);
    }
    if (message.buyTokenId.length !== 0) {
      writer.uint32(18).bytes(message.buyTokenId);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketOrderPair {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketOrderPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sellTokenId = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.buyTokenId = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MarketOrderPair {
    return {
      sellTokenId: isSet(object.sellTokenId) ? Buffer.from(bytesFromBase64(object.sellTokenId)) : Buffer.alloc(0),
      buyTokenId: isSet(object.buyTokenId) ? Buffer.from(bytesFromBase64(object.buyTokenId)) : Buffer.alloc(0),
    };
  },

  toJSON(message: MarketOrderPair): unknown {
    const obj: any = {};
    if (message.sellTokenId.length !== 0) {
      obj.sellTokenId = base64FromBytes(message.sellTokenId);
    }
    if (message.buyTokenId.length !== 0) {
      obj.buyTokenId = base64FromBytes(message.buyTokenId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketOrderPair>, I>>(base?: I): MarketOrderPair {
    return MarketOrderPair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketOrderPair>, I>>(object: I): MarketOrderPair {
    const message = createBaseMarketOrderPair();
    message.sellTokenId = object.sellTokenId ?? Buffer.alloc(0);
    message.buyTokenId = object.buyTokenId ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseMarketAccountOrder(): MarketAccountOrder {
  return { ownerAddress: Buffer.alloc(0), orders: [], count: Long.ZERO, totalCount: Long.ZERO, _unknownFields: {} };
}

export const MarketAccountOrder = {
  encode(message: MarketAccountOrder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress.length !== 0) {
      writer.uint32(10).bytes(message.ownerAddress);
    }
    for (const v of message.orders) {
      writer.uint32(18).bytes(v!);
    }
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.count);
    }
    if (!message.totalCount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.totalCount);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketAccountOrder {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketAccountOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orders.push(reader.bytes() as Buffer);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.count = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalCount = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MarketAccountOrder {
    return {
      ownerAddress: isSet(object.ownerAddress) ? Buffer.from(bytesFromBase64(object.ownerAddress)) : Buffer.alloc(0),
      orders: globalThis.Array.isArray(object?.orders)
        ? object.orders.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO,
      totalCount: isSet(object.totalCount) ? Long.fromValue(object.totalCount) : Long.ZERO,
    };
  },

  toJSON(message: MarketAccountOrder): unknown {
    const obj: any = {};
    if (message.ownerAddress.length !== 0) {
      obj.ownerAddress = base64FromBytes(message.ownerAddress);
    }
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => base64FromBytes(e));
    }
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    if (!message.totalCount.equals(Long.ZERO)) {
      obj.totalCount = (message.totalCount || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketAccountOrder>, I>>(base?: I): MarketAccountOrder {
    return MarketAccountOrder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketAccountOrder>, I>>(object: I): MarketAccountOrder {
    const message = createBaseMarketAccountOrder();
    message.ownerAddress = object.ownerAddress ?? Buffer.alloc(0);
    message.orders = object.orders?.map((e) => e) || [];
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    message.totalCount = (object.totalCount !== undefined && object.totalCount !== null)
      ? Long.fromValue(object.totalCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseMarketPrice(): MarketPrice {
  return { sellTokenQuantity: Long.ZERO, buyTokenQuantity: Long.ZERO, _unknownFields: {} };
}

export const MarketPrice = {
  encode(message: MarketPrice, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.sellTokenQuantity.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.sellTokenQuantity);
    }
    if (!message.buyTokenQuantity.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.buyTokenQuantity);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketPrice {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketPrice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sellTokenQuantity = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.buyTokenQuantity = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MarketPrice {
    return {
      sellTokenQuantity: isSet(object.sellTokenQuantity) ? Long.fromValue(object.sellTokenQuantity) : Long.ZERO,
      buyTokenQuantity: isSet(object.buyTokenQuantity) ? Long.fromValue(object.buyTokenQuantity) : Long.ZERO,
    };
  },

  toJSON(message: MarketPrice): unknown {
    const obj: any = {};
    if (!message.sellTokenQuantity.equals(Long.ZERO)) {
      obj.sellTokenQuantity = (message.sellTokenQuantity || Long.ZERO).toString();
    }
    if (!message.buyTokenQuantity.equals(Long.ZERO)) {
      obj.buyTokenQuantity = (message.buyTokenQuantity || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketPrice>, I>>(base?: I): MarketPrice {
    return MarketPrice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketPrice>, I>>(object: I): MarketPrice {
    const message = createBaseMarketPrice();
    message.sellTokenQuantity = (object.sellTokenQuantity !== undefined && object.sellTokenQuantity !== null)
      ? Long.fromValue(object.sellTokenQuantity)
      : Long.ZERO;
    message.buyTokenQuantity = (object.buyTokenQuantity !== undefined && object.buyTokenQuantity !== null)
      ? Long.fromValue(object.buyTokenQuantity)
      : Long.ZERO;
    return message;
  },
};

function createBaseMarketPriceList(): MarketPriceList {
  return { sellTokenId: Buffer.alloc(0), buyTokenId: Buffer.alloc(0), prices: [], _unknownFields: {} };
}

export const MarketPriceList = {
  encode(message: MarketPriceList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sellTokenId.length !== 0) {
      writer.uint32(10).bytes(message.sellTokenId);
    }
    if (message.buyTokenId.length !== 0) {
      writer.uint32(18).bytes(message.buyTokenId);
    }
    for (const v of message.prices) {
      MarketPrice.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketPriceList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketPriceList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sellTokenId = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.buyTokenId = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.prices.push(MarketPrice.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MarketPriceList {
    return {
      sellTokenId: isSet(object.sellTokenId) ? Buffer.from(bytesFromBase64(object.sellTokenId)) : Buffer.alloc(0),
      buyTokenId: isSet(object.buyTokenId) ? Buffer.from(bytesFromBase64(object.buyTokenId)) : Buffer.alloc(0),
      prices: globalThis.Array.isArray(object?.prices) ? object.prices.map((e: any) => MarketPrice.fromJSON(e)) : [],
    };
  },

  toJSON(message: MarketPriceList): unknown {
    const obj: any = {};
    if (message.sellTokenId.length !== 0) {
      obj.sellTokenId = base64FromBytes(message.sellTokenId);
    }
    if (message.buyTokenId.length !== 0) {
      obj.buyTokenId = base64FromBytes(message.buyTokenId);
    }
    if (message.prices?.length) {
      obj.prices = message.prices.map((e) => MarketPrice.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketPriceList>, I>>(base?: I): MarketPriceList {
    return MarketPriceList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketPriceList>, I>>(object: I): MarketPriceList {
    const message = createBaseMarketPriceList();
    message.sellTokenId = object.sellTokenId ?? Buffer.alloc(0);
    message.buyTokenId = object.buyTokenId ?? Buffer.alloc(0);
    message.prices = object.prices?.map((e) => MarketPrice.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMarketOrderIdList(): MarketOrderIdList {
  return { head: Buffer.alloc(0), tail: Buffer.alloc(0), _unknownFields: {} };
}

export const MarketOrderIdList = {
  encode(message: MarketOrderIdList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.head.length !== 0) {
      writer.uint32(10).bytes(message.head);
    }
    if (message.tail.length !== 0) {
      writer.uint32(18).bytes(message.tail);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketOrderIdList {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketOrderIdList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.head = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tail = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MarketOrderIdList {
    return {
      head: isSet(object.head) ? Buffer.from(bytesFromBase64(object.head)) : Buffer.alloc(0),
      tail: isSet(object.tail) ? Buffer.from(bytesFromBase64(object.tail)) : Buffer.alloc(0),
    };
  },

  toJSON(message: MarketOrderIdList): unknown {
    const obj: any = {};
    if (message.head.length !== 0) {
      obj.head = base64FromBytes(message.head);
    }
    if (message.tail.length !== 0) {
      obj.tail = base64FromBytes(message.tail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketOrderIdList>, I>>(base?: I): MarketOrderIdList {
    return MarketOrderIdList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketOrderIdList>, I>>(object: I): MarketOrderIdList {
    const message = createBaseMarketOrderIdList();
    message.head = object.head ?? Buffer.alloc(0);
    message.tail = object.tail ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseChainParameters(): ChainParameters {
  return { chainParameter: [], _unknownFields: {} };
}

export const ChainParameters = {
  encode(message: ChainParameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.chainParameter) {
      ChainParameters_ChainParameter.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChainParameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainParameter.push(ChainParameters_ChainParameter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ChainParameters {
    return {
      chainParameter: globalThis.Array.isArray(object?.chainParameter)
        ? object.chainParameter.map((e: any) => ChainParameters_ChainParameter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChainParameters): unknown {
    const obj: any = {};
    if (message.chainParameter?.length) {
      obj.chainParameter = message.chainParameter.map((e) => ChainParameters_ChainParameter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainParameters>, I>>(base?: I): ChainParameters {
    return ChainParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainParameters>, I>>(object: I): ChainParameters {
    const message = createBaseChainParameters();
    message.chainParameter = object.chainParameter?.map((e) => ChainParameters_ChainParameter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChainParameters_ChainParameter(): ChainParameters_ChainParameter {
  return { key: "", value: Long.ZERO, _unknownFields: {} };
}

export const ChainParameters_ChainParameter = {
  encode(message: ChainParameters_ChainParameter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChainParameters_ChainParameter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainParameters_ChainParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ChainParameters_ChainParameter {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: ChainParameters_ChainParameter): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainParameters_ChainParameter>, I>>(base?: I): ChainParameters_ChainParameter {
    return ChainParameters_ChainParameter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainParameters_ChainParameter>, I>>(
    object: I,
  ): ChainParameters_ChainParameter {
    const message = createBaseChainParameters_ChainParameter();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseAccount(): Account {
  return {
    accountName: Buffer.alloc(0),
    type: 0,
    address: Buffer.alloc(0),
    balance: Long.ZERO,
    votes: [],
    asset: {},
    assetV2: {},
    frozen: [],
    netUsage: Long.ZERO,
    acquiredDelegatedFrozenBalanceForBandwidth: Long.ZERO,
    delegatedFrozenBalanceForBandwidth: Long.ZERO,
    oldTronPower: Long.ZERO,
    tronPower: undefined,
    assetOptimized: false,
    createTime: Long.ZERO,
    latestOprationTime: Long.ZERO,
    allowance: Long.ZERO,
    latestWithdrawTime: Long.ZERO,
    code: Buffer.alloc(0),
    isWitness: false,
    isCommittee: false,
    frozenSupply: [],
    assetIssuedName: Buffer.alloc(0),
    assetIssuedID: Buffer.alloc(0),
    latestAssetOperationTime: {},
    latestAssetOperationTimeV2: {},
    freeNetUsage: Long.ZERO,
    freeAssetNetUsage: {},
    freeAssetNetUsageV2: {},
    latestConsumeTime: Long.ZERO,
    latestConsumeFreeTime: Long.ZERO,
    accountId: Buffer.alloc(0),
    netWindowSize: Long.ZERO,
    netWindowOptimized: false,
    accountResource: undefined,
    codeHash: Buffer.alloc(0),
    ownerPermission: undefined,
    witnessPermission: undefined,
    activePermission: [],
    frozenV2: [],
    unfrozenV2: [],
    delegatedFrozenV2BalanceForBandwidth: Long.ZERO,
    acquiredDelegatedFrozenV2BalanceForBandwidth: Long.ZERO,
    _unknownFields: {},
  };
}

export const Account = {
  encode(message: Account, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountName.length !== 0) {
      writer.uint32(10).bytes(message.accountName);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.address.length !== 0) {
      writer.uint32(26).bytes(message.address);
    }
    if (!message.balance.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.balance);
    }
    for (const v of message.votes) {
      Vote.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    Object.entries(message.asset).forEach(([key, value]) => {
      Account_AssetEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).ldelim();
    });
    Object.entries(message.assetV2).forEach(([key, value]) => {
      Account_AssetV2Entry.encode({ key: key as any, value }, writer.uint32(450).fork()).ldelim();
    });
    for (const v of message.frozen) {
      Account_Frozen.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (!message.netUsage.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.netUsage);
    }
    if (!message.acquiredDelegatedFrozenBalanceForBandwidth.equals(Long.ZERO)) {
      writer.uint32(328).int64(message.acquiredDelegatedFrozenBalanceForBandwidth);
    }
    if (!message.delegatedFrozenBalanceForBandwidth.equals(Long.ZERO)) {
      writer.uint32(336).int64(message.delegatedFrozenBalanceForBandwidth);
    }
    if (!message.oldTronPower.equals(Long.ZERO)) {
      writer.uint32(368).int64(message.oldTronPower);
    }
    if (message.tronPower !== undefined) {
      Account_Frozen.encode(message.tronPower, writer.uint32(378).fork()).ldelim();
    }
    if (message.assetOptimized !== false) {
      writer.uint32(480).bool(message.assetOptimized);
    }
    if (!message.createTime.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.createTime);
    }
    if (!message.latestOprationTime.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.latestOprationTime);
    }
    if (!message.allowance.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.allowance);
    }
    if (!message.latestWithdrawTime.equals(Long.ZERO)) {
      writer.uint32(96).int64(message.latestWithdrawTime);
    }
    if (message.code.length !== 0) {
      writer.uint32(106).bytes(message.code);
    }
    if (message.isWitness !== false) {
      writer.uint32(112).bool(message.isWitness);
    }
    if (message.isCommittee !== false) {
      writer.uint32(120).bool(message.isCommittee);
    }
    for (const v of message.frozenSupply) {
      Account_Frozen.encode(v!, writer.uint32(130).fork()).ldelim();
    }
    if (message.assetIssuedName.length !== 0) {
      writer.uint32(138).bytes(message.assetIssuedName);
    }
    if (message.assetIssuedID.length !== 0) {
      writer.uint32(458).bytes(message.assetIssuedID);
    }
    Object.entries(message.latestAssetOperationTime).forEach(([key, value]) => {
      Account_LatestAssetOperationTimeEntry.encode({ key: key as any, value }, writer.uint32(146).fork()).ldelim();
    });
    Object.entries(message.latestAssetOperationTimeV2).forEach(([key, value]) => {
      Account_LatestAssetOperationTimeV2Entry.encode({ key: key as any, value }, writer.uint32(466).fork()).ldelim();
    });
    if (!message.freeNetUsage.equals(Long.ZERO)) {
      writer.uint32(152).int64(message.freeNetUsage);
    }
    Object.entries(message.freeAssetNetUsage).forEach(([key, value]) => {
      Account_FreeAssetNetUsageEntry.encode({ key: key as any, value }, writer.uint32(162).fork()).ldelim();
    });
    Object.entries(message.freeAssetNetUsageV2).forEach(([key, value]) => {
      Account_FreeAssetNetUsageV2Entry.encode({ key: key as any, value }, writer.uint32(474).fork()).ldelim();
    });
    if (!message.latestConsumeTime.equals(Long.ZERO)) {
      writer.uint32(168).int64(message.latestConsumeTime);
    }
    if (!message.latestConsumeFreeTime.equals(Long.ZERO)) {
      writer.uint32(176).int64(message.latestConsumeFreeTime);
    }
    if (message.accountId.length !== 0) {
      writer.uint32(186).bytes(message.accountId);
    }
    if (!message.netWindowSize.equals(Long.ZERO)) {
      writer.uint32(192).int64(message.netWindowSize);
    }
    if (message.netWindowOptimized !== false) {
      writer.uint32(200).bool(message.netWindowOptimized);
    }
    if (message.accountResource !== undefined) {
      Account_AccountResource.encode(message.accountResource, writer.uint32(210).fork()).ldelim();
    }
    if (message.codeHash.length !== 0) {
      writer.uint32(242).bytes(message.codeHash);
    }
    if (message.ownerPermission !== undefined) {
      Permission.encode(message.ownerPermission, writer.uint32(250).fork()).ldelim();
    }
    if (message.witnessPermission !== undefined) {
      Permission.encode(message.witnessPermission, writer.uint32(258).fork()).ldelim();
    }
    for (const v of message.activePermission) {
      Permission.encode(v!, writer.uint32(266).fork()).ldelim();
    }
    for (const v of message.frozenV2) {
      Account_FreezeV2.encode(v!, writer.uint32(274).fork()).ldelim();
    }
    for (const v of message.unfrozenV2) {
      Account_UnFreezeV2.encode(v!, writer.uint32(282).fork()).ldelim();
    }
    if (!message.delegatedFrozenV2BalanceForBandwidth.equals(Long.ZERO)) {
      writer.uint32(288).int64(message.delegatedFrozenV2BalanceForBandwidth);
    }
    if (!message.acquiredDelegatedFrozenV2BalanceForBandwidth.equals(Long.ZERO)) {
      writer.uint32(296).int64(message.acquiredDelegatedFrozenV2BalanceForBandwidth);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Account {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountName = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.balance = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.votes.push(Vote.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = Account_AssetEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.asset[entry6.key] = entry6.value;
          }
          continue;
        case 56:
          if (tag !== 450) {
            break;
          }

          const entry56 = Account_AssetV2Entry.decode(reader, reader.uint32());
          if (entry56.value !== undefined) {
            message.assetV2[entry56.key] = entry56.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.frozen.push(Account_Frozen.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.netUsage = reader.int64() as Long;
          continue;
        case 41:
          if (tag !== 328) {
            break;
          }

          message.acquiredDelegatedFrozenBalanceForBandwidth = reader.int64() as Long;
          continue;
        case 42:
          if (tag !== 336) {
            break;
          }

          message.delegatedFrozenBalanceForBandwidth = reader.int64() as Long;
          continue;
        case 46:
          if (tag !== 368) {
            break;
          }

          message.oldTronPower = reader.int64() as Long;
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }

          message.tronPower = Account_Frozen.decode(reader, reader.uint32());
          continue;
        case 60:
          if (tag !== 480) {
            break;
          }

          message.assetOptimized = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.createTime = reader.int64() as Long;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.latestOprationTime = reader.int64() as Long;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.allowance = reader.int64() as Long;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.latestWithdrawTime = reader.int64() as Long;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.code = reader.bytes() as Buffer;
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.isWitness = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.isCommittee = reader.bool();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.frozenSupply.push(Account_Frozen.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.assetIssuedName = reader.bytes() as Buffer;
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }

          message.assetIssuedID = reader.bytes() as Buffer;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          const entry18 = Account_LatestAssetOperationTimeEntry.decode(reader, reader.uint32());
          if (entry18.value !== undefined) {
            message.latestAssetOperationTime[entry18.key] = entry18.value;
          }
          continue;
        case 58:
          if (tag !== 466) {
            break;
          }

          const entry58 = Account_LatestAssetOperationTimeV2Entry.decode(reader, reader.uint32());
          if (entry58.value !== undefined) {
            message.latestAssetOperationTimeV2[entry58.key] = entry58.value;
          }
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.freeNetUsage = reader.int64() as Long;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          const entry20 = Account_FreeAssetNetUsageEntry.decode(reader, reader.uint32());
          if (entry20.value !== undefined) {
            message.freeAssetNetUsage[entry20.key] = entry20.value;
          }
          continue;
        case 59:
          if (tag !== 474) {
            break;
          }

          const entry59 = Account_FreeAssetNetUsageV2Entry.decode(reader, reader.uint32());
          if (entry59.value !== undefined) {
            message.freeAssetNetUsageV2[entry59.key] = entry59.value;
          }
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.latestConsumeTime = reader.int64() as Long;
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.latestConsumeFreeTime = reader.int64() as Long;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.accountId = reader.bytes() as Buffer;
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.netWindowSize = reader.int64() as Long;
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.netWindowOptimized = reader.bool();
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.accountResource = Account_AccountResource.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.codeHash = reader.bytes() as Buffer;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.ownerPermission = Permission.decode(reader, reader.uint32());
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.witnessPermission = Permission.decode(reader, reader.uint32());
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.activePermission.push(Permission.decode(reader, reader.uint32()));
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.frozenV2.push(Account_FreezeV2.decode(reader, reader.uint32()));
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.unfrozenV2.push(Account_UnFreezeV2.decode(reader, reader.uint32()));
          continue;
        case 36:
          if (tag !== 288) {
            break;
          }

          message.delegatedFrozenV2BalanceForBandwidth = reader.int64() as Long;
          continue;
        case 37:
          if (tag !== 296) {
            break;
          }

          message.acquiredDelegatedFrozenV2BalanceForBandwidth = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Account {
    return {
      accountName: isSet(object.accountName) ? Buffer.from(bytesFromBase64(object.accountName)) : Buffer.alloc(0),
      type: isSet(object.type) ? accountTypeFromJSON(object.type) : 0,
      address: isSet(object.address) ? Buffer.from(bytesFromBase64(object.address)) : Buffer.alloc(0),
      balance: isSet(object.balance) ? Long.fromValue(object.balance) : Long.ZERO,
      votes: globalThis.Array.isArray(object?.votes) ? object.votes.map((e: any) => Vote.fromJSON(e)) : [],
      asset: isObject(object.asset)
        ? Object.entries(object.asset).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
      assetV2: isObject(object.assetV2)
        ? Object.entries(object.assetV2).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
      frozen: globalThis.Array.isArray(object?.frozen) ? object.frozen.map((e: any) => Account_Frozen.fromJSON(e)) : [],
      netUsage: isSet(object.netUsage) ? Long.fromValue(object.netUsage) : Long.ZERO,
      acquiredDelegatedFrozenBalanceForBandwidth: isSet(object.acquiredDelegatedFrozenBalanceForBandwidth)
        ? Long.fromValue(object.acquiredDelegatedFrozenBalanceForBandwidth)
        : Long.ZERO,
      delegatedFrozenBalanceForBandwidth: isSet(object.delegatedFrozenBalanceForBandwidth)
        ? Long.fromValue(object.delegatedFrozenBalanceForBandwidth)
        : Long.ZERO,
      oldTronPower: isSet(object.oldTronPower) ? Long.fromValue(object.oldTronPower) : Long.ZERO,
      tronPower: isSet(object.tronPower) ? Account_Frozen.fromJSON(object.tronPower) : undefined,
      assetOptimized: isSet(object.assetOptimized) ? globalThis.Boolean(object.assetOptimized) : false,
      createTime: isSet(object.createTime) ? Long.fromValue(object.createTime) : Long.ZERO,
      latestOprationTime: isSet(object.latestOprationTime) ? Long.fromValue(object.latestOprationTime) : Long.ZERO,
      allowance: isSet(object.allowance) ? Long.fromValue(object.allowance) : Long.ZERO,
      latestWithdrawTime: isSet(object.latestWithdrawTime) ? Long.fromValue(object.latestWithdrawTime) : Long.ZERO,
      code: isSet(object.code) ? Buffer.from(bytesFromBase64(object.code)) : Buffer.alloc(0),
      isWitness: isSet(object.isWitness) ? globalThis.Boolean(object.isWitness) : false,
      isCommittee: isSet(object.isCommittee) ? globalThis.Boolean(object.isCommittee) : false,
      frozenSupply: globalThis.Array.isArray(object?.frozenSupply)
        ? object.frozenSupply.map((e: any) => Account_Frozen.fromJSON(e))
        : [],
      assetIssuedName: isSet(object.assetIssuedName)
        ? Buffer.from(bytesFromBase64(object.assetIssuedName))
        : Buffer.alloc(0),
      assetIssuedID: isSet(object.assetIssuedID) ? Buffer.from(bytesFromBase64(object.assetIssuedID)) : Buffer.alloc(0),
      latestAssetOperationTime: isObject(object.latestAssetOperationTime)
        ? Object.entries(object.latestAssetOperationTime).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
      latestAssetOperationTimeV2: isObject(object.latestAssetOperationTimeV2)
        ? Object.entries(object.latestAssetOperationTimeV2).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
      freeNetUsage: isSet(object.freeNetUsage) ? Long.fromValue(object.freeNetUsage) : Long.ZERO,
      freeAssetNetUsage: isObject(object.freeAssetNetUsage)
        ? Object.entries(object.freeAssetNetUsage).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
      freeAssetNetUsageV2: isObject(object.freeAssetNetUsageV2)
        ? Object.entries(object.freeAssetNetUsageV2).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
      latestConsumeTime: isSet(object.latestConsumeTime) ? Long.fromValue(object.latestConsumeTime) : Long.ZERO,
      latestConsumeFreeTime: isSet(object.latestConsumeFreeTime)
        ? Long.fromValue(object.latestConsumeFreeTime)
        : Long.ZERO,
      accountId: isSet(object.accountId) ? Buffer.from(bytesFromBase64(object.accountId)) : Buffer.alloc(0),
      netWindowSize: isSet(object.netWindowSize) ? Long.fromValue(object.netWindowSize) : Long.ZERO,
      netWindowOptimized: isSet(object.netWindowOptimized) ? globalThis.Boolean(object.netWindowOptimized) : false,
      accountResource: isSet(object.accountResource)
        ? Account_AccountResource.fromJSON(object.accountResource)
        : undefined,
      codeHash: isSet(object.codeHash) ? Buffer.from(bytesFromBase64(object.codeHash)) : Buffer.alloc(0),
      ownerPermission: isSet(object.ownerPermission) ? Permission.fromJSON(object.ownerPermission) : undefined,
      witnessPermission: isSet(object.witnessPermission) ? Permission.fromJSON(object.witnessPermission) : undefined,
      activePermission: globalThis.Array.isArray(object?.activePermission)
        ? object.activePermission.map((e: any) => Permission.fromJSON(e))
        : [],
      frozenV2: globalThis.Array.isArray(object?.frozenV2)
        ? object.frozenV2.map((e: any) => Account_FreezeV2.fromJSON(e))
        : [],
      unfrozenV2: globalThis.Array.isArray(object?.unfrozenV2)
        ? object.unfrozenV2.map((e: any) => Account_UnFreezeV2.fromJSON(e))
        : [],
      delegatedFrozenV2BalanceForBandwidth: isSet(object.delegatedFrozenV2BalanceForBandwidth)
        ? Long.fromValue(object.delegatedFrozenV2BalanceForBandwidth)
        : Long.ZERO,
      acquiredDelegatedFrozenV2BalanceForBandwidth: isSet(object.acquiredDelegatedFrozenV2BalanceForBandwidth)
        ? Long.fromValue(object.acquiredDelegatedFrozenV2BalanceForBandwidth)
        : Long.ZERO,
    };
  },

  toJSON(message: Account): unknown {
    const obj: any = {};
    if (message.accountName.length !== 0) {
      obj.accountName = base64FromBytes(message.accountName);
    }
    if (message.type !== 0) {
      obj.type = accountTypeToJSON(message.type);
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (!message.balance.equals(Long.ZERO)) {
      obj.balance = (message.balance || Long.ZERO).toString();
    }
    if (message.votes?.length) {
      obj.votes = message.votes.map((e) => Vote.toJSON(e));
    }
    if (message.asset) {
      const entries = Object.entries(message.asset);
      if (entries.length > 0) {
        obj.asset = {};
        entries.forEach(([k, v]) => {
          obj.asset[k] = v.toString();
        });
      }
    }
    if (message.assetV2) {
      const entries = Object.entries(message.assetV2);
      if (entries.length > 0) {
        obj.assetV2 = {};
        entries.forEach(([k, v]) => {
          obj.assetV2[k] = v.toString();
        });
      }
    }
    if (message.frozen?.length) {
      obj.frozen = message.frozen.map((e) => Account_Frozen.toJSON(e));
    }
    if (!message.netUsage.equals(Long.ZERO)) {
      obj.netUsage = (message.netUsage || Long.ZERO).toString();
    }
    if (!message.acquiredDelegatedFrozenBalanceForBandwidth.equals(Long.ZERO)) {
      obj.acquiredDelegatedFrozenBalanceForBandwidth = (message.acquiredDelegatedFrozenBalanceForBandwidth || Long.ZERO)
        .toString();
    }
    if (!message.delegatedFrozenBalanceForBandwidth.equals(Long.ZERO)) {
      obj.delegatedFrozenBalanceForBandwidth = (message.delegatedFrozenBalanceForBandwidth || Long.ZERO).toString();
    }
    if (!message.oldTronPower.equals(Long.ZERO)) {
      obj.oldTronPower = (message.oldTronPower || Long.ZERO).toString();
    }
    if (message.tronPower !== undefined) {
      obj.tronPower = Account_Frozen.toJSON(message.tronPower);
    }
    if (message.assetOptimized !== false) {
      obj.assetOptimized = message.assetOptimized;
    }
    if (!message.createTime.equals(Long.ZERO)) {
      obj.createTime = (message.createTime || Long.ZERO).toString();
    }
    if (!message.latestOprationTime.equals(Long.ZERO)) {
      obj.latestOprationTime = (message.latestOprationTime || Long.ZERO).toString();
    }
    if (!message.allowance.equals(Long.ZERO)) {
      obj.allowance = (message.allowance || Long.ZERO).toString();
    }
    if (!message.latestWithdrawTime.equals(Long.ZERO)) {
      obj.latestWithdrawTime = (message.latestWithdrawTime || Long.ZERO).toString();
    }
    if (message.code.length !== 0) {
      obj.code = base64FromBytes(message.code);
    }
    if (message.isWitness !== false) {
      obj.isWitness = message.isWitness;
    }
    if (message.isCommittee !== false) {
      obj.isCommittee = message.isCommittee;
    }
    if (message.frozenSupply?.length) {
      obj.frozenSupply = message.frozenSupply.map((e) => Account_Frozen.toJSON(e));
    }
    if (message.assetIssuedName.length !== 0) {
      obj.assetIssuedName = base64FromBytes(message.assetIssuedName);
    }
    if (message.assetIssuedID.length !== 0) {
      obj.assetIssuedID = base64FromBytes(message.assetIssuedID);
    }
    if (message.latestAssetOperationTime) {
      const entries = Object.entries(message.latestAssetOperationTime);
      if (entries.length > 0) {
        obj.latestAssetOperationTime = {};
        entries.forEach(([k, v]) => {
          obj.latestAssetOperationTime[k] = v.toString();
        });
      }
    }
    if (message.latestAssetOperationTimeV2) {
      const entries = Object.entries(message.latestAssetOperationTimeV2);
      if (entries.length > 0) {
        obj.latestAssetOperationTimeV2 = {};
        entries.forEach(([k, v]) => {
          obj.latestAssetOperationTimeV2[k] = v.toString();
        });
      }
    }
    if (!message.freeNetUsage.equals(Long.ZERO)) {
      obj.freeNetUsage = (message.freeNetUsage || Long.ZERO).toString();
    }
    if (message.freeAssetNetUsage) {
      const entries = Object.entries(message.freeAssetNetUsage);
      if (entries.length > 0) {
        obj.freeAssetNetUsage = {};
        entries.forEach(([k, v]) => {
          obj.freeAssetNetUsage[k] = v.toString();
        });
      }
    }
    if (message.freeAssetNetUsageV2) {
      const entries = Object.entries(message.freeAssetNetUsageV2);
      if (entries.length > 0) {
        obj.freeAssetNetUsageV2 = {};
        entries.forEach(([k, v]) => {
          obj.freeAssetNetUsageV2[k] = v.toString();
        });
      }
    }
    if (!message.latestConsumeTime.equals(Long.ZERO)) {
      obj.latestConsumeTime = (message.latestConsumeTime || Long.ZERO).toString();
    }
    if (!message.latestConsumeFreeTime.equals(Long.ZERO)) {
      obj.latestConsumeFreeTime = (message.latestConsumeFreeTime || Long.ZERO).toString();
    }
    if (message.accountId.length !== 0) {
      obj.accountId = base64FromBytes(message.accountId);
    }
    if (!message.netWindowSize.equals(Long.ZERO)) {
      obj.netWindowSize = (message.netWindowSize || Long.ZERO).toString();
    }
    if (message.netWindowOptimized !== false) {
      obj.netWindowOptimized = message.netWindowOptimized;
    }
    if (message.accountResource !== undefined) {
      obj.accountResource = Account_AccountResource.toJSON(message.accountResource);
    }
    if (message.codeHash.length !== 0) {
      obj.codeHash = base64FromBytes(message.codeHash);
    }
    if (message.ownerPermission !== undefined) {
      obj.ownerPermission = Permission.toJSON(message.ownerPermission);
    }
    if (message.witnessPermission !== undefined) {
      obj.witnessPermission = Permission.toJSON(message.witnessPermission);
    }
    if (message.activePermission?.length) {
      obj.activePermission = message.activePermission.map((e) => Permission.toJSON(e));
    }
    if (message.frozenV2?.length) {
      obj.frozenV2 = message.frozenV2.map((e) => Account_FreezeV2.toJSON(e));
    }
    if (message.unfrozenV2?.length) {
      obj.unfrozenV2 = message.unfrozenV2.map((e) => Account_UnFreezeV2.toJSON(e));
    }
    if (!message.delegatedFrozenV2BalanceForBandwidth.equals(Long.ZERO)) {
      obj.delegatedFrozenV2BalanceForBandwidth = (message.delegatedFrozenV2BalanceForBandwidth || Long.ZERO).toString();
    }
    if (!message.acquiredDelegatedFrozenV2BalanceForBandwidth.equals(Long.ZERO)) {
      obj.acquiredDelegatedFrozenV2BalanceForBandwidth =
        (message.acquiredDelegatedFrozenV2BalanceForBandwidth || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account>, I>>(base?: I): Account {
    return Account.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account>, I>>(object: I): Account {
    const message = createBaseAccount();
    message.accountName = object.accountName ?? Buffer.alloc(0);
    message.type = object.type ?? 0;
    message.address = object.address ?? Buffer.alloc(0);
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? Long.fromValue(object.balance)
      : Long.ZERO;
    message.votes = object.votes?.map((e) => Vote.fromPartial(e)) || [];
    message.asset = Object.entries(object.asset ?? {}).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Long.fromValue(value);
      }
      return acc;
    }, {});
    message.assetV2 = Object.entries(object.assetV2 ?? {}).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Long.fromValue(value);
      }
      return acc;
    }, {});
    message.frozen = object.frozen?.map((e) => Account_Frozen.fromPartial(e)) || [];
    message.netUsage = (object.netUsage !== undefined && object.netUsage !== null)
      ? Long.fromValue(object.netUsage)
      : Long.ZERO;
    message.acquiredDelegatedFrozenBalanceForBandwidth =
      (object.acquiredDelegatedFrozenBalanceForBandwidth !== undefined &&
          object.acquiredDelegatedFrozenBalanceForBandwidth !== null)
        ? Long.fromValue(object.acquiredDelegatedFrozenBalanceForBandwidth)
        : Long.ZERO;
    message.delegatedFrozenBalanceForBandwidth =
      (object.delegatedFrozenBalanceForBandwidth !== undefined && object.delegatedFrozenBalanceForBandwidth !== null)
        ? Long.fromValue(object.delegatedFrozenBalanceForBandwidth)
        : Long.ZERO;
    message.oldTronPower = (object.oldTronPower !== undefined && object.oldTronPower !== null)
      ? Long.fromValue(object.oldTronPower)
      : Long.ZERO;
    message.tronPower = (object.tronPower !== undefined && object.tronPower !== null)
      ? Account_Frozen.fromPartial(object.tronPower)
      : undefined;
    message.assetOptimized = object.assetOptimized ?? false;
    message.createTime = (object.createTime !== undefined && object.createTime !== null)
      ? Long.fromValue(object.createTime)
      : Long.ZERO;
    message.latestOprationTime = (object.latestOprationTime !== undefined && object.latestOprationTime !== null)
      ? Long.fromValue(object.latestOprationTime)
      : Long.ZERO;
    message.allowance = (object.allowance !== undefined && object.allowance !== null)
      ? Long.fromValue(object.allowance)
      : Long.ZERO;
    message.latestWithdrawTime = (object.latestWithdrawTime !== undefined && object.latestWithdrawTime !== null)
      ? Long.fromValue(object.latestWithdrawTime)
      : Long.ZERO;
    message.code = object.code ?? Buffer.alloc(0);
    message.isWitness = object.isWitness ?? false;
    message.isCommittee = object.isCommittee ?? false;
    message.frozenSupply = object.frozenSupply?.map((e) => Account_Frozen.fromPartial(e)) || [];
    message.assetIssuedName = object.assetIssuedName ?? Buffer.alloc(0);
    message.assetIssuedID = object.assetIssuedID ?? Buffer.alloc(0);
    message.latestAssetOperationTime = Object.entries(object.latestAssetOperationTime ?? {}).reduce<
      { [key: string]: Long }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Long.fromValue(value);
      }
      return acc;
    }, {});
    message.latestAssetOperationTimeV2 = Object.entries(object.latestAssetOperationTimeV2 ?? {}).reduce<
      { [key: string]: Long }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Long.fromValue(value);
      }
      return acc;
    }, {});
    message.freeNetUsage = (object.freeNetUsage !== undefined && object.freeNetUsage !== null)
      ? Long.fromValue(object.freeNetUsage)
      : Long.ZERO;
    message.freeAssetNetUsage = Object.entries(object.freeAssetNetUsage ?? {}).reduce<{ [key: string]: Long }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Long.fromValue(value);
        }
        return acc;
      },
      {},
    );
    message.freeAssetNetUsageV2 = Object.entries(object.freeAssetNetUsageV2 ?? {}).reduce<{ [key: string]: Long }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Long.fromValue(value);
        }
        return acc;
      },
      {},
    );
    message.latestConsumeTime = (object.latestConsumeTime !== undefined && object.latestConsumeTime !== null)
      ? Long.fromValue(object.latestConsumeTime)
      : Long.ZERO;
    message.latestConsumeFreeTime =
      (object.latestConsumeFreeTime !== undefined && object.latestConsumeFreeTime !== null)
        ? Long.fromValue(object.latestConsumeFreeTime)
        : Long.ZERO;
    message.accountId = object.accountId ?? Buffer.alloc(0);
    message.netWindowSize = (object.netWindowSize !== undefined && object.netWindowSize !== null)
      ? Long.fromValue(object.netWindowSize)
      : Long.ZERO;
    message.netWindowOptimized = object.netWindowOptimized ?? false;
    message.accountResource = (object.accountResource !== undefined && object.accountResource !== null)
      ? Account_AccountResource.fromPartial(object.accountResource)
      : undefined;
    message.codeHash = object.codeHash ?? Buffer.alloc(0);
    message.ownerPermission = (object.ownerPermission !== undefined && object.ownerPermission !== null)
      ? Permission.fromPartial(object.ownerPermission)
      : undefined;
    message.witnessPermission = (object.witnessPermission !== undefined && object.witnessPermission !== null)
      ? Permission.fromPartial(object.witnessPermission)
      : undefined;
    message.activePermission = object.activePermission?.map((e) => Permission.fromPartial(e)) || [];
    message.frozenV2 = object.frozenV2?.map((e) => Account_FreezeV2.fromPartial(e)) || [];
    message.unfrozenV2 = object.unfrozenV2?.map((e) => Account_UnFreezeV2.fromPartial(e)) || [];
    message.delegatedFrozenV2BalanceForBandwidth =
      (object.delegatedFrozenV2BalanceForBandwidth !== undefined &&
          object.delegatedFrozenV2BalanceForBandwidth !== null)
        ? Long.fromValue(object.delegatedFrozenV2BalanceForBandwidth)
        : Long.ZERO;
    message.acquiredDelegatedFrozenV2BalanceForBandwidth =
      (object.acquiredDelegatedFrozenV2BalanceForBandwidth !== undefined &&
          object.acquiredDelegatedFrozenV2BalanceForBandwidth !== null)
        ? Long.fromValue(object.acquiredDelegatedFrozenV2BalanceForBandwidth)
        : Long.ZERO;
    return message;
  },
};

function createBaseAccount_Frozen(): Account_Frozen {
  return { frozenBalance: Long.ZERO, expireTime: Long.ZERO, _unknownFields: {} };
}

export const Account_Frozen = {
  encode(message: Account_Frozen, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.frozenBalance.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.frozenBalance);
    }
    if (!message.expireTime.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.expireTime);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Account_Frozen {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount_Frozen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.frozenBalance = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.expireTime = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Account_Frozen {
    return {
      frozenBalance: isSet(object.frozenBalance) ? Long.fromValue(object.frozenBalance) : Long.ZERO,
      expireTime: isSet(object.expireTime) ? Long.fromValue(object.expireTime) : Long.ZERO,
    };
  },

  toJSON(message: Account_Frozen): unknown {
    const obj: any = {};
    if (!message.frozenBalance.equals(Long.ZERO)) {
      obj.frozenBalance = (message.frozenBalance || Long.ZERO).toString();
    }
    if (!message.expireTime.equals(Long.ZERO)) {
      obj.expireTime = (message.expireTime || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account_Frozen>, I>>(base?: I): Account_Frozen {
    return Account_Frozen.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account_Frozen>, I>>(object: I): Account_Frozen {
    const message = createBaseAccount_Frozen();
    message.frozenBalance = (object.frozenBalance !== undefined && object.frozenBalance !== null)
      ? Long.fromValue(object.frozenBalance)
      : Long.ZERO;
    message.expireTime = (object.expireTime !== undefined && object.expireTime !== null)
      ? Long.fromValue(object.expireTime)
      : Long.ZERO;
    return message;
  },
};

function createBaseAccount_AssetEntry(): Account_AssetEntry {
  return { key: "", value: Long.ZERO, _unknownFields: {} };
}

export const Account_AssetEntry = {
  encode(message: Account_AssetEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Account_AssetEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount_AssetEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Account_AssetEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: Account_AssetEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account_AssetEntry>, I>>(base?: I): Account_AssetEntry {
    return Account_AssetEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account_AssetEntry>, I>>(object: I): Account_AssetEntry {
    const message = createBaseAccount_AssetEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseAccount_AssetV2Entry(): Account_AssetV2Entry {
  return { key: "", value: Long.ZERO, _unknownFields: {} };
}

export const Account_AssetV2Entry = {
  encode(message: Account_AssetV2Entry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Account_AssetV2Entry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount_AssetV2Entry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Account_AssetV2Entry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: Account_AssetV2Entry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account_AssetV2Entry>, I>>(base?: I): Account_AssetV2Entry {
    return Account_AssetV2Entry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account_AssetV2Entry>, I>>(object: I): Account_AssetV2Entry {
    const message = createBaseAccount_AssetV2Entry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseAccount_LatestAssetOperationTimeEntry(): Account_LatestAssetOperationTimeEntry {
  return { key: "", value: Long.ZERO, _unknownFields: {} };
}

export const Account_LatestAssetOperationTimeEntry = {
  encode(message: Account_LatestAssetOperationTimeEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Account_LatestAssetOperationTimeEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount_LatestAssetOperationTimeEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Account_LatestAssetOperationTimeEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: Account_LatestAssetOperationTimeEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account_LatestAssetOperationTimeEntry>, I>>(
    base?: I,
  ): Account_LatestAssetOperationTimeEntry {
    return Account_LatestAssetOperationTimeEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account_LatestAssetOperationTimeEntry>, I>>(
    object: I,
  ): Account_LatestAssetOperationTimeEntry {
    const message = createBaseAccount_LatestAssetOperationTimeEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseAccount_LatestAssetOperationTimeV2Entry(): Account_LatestAssetOperationTimeV2Entry {
  return { key: "", value: Long.ZERO, _unknownFields: {} };
}

export const Account_LatestAssetOperationTimeV2Entry = {
  encode(message: Account_LatestAssetOperationTimeV2Entry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Account_LatestAssetOperationTimeV2Entry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount_LatestAssetOperationTimeV2Entry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Account_LatestAssetOperationTimeV2Entry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: Account_LatestAssetOperationTimeV2Entry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account_LatestAssetOperationTimeV2Entry>, I>>(
    base?: I,
  ): Account_LatestAssetOperationTimeV2Entry {
    return Account_LatestAssetOperationTimeV2Entry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account_LatestAssetOperationTimeV2Entry>, I>>(
    object: I,
  ): Account_LatestAssetOperationTimeV2Entry {
    const message = createBaseAccount_LatestAssetOperationTimeV2Entry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseAccount_FreeAssetNetUsageEntry(): Account_FreeAssetNetUsageEntry {
  return { key: "", value: Long.ZERO, _unknownFields: {} };
}

export const Account_FreeAssetNetUsageEntry = {
  encode(message: Account_FreeAssetNetUsageEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Account_FreeAssetNetUsageEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount_FreeAssetNetUsageEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Account_FreeAssetNetUsageEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: Account_FreeAssetNetUsageEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account_FreeAssetNetUsageEntry>, I>>(base?: I): Account_FreeAssetNetUsageEntry {
    return Account_FreeAssetNetUsageEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account_FreeAssetNetUsageEntry>, I>>(
    object: I,
  ): Account_FreeAssetNetUsageEntry {
    const message = createBaseAccount_FreeAssetNetUsageEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseAccount_FreeAssetNetUsageV2Entry(): Account_FreeAssetNetUsageV2Entry {
  return { key: "", value: Long.ZERO, _unknownFields: {} };
}

export const Account_FreeAssetNetUsageV2Entry = {
  encode(message: Account_FreeAssetNetUsageV2Entry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Account_FreeAssetNetUsageV2Entry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount_FreeAssetNetUsageV2Entry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Account_FreeAssetNetUsageV2Entry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: Account_FreeAssetNetUsageV2Entry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account_FreeAssetNetUsageV2Entry>, I>>(
    base?: I,
  ): Account_FreeAssetNetUsageV2Entry {
    return Account_FreeAssetNetUsageV2Entry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account_FreeAssetNetUsageV2Entry>, I>>(
    object: I,
  ): Account_FreeAssetNetUsageV2Entry {
    const message = createBaseAccount_FreeAssetNetUsageV2Entry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseAccount_AccountResource(): Account_AccountResource {
  return {
    energyUsage: Long.ZERO,
    frozenBalanceForEnergy: undefined,
    latestConsumeTimeForEnergy: Long.ZERO,
    acquiredDelegatedFrozenBalanceForEnergy: Long.ZERO,
    delegatedFrozenBalanceForEnergy: Long.ZERO,
    storageLimit: Long.ZERO,
    storageUsage: Long.ZERO,
    latestExchangeStorageTime: Long.ZERO,
    energyWindowSize: Long.ZERO,
    delegatedFrozenV2BalanceForEnergy: Long.ZERO,
    acquiredDelegatedFrozenV2BalanceForEnergy: Long.ZERO,
    energyWindowOptimized: false,
    _unknownFields: {},
  };
}

export const Account_AccountResource = {
  encode(message: Account_AccountResource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.energyUsage.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.energyUsage);
    }
    if (message.frozenBalanceForEnergy !== undefined) {
      Account_Frozen.encode(message.frozenBalanceForEnergy, writer.uint32(18).fork()).ldelim();
    }
    if (!message.latestConsumeTimeForEnergy.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.latestConsumeTimeForEnergy);
    }
    if (!message.acquiredDelegatedFrozenBalanceForEnergy.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.acquiredDelegatedFrozenBalanceForEnergy);
    }
    if (!message.delegatedFrozenBalanceForEnergy.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.delegatedFrozenBalanceForEnergy);
    }
    if (!message.storageLimit.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.storageLimit);
    }
    if (!message.storageUsage.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.storageUsage);
    }
    if (!message.latestExchangeStorageTime.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.latestExchangeStorageTime);
    }
    if (!message.energyWindowSize.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.energyWindowSize);
    }
    if (!message.delegatedFrozenV2BalanceForEnergy.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.delegatedFrozenV2BalanceForEnergy);
    }
    if (!message.acquiredDelegatedFrozenV2BalanceForEnergy.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.acquiredDelegatedFrozenV2BalanceForEnergy);
    }
    if (message.energyWindowOptimized !== false) {
      writer.uint32(96).bool(message.energyWindowOptimized);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Account_AccountResource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount_AccountResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.energyUsage = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.frozenBalanceForEnergy = Account_Frozen.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.latestConsumeTimeForEnergy = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.acquiredDelegatedFrozenBalanceForEnergy = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.delegatedFrozenBalanceForEnergy = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.storageLimit = reader.int64() as Long;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.storageUsage = reader.int64() as Long;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.latestExchangeStorageTime = reader.int64() as Long;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.energyWindowSize = reader.int64() as Long;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.delegatedFrozenV2BalanceForEnergy = reader.int64() as Long;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.acquiredDelegatedFrozenV2BalanceForEnergy = reader.int64() as Long;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.energyWindowOptimized = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Account_AccountResource {
    return {
      energyUsage: isSet(object.energyUsage) ? Long.fromValue(object.energyUsage) : Long.ZERO,
      frozenBalanceForEnergy: isSet(object.frozenBalanceForEnergy)
        ? Account_Frozen.fromJSON(object.frozenBalanceForEnergy)
        : undefined,
      latestConsumeTimeForEnergy: isSet(object.latestConsumeTimeForEnergy)
        ? Long.fromValue(object.latestConsumeTimeForEnergy)
        : Long.ZERO,
      acquiredDelegatedFrozenBalanceForEnergy: isSet(object.acquiredDelegatedFrozenBalanceForEnergy)
        ? Long.fromValue(object.acquiredDelegatedFrozenBalanceForEnergy)
        : Long.ZERO,
      delegatedFrozenBalanceForEnergy: isSet(object.delegatedFrozenBalanceForEnergy)
        ? Long.fromValue(object.delegatedFrozenBalanceForEnergy)
        : Long.ZERO,
      storageLimit: isSet(object.storageLimit) ? Long.fromValue(object.storageLimit) : Long.ZERO,
      storageUsage: isSet(object.storageUsage) ? Long.fromValue(object.storageUsage) : Long.ZERO,
      latestExchangeStorageTime: isSet(object.latestExchangeStorageTime)
        ? Long.fromValue(object.latestExchangeStorageTime)
        : Long.ZERO,
      energyWindowSize: isSet(object.energyWindowSize) ? Long.fromValue(object.energyWindowSize) : Long.ZERO,
      delegatedFrozenV2BalanceForEnergy: isSet(object.delegatedFrozenV2BalanceForEnergy)
        ? Long.fromValue(object.delegatedFrozenV2BalanceForEnergy)
        : Long.ZERO,
      acquiredDelegatedFrozenV2BalanceForEnergy: isSet(object.acquiredDelegatedFrozenV2BalanceForEnergy)
        ? Long.fromValue(object.acquiredDelegatedFrozenV2BalanceForEnergy)
        : Long.ZERO,
      energyWindowOptimized: isSet(object.energyWindowOptimized)
        ? globalThis.Boolean(object.energyWindowOptimized)
        : false,
    };
  },

  toJSON(message: Account_AccountResource): unknown {
    const obj: any = {};
    if (!message.energyUsage.equals(Long.ZERO)) {
      obj.energyUsage = (message.energyUsage || Long.ZERO).toString();
    }
    if (message.frozenBalanceForEnergy !== undefined) {
      obj.frozenBalanceForEnergy = Account_Frozen.toJSON(message.frozenBalanceForEnergy);
    }
    if (!message.latestConsumeTimeForEnergy.equals(Long.ZERO)) {
      obj.latestConsumeTimeForEnergy = (message.latestConsumeTimeForEnergy || Long.ZERO).toString();
    }
    if (!message.acquiredDelegatedFrozenBalanceForEnergy.equals(Long.ZERO)) {
      obj.acquiredDelegatedFrozenBalanceForEnergy = (message.acquiredDelegatedFrozenBalanceForEnergy || Long.ZERO)
        .toString();
    }
    if (!message.delegatedFrozenBalanceForEnergy.equals(Long.ZERO)) {
      obj.delegatedFrozenBalanceForEnergy = (message.delegatedFrozenBalanceForEnergy || Long.ZERO).toString();
    }
    if (!message.storageLimit.equals(Long.ZERO)) {
      obj.storageLimit = (message.storageLimit || Long.ZERO).toString();
    }
    if (!message.storageUsage.equals(Long.ZERO)) {
      obj.storageUsage = (message.storageUsage || Long.ZERO).toString();
    }
    if (!message.latestExchangeStorageTime.equals(Long.ZERO)) {
      obj.latestExchangeStorageTime = (message.latestExchangeStorageTime || Long.ZERO).toString();
    }
    if (!message.energyWindowSize.equals(Long.ZERO)) {
      obj.energyWindowSize = (message.energyWindowSize || Long.ZERO).toString();
    }
    if (!message.delegatedFrozenV2BalanceForEnergy.equals(Long.ZERO)) {
      obj.delegatedFrozenV2BalanceForEnergy = (message.delegatedFrozenV2BalanceForEnergy || Long.ZERO).toString();
    }
    if (!message.acquiredDelegatedFrozenV2BalanceForEnergy.equals(Long.ZERO)) {
      obj.acquiredDelegatedFrozenV2BalanceForEnergy = (message.acquiredDelegatedFrozenV2BalanceForEnergy || Long.ZERO)
        .toString();
    }
    if (message.energyWindowOptimized !== false) {
      obj.energyWindowOptimized = message.energyWindowOptimized;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account_AccountResource>, I>>(base?: I): Account_AccountResource {
    return Account_AccountResource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account_AccountResource>, I>>(object: I): Account_AccountResource {
    const message = createBaseAccount_AccountResource();
    message.energyUsage = (object.energyUsage !== undefined && object.energyUsage !== null)
      ? Long.fromValue(object.energyUsage)
      : Long.ZERO;
    message.frozenBalanceForEnergy =
      (object.frozenBalanceForEnergy !== undefined && object.frozenBalanceForEnergy !== null)
        ? Account_Frozen.fromPartial(object.frozenBalanceForEnergy)
        : undefined;
    message.latestConsumeTimeForEnergy =
      (object.latestConsumeTimeForEnergy !== undefined && object.latestConsumeTimeForEnergy !== null)
        ? Long.fromValue(object.latestConsumeTimeForEnergy)
        : Long.ZERO;
    message.acquiredDelegatedFrozenBalanceForEnergy =
      (object.acquiredDelegatedFrozenBalanceForEnergy !== undefined &&
          object.acquiredDelegatedFrozenBalanceForEnergy !== null)
        ? Long.fromValue(object.acquiredDelegatedFrozenBalanceForEnergy)
        : Long.ZERO;
    message.delegatedFrozenBalanceForEnergy =
      (object.delegatedFrozenBalanceForEnergy !== undefined && object.delegatedFrozenBalanceForEnergy !== null)
        ? Long.fromValue(object.delegatedFrozenBalanceForEnergy)
        : Long.ZERO;
    message.storageLimit = (object.storageLimit !== undefined && object.storageLimit !== null)
      ? Long.fromValue(object.storageLimit)
      : Long.ZERO;
    message.storageUsage = (object.storageUsage !== undefined && object.storageUsage !== null)
      ? Long.fromValue(object.storageUsage)
      : Long.ZERO;
    message.latestExchangeStorageTime =
      (object.latestExchangeStorageTime !== undefined && object.latestExchangeStorageTime !== null)
        ? Long.fromValue(object.latestExchangeStorageTime)
        : Long.ZERO;
    message.energyWindowSize = (object.energyWindowSize !== undefined && object.energyWindowSize !== null)
      ? Long.fromValue(object.energyWindowSize)
      : Long.ZERO;
    message.delegatedFrozenV2BalanceForEnergy =
      (object.delegatedFrozenV2BalanceForEnergy !== undefined && object.delegatedFrozenV2BalanceForEnergy !== null)
        ? Long.fromValue(object.delegatedFrozenV2BalanceForEnergy)
        : Long.ZERO;
    message.acquiredDelegatedFrozenV2BalanceForEnergy =
      (object.acquiredDelegatedFrozenV2BalanceForEnergy !== undefined &&
          object.acquiredDelegatedFrozenV2BalanceForEnergy !== null)
        ? Long.fromValue(object.acquiredDelegatedFrozenV2BalanceForEnergy)
        : Long.ZERO;
    message.energyWindowOptimized = object.energyWindowOptimized ?? false;
    return message;
  },
};

function createBaseAccount_FreezeV2(): Account_FreezeV2 {
  return { type: 0, amount: Long.ZERO, _unknownFields: {} };
}

export const Account_FreezeV2 = {
  encode(message: Account_FreezeV2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (!message.amount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.amount);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Account_FreezeV2 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount_FreezeV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Account_FreezeV2 {
    return {
      type: isSet(object.type) ? resourceCodeFromJSON(object.type) : 0,
      amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.ZERO,
    };
  },

  toJSON(message: Account_FreezeV2): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = resourceCodeToJSON(message.type);
    }
    if (!message.amount.equals(Long.ZERO)) {
      obj.amount = (message.amount || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account_FreezeV2>, I>>(base?: I): Account_FreezeV2 {
    return Account_FreezeV2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account_FreezeV2>, I>>(object: I): Account_FreezeV2 {
    const message = createBaseAccount_FreezeV2();
    message.type = object.type ?? 0;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.ZERO;
    return message;
  },
};

function createBaseAccount_UnFreezeV2(): Account_UnFreezeV2 {
  return { type: 0, unfreezeAmount: Long.ZERO, unfreezeExpireTime: Long.ZERO, _unknownFields: {} };
}

export const Account_UnFreezeV2 = {
  encode(message: Account_UnFreezeV2, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (!message.unfreezeAmount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.unfreezeAmount);
    }
    if (!message.unfreezeExpireTime.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.unfreezeExpireTime);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Account_UnFreezeV2 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount_UnFreezeV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.unfreezeAmount = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.unfreezeExpireTime = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Account_UnFreezeV2 {
    return {
      type: isSet(object.type) ? resourceCodeFromJSON(object.type) : 0,
      unfreezeAmount: isSet(object.unfreezeAmount) ? Long.fromValue(object.unfreezeAmount) : Long.ZERO,
      unfreezeExpireTime: isSet(object.unfreezeExpireTime) ? Long.fromValue(object.unfreezeExpireTime) : Long.ZERO,
    };
  },

  toJSON(message: Account_UnFreezeV2): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = resourceCodeToJSON(message.type);
    }
    if (!message.unfreezeAmount.equals(Long.ZERO)) {
      obj.unfreezeAmount = (message.unfreezeAmount || Long.ZERO).toString();
    }
    if (!message.unfreezeExpireTime.equals(Long.ZERO)) {
      obj.unfreezeExpireTime = (message.unfreezeExpireTime || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account_UnFreezeV2>, I>>(base?: I): Account_UnFreezeV2 {
    return Account_UnFreezeV2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account_UnFreezeV2>, I>>(object: I): Account_UnFreezeV2 {
    const message = createBaseAccount_UnFreezeV2();
    message.type = object.type ?? 0;
    message.unfreezeAmount = (object.unfreezeAmount !== undefined && object.unfreezeAmount !== null)
      ? Long.fromValue(object.unfreezeAmount)
      : Long.ZERO;
    message.unfreezeExpireTime = (object.unfreezeExpireTime !== undefined && object.unfreezeExpireTime !== null)
      ? Long.fromValue(object.unfreezeExpireTime)
      : Long.ZERO;
    return message;
  },
};

function createBaseKey(): Key {
  return { address: Buffer.alloc(0), weight: Long.ZERO, _unknownFields: {} };
}

export const Key = {
  encode(message: Key, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    if (!message.weight.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.weight);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Key {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.weight = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Key {
    return {
      address: isSet(object.address) ? Buffer.from(bytesFromBase64(object.address)) : Buffer.alloc(0),
      weight: isSet(object.weight) ? Long.fromValue(object.weight) : Long.ZERO,
    };
  },

  toJSON(message: Key): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (!message.weight.equals(Long.ZERO)) {
      obj.weight = (message.weight || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Key>, I>>(base?: I): Key {
    return Key.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Key>, I>>(object: I): Key {
    const message = createBaseKey();
    message.address = object.address ?? Buffer.alloc(0);
    message.weight = (object.weight !== undefined && object.weight !== null)
      ? Long.fromValue(object.weight)
      : Long.ZERO;
    return message;
  },
};

function createBaseDelegatedResource(): DelegatedResource {
  return {
    from: Buffer.alloc(0),
    to: Buffer.alloc(0),
    frozenBalanceForBandwidth: Long.ZERO,
    frozenBalanceForEnergy: Long.ZERO,
    expireTimeForBandwidth: Long.ZERO,
    expireTimeForEnergy: Long.ZERO,
    _unknownFields: {},
  };
}

export const DelegatedResource = {
  encode(message: DelegatedResource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from.length !== 0) {
      writer.uint32(10).bytes(message.from);
    }
    if (message.to.length !== 0) {
      writer.uint32(18).bytes(message.to);
    }
    if (!message.frozenBalanceForBandwidth.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.frozenBalanceForBandwidth);
    }
    if (!message.frozenBalanceForEnergy.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.frozenBalanceForEnergy);
    }
    if (!message.expireTimeForBandwidth.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.expireTimeForBandwidth);
    }
    if (!message.expireTimeForEnergy.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.expireTimeForEnergy);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DelegatedResource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegatedResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.frozenBalanceForBandwidth = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.frozenBalanceForEnergy = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.expireTimeForBandwidth = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.expireTimeForEnergy = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): DelegatedResource {
    return {
      from: isSet(object.from) ? Buffer.from(bytesFromBase64(object.from)) : Buffer.alloc(0),
      to: isSet(object.to) ? Buffer.from(bytesFromBase64(object.to)) : Buffer.alloc(0),
      frozenBalanceForBandwidth: isSet(object.frozenBalanceForBandwidth)
        ? Long.fromValue(object.frozenBalanceForBandwidth)
        : Long.ZERO,
      frozenBalanceForEnergy: isSet(object.frozenBalanceForEnergy)
        ? Long.fromValue(object.frozenBalanceForEnergy)
        : Long.ZERO,
      expireTimeForBandwidth: isSet(object.expireTimeForBandwidth)
        ? Long.fromValue(object.expireTimeForBandwidth)
        : Long.ZERO,
      expireTimeForEnergy: isSet(object.expireTimeForEnergy) ? Long.fromValue(object.expireTimeForEnergy) : Long.ZERO,
    };
  },

  toJSON(message: DelegatedResource): unknown {
    const obj: any = {};
    if (message.from.length !== 0) {
      obj.from = base64FromBytes(message.from);
    }
    if (message.to.length !== 0) {
      obj.to = base64FromBytes(message.to);
    }
    if (!message.frozenBalanceForBandwidth.equals(Long.ZERO)) {
      obj.frozenBalanceForBandwidth = (message.frozenBalanceForBandwidth || Long.ZERO).toString();
    }
    if (!message.frozenBalanceForEnergy.equals(Long.ZERO)) {
      obj.frozenBalanceForEnergy = (message.frozenBalanceForEnergy || Long.ZERO).toString();
    }
    if (!message.expireTimeForBandwidth.equals(Long.ZERO)) {
      obj.expireTimeForBandwidth = (message.expireTimeForBandwidth || Long.ZERO).toString();
    }
    if (!message.expireTimeForEnergy.equals(Long.ZERO)) {
      obj.expireTimeForEnergy = (message.expireTimeForEnergy || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DelegatedResource>, I>>(base?: I): DelegatedResource {
    return DelegatedResource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DelegatedResource>, I>>(object: I): DelegatedResource {
    const message = createBaseDelegatedResource();
    message.from = object.from ?? Buffer.alloc(0);
    message.to = object.to ?? Buffer.alloc(0);
    message.frozenBalanceForBandwidth =
      (object.frozenBalanceForBandwidth !== undefined && object.frozenBalanceForBandwidth !== null)
        ? Long.fromValue(object.frozenBalanceForBandwidth)
        : Long.ZERO;
    message.frozenBalanceForEnergy =
      (object.frozenBalanceForEnergy !== undefined && object.frozenBalanceForEnergy !== null)
        ? Long.fromValue(object.frozenBalanceForEnergy)
        : Long.ZERO;
    message.expireTimeForBandwidth =
      (object.expireTimeForBandwidth !== undefined && object.expireTimeForBandwidth !== null)
        ? Long.fromValue(object.expireTimeForBandwidth)
        : Long.ZERO;
    message.expireTimeForEnergy = (object.expireTimeForEnergy !== undefined && object.expireTimeForEnergy !== null)
      ? Long.fromValue(object.expireTimeForEnergy)
      : Long.ZERO;
    return message;
  },
};

function createBaseauthority(): authority {
  return { account: undefined, permissionName: Buffer.alloc(0), _unknownFields: {} };
}

export const authority = {
  encode(message: authority, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account !== undefined) {
      AccountId.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.permissionName.length !== 0) {
      writer.uint32(18).bytes(message.permissionName);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): authority {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseauthority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = AccountId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.permissionName = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): authority {
    return {
      account: isSet(object.account) ? AccountId.fromJSON(object.account) : undefined,
      permissionName: isSet(object.permissionName)
        ? Buffer.from(bytesFromBase64(object.permissionName))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: authority): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = AccountId.toJSON(message.account);
    }
    if (message.permissionName.length !== 0) {
      obj.permissionName = base64FromBytes(message.permissionName);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<authority>, I>>(base?: I): authority {
    return authority.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<authority>, I>>(object: I): authority {
    const message = createBaseauthority();
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountId.fromPartial(object.account)
      : undefined;
    message.permissionName = object.permissionName ?? Buffer.alloc(0);
    return message;
  },
};

function createBasePermission(): Permission {
  return {
    type: 0,
    id: 0,
    permissionName: "",
    threshold: Long.ZERO,
    parentId: 0,
    operations: Buffer.alloc(0),
    keys: [],
    _unknownFields: {},
  };
}

export const Permission = {
  encode(message: Permission, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== 0) {
      writer.uint32(16).int32(message.id);
    }
    if (message.permissionName !== "") {
      writer.uint32(26).string(message.permissionName);
    }
    if (!message.threshold.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.threshold);
    }
    if (message.parentId !== 0) {
      writer.uint32(40).int32(message.parentId);
    }
    if (message.operations.length !== 0) {
      writer.uint32(50).bytes(message.operations);
    }
    for (const v of message.keys) {
      Key.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Permission {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.permissionName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.threshold = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.parentId = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.operations = reader.bytes() as Buffer;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.keys.push(Key.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Permission {
    return {
      type: isSet(object.type) ? permission_PermissionTypeFromJSON(object.type) : 0,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      permissionName: isSet(object.permissionName) ? globalThis.String(object.permissionName) : "",
      threshold: isSet(object.threshold) ? Long.fromValue(object.threshold) : Long.ZERO,
      parentId: isSet(object.parentId) ? globalThis.Number(object.parentId) : 0,
      operations: isSet(object.operations) ? Buffer.from(bytesFromBase64(object.operations)) : Buffer.alloc(0),
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => Key.fromJSON(e)) : [],
    };
  },

  toJSON(message: Permission): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = permission_PermissionTypeToJSON(message.type);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.permissionName !== "") {
      obj.permissionName = message.permissionName;
    }
    if (!message.threshold.equals(Long.ZERO)) {
      obj.threshold = (message.threshold || Long.ZERO).toString();
    }
    if (message.parentId !== 0) {
      obj.parentId = Math.round(message.parentId);
    }
    if (message.operations.length !== 0) {
      obj.operations = base64FromBytes(message.operations);
    }
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => Key.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Permission>, I>>(base?: I): Permission {
    return Permission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Permission>, I>>(object: I): Permission {
    const message = createBasePermission();
    message.type = object.type ?? 0;
    message.id = object.id ?? 0;
    message.permissionName = object.permissionName ?? "";
    message.threshold = (object.threshold !== undefined && object.threshold !== null)
      ? Long.fromValue(object.threshold)
      : Long.ZERO;
    message.parentId = object.parentId ?? 0;
    message.operations = object.operations ?? Buffer.alloc(0);
    message.keys = object.keys?.map((e) => Key.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWitness(): Witness {
  return {
    address: Buffer.alloc(0),
    voteCount: Long.ZERO,
    pubKey: Buffer.alloc(0),
    url: "",
    totalProduced: Long.ZERO,
    totalMissed: Long.ZERO,
    latestBlockNum: Long.ZERO,
    latestSlotNum: Long.ZERO,
    isJobs: false,
    _unknownFields: {},
  };
}

export const Witness = {
  encode(message: Witness, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    if (!message.voteCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.voteCount);
    }
    if (message.pubKey.length !== 0) {
      writer.uint32(26).bytes(message.pubKey);
    }
    if (message.url !== "") {
      writer.uint32(34).string(message.url);
    }
    if (!message.totalProduced.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.totalProduced);
    }
    if (!message.totalMissed.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.totalMissed);
    }
    if (!message.latestBlockNum.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.latestBlockNum);
    }
    if (!message.latestSlotNum.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.latestSlotNum);
    }
    if (message.isJobs !== false) {
      writer.uint32(72).bool(message.isJobs);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Witness {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWitness();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.voteCount = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pubKey = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.url = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalProduced = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.totalMissed = reader.int64() as Long;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.latestBlockNum = reader.int64() as Long;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.latestSlotNum = reader.int64() as Long;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isJobs = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Witness {
    return {
      address: isSet(object.address) ? Buffer.from(bytesFromBase64(object.address)) : Buffer.alloc(0),
      voteCount: isSet(object.voteCount) ? Long.fromValue(object.voteCount) : Long.ZERO,
      pubKey: isSet(object.pubKey) ? Buffer.from(bytesFromBase64(object.pubKey)) : Buffer.alloc(0),
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      totalProduced: isSet(object.totalProduced) ? Long.fromValue(object.totalProduced) : Long.ZERO,
      totalMissed: isSet(object.totalMissed) ? Long.fromValue(object.totalMissed) : Long.ZERO,
      latestBlockNum: isSet(object.latestBlockNum) ? Long.fromValue(object.latestBlockNum) : Long.ZERO,
      latestSlotNum: isSet(object.latestSlotNum) ? Long.fromValue(object.latestSlotNum) : Long.ZERO,
      isJobs: isSet(object.isJobs) ? globalThis.Boolean(object.isJobs) : false,
    };
  },

  toJSON(message: Witness): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (!message.voteCount.equals(Long.ZERO)) {
      obj.voteCount = (message.voteCount || Long.ZERO).toString();
    }
    if (message.pubKey.length !== 0) {
      obj.pubKey = base64FromBytes(message.pubKey);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (!message.totalProduced.equals(Long.ZERO)) {
      obj.totalProduced = (message.totalProduced || Long.ZERO).toString();
    }
    if (!message.totalMissed.equals(Long.ZERO)) {
      obj.totalMissed = (message.totalMissed || Long.ZERO).toString();
    }
    if (!message.latestBlockNum.equals(Long.ZERO)) {
      obj.latestBlockNum = (message.latestBlockNum || Long.ZERO).toString();
    }
    if (!message.latestSlotNum.equals(Long.ZERO)) {
      obj.latestSlotNum = (message.latestSlotNum || Long.ZERO).toString();
    }
    if (message.isJobs !== false) {
      obj.isJobs = message.isJobs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Witness>, I>>(base?: I): Witness {
    return Witness.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Witness>, I>>(object: I): Witness {
    const message = createBaseWitness();
    message.address = object.address ?? Buffer.alloc(0);
    message.voteCount = (object.voteCount !== undefined && object.voteCount !== null)
      ? Long.fromValue(object.voteCount)
      : Long.ZERO;
    message.pubKey = object.pubKey ?? Buffer.alloc(0);
    message.url = object.url ?? "";
    message.totalProduced = (object.totalProduced !== undefined && object.totalProduced !== null)
      ? Long.fromValue(object.totalProduced)
      : Long.ZERO;
    message.totalMissed = (object.totalMissed !== undefined && object.totalMissed !== null)
      ? Long.fromValue(object.totalMissed)
      : Long.ZERO;
    message.latestBlockNum = (object.latestBlockNum !== undefined && object.latestBlockNum !== null)
      ? Long.fromValue(object.latestBlockNum)
      : Long.ZERO;
    message.latestSlotNum = (object.latestSlotNum !== undefined && object.latestSlotNum !== null)
      ? Long.fromValue(object.latestSlotNum)
      : Long.ZERO;
    message.isJobs = object.isJobs ?? false;
    return message;
  },
};

function createBaseVotes(): Votes {
  return { address: Buffer.alloc(0), oldVotes: [], newVotes: [], _unknownFields: {} };
}

export const Votes = {
  encode(message: Votes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    for (const v of message.oldVotes) {
      Vote.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.newVotes) {
      Vote.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Votes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVotes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.oldVotes.push(Vote.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.newVotes.push(Vote.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Votes {
    return {
      address: isSet(object.address) ? Buffer.from(bytesFromBase64(object.address)) : Buffer.alloc(0),
      oldVotes: globalThis.Array.isArray(object?.oldVotes) ? object.oldVotes.map((e: any) => Vote.fromJSON(e)) : [],
      newVotes: globalThis.Array.isArray(object?.newVotes) ? object.newVotes.map((e: any) => Vote.fromJSON(e)) : [],
    };
  },

  toJSON(message: Votes): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.oldVotes?.length) {
      obj.oldVotes = message.oldVotes.map((e) => Vote.toJSON(e));
    }
    if (message.newVotes?.length) {
      obj.newVotes = message.newVotes.map((e) => Vote.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Votes>, I>>(base?: I): Votes {
    return Votes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Votes>, I>>(object: I): Votes {
    const message = createBaseVotes();
    message.address = object.address ?? Buffer.alloc(0);
    message.oldVotes = object.oldVotes?.map((e) => Vote.fromPartial(e)) || [];
    message.newVotes = object.newVotes?.map((e) => Vote.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTXOutput(): TXOutput {
  return { value: Long.ZERO, pubKeyHash: Buffer.alloc(0), _unknownFields: {} };
}

export const TXOutput = {
  encode(message: TXOutput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.value);
    }
    if (message.pubKeyHash.length !== 0) {
      writer.uint32(18).bytes(message.pubKeyHash);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TXOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTXOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pubKeyHash = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TXOutput {
    return {
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
      pubKeyHash: isSet(object.pubKeyHash) ? Buffer.from(bytesFromBase64(object.pubKeyHash)) : Buffer.alloc(0),
    };
  },

  toJSON(message: TXOutput): unknown {
    const obj: any = {};
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    if (message.pubKeyHash.length !== 0) {
      obj.pubKeyHash = base64FromBytes(message.pubKeyHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TXOutput>, I>>(base?: I): TXOutput {
    return TXOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TXOutput>, I>>(object: I): TXOutput {
    const message = createBaseTXOutput();
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    message.pubKeyHash = object.pubKeyHash ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseTXInput(): TXInput {
  return { rawData: undefined, signature: Buffer.alloc(0), _unknownFields: {} };
}

export const TXInput = {
  encode(message: TXInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rawData !== undefined) {
      TXInput_raw.encode(message.rawData, writer.uint32(10).fork()).ldelim();
    }
    if (message.signature.length !== 0) {
      writer.uint32(34).bytes(message.signature);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TXInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTXInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rawData = TXInput_raw.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.signature = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TXInput {
    return {
      rawData: isSet(object.rawData) ? TXInput_raw.fromJSON(object.rawData) : undefined,
      signature: isSet(object.signature) ? Buffer.from(bytesFromBase64(object.signature)) : Buffer.alloc(0),
    };
  },

  toJSON(message: TXInput): unknown {
    const obj: any = {};
    if (message.rawData !== undefined) {
      obj.rawData = TXInput_raw.toJSON(message.rawData);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TXInput>, I>>(base?: I): TXInput {
    return TXInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TXInput>, I>>(object: I): TXInput {
    const message = createBaseTXInput();
    message.rawData = (object.rawData !== undefined && object.rawData !== null)
      ? TXInput_raw.fromPartial(object.rawData)
      : undefined;
    message.signature = object.signature ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseTXInput_raw(): TXInput_raw {
  return { txID: Buffer.alloc(0), vout: Long.ZERO, pubKey: Buffer.alloc(0), _unknownFields: {} };
}

export const TXInput_raw = {
  encode(message: TXInput_raw, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.txID.length !== 0) {
      writer.uint32(10).bytes(message.txID);
    }
    if (!message.vout.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.vout);
    }
    if (message.pubKey.length !== 0) {
      writer.uint32(26).bytes(message.pubKey);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TXInput_raw {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTXInput_raw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txID = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.vout = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pubKey = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TXInput_raw {
    return {
      txID: isSet(object.txID) ? Buffer.from(bytesFromBase64(object.txID)) : Buffer.alloc(0),
      vout: isSet(object.vout) ? Long.fromValue(object.vout) : Long.ZERO,
      pubKey: isSet(object.pubKey) ? Buffer.from(bytesFromBase64(object.pubKey)) : Buffer.alloc(0),
    };
  },

  toJSON(message: TXInput_raw): unknown {
    const obj: any = {};
    if (message.txID.length !== 0) {
      obj.txID = base64FromBytes(message.txID);
    }
    if (!message.vout.equals(Long.ZERO)) {
      obj.vout = (message.vout || Long.ZERO).toString();
    }
    if (message.pubKey.length !== 0) {
      obj.pubKey = base64FromBytes(message.pubKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TXInput_raw>, I>>(base?: I): TXInput_raw {
    return TXInput_raw.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TXInput_raw>, I>>(object: I): TXInput_raw {
    const message = createBaseTXInput_raw();
    message.txID = object.txID ?? Buffer.alloc(0);
    message.vout = (object.vout !== undefined && object.vout !== null) ? Long.fromValue(object.vout) : Long.ZERO;
    message.pubKey = object.pubKey ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseTXOutputs(): TXOutputs {
  return { outputs: [], _unknownFields: {} };
}

export const TXOutputs = {
  encode(message: TXOutputs, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.outputs) {
      TXOutput.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TXOutputs {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTXOutputs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.outputs.push(TXOutput.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TXOutputs {
    return {
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => TXOutput.fromJSON(e)) : [],
    };
  },

  toJSON(message: TXOutputs): unknown {
    const obj: any = {};
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => TXOutput.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TXOutputs>, I>>(base?: I): TXOutputs {
    return TXOutputs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TXOutputs>, I>>(object: I): TXOutputs {
    const message = createBaseTXOutputs();
    message.outputs = object.outputs?.map((e) => TXOutput.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResourceReceipt(): ResourceReceipt {
  return {
    energyUsage: Long.ZERO,
    energyFee: Long.ZERO,
    originEnergyUsage: Long.ZERO,
    energyUsageTotal: Long.ZERO,
    netUsage: Long.ZERO,
    netFee: Long.ZERO,
    result: 0,
    energyPenaltyTotal: Long.ZERO,
    _unknownFields: {},
  };
}

export const ResourceReceipt = {
  encode(message: ResourceReceipt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.energyUsage.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.energyUsage);
    }
    if (!message.energyFee.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.energyFee);
    }
    if (!message.originEnergyUsage.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.originEnergyUsage);
    }
    if (!message.energyUsageTotal.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.energyUsageTotal);
    }
    if (!message.netUsage.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.netUsage);
    }
    if (!message.netFee.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.netFee);
    }
    if (message.result !== 0) {
      writer.uint32(56).int32(message.result);
    }
    if (!message.energyPenaltyTotal.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.energyPenaltyTotal);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResourceReceipt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.energyUsage = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.energyFee = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.originEnergyUsage = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.energyUsageTotal = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.netUsage = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.netFee = reader.int64() as Long;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.energyPenaltyTotal = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ResourceReceipt {
    return {
      energyUsage: isSet(object.energyUsage) ? Long.fromValue(object.energyUsage) : Long.ZERO,
      energyFee: isSet(object.energyFee) ? Long.fromValue(object.energyFee) : Long.ZERO,
      originEnergyUsage: isSet(object.originEnergyUsage) ? Long.fromValue(object.originEnergyUsage) : Long.ZERO,
      energyUsageTotal: isSet(object.energyUsageTotal) ? Long.fromValue(object.energyUsageTotal) : Long.ZERO,
      netUsage: isSet(object.netUsage) ? Long.fromValue(object.netUsage) : Long.ZERO,
      netFee: isSet(object.netFee) ? Long.fromValue(object.netFee) : Long.ZERO,
      result: isSet(object.result) ? transaction_Result_contractResultFromJSON(object.result) : 0,
      energyPenaltyTotal: isSet(object.energyPenaltyTotal) ? Long.fromValue(object.energyPenaltyTotal) : Long.ZERO,
    };
  },

  toJSON(message: ResourceReceipt): unknown {
    const obj: any = {};
    if (!message.energyUsage.equals(Long.ZERO)) {
      obj.energyUsage = (message.energyUsage || Long.ZERO).toString();
    }
    if (!message.energyFee.equals(Long.ZERO)) {
      obj.energyFee = (message.energyFee || Long.ZERO).toString();
    }
    if (!message.originEnergyUsage.equals(Long.ZERO)) {
      obj.originEnergyUsage = (message.originEnergyUsage || Long.ZERO).toString();
    }
    if (!message.energyUsageTotal.equals(Long.ZERO)) {
      obj.energyUsageTotal = (message.energyUsageTotal || Long.ZERO).toString();
    }
    if (!message.netUsage.equals(Long.ZERO)) {
      obj.netUsage = (message.netUsage || Long.ZERO).toString();
    }
    if (!message.netFee.equals(Long.ZERO)) {
      obj.netFee = (message.netFee || Long.ZERO).toString();
    }
    if (message.result !== 0) {
      obj.result = transaction_Result_contractResultToJSON(message.result);
    }
    if (!message.energyPenaltyTotal.equals(Long.ZERO)) {
      obj.energyPenaltyTotal = (message.energyPenaltyTotal || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceReceipt>, I>>(base?: I): ResourceReceipt {
    return ResourceReceipt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceReceipt>, I>>(object: I): ResourceReceipt {
    const message = createBaseResourceReceipt();
    message.energyUsage = (object.energyUsage !== undefined && object.energyUsage !== null)
      ? Long.fromValue(object.energyUsage)
      : Long.ZERO;
    message.energyFee = (object.energyFee !== undefined && object.energyFee !== null)
      ? Long.fromValue(object.energyFee)
      : Long.ZERO;
    message.originEnergyUsage = (object.originEnergyUsage !== undefined && object.originEnergyUsage !== null)
      ? Long.fromValue(object.originEnergyUsage)
      : Long.ZERO;
    message.energyUsageTotal = (object.energyUsageTotal !== undefined && object.energyUsageTotal !== null)
      ? Long.fromValue(object.energyUsageTotal)
      : Long.ZERO;
    message.netUsage = (object.netUsage !== undefined && object.netUsage !== null)
      ? Long.fromValue(object.netUsage)
      : Long.ZERO;
    message.netFee = (object.netFee !== undefined && object.netFee !== null)
      ? Long.fromValue(object.netFee)
      : Long.ZERO;
    message.result = object.result ?? 0;
    message.energyPenaltyTotal = (object.energyPenaltyTotal !== undefined && object.energyPenaltyTotal !== null)
      ? Long.fromValue(object.energyPenaltyTotal)
      : Long.ZERO;
    return message;
  },
};

function createBaseMarketOrderDetail(): MarketOrderDetail {
  return {
    makerOrderId: Buffer.alloc(0),
    takerOrderId: Buffer.alloc(0),
    fillSellQuantity: Long.ZERO,
    fillBuyQuantity: Long.ZERO,
    _unknownFields: {},
  };
}

export const MarketOrderDetail = {
  encode(message: MarketOrderDetail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.makerOrderId.length !== 0) {
      writer.uint32(10).bytes(message.makerOrderId);
    }
    if (message.takerOrderId.length !== 0) {
      writer.uint32(18).bytes(message.takerOrderId);
    }
    if (!message.fillSellQuantity.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.fillSellQuantity);
    }
    if (!message.fillBuyQuantity.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.fillBuyQuantity);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarketOrderDetail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketOrderDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.makerOrderId = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.takerOrderId = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fillSellQuantity = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fillBuyQuantity = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MarketOrderDetail {
    return {
      makerOrderId: isSet(object.makerOrderId) ? Buffer.from(bytesFromBase64(object.makerOrderId)) : Buffer.alloc(0),
      takerOrderId: isSet(object.takerOrderId) ? Buffer.from(bytesFromBase64(object.takerOrderId)) : Buffer.alloc(0),
      fillSellQuantity: isSet(object.fillSellQuantity) ? Long.fromValue(object.fillSellQuantity) : Long.ZERO,
      fillBuyQuantity: isSet(object.fillBuyQuantity) ? Long.fromValue(object.fillBuyQuantity) : Long.ZERO,
    };
  },

  toJSON(message: MarketOrderDetail): unknown {
    const obj: any = {};
    if (message.makerOrderId.length !== 0) {
      obj.makerOrderId = base64FromBytes(message.makerOrderId);
    }
    if (message.takerOrderId.length !== 0) {
      obj.takerOrderId = base64FromBytes(message.takerOrderId);
    }
    if (!message.fillSellQuantity.equals(Long.ZERO)) {
      obj.fillSellQuantity = (message.fillSellQuantity || Long.ZERO).toString();
    }
    if (!message.fillBuyQuantity.equals(Long.ZERO)) {
      obj.fillBuyQuantity = (message.fillBuyQuantity || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketOrderDetail>, I>>(base?: I): MarketOrderDetail {
    return MarketOrderDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketOrderDetail>, I>>(object: I): MarketOrderDetail {
    const message = createBaseMarketOrderDetail();
    message.makerOrderId = object.makerOrderId ?? Buffer.alloc(0);
    message.takerOrderId = object.takerOrderId ?? Buffer.alloc(0);
    message.fillSellQuantity = (object.fillSellQuantity !== undefined && object.fillSellQuantity !== null)
      ? Long.fromValue(object.fillSellQuantity)
      : Long.ZERO;
    message.fillBuyQuantity = (object.fillBuyQuantity !== undefined && object.fillBuyQuantity !== null)
      ? Long.fromValue(object.fillBuyQuantity)
      : Long.ZERO;
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return { rawData: undefined, signature: [], ret: [], _unknownFields: {} };
}

export const Transaction = {
  encode(message: Transaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rawData !== undefined) {
      Transaction_raw.encode(message.rawData, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.signature) {
      writer.uint32(18).bytes(v!);
    }
    for (const v of message.ret) {
      Transaction_Result.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rawData = Transaction_raw.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature.push(reader.bytes() as Buffer);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ret.push(Transaction_Result.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      rawData: isSet(object.rawData) ? Transaction_raw.fromJSON(object.rawData) : undefined,
      signature: globalThis.Array.isArray(object?.signature)
        ? object.signature.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      ret: globalThis.Array.isArray(object?.ret) ? object.ret.map((e: any) => Transaction_Result.fromJSON(e)) : [],
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.rawData !== undefined) {
      obj.rawData = Transaction_raw.toJSON(message.rawData);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => base64FromBytes(e));
    }
    if (message.ret?.length) {
      obj.ret = message.ret.map((e) => Transaction_Result.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction>, I>>(base?: I): Transaction {
    return Transaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction>, I>>(object: I): Transaction {
    const message = createBaseTransaction();
    message.rawData = (object.rawData !== undefined && object.rawData !== null)
      ? Transaction_raw.fromPartial(object.rawData)
      : undefined;
    message.signature = object.signature?.map((e) => e) || [];
    message.ret = object.ret?.map((e) => Transaction_Result.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransaction_Contract(): Transaction_Contract {
  return {
    type: 0,
    parameter: undefined,
    provider: Buffer.alloc(0),
    ContractName: Buffer.alloc(0),
    PermissionId: 0,
    _unknownFields: {},
  };
}

export const Transaction_Contract = {
  encode(message: Transaction_Contract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.parameter !== undefined) {
      Any.encode(message.parameter, writer.uint32(18).fork()).ldelim();
    }
    if (message.provider.length !== 0) {
      writer.uint32(26).bytes(message.provider);
    }
    if (message.ContractName.length !== 0) {
      writer.uint32(34).bytes(message.ContractName);
    }
    if (message.PermissionId !== 0) {
      writer.uint32(40).int32(message.PermissionId);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Transaction_Contract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction_Contract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameter = Any.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.provider = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ContractName = reader.bytes() as Buffer;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.PermissionId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Transaction_Contract {
    return {
      type: isSet(object.type) ? transaction_Contract_ContractTypeFromJSON(object.type) : 0,
      parameter: isSet(object.parameter) ? Any.fromJSON(object.parameter) : undefined,
      provider: isSet(object.provider) ? Buffer.from(bytesFromBase64(object.provider)) : Buffer.alloc(0),
      ContractName: isSet(object.ContractName) ? Buffer.from(bytesFromBase64(object.ContractName)) : Buffer.alloc(0),
      PermissionId: isSet(object.PermissionId) ? globalThis.Number(object.PermissionId) : 0,
    };
  },

  toJSON(message: Transaction_Contract): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = transaction_Contract_ContractTypeToJSON(message.type);
    }
    if (message.parameter !== undefined) {
      obj.parameter = Any.toJSON(message.parameter);
    }
    if (message.provider.length !== 0) {
      obj.provider = base64FromBytes(message.provider);
    }
    if (message.ContractName.length !== 0) {
      obj.ContractName = base64FromBytes(message.ContractName);
    }
    if (message.PermissionId !== 0) {
      obj.PermissionId = Math.round(message.PermissionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction_Contract>, I>>(base?: I): Transaction_Contract {
    return Transaction_Contract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction_Contract>, I>>(object: I): Transaction_Contract {
    const message = createBaseTransaction_Contract();
    message.type = object.type ?? 0;
    message.parameter = (object.parameter !== undefined && object.parameter !== null)
      ? Any.fromPartial(object.parameter)
      : undefined;
    message.provider = object.provider ?? Buffer.alloc(0);
    message.ContractName = object.ContractName ?? Buffer.alloc(0);
    message.PermissionId = object.PermissionId ?? 0;
    return message;
  },
};

function createBaseTransaction_Result(): Transaction_Result {
  return {
    fee: Long.ZERO,
    ret: 0,
    contractRet: 0,
    assetIssueID: "",
    withdrawAmount: Long.ZERO,
    unfreezeAmount: Long.ZERO,
    exchangeReceivedAmount: Long.ZERO,
    exchangeInjectAnotherAmount: Long.ZERO,
    exchangeWithdrawAnotherAmount: Long.ZERO,
    exchangeId: Long.ZERO,
    shieldedTransactionFee: Long.ZERO,
    orderId: Buffer.alloc(0),
    orderDetails: [],
    withdrawExpireAmount: Long.ZERO,
    cancelUnfreezeV2Amount: {},
    _unknownFields: {},
  };
}

export const Transaction_Result = {
  encode(message: Transaction_Result, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.fee.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.fee);
    }
    if (message.ret !== 0) {
      writer.uint32(16).int32(message.ret);
    }
    if (message.contractRet !== 0) {
      writer.uint32(24).int32(message.contractRet);
    }
    if (message.assetIssueID !== "") {
      writer.uint32(114).string(message.assetIssueID);
    }
    if (!message.withdrawAmount.equals(Long.ZERO)) {
      writer.uint32(120).int64(message.withdrawAmount);
    }
    if (!message.unfreezeAmount.equals(Long.ZERO)) {
      writer.uint32(128).int64(message.unfreezeAmount);
    }
    if (!message.exchangeReceivedAmount.equals(Long.ZERO)) {
      writer.uint32(144).int64(message.exchangeReceivedAmount);
    }
    if (!message.exchangeInjectAnotherAmount.equals(Long.ZERO)) {
      writer.uint32(152).int64(message.exchangeInjectAnotherAmount);
    }
    if (!message.exchangeWithdrawAnotherAmount.equals(Long.ZERO)) {
      writer.uint32(160).int64(message.exchangeWithdrawAnotherAmount);
    }
    if (!message.exchangeId.equals(Long.ZERO)) {
      writer.uint32(168).int64(message.exchangeId);
    }
    if (!message.shieldedTransactionFee.equals(Long.ZERO)) {
      writer.uint32(176).int64(message.shieldedTransactionFee);
    }
    if (message.orderId.length !== 0) {
      writer.uint32(202).bytes(message.orderId);
    }
    for (const v of message.orderDetails) {
      MarketOrderDetail.encode(v!, writer.uint32(210).fork()).ldelim();
    }
    if (!message.withdrawExpireAmount.equals(Long.ZERO)) {
      writer.uint32(216).int64(message.withdrawExpireAmount);
    }
    Object.entries(message.cancelUnfreezeV2Amount).forEach(([key, value]) => {
      Transaction_Result_CancelUnfreezeV2AmountEntry.encode({ key: key as any, value }, writer.uint32(226).fork())
        .ldelim();
    });
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Transaction_Result {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction_Result();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fee = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ret = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contractRet = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.assetIssueID = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.withdrawAmount = reader.int64() as Long;
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.unfreezeAmount = reader.int64() as Long;
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.exchangeReceivedAmount = reader.int64() as Long;
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.exchangeInjectAnotherAmount = reader.int64() as Long;
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.exchangeWithdrawAnotherAmount = reader.int64() as Long;
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.exchangeId = reader.int64() as Long;
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.shieldedTransactionFee = reader.int64() as Long;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.orderId = reader.bytes() as Buffer;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.orderDetails.push(MarketOrderDetail.decode(reader, reader.uint32()));
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.withdrawExpireAmount = reader.int64() as Long;
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          const entry28 = Transaction_Result_CancelUnfreezeV2AmountEntry.decode(reader, reader.uint32());
          if (entry28.value !== undefined) {
            message.cancelUnfreezeV2Amount[entry28.key] = entry28.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Transaction_Result {
    return {
      fee: isSet(object.fee) ? Long.fromValue(object.fee) : Long.ZERO,
      ret: isSet(object.ret) ? transaction_Result_codeFromJSON(object.ret) : 0,
      contractRet: isSet(object.contractRet) ? transaction_Result_contractResultFromJSON(object.contractRet) : 0,
      assetIssueID: isSet(object.assetIssueID) ? globalThis.String(object.assetIssueID) : "",
      withdrawAmount: isSet(object.withdrawAmount) ? Long.fromValue(object.withdrawAmount) : Long.ZERO,
      unfreezeAmount: isSet(object.unfreezeAmount) ? Long.fromValue(object.unfreezeAmount) : Long.ZERO,
      exchangeReceivedAmount: isSet(object.exchangeReceivedAmount)
        ? Long.fromValue(object.exchangeReceivedAmount)
        : Long.ZERO,
      exchangeInjectAnotherAmount: isSet(object.exchangeInjectAnotherAmount)
        ? Long.fromValue(object.exchangeInjectAnotherAmount)
        : Long.ZERO,
      exchangeWithdrawAnotherAmount: isSet(object.exchangeWithdrawAnotherAmount)
        ? Long.fromValue(object.exchangeWithdrawAnotherAmount)
        : Long.ZERO,
      exchangeId: isSet(object.exchangeId) ? Long.fromValue(object.exchangeId) : Long.ZERO,
      shieldedTransactionFee: isSet(object.shieldedTransactionFee)
        ? Long.fromValue(object.shieldedTransactionFee)
        : Long.ZERO,
      orderId: isSet(object.orderId) ? Buffer.from(bytesFromBase64(object.orderId)) : Buffer.alloc(0),
      orderDetails: globalThis.Array.isArray(object?.orderDetails)
        ? object.orderDetails.map((e: any) => MarketOrderDetail.fromJSON(e))
        : [],
      withdrawExpireAmount: isSet(object.withdrawExpireAmount)
        ? Long.fromValue(object.withdrawExpireAmount)
        : Long.ZERO,
      cancelUnfreezeV2Amount: isObject(object.cancelUnfreezeV2Amount)
        ? Object.entries(object.cancelUnfreezeV2Amount).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Transaction_Result): unknown {
    const obj: any = {};
    if (!message.fee.equals(Long.ZERO)) {
      obj.fee = (message.fee || Long.ZERO).toString();
    }
    if (message.ret !== 0) {
      obj.ret = transaction_Result_codeToJSON(message.ret);
    }
    if (message.contractRet !== 0) {
      obj.contractRet = transaction_Result_contractResultToJSON(message.contractRet);
    }
    if (message.assetIssueID !== "") {
      obj.assetIssueID = message.assetIssueID;
    }
    if (!message.withdrawAmount.equals(Long.ZERO)) {
      obj.withdrawAmount = (message.withdrawAmount || Long.ZERO).toString();
    }
    if (!message.unfreezeAmount.equals(Long.ZERO)) {
      obj.unfreezeAmount = (message.unfreezeAmount || Long.ZERO).toString();
    }
    if (!message.exchangeReceivedAmount.equals(Long.ZERO)) {
      obj.exchangeReceivedAmount = (message.exchangeReceivedAmount || Long.ZERO).toString();
    }
    if (!message.exchangeInjectAnotherAmount.equals(Long.ZERO)) {
      obj.exchangeInjectAnotherAmount = (message.exchangeInjectAnotherAmount || Long.ZERO).toString();
    }
    if (!message.exchangeWithdrawAnotherAmount.equals(Long.ZERO)) {
      obj.exchangeWithdrawAnotherAmount = (message.exchangeWithdrawAnotherAmount || Long.ZERO).toString();
    }
    if (!message.exchangeId.equals(Long.ZERO)) {
      obj.exchangeId = (message.exchangeId || Long.ZERO).toString();
    }
    if (!message.shieldedTransactionFee.equals(Long.ZERO)) {
      obj.shieldedTransactionFee = (message.shieldedTransactionFee || Long.ZERO).toString();
    }
    if (message.orderId.length !== 0) {
      obj.orderId = base64FromBytes(message.orderId);
    }
    if (message.orderDetails?.length) {
      obj.orderDetails = message.orderDetails.map((e) => MarketOrderDetail.toJSON(e));
    }
    if (!message.withdrawExpireAmount.equals(Long.ZERO)) {
      obj.withdrawExpireAmount = (message.withdrawExpireAmount || Long.ZERO).toString();
    }
    if (message.cancelUnfreezeV2Amount) {
      const entries = Object.entries(message.cancelUnfreezeV2Amount);
      if (entries.length > 0) {
        obj.cancelUnfreezeV2Amount = {};
        entries.forEach(([k, v]) => {
          obj.cancelUnfreezeV2Amount[k] = v.toString();
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction_Result>, I>>(base?: I): Transaction_Result {
    return Transaction_Result.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction_Result>, I>>(object: I): Transaction_Result {
    const message = createBaseTransaction_Result();
    message.fee = (object.fee !== undefined && object.fee !== null) ? Long.fromValue(object.fee) : Long.ZERO;
    message.ret = object.ret ?? 0;
    message.contractRet = object.contractRet ?? 0;
    message.assetIssueID = object.assetIssueID ?? "";
    message.withdrawAmount = (object.withdrawAmount !== undefined && object.withdrawAmount !== null)
      ? Long.fromValue(object.withdrawAmount)
      : Long.ZERO;
    message.unfreezeAmount = (object.unfreezeAmount !== undefined && object.unfreezeAmount !== null)
      ? Long.fromValue(object.unfreezeAmount)
      : Long.ZERO;
    message.exchangeReceivedAmount =
      (object.exchangeReceivedAmount !== undefined && object.exchangeReceivedAmount !== null)
        ? Long.fromValue(object.exchangeReceivedAmount)
        : Long.ZERO;
    message.exchangeInjectAnotherAmount =
      (object.exchangeInjectAnotherAmount !== undefined && object.exchangeInjectAnotherAmount !== null)
        ? Long.fromValue(object.exchangeInjectAnotherAmount)
        : Long.ZERO;
    message.exchangeWithdrawAnotherAmount =
      (object.exchangeWithdrawAnotherAmount !== undefined && object.exchangeWithdrawAnotherAmount !== null)
        ? Long.fromValue(object.exchangeWithdrawAnotherAmount)
        : Long.ZERO;
    message.exchangeId = (object.exchangeId !== undefined && object.exchangeId !== null)
      ? Long.fromValue(object.exchangeId)
      : Long.ZERO;
    message.shieldedTransactionFee =
      (object.shieldedTransactionFee !== undefined && object.shieldedTransactionFee !== null)
        ? Long.fromValue(object.shieldedTransactionFee)
        : Long.ZERO;
    message.orderId = object.orderId ?? Buffer.alloc(0);
    message.orderDetails = object.orderDetails?.map((e) => MarketOrderDetail.fromPartial(e)) || [];
    message.withdrawExpireAmount = (object.withdrawExpireAmount !== undefined && object.withdrawExpireAmount !== null)
      ? Long.fromValue(object.withdrawExpireAmount)
      : Long.ZERO;
    message.cancelUnfreezeV2Amount = Object.entries(object.cancelUnfreezeV2Amount ?? {}).reduce<
      { [key: string]: Long }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Long.fromValue(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTransaction_Result_CancelUnfreezeV2AmountEntry(): Transaction_Result_CancelUnfreezeV2AmountEntry {
  return { key: "", value: Long.ZERO, _unknownFields: {} };
}

export const Transaction_Result_CancelUnfreezeV2AmountEntry = {
  encode(
    message: Transaction_Result_CancelUnfreezeV2AmountEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Transaction_Result_CancelUnfreezeV2AmountEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction_Result_CancelUnfreezeV2AmountEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Transaction_Result_CancelUnfreezeV2AmountEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: Transaction_Result_CancelUnfreezeV2AmountEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction_Result_CancelUnfreezeV2AmountEntry>, I>>(
    base?: I,
  ): Transaction_Result_CancelUnfreezeV2AmountEntry {
    return Transaction_Result_CancelUnfreezeV2AmountEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction_Result_CancelUnfreezeV2AmountEntry>, I>>(
    object: I,
  ): Transaction_Result_CancelUnfreezeV2AmountEntry {
    const message = createBaseTransaction_Result_CancelUnfreezeV2AmountEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseTransaction_raw(): Transaction_raw {
  return {
    refBlockBytes: Buffer.alloc(0),
    refBlockNum: Long.ZERO,
    refBlockHash: Buffer.alloc(0),
    expiration: Long.ZERO,
    auths: [],
    data: Buffer.alloc(0),
    contract: [],
    scripts: Buffer.alloc(0),
    timestamp: Long.ZERO,
    feeLimit: Long.ZERO,
    _unknownFields: {},
  };
}

export const Transaction_raw = {
  encode(message: Transaction_raw, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.refBlockBytes.length !== 0) {
      writer.uint32(10).bytes(message.refBlockBytes);
    }
    if (!message.refBlockNum.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.refBlockNum);
    }
    if (message.refBlockHash.length !== 0) {
      writer.uint32(34).bytes(message.refBlockHash);
    }
    if (!message.expiration.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.expiration);
    }
    for (const v of message.auths) {
      authority.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    if (message.data.length !== 0) {
      writer.uint32(82).bytes(message.data);
    }
    for (const v of message.contract) {
      Transaction_Contract.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    if (message.scripts.length !== 0) {
      writer.uint32(98).bytes(message.scripts);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.timestamp);
    }
    if (!message.feeLimit.equals(Long.ZERO)) {
      writer.uint32(144).int64(message.feeLimit);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Transaction_raw {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction_raw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.refBlockBytes = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.refBlockNum = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.refBlockHash = reader.bytes() as Buffer;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.expiration = reader.int64() as Long;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.auths.push(authority.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.contract.push(Transaction_Contract.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.scripts = reader.bytes() as Buffer;
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.feeLimit = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Transaction_raw {
    return {
      refBlockBytes: isSet(object.refBlockBytes) ? Buffer.from(bytesFromBase64(object.refBlockBytes)) : Buffer.alloc(0),
      refBlockNum: isSet(object.refBlockNum) ? Long.fromValue(object.refBlockNum) : Long.ZERO,
      refBlockHash: isSet(object.refBlockHash) ? Buffer.from(bytesFromBase64(object.refBlockHash)) : Buffer.alloc(0),
      expiration: isSet(object.expiration) ? Long.fromValue(object.expiration) : Long.ZERO,
      auths: globalThis.Array.isArray(object?.auths) ? object.auths.map((e: any) => authority.fromJSON(e)) : [],
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      contract: globalThis.Array.isArray(object?.contract)
        ? object.contract.map((e: any) => Transaction_Contract.fromJSON(e))
        : [],
      scripts: isSet(object.scripts) ? Buffer.from(bytesFromBase64(object.scripts)) : Buffer.alloc(0),
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
      feeLimit: isSet(object.feeLimit) ? Long.fromValue(object.feeLimit) : Long.ZERO,
    };
  },

  toJSON(message: Transaction_raw): unknown {
    const obj: any = {};
    if (message.refBlockBytes.length !== 0) {
      obj.refBlockBytes = base64FromBytes(message.refBlockBytes);
    }
    if (!message.refBlockNum.equals(Long.ZERO)) {
      obj.refBlockNum = (message.refBlockNum || Long.ZERO).toString();
    }
    if (message.refBlockHash.length !== 0) {
      obj.refBlockHash = base64FromBytes(message.refBlockHash);
    }
    if (!message.expiration.equals(Long.ZERO)) {
      obj.expiration = (message.expiration || Long.ZERO).toString();
    }
    if (message.auths?.length) {
      obj.auths = message.auths.map((e) => authority.toJSON(e));
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.contract?.length) {
      obj.contract = message.contract.map((e) => Transaction_Contract.toJSON(e));
    }
    if (message.scripts.length !== 0) {
      obj.scripts = base64FromBytes(message.scripts);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    if (!message.feeLimit.equals(Long.ZERO)) {
      obj.feeLimit = (message.feeLimit || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction_raw>, I>>(base?: I): Transaction_raw {
    return Transaction_raw.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction_raw>, I>>(object: I): Transaction_raw {
    const message = createBaseTransaction_raw();
    message.refBlockBytes = object.refBlockBytes ?? Buffer.alloc(0);
    message.refBlockNum = (object.refBlockNum !== undefined && object.refBlockNum !== null)
      ? Long.fromValue(object.refBlockNum)
      : Long.ZERO;
    message.refBlockHash = object.refBlockHash ?? Buffer.alloc(0);
    message.expiration = (object.expiration !== undefined && object.expiration !== null)
      ? Long.fromValue(object.expiration)
      : Long.ZERO;
    message.auths = object.auths?.map((e) => authority.fromPartial(e)) || [];
    message.data = object.data ?? Buffer.alloc(0);
    message.contract = object.contract?.map((e) => Transaction_Contract.fromPartial(e)) || [];
    message.scripts = object.scripts ?? Buffer.alloc(0);
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    message.feeLimit = (object.feeLimit !== undefined && object.feeLimit !== null)
      ? Long.fromValue(object.feeLimit)
      : Long.ZERO;
    return message;
  },
};

function createBaseTransactionInfo(): TransactionInfo {
  return {
    id: Buffer.alloc(0),
    fee: Long.ZERO,
    blockNumber: Long.ZERO,
    blockTimeStamp: Long.ZERO,
    contractResult: [],
    contractAddress: Buffer.alloc(0),
    receipt: undefined,
    log: [],
    result: 0,
    resMessage: Buffer.alloc(0),
    assetIssueID: "",
    withdrawAmount: Long.ZERO,
    unfreezeAmount: Long.ZERO,
    internalTransactions: [],
    exchangeReceivedAmount: Long.ZERO,
    exchangeInjectAnotherAmount: Long.ZERO,
    exchangeWithdrawAnotherAmount: Long.ZERO,
    exchangeId: Long.ZERO,
    shieldedTransactionFee: Long.ZERO,
    orderId: Buffer.alloc(0),
    orderDetails: [],
    packingFee: Long.ZERO,
    withdrawExpireAmount: Long.ZERO,
    cancelUnfreezeV2Amount: {},
    _unknownFields: {},
  };
}

export const TransactionInfo = {
  encode(message: TransactionInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (!message.fee.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.fee);
    }
    if (!message.blockNumber.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.blockNumber);
    }
    if (!message.blockTimeStamp.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.blockTimeStamp);
    }
    for (const v of message.contractResult) {
      writer.uint32(42).bytes(v!);
    }
    if (message.contractAddress.length !== 0) {
      writer.uint32(50).bytes(message.contractAddress);
    }
    if (message.receipt !== undefined) {
      ResourceReceipt.encode(message.receipt, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.log) {
      TransactionInfo_Log.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.result !== 0) {
      writer.uint32(72).int32(message.result);
    }
    if (message.resMessage.length !== 0) {
      writer.uint32(82).bytes(message.resMessage);
    }
    if (message.assetIssueID !== "") {
      writer.uint32(114).string(message.assetIssueID);
    }
    if (!message.withdrawAmount.equals(Long.ZERO)) {
      writer.uint32(120).int64(message.withdrawAmount);
    }
    if (!message.unfreezeAmount.equals(Long.ZERO)) {
      writer.uint32(128).int64(message.unfreezeAmount);
    }
    for (const v of message.internalTransactions) {
      InternalTransaction.encode(v!, writer.uint32(138).fork()).ldelim();
    }
    if (!message.exchangeReceivedAmount.equals(Long.ZERO)) {
      writer.uint32(144).int64(message.exchangeReceivedAmount);
    }
    if (!message.exchangeInjectAnotherAmount.equals(Long.ZERO)) {
      writer.uint32(152).int64(message.exchangeInjectAnotherAmount);
    }
    if (!message.exchangeWithdrawAnotherAmount.equals(Long.ZERO)) {
      writer.uint32(160).int64(message.exchangeWithdrawAnotherAmount);
    }
    if (!message.exchangeId.equals(Long.ZERO)) {
      writer.uint32(168).int64(message.exchangeId);
    }
    if (!message.shieldedTransactionFee.equals(Long.ZERO)) {
      writer.uint32(176).int64(message.shieldedTransactionFee);
    }
    if (message.orderId.length !== 0) {
      writer.uint32(202).bytes(message.orderId);
    }
    for (const v of message.orderDetails) {
      MarketOrderDetail.encode(v!, writer.uint32(210).fork()).ldelim();
    }
    if (!message.packingFee.equals(Long.ZERO)) {
      writer.uint32(216).int64(message.packingFee);
    }
    if (!message.withdrawExpireAmount.equals(Long.ZERO)) {
      writer.uint32(224).int64(message.withdrawExpireAmount);
    }
    Object.entries(message.cancelUnfreezeV2Amount).forEach(([key, value]) => {
      TransactionInfo_CancelUnfreezeV2AmountEntry.encode({ key: key as any, value }, writer.uint32(234).fork())
        .ldelim();
    });
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fee = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.blockNumber = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.blockTimeStamp = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contractResult.push(reader.bytes() as Buffer);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.contractAddress = reader.bytes() as Buffer;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.receipt = ResourceReceipt.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.log.push(TransactionInfo_Log.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.resMessage = reader.bytes() as Buffer;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.assetIssueID = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.withdrawAmount = reader.int64() as Long;
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.unfreezeAmount = reader.int64() as Long;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.internalTransactions.push(InternalTransaction.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.exchangeReceivedAmount = reader.int64() as Long;
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.exchangeInjectAnotherAmount = reader.int64() as Long;
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.exchangeWithdrawAnotherAmount = reader.int64() as Long;
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.exchangeId = reader.int64() as Long;
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.shieldedTransactionFee = reader.int64() as Long;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.orderId = reader.bytes() as Buffer;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.orderDetails.push(MarketOrderDetail.decode(reader, reader.uint32()));
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.packingFee = reader.int64() as Long;
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.withdrawExpireAmount = reader.int64() as Long;
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          const entry29 = TransactionInfo_CancelUnfreezeV2AmountEntry.decode(reader, reader.uint32());
          if (entry29.value !== undefined) {
            message.cancelUnfreezeV2Amount[entry29.key] = entry29.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionInfo {
    return {
      id: isSet(object.id) ? Buffer.from(bytesFromBase64(object.id)) : Buffer.alloc(0),
      fee: isSet(object.fee) ? Long.fromValue(object.fee) : Long.ZERO,
      blockNumber: isSet(object.blockNumber) ? Long.fromValue(object.blockNumber) : Long.ZERO,
      blockTimeStamp: isSet(object.blockTimeStamp) ? Long.fromValue(object.blockTimeStamp) : Long.ZERO,
      contractResult: globalThis.Array.isArray(object?.contractResult)
        ? object.contractResult.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      contractAddress: isSet(object.contractAddress)
        ? Buffer.from(bytesFromBase64(object.contractAddress))
        : Buffer.alloc(0),
      receipt: isSet(object.receipt) ? ResourceReceipt.fromJSON(object.receipt) : undefined,
      log: globalThis.Array.isArray(object?.log) ? object.log.map((e: any) => TransactionInfo_Log.fromJSON(e)) : [],
      result: isSet(object.result) ? transactionInfo_codeFromJSON(object.result) : 0,
      resMessage: isSet(object.resMessage) ? Buffer.from(bytesFromBase64(object.resMessage)) : Buffer.alloc(0),
      assetIssueID: isSet(object.assetIssueID) ? globalThis.String(object.assetIssueID) : "",
      withdrawAmount: isSet(object.withdrawAmount) ? Long.fromValue(object.withdrawAmount) : Long.ZERO,
      unfreezeAmount: isSet(object.unfreezeAmount) ? Long.fromValue(object.unfreezeAmount) : Long.ZERO,
      internalTransactions: globalThis.Array.isArray(object?.internalTransactions)
        ? object.internalTransactions.map((e: any) => InternalTransaction.fromJSON(e))
        : [],
      exchangeReceivedAmount: isSet(object.exchangeReceivedAmount)
        ? Long.fromValue(object.exchangeReceivedAmount)
        : Long.ZERO,
      exchangeInjectAnotherAmount: isSet(object.exchangeInjectAnotherAmount)
        ? Long.fromValue(object.exchangeInjectAnotherAmount)
        : Long.ZERO,
      exchangeWithdrawAnotherAmount: isSet(object.exchangeWithdrawAnotherAmount)
        ? Long.fromValue(object.exchangeWithdrawAnotherAmount)
        : Long.ZERO,
      exchangeId: isSet(object.exchangeId) ? Long.fromValue(object.exchangeId) : Long.ZERO,
      shieldedTransactionFee: isSet(object.shieldedTransactionFee)
        ? Long.fromValue(object.shieldedTransactionFee)
        : Long.ZERO,
      orderId: isSet(object.orderId) ? Buffer.from(bytesFromBase64(object.orderId)) : Buffer.alloc(0),
      orderDetails: globalThis.Array.isArray(object?.orderDetails)
        ? object.orderDetails.map((e: any) => MarketOrderDetail.fromJSON(e))
        : [],
      packingFee: isSet(object.packingFee) ? Long.fromValue(object.packingFee) : Long.ZERO,
      withdrawExpireAmount: isSet(object.withdrawExpireAmount)
        ? Long.fromValue(object.withdrawExpireAmount)
        : Long.ZERO,
      cancelUnfreezeV2Amount: isObject(object.cancelUnfreezeV2Amount)
        ? Object.entries(object.cancelUnfreezeV2Amount).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TransactionInfo): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (!message.fee.equals(Long.ZERO)) {
      obj.fee = (message.fee || Long.ZERO).toString();
    }
    if (!message.blockNumber.equals(Long.ZERO)) {
      obj.blockNumber = (message.blockNumber || Long.ZERO).toString();
    }
    if (!message.blockTimeStamp.equals(Long.ZERO)) {
      obj.blockTimeStamp = (message.blockTimeStamp || Long.ZERO).toString();
    }
    if (message.contractResult?.length) {
      obj.contractResult = message.contractResult.map((e) => base64FromBytes(e));
    }
    if (message.contractAddress.length !== 0) {
      obj.contractAddress = base64FromBytes(message.contractAddress);
    }
    if (message.receipt !== undefined) {
      obj.receipt = ResourceReceipt.toJSON(message.receipt);
    }
    if (message.log?.length) {
      obj.log = message.log.map((e) => TransactionInfo_Log.toJSON(e));
    }
    if (message.result !== 0) {
      obj.result = transactionInfo_codeToJSON(message.result);
    }
    if (message.resMessage.length !== 0) {
      obj.resMessage = base64FromBytes(message.resMessage);
    }
    if (message.assetIssueID !== "") {
      obj.assetIssueID = message.assetIssueID;
    }
    if (!message.withdrawAmount.equals(Long.ZERO)) {
      obj.withdrawAmount = (message.withdrawAmount || Long.ZERO).toString();
    }
    if (!message.unfreezeAmount.equals(Long.ZERO)) {
      obj.unfreezeAmount = (message.unfreezeAmount || Long.ZERO).toString();
    }
    if (message.internalTransactions?.length) {
      obj.internalTransactions = message.internalTransactions.map((e) => InternalTransaction.toJSON(e));
    }
    if (!message.exchangeReceivedAmount.equals(Long.ZERO)) {
      obj.exchangeReceivedAmount = (message.exchangeReceivedAmount || Long.ZERO).toString();
    }
    if (!message.exchangeInjectAnotherAmount.equals(Long.ZERO)) {
      obj.exchangeInjectAnotherAmount = (message.exchangeInjectAnotherAmount || Long.ZERO).toString();
    }
    if (!message.exchangeWithdrawAnotherAmount.equals(Long.ZERO)) {
      obj.exchangeWithdrawAnotherAmount = (message.exchangeWithdrawAnotherAmount || Long.ZERO).toString();
    }
    if (!message.exchangeId.equals(Long.ZERO)) {
      obj.exchangeId = (message.exchangeId || Long.ZERO).toString();
    }
    if (!message.shieldedTransactionFee.equals(Long.ZERO)) {
      obj.shieldedTransactionFee = (message.shieldedTransactionFee || Long.ZERO).toString();
    }
    if (message.orderId.length !== 0) {
      obj.orderId = base64FromBytes(message.orderId);
    }
    if (message.orderDetails?.length) {
      obj.orderDetails = message.orderDetails.map((e) => MarketOrderDetail.toJSON(e));
    }
    if (!message.packingFee.equals(Long.ZERO)) {
      obj.packingFee = (message.packingFee || Long.ZERO).toString();
    }
    if (!message.withdrawExpireAmount.equals(Long.ZERO)) {
      obj.withdrawExpireAmount = (message.withdrawExpireAmount || Long.ZERO).toString();
    }
    if (message.cancelUnfreezeV2Amount) {
      const entries = Object.entries(message.cancelUnfreezeV2Amount);
      if (entries.length > 0) {
        obj.cancelUnfreezeV2Amount = {};
        entries.forEach(([k, v]) => {
          obj.cancelUnfreezeV2Amount[k] = v.toString();
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionInfo>, I>>(base?: I): TransactionInfo {
    return TransactionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionInfo>, I>>(object: I): TransactionInfo {
    const message = createBaseTransactionInfo();
    message.id = object.id ?? Buffer.alloc(0);
    message.fee = (object.fee !== undefined && object.fee !== null) ? Long.fromValue(object.fee) : Long.ZERO;
    message.blockNumber = (object.blockNumber !== undefined && object.blockNumber !== null)
      ? Long.fromValue(object.blockNumber)
      : Long.ZERO;
    message.blockTimeStamp = (object.blockTimeStamp !== undefined && object.blockTimeStamp !== null)
      ? Long.fromValue(object.blockTimeStamp)
      : Long.ZERO;
    message.contractResult = object.contractResult?.map((e) => e) || [];
    message.contractAddress = object.contractAddress ?? Buffer.alloc(0);
    message.receipt = (object.receipt !== undefined && object.receipt !== null)
      ? ResourceReceipt.fromPartial(object.receipt)
      : undefined;
    message.log = object.log?.map((e) => TransactionInfo_Log.fromPartial(e)) || [];
    message.result = object.result ?? 0;
    message.resMessage = object.resMessage ?? Buffer.alloc(0);
    message.assetIssueID = object.assetIssueID ?? "";
    message.withdrawAmount = (object.withdrawAmount !== undefined && object.withdrawAmount !== null)
      ? Long.fromValue(object.withdrawAmount)
      : Long.ZERO;
    message.unfreezeAmount = (object.unfreezeAmount !== undefined && object.unfreezeAmount !== null)
      ? Long.fromValue(object.unfreezeAmount)
      : Long.ZERO;
    message.internalTransactions = object.internalTransactions?.map((e) => InternalTransaction.fromPartial(e)) || [];
    message.exchangeReceivedAmount =
      (object.exchangeReceivedAmount !== undefined && object.exchangeReceivedAmount !== null)
        ? Long.fromValue(object.exchangeReceivedAmount)
        : Long.ZERO;
    message.exchangeInjectAnotherAmount =
      (object.exchangeInjectAnotherAmount !== undefined && object.exchangeInjectAnotherAmount !== null)
        ? Long.fromValue(object.exchangeInjectAnotherAmount)
        : Long.ZERO;
    message.exchangeWithdrawAnotherAmount =
      (object.exchangeWithdrawAnotherAmount !== undefined && object.exchangeWithdrawAnotherAmount !== null)
        ? Long.fromValue(object.exchangeWithdrawAnotherAmount)
        : Long.ZERO;
    message.exchangeId = (object.exchangeId !== undefined && object.exchangeId !== null)
      ? Long.fromValue(object.exchangeId)
      : Long.ZERO;
    message.shieldedTransactionFee =
      (object.shieldedTransactionFee !== undefined && object.shieldedTransactionFee !== null)
        ? Long.fromValue(object.shieldedTransactionFee)
        : Long.ZERO;
    message.orderId = object.orderId ?? Buffer.alloc(0);
    message.orderDetails = object.orderDetails?.map((e) => MarketOrderDetail.fromPartial(e)) || [];
    message.packingFee = (object.packingFee !== undefined && object.packingFee !== null)
      ? Long.fromValue(object.packingFee)
      : Long.ZERO;
    message.withdrawExpireAmount = (object.withdrawExpireAmount !== undefined && object.withdrawExpireAmount !== null)
      ? Long.fromValue(object.withdrawExpireAmount)
      : Long.ZERO;
    message.cancelUnfreezeV2Amount = Object.entries(object.cancelUnfreezeV2Amount ?? {}).reduce<
      { [key: string]: Long }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Long.fromValue(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTransactionInfo_Log(): TransactionInfo_Log {
  return { address: Buffer.alloc(0), topics: [], data: Buffer.alloc(0), _unknownFields: {} };
}

export const TransactionInfo_Log = {
  encode(message: TransactionInfo_Log, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    for (const v of message.topics) {
      writer.uint32(18).bytes(v!);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionInfo_Log {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfo_Log();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topics.push(reader.bytes() as Buffer);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionInfo_Log {
    return {
      address: isSet(object.address) ? Buffer.from(bytesFromBase64(object.address)) : Buffer.alloc(0),
      topics: globalThis.Array.isArray(object?.topics)
        ? object.topics.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
    };
  },

  toJSON(message: TransactionInfo_Log): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.topics?.length) {
      obj.topics = message.topics.map((e) => base64FromBytes(e));
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionInfo_Log>, I>>(base?: I): TransactionInfo_Log {
    return TransactionInfo_Log.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionInfo_Log>, I>>(object: I): TransactionInfo_Log {
    const message = createBaseTransactionInfo_Log();
    message.address = object.address ?? Buffer.alloc(0);
    message.topics = object.topics?.map((e) => e) || [];
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseTransactionInfo_CancelUnfreezeV2AmountEntry(): TransactionInfo_CancelUnfreezeV2AmountEntry {
  return { key: "", value: Long.ZERO, _unknownFields: {} };
}

export const TransactionInfo_CancelUnfreezeV2AmountEntry = {
  encode(message: TransactionInfo_CancelUnfreezeV2AmountEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionInfo_CancelUnfreezeV2AmountEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfo_CancelUnfreezeV2AmountEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionInfo_CancelUnfreezeV2AmountEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: TransactionInfo_CancelUnfreezeV2AmountEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionInfo_CancelUnfreezeV2AmountEntry>, I>>(
    base?: I,
  ): TransactionInfo_CancelUnfreezeV2AmountEntry {
    return TransactionInfo_CancelUnfreezeV2AmountEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionInfo_CancelUnfreezeV2AmountEntry>, I>>(
    object: I,
  ): TransactionInfo_CancelUnfreezeV2AmountEntry {
    const message = createBaseTransactionInfo_CancelUnfreezeV2AmountEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseTransactionRet(): TransactionRet {
  return { blockNumber: Long.ZERO, blockTimeStamp: Long.ZERO, transactioninfo: [], _unknownFields: {} };
}

export const TransactionRet = {
  encode(message: TransactionRet, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.blockNumber.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.blockNumber);
    }
    if (!message.blockTimeStamp.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.blockTimeStamp);
    }
    for (const v of message.transactioninfo) {
      TransactionInfo.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionRet {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionRet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.blockNumber = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.blockTimeStamp = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transactioninfo.push(TransactionInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): TransactionRet {
    return {
      blockNumber: isSet(object.blockNumber) ? Long.fromValue(object.blockNumber) : Long.ZERO,
      blockTimeStamp: isSet(object.blockTimeStamp) ? Long.fromValue(object.blockTimeStamp) : Long.ZERO,
      transactioninfo: globalThis.Array.isArray(object?.transactioninfo)
        ? object.transactioninfo.map((e: any) => TransactionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransactionRet): unknown {
    const obj: any = {};
    if (!message.blockNumber.equals(Long.ZERO)) {
      obj.blockNumber = (message.blockNumber || Long.ZERO).toString();
    }
    if (!message.blockTimeStamp.equals(Long.ZERO)) {
      obj.blockTimeStamp = (message.blockTimeStamp || Long.ZERO).toString();
    }
    if (message.transactioninfo?.length) {
      obj.transactioninfo = message.transactioninfo.map((e) => TransactionInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionRet>, I>>(base?: I): TransactionRet {
    return TransactionRet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionRet>, I>>(object: I): TransactionRet {
    const message = createBaseTransactionRet();
    message.blockNumber = (object.blockNumber !== undefined && object.blockNumber !== null)
      ? Long.fromValue(object.blockNumber)
      : Long.ZERO;
    message.blockTimeStamp = (object.blockTimeStamp !== undefined && object.blockTimeStamp !== null)
      ? Long.fromValue(object.blockTimeStamp)
      : Long.ZERO;
    message.transactioninfo = object.transactioninfo?.map((e) => TransactionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactions(): Transactions {
  return { transactions: [], _unknownFields: {} };
}

export const Transactions = {
  encode(message: Transactions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      Transaction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Transactions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Transactions {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Transactions): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transactions>, I>>(base?: I): Transactions {
    return Transactions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transactions>, I>>(object: I): Transactions {
    const message = createBaseTransactions();
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlockHeader(): BlockHeader {
  return { rawData: undefined, witnessSignature: Buffer.alloc(0), _unknownFields: {} };
}

export const BlockHeader = {
  encode(message: BlockHeader, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rawData !== undefined) {
      BlockHeader_raw.encode(message.rawData, writer.uint32(10).fork()).ldelim();
    }
    if (message.witnessSignature.length !== 0) {
      writer.uint32(18).bytes(message.witnessSignature);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockHeader {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rawData = BlockHeader_raw.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.witnessSignature = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): BlockHeader {
    return {
      rawData: isSet(object.rawData) ? BlockHeader_raw.fromJSON(object.rawData) : undefined,
      witnessSignature: isSet(object.witnessSignature)
        ? Buffer.from(bytesFromBase64(object.witnessSignature))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: BlockHeader): unknown {
    const obj: any = {};
    if (message.rawData !== undefined) {
      obj.rawData = BlockHeader_raw.toJSON(message.rawData);
    }
    if (message.witnessSignature.length !== 0) {
      obj.witnessSignature = base64FromBytes(message.witnessSignature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockHeader>, I>>(base?: I): BlockHeader {
    return BlockHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockHeader>, I>>(object: I): BlockHeader {
    const message = createBaseBlockHeader();
    message.rawData = (object.rawData !== undefined && object.rawData !== null)
      ? BlockHeader_raw.fromPartial(object.rawData)
      : undefined;
    message.witnessSignature = object.witnessSignature ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseBlockHeader_raw(): BlockHeader_raw {
  return {
    timestamp: Long.ZERO,
    txTrieRoot: Buffer.alloc(0),
    parentHash: Buffer.alloc(0),
    number: Long.ZERO,
    witnessId: Long.ZERO,
    witnessAddress: Buffer.alloc(0),
    version: 0,
    accountStateRoot: Buffer.alloc(0),
    _unknownFields: {},
  };
}

export const BlockHeader_raw = {
  encode(message: BlockHeader_raw, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.timestamp);
    }
    if (message.txTrieRoot.length !== 0) {
      writer.uint32(18).bytes(message.txTrieRoot);
    }
    if (message.parentHash.length !== 0) {
      writer.uint32(26).bytes(message.parentHash);
    }
    if (!message.number.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.number);
    }
    if (!message.witnessId.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.witnessId);
    }
    if (message.witnessAddress.length !== 0) {
      writer.uint32(74).bytes(message.witnessAddress);
    }
    if (message.version !== 0) {
      writer.uint32(80).int32(message.version);
    }
    if (message.accountStateRoot.length !== 0) {
      writer.uint32(90).bytes(message.accountStateRoot);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockHeader_raw {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockHeader_raw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.txTrieRoot = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parentHash = reader.bytes() as Buffer;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.number = reader.int64() as Long;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.witnessId = reader.int64() as Long;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.witnessAddress = reader.bytes() as Buffer;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.accountStateRoot = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): BlockHeader_raw {
    return {
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
      txTrieRoot: isSet(object.txTrieRoot) ? Buffer.from(bytesFromBase64(object.txTrieRoot)) : Buffer.alloc(0),
      parentHash: isSet(object.parentHash) ? Buffer.from(bytesFromBase64(object.parentHash)) : Buffer.alloc(0),
      number: isSet(object.number) ? Long.fromValue(object.number) : Long.ZERO,
      witnessId: isSet(object.witnessId) ? Long.fromValue(object.witnessId) : Long.ZERO,
      witnessAddress: isSet(object.witnessAddress)
        ? Buffer.from(bytesFromBase64(object.witnessAddress))
        : Buffer.alloc(0),
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      accountStateRoot: isSet(object.accountStateRoot)
        ? Buffer.from(bytesFromBase64(object.accountStateRoot))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: BlockHeader_raw): unknown {
    const obj: any = {};
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    if (message.txTrieRoot.length !== 0) {
      obj.txTrieRoot = base64FromBytes(message.txTrieRoot);
    }
    if (message.parentHash.length !== 0) {
      obj.parentHash = base64FromBytes(message.parentHash);
    }
    if (!message.number.equals(Long.ZERO)) {
      obj.number = (message.number || Long.ZERO).toString();
    }
    if (!message.witnessId.equals(Long.ZERO)) {
      obj.witnessId = (message.witnessId || Long.ZERO).toString();
    }
    if (message.witnessAddress.length !== 0) {
      obj.witnessAddress = base64FromBytes(message.witnessAddress);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.accountStateRoot.length !== 0) {
      obj.accountStateRoot = base64FromBytes(message.accountStateRoot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockHeader_raw>, I>>(base?: I): BlockHeader_raw {
    return BlockHeader_raw.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockHeader_raw>, I>>(object: I): BlockHeader_raw {
    const message = createBaseBlockHeader_raw();
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    message.txTrieRoot = object.txTrieRoot ?? Buffer.alloc(0);
    message.parentHash = object.parentHash ?? Buffer.alloc(0);
    message.number = (object.number !== undefined && object.number !== null)
      ? Long.fromValue(object.number)
      : Long.ZERO;
    message.witnessId = (object.witnessId !== undefined && object.witnessId !== null)
      ? Long.fromValue(object.witnessId)
      : Long.ZERO;
    message.witnessAddress = object.witnessAddress ?? Buffer.alloc(0);
    message.version = object.version ?? 0;
    message.accountStateRoot = object.accountStateRoot ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseBlock(): Block {
  return { transactions: [], blockHeader: undefined, _unknownFields: {} };
}

export const Block = {
  encode(message: Block, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      Transaction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.blockHeader !== undefined) {
      BlockHeader.encode(message.blockHeader, writer.uint32(18).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Block {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockHeader = BlockHeader.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Block {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
      blockHeader: isSet(object.blockHeader) ? BlockHeader.fromJSON(object.blockHeader) : undefined,
    };
  },

  toJSON(message: Block): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    if (message.blockHeader !== undefined) {
      obj.blockHeader = BlockHeader.toJSON(message.blockHeader);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Block>, I>>(base?: I): Block {
    return Block.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Block>, I>>(object: I): Block {
    const message = createBaseBlock();
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    message.blockHeader = (object.blockHeader !== undefined && object.blockHeader !== null)
      ? BlockHeader.fromPartial(object.blockHeader)
      : undefined;
    return message;
  },
};

function createBaseChainInventory(): ChainInventory {
  return { ids: [], remainNum: Long.ZERO, _unknownFields: {} };
}

export const ChainInventory = {
  encode(message: ChainInventory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ids) {
      ChainInventory_BlockId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (!message.remainNum.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.remainNum);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChainInventory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainInventory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ids.push(ChainInventory_BlockId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.remainNum = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ChainInventory {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => ChainInventory_BlockId.fromJSON(e)) : [],
      remainNum: isSet(object.remainNum) ? Long.fromValue(object.remainNum) : Long.ZERO,
    };
  },

  toJSON(message: ChainInventory): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => ChainInventory_BlockId.toJSON(e));
    }
    if (!message.remainNum.equals(Long.ZERO)) {
      obj.remainNum = (message.remainNum || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainInventory>, I>>(base?: I): ChainInventory {
    return ChainInventory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainInventory>, I>>(object: I): ChainInventory {
    const message = createBaseChainInventory();
    message.ids = object.ids?.map((e) => ChainInventory_BlockId.fromPartial(e)) || [];
    message.remainNum = (object.remainNum !== undefined && object.remainNum !== null)
      ? Long.fromValue(object.remainNum)
      : Long.ZERO;
    return message;
  },
};

function createBaseChainInventory_BlockId(): ChainInventory_BlockId {
  return { hash: Buffer.alloc(0), number: Long.ZERO, _unknownFields: {} };
}

export const ChainInventory_BlockId = {
  encode(message: ChainInventory_BlockId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    if (!message.number.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.number);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChainInventory_BlockId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainInventory_BlockId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.number = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ChainInventory_BlockId {
    return {
      hash: isSet(object.hash) ? Buffer.from(bytesFromBase64(object.hash)) : Buffer.alloc(0),
      number: isSet(object.number) ? Long.fromValue(object.number) : Long.ZERO,
    };
  },

  toJSON(message: ChainInventory_BlockId): unknown {
    const obj: any = {};
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (!message.number.equals(Long.ZERO)) {
      obj.number = (message.number || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainInventory_BlockId>, I>>(base?: I): ChainInventory_BlockId {
    return ChainInventory_BlockId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainInventory_BlockId>, I>>(object: I): ChainInventory_BlockId {
    const message = createBaseChainInventory_BlockId();
    message.hash = object.hash ?? Buffer.alloc(0);
    message.number = (object.number !== undefined && object.number !== null)
      ? Long.fromValue(object.number)
      : Long.ZERO;
    return message;
  },
};

function createBaseBlockInventory(): BlockInventory {
  return { ids: [], type: 0, _unknownFields: {} };
}

export const BlockInventory = {
  encode(message: BlockInventory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ids) {
      BlockInventory_BlockId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockInventory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockInventory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ids.push(BlockInventory_BlockId.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): BlockInventory {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => BlockInventory_BlockId.fromJSON(e)) : [],
      type: isSet(object.type) ? blockInventory_TypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: BlockInventory): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => BlockInventory_BlockId.toJSON(e));
    }
    if (message.type !== 0) {
      obj.type = blockInventory_TypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockInventory>, I>>(base?: I): BlockInventory {
    return BlockInventory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockInventory>, I>>(object: I): BlockInventory {
    const message = createBaseBlockInventory();
    message.ids = object.ids?.map((e) => BlockInventory_BlockId.fromPartial(e)) || [];
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseBlockInventory_BlockId(): BlockInventory_BlockId {
  return { hash: Buffer.alloc(0), number: Long.ZERO, _unknownFields: {} };
}

export const BlockInventory_BlockId = {
  encode(message: BlockInventory_BlockId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    if (!message.number.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.number);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockInventory_BlockId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockInventory_BlockId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.number = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): BlockInventory_BlockId {
    return {
      hash: isSet(object.hash) ? Buffer.from(bytesFromBase64(object.hash)) : Buffer.alloc(0),
      number: isSet(object.number) ? Long.fromValue(object.number) : Long.ZERO,
    };
  },

  toJSON(message: BlockInventory_BlockId): unknown {
    const obj: any = {};
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (!message.number.equals(Long.ZERO)) {
      obj.number = (message.number || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockInventory_BlockId>, I>>(base?: I): BlockInventory_BlockId {
    return BlockInventory_BlockId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockInventory_BlockId>, I>>(object: I): BlockInventory_BlockId {
    const message = createBaseBlockInventory_BlockId();
    message.hash = object.hash ?? Buffer.alloc(0);
    message.number = (object.number !== undefined && object.number !== null)
      ? Long.fromValue(object.number)
      : Long.ZERO;
    return message;
  },
};

function createBaseInventory(): Inventory {
  return { type: 0, ids: [], _unknownFields: {} };
}

export const Inventory = {
  encode(message: Inventory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.ids) {
      writer.uint32(18).bytes(v!);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Inventory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInventory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.bytes() as Buffer);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Inventory {
    return {
      type: isSet(object.type) ? inventory_InventoryTypeFromJSON(object.type) : 0,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => Buffer.from(bytesFromBase64(e))) : [],
    };
  },

  toJSON(message: Inventory): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = inventory_InventoryTypeToJSON(message.type);
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Inventory>, I>>(base?: I): Inventory {
    return Inventory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Inventory>, I>>(object: I): Inventory {
    const message = createBaseInventory();
    message.type = object.type ?? 0;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseItems(): Items {
  return { type: 0, blocks: [], blockHeaders: [], transactions: [], _unknownFields: {} };
}

export const Items = {
  encode(message: Items, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.blocks) {
      Block.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.blockHeaders) {
      BlockHeader.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.transactions) {
      Transaction.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Items {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blocks.push(Block.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blockHeaders.push(BlockHeader.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): Items {
    return {
      type: isSet(object.type) ? items_ItemTypeFromJSON(object.type) : 0,
      blocks: globalThis.Array.isArray(object?.blocks) ? object.blocks.map((e: any) => Block.fromJSON(e)) : [],
      blockHeaders: globalThis.Array.isArray(object?.blockHeaders)
        ? object.blockHeaders.map((e: any) => BlockHeader.fromJSON(e))
        : [],
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Items): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = items_ItemTypeToJSON(message.type);
    }
    if (message.blocks?.length) {
      obj.blocks = message.blocks.map((e) => Block.toJSON(e));
    }
    if (message.blockHeaders?.length) {
      obj.blockHeaders = message.blockHeaders.map((e) => BlockHeader.toJSON(e));
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Items>, I>>(base?: I): Items {
    return Items.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Items>, I>>(object: I): Items {
    const message = createBaseItems();
    message.type = object.type ?? 0;
    message.blocks = object.blocks?.map((e) => Block.fromPartial(e)) || [];
    message.blockHeaders = object.blockHeaders?.map((e) => BlockHeader.fromPartial(e)) || [];
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDynamicProperties(): DynamicProperties {
  return { lastSolidityBlockNum: Long.ZERO, _unknownFields: {} };
}

export const DynamicProperties = {
  encode(message: DynamicProperties, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.lastSolidityBlockNum.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.lastSolidityBlockNum);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DynamicProperties {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDynamicProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lastSolidityBlockNum = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): DynamicProperties {
    return {
      lastSolidityBlockNum: isSet(object.lastSolidityBlockNum)
        ? Long.fromValue(object.lastSolidityBlockNum)
        : Long.ZERO,
    };
  },

  toJSON(message: DynamicProperties): unknown {
    const obj: any = {};
    if (!message.lastSolidityBlockNum.equals(Long.ZERO)) {
      obj.lastSolidityBlockNum = (message.lastSolidityBlockNum || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DynamicProperties>, I>>(base?: I): DynamicProperties {
    return DynamicProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DynamicProperties>, I>>(object: I): DynamicProperties {
    const message = createBaseDynamicProperties();
    message.lastSolidityBlockNum = (object.lastSolidityBlockNum !== undefined && object.lastSolidityBlockNum !== null)
      ? Long.fromValue(object.lastSolidityBlockNum)
      : Long.ZERO;
    return message;
  },
};

function createBaseDisconnectMessage(): DisconnectMessage {
  return { reason: 0, _unknownFields: {} };
}

export const DisconnectMessage = {
  encode(message: DisconnectMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reason !== 0) {
      writer.uint32(8).int32(message.reason);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DisconnectMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisconnectMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): DisconnectMessage {
    return { reason: isSet(object.reason) ? reasonCodeFromJSON(object.reason) : 0 };
  },

  toJSON(message: DisconnectMessage): unknown {
    const obj: any = {};
    if (message.reason !== 0) {
      obj.reason = reasonCodeToJSON(message.reason);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DisconnectMessage>, I>>(base?: I): DisconnectMessage {
    return DisconnectMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisconnectMessage>, I>>(object: I): DisconnectMessage {
    const message = createBaseDisconnectMessage();
    message.reason = object.reason ?? 0;
    return message;
  },
};

function createBaseHelloMessage(): HelloMessage {
  return {
    from: undefined,
    version: 0,
    timestamp: Long.ZERO,
    genesisBlockId: undefined,
    solidBlockId: undefined,
    headBlockId: undefined,
    address: Buffer.alloc(0),
    signature: Buffer.alloc(0),
    nodeType: 0,
    lowestBlockNum: Long.ZERO,
    codeVersion: Buffer.alloc(0),
    _unknownFields: {},
  };
}

export const HelloMessage = {
  encode(message: HelloMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Endpoint.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.timestamp);
    }
    if (message.genesisBlockId !== undefined) {
      HelloMessage_BlockId.encode(message.genesisBlockId, writer.uint32(34).fork()).ldelim();
    }
    if (message.solidBlockId !== undefined) {
      HelloMessage_BlockId.encode(message.solidBlockId, writer.uint32(42).fork()).ldelim();
    }
    if (message.headBlockId !== undefined) {
      HelloMessage_BlockId.encode(message.headBlockId, writer.uint32(50).fork()).ldelim();
    }
    if (message.address.length !== 0) {
      writer.uint32(58).bytes(message.address);
    }
    if (message.signature.length !== 0) {
      writer.uint32(66).bytes(message.signature);
    }
    if (message.nodeType !== 0) {
      writer.uint32(72).int32(message.nodeType);
    }
    if (!message.lowestBlockNum.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.lowestBlockNum);
    }
    if (message.codeVersion.length !== 0) {
      writer.uint32(90).bytes(message.codeVersion);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HelloMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHelloMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Endpoint.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.genesisBlockId = HelloMessage_BlockId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.solidBlockId = HelloMessage_BlockId.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.headBlockId = HelloMessage_BlockId.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.address = reader.bytes() as Buffer;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.signature = reader.bytes() as Buffer;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.nodeType = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.lowestBlockNum = reader.int64() as Long;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.codeVersion = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): HelloMessage {
    return {
      from: isSet(object.from) ? Endpoint.fromJSON(object.from) : undefined,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
      genesisBlockId: isSet(object.genesisBlockId) ? HelloMessage_BlockId.fromJSON(object.genesisBlockId) : undefined,
      solidBlockId: isSet(object.solidBlockId) ? HelloMessage_BlockId.fromJSON(object.solidBlockId) : undefined,
      headBlockId: isSet(object.headBlockId) ? HelloMessage_BlockId.fromJSON(object.headBlockId) : undefined,
      address: isSet(object.address) ? Buffer.from(bytesFromBase64(object.address)) : Buffer.alloc(0),
      signature: isSet(object.signature) ? Buffer.from(bytesFromBase64(object.signature)) : Buffer.alloc(0),
      nodeType: isSet(object.nodeType) ? globalThis.Number(object.nodeType) : 0,
      lowestBlockNum: isSet(object.lowestBlockNum) ? Long.fromValue(object.lowestBlockNum) : Long.ZERO,
      codeVersion: isSet(object.codeVersion) ? Buffer.from(bytesFromBase64(object.codeVersion)) : Buffer.alloc(0),
    };
  },

  toJSON(message: HelloMessage): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Endpoint.toJSON(message.from);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    if (message.genesisBlockId !== undefined) {
      obj.genesisBlockId = HelloMessage_BlockId.toJSON(message.genesisBlockId);
    }
    if (message.solidBlockId !== undefined) {
      obj.solidBlockId = HelloMessage_BlockId.toJSON(message.solidBlockId);
    }
    if (message.headBlockId !== undefined) {
      obj.headBlockId = HelloMessage_BlockId.toJSON(message.headBlockId);
    }
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.nodeType !== 0) {
      obj.nodeType = Math.round(message.nodeType);
    }
    if (!message.lowestBlockNum.equals(Long.ZERO)) {
      obj.lowestBlockNum = (message.lowestBlockNum || Long.ZERO).toString();
    }
    if (message.codeVersion.length !== 0) {
      obj.codeVersion = base64FromBytes(message.codeVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HelloMessage>, I>>(base?: I): HelloMessage {
    return HelloMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HelloMessage>, I>>(object: I): HelloMessage {
    const message = createBaseHelloMessage();
    message.from = (object.from !== undefined && object.from !== null) ? Endpoint.fromPartial(object.from) : undefined;
    message.version = object.version ?? 0;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    message.genesisBlockId = (object.genesisBlockId !== undefined && object.genesisBlockId !== null)
      ? HelloMessage_BlockId.fromPartial(object.genesisBlockId)
      : undefined;
    message.solidBlockId = (object.solidBlockId !== undefined && object.solidBlockId !== null)
      ? HelloMessage_BlockId.fromPartial(object.solidBlockId)
      : undefined;
    message.headBlockId = (object.headBlockId !== undefined && object.headBlockId !== null)
      ? HelloMessage_BlockId.fromPartial(object.headBlockId)
      : undefined;
    message.address = object.address ?? Buffer.alloc(0);
    message.signature = object.signature ?? Buffer.alloc(0);
    message.nodeType = object.nodeType ?? 0;
    message.lowestBlockNum = (object.lowestBlockNum !== undefined && object.lowestBlockNum !== null)
      ? Long.fromValue(object.lowestBlockNum)
      : Long.ZERO;
    message.codeVersion = object.codeVersion ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseHelloMessage_BlockId(): HelloMessage_BlockId {
  return { hash: Buffer.alloc(0), number: Long.ZERO, _unknownFields: {} };
}

export const HelloMessage_BlockId = {
  encode(message: HelloMessage_BlockId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    if (!message.number.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.number);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HelloMessage_BlockId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHelloMessage_BlockId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.number = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): HelloMessage_BlockId {
    return {
      hash: isSet(object.hash) ? Buffer.from(bytesFromBase64(object.hash)) : Buffer.alloc(0),
      number: isSet(object.number) ? Long.fromValue(object.number) : Long.ZERO,
    };
  },

  toJSON(message: HelloMessage_BlockId): unknown {
    const obj: any = {};
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (!message.number.equals(Long.ZERO)) {
      obj.number = (message.number || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HelloMessage_BlockId>, I>>(base?: I): HelloMessage_BlockId {
    return HelloMessage_BlockId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HelloMessage_BlockId>, I>>(object: I): HelloMessage_BlockId {
    const message = createBaseHelloMessage_BlockId();
    message.hash = object.hash ?? Buffer.alloc(0);
    message.number = (object.number !== undefined && object.number !== null)
      ? Long.fromValue(object.number)
      : Long.ZERO;
    return message;
  },
};

function createBaseInternalTransaction(): InternalTransaction {
  return {
    hash: Buffer.alloc(0),
    callerAddress: Buffer.alloc(0),
    transferToAddress: Buffer.alloc(0),
    callValueInfo: [],
    note: Buffer.alloc(0),
    rejected: false,
    extra: "",
    _unknownFields: {},
  };
}

export const InternalTransaction = {
  encode(message: InternalTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    if (message.callerAddress.length !== 0) {
      writer.uint32(18).bytes(message.callerAddress);
    }
    if (message.transferToAddress.length !== 0) {
      writer.uint32(26).bytes(message.transferToAddress);
    }
    for (const v of message.callValueInfo) {
      InternalTransaction_CallValueInfo.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.note.length !== 0) {
      writer.uint32(42).bytes(message.note);
    }
    if (message.rejected !== false) {
      writer.uint32(48).bool(message.rejected);
    }
    if (message.extra !== "") {
      writer.uint32(58).string(message.extra);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InternalTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.callerAddress = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transferToAddress = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.callValueInfo.push(InternalTransaction_CallValueInfo.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.note = reader.bytes() as Buffer;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.rejected = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.extra = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): InternalTransaction {
    return {
      hash: isSet(object.hash) ? Buffer.from(bytesFromBase64(object.hash)) : Buffer.alloc(0),
      callerAddress: isSet(object.callerAddress) ? Buffer.from(bytesFromBase64(object.callerAddress)) : Buffer.alloc(0),
      transferToAddress: isSet(object.transferToAddress)
        ? Buffer.from(bytesFromBase64(object.transferToAddress))
        : Buffer.alloc(0),
      callValueInfo: globalThis.Array.isArray(object?.callValueInfo)
        ? object.callValueInfo.map((e: any) => InternalTransaction_CallValueInfo.fromJSON(e))
        : [],
      note: isSet(object.note) ? Buffer.from(bytesFromBase64(object.note)) : Buffer.alloc(0),
      rejected: isSet(object.rejected) ? globalThis.Boolean(object.rejected) : false,
      extra: isSet(object.extra) ? globalThis.String(object.extra) : "",
    };
  },

  toJSON(message: InternalTransaction): unknown {
    const obj: any = {};
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.callerAddress.length !== 0) {
      obj.callerAddress = base64FromBytes(message.callerAddress);
    }
    if (message.transferToAddress.length !== 0) {
      obj.transferToAddress = base64FromBytes(message.transferToAddress);
    }
    if (message.callValueInfo?.length) {
      obj.callValueInfo = message.callValueInfo.map((e) => InternalTransaction_CallValueInfo.toJSON(e));
    }
    if (message.note.length !== 0) {
      obj.note = base64FromBytes(message.note);
    }
    if (message.rejected !== false) {
      obj.rejected = message.rejected;
    }
    if (message.extra !== "") {
      obj.extra = message.extra;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InternalTransaction>, I>>(base?: I): InternalTransaction {
    return InternalTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InternalTransaction>, I>>(object: I): InternalTransaction {
    const message = createBaseInternalTransaction();
    message.hash = object.hash ?? Buffer.alloc(0);
    message.callerAddress = object.callerAddress ?? Buffer.alloc(0);
    message.transferToAddress = object.transferToAddress ?? Buffer.alloc(0);
    message.callValueInfo = object.callValueInfo?.map((e) => InternalTransaction_CallValueInfo.fromPartial(e)) || [];
    message.note = object.note ?? Buffer.alloc(0);
    message.rejected = object.rejected ?? false;
    message.extra = object.extra ?? "";
    return message;
  },
};

function createBaseInternalTransaction_CallValueInfo(): InternalTransaction_CallValueInfo {
  return { callValue: Long.ZERO, tokenId: "", _unknownFields: {} };
}

export const InternalTransaction_CallValueInfo = {
  encode(message: InternalTransaction_CallValueInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.callValue.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.callValue);
    }
    if (message.tokenId !== "") {
      writer.uint32(18).string(message.tokenId);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InternalTransaction_CallValueInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalTransaction_CallValueInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.callValue = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): InternalTransaction_CallValueInfo {
    return {
      callValue: isSet(object.callValue) ? Long.fromValue(object.callValue) : Long.ZERO,
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
    };
  },

  toJSON(message: InternalTransaction_CallValueInfo): unknown {
    const obj: any = {};
    if (!message.callValue.equals(Long.ZERO)) {
      obj.callValue = (message.callValue || Long.ZERO).toString();
    }
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InternalTransaction_CallValueInfo>, I>>(
    base?: I,
  ): InternalTransaction_CallValueInfo {
    return InternalTransaction_CallValueInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InternalTransaction_CallValueInfo>, I>>(
    object: I,
  ): InternalTransaction_CallValueInfo {
    const message = createBaseInternalTransaction_CallValueInfo();
    message.callValue = (object.callValue !== undefined && object.callValue !== null)
      ? Long.fromValue(object.callValue)
      : Long.ZERO;
    message.tokenId = object.tokenId ?? "";
    return message;
  },
};

function createBaseDelegatedResourceAccountIndex(): DelegatedResourceAccountIndex {
  return { account: Buffer.alloc(0), fromAccounts: [], toAccounts: [], timestamp: Long.ZERO, _unknownFields: {} };
}

export const DelegatedResourceAccountIndex = {
  encode(message: DelegatedResourceAccountIndex, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.account.length !== 0) {
      writer.uint32(10).bytes(message.account);
    }
    for (const v of message.fromAccounts) {
      writer.uint32(18).bytes(v!);
    }
    for (const v of message.toAccounts) {
      writer.uint32(26).bytes(v!);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.timestamp);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DelegatedResourceAccountIndex {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegatedResourceAccountIndex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.account = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fromAccounts.push(reader.bytes() as Buffer);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.toAccounts.push(reader.bytes() as Buffer);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): DelegatedResourceAccountIndex {
    return {
      account: isSet(object.account) ? Buffer.from(bytesFromBase64(object.account)) : Buffer.alloc(0),
      fromAccounts: globalThis.Array.isArray(object?.fromAccounts)
        ? object.fromAccounts.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      toAccounts: globalThis.Array.isArray(object?.toAccounts)
        ? object.toAccounts.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
    };
  },

  toJSON(message: DelegatedResourceAccountIndex): unknown {
    const obj: any = {};
    if (message.account.length !== 0) {
      obj.account = base64FromBytes(message.account);
    }
    if (message.fromAccounts?.length) {
      obj.fromAccounts = message.fromAccounts.map((e) => base64FromBytes(e));
    }
    if (message.toAccounts?.length) {
      obj.toAccounts = message.toAccounts.map((e) => base64FromBytes(e));
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DelegatedResourceAccountIndex>, I>>(base?: I): DelegatedResourceAccountIndex {
    return DelegatedResourceAccountIndex.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DelegatedResourceAccountIndex>, I>>(
    object: I,
  ): DelegatedResourceAccountIndex {
    const message = createBaseDelegatedResourceAccountIndex();
    message.account = object.account ?? Buffer.alloc(0);
    message.fromAccounts = object.fromAccounts?.map((e) => e) || [];
    message.toAccounts = object.toAccounts?.map((e) => e) || [];
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    return message;
  },
};

function createBaseNodeInfo(): NodeInfo {
  return {
    beginSyncNum: Long.ZERO,
    block: "",
    solidityBlock: "",
    currentConnectCount: 0,
    activeConnectCount: 0,
    passiveConnectCount: 0,
    totalFlow: Long.ZERO,
    peerInfoList: [],
    configNodeInfo: undefined,
    machineInfo: undefined,
    cheatWitnessInfoMap: {},
    _unknownFields: {},
  };
}

export const NodeInfo = {
  encode(message: NodeInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.beginSyncNum.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.beginSyncNum);
    }
    if (message.block !== "") {
      writer.uint32(18).string(message.block);
    }
    if (message.solidityBlock !== "") {
      writer.uint32(26).string(message.solidityBlock);
    }
    if (message.currentConnectCount !== 0) {
      writer.uint32(32).int32(message.currentConnectCount);
    }
    if (message.activeConnectCount !== 0) {
      writer.uint32(40).int32(message.activeConnectCount);
    }
    if (message.passiveConnectCount !== 0) {
      writer.uint32(48).int32(message.passiveConnectCount);
    }
    if (!message.totalFlow.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.totalFlow);
    }
    for (const v of message.peerInfoList) {
      NodeInfo_PeerInfo.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.configNodeInfo !== undefined) {
      NodeInfo_ConfigNodeInfo.encode(message.configNodeInfo, writer.uint32(74).fork()).ldelim();
    }
    if (message.machineInfo !== undefined) {
      NodeInfo_MachineInfo.encode(message.machineInfo, writer.uint32(82).fork()).ldelim();
    }
    Object.entries(message.cheatWitnessInfoMap).forEach(([key, value]) => {
      NodeInfo_CheatWitnessInfoMapEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).ldelim();
    });
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.beginSyncNum = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.block = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.solidityBlock = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.currentConnectCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.activeConnectCount = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.passiveConnectCount = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.totalFlow = reader.int64() as Long;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.peerInfoList.push(NodeInfo_PeerInfo.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.configNodeInfo = NodeInfo_ConfigNodeInfo.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.machineInfo = NodeInfo_MachineInfo.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = NodeInfo_CheatWitnessInfoMapEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.cheatWitnessInfoMap[entry11.key] = entry11.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): NodeInfo {
    return {
      beginSyncNum: isSet(object.beginSyncNum) ? Long.fromValue(object.beginSyncNum) : Long.ZERO,
      block: isSet(object.block) ? globalThis.String(object.block) : "",
      solidityBlock: isSet(object.solidityBlock) ? globalThis.String(object.solidityBlock) : "",
      currentConnectCount: isSet(object.currentConnectCount) ? globalThis.Number(object.currentConnectCount) : 0,
      activeConnectCount: isSet(object.activeConnectCount) ? globalThis.Number(object.activeConnectCount) : 0,
      passiveConnectCount: isSet(object.passiveConnectCount) ? globalThis.Number(object.passiveConnectCount) : 0,
      totalFlow: isSet(object.totalFlow) ? Long.fromValue(object.totalFlow) : Long.ZERO,
      peerInfoList: globalThis.Array.isArray(object?.peerInfoList)
        ? object.peerInfoList.map((e: any) => NodeInfo_PeerInfo.fromJSON(e))
        : [],
      configNodeInfo: isSet(object.configNodeInfo)
        ? NodeInfo_ConfigNodeInfo.fromJSON(object.configNodeInfo)
        : undefined,
      machineInfo: isSet(object.machineInfo) ? NodeInfo_MachineInfo.fromJSON(object.machineInfo) : undefined,
      cheatWitnessInfoMap: isObject(object.cheatWitnessInfoMap)
        ? Object.entries(object.cheatWitnessInfoMap).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: NodeInfo): unknown {
    const obj: any = {};
    if (!message.beginSyncNum.equals(Long.ZERO)) {
      obj.beginSyncNum = (message.beginSyncNum || Long.ZERO).toString();
    }
    if (message.block !== "") {
      obj.block = message.block;
    }
    if (message.solidityBlock !== "") {
      obj.solidityBlock = message.solidityBlock;
    }
    if (message.currentConnectCount !== 0) {
      obj.currentConnectCount = Math.round(message.currentConnectCount);
    }
    if (message.activeConnectCount !== 0) {
      obj.activeConnectCount = Math.round(message.activeConnectCount);
    }
    if (message.passiveConnectCount !== 0) {
      obj.passiveConnectCount = Math.round(message.passiveConnectCount);
    }
    if (!message.totalFlow.equals(Long.ZERO)) {
      obj.totalFlow = (message.totalFlow || Long.ZERO).toString();
    }
    if (message.peerInfoList?.length) {
      obj.peerInfoList = message.peerInfoList.map((e) => NodeInfo_PeerInfo.toJSON(e));
    }
    if (message.configNodeInfo !== undefined) {
      obj.configNodeInfo = NodeInfo_ConfigNodeInfo.toJSON(message.configNodeInfo);
    }
    if (message.machineInfo !== undefined) {
      obj.machineInfo = NodeInfo_MachineInfo.toJSON(message.machineInfo);
    }
    if (message.cheatWitnessInfoMap) {
      const entries = Object.entries(message.cheatWitnessInfoMap);
      if (entries.length > 0) {
        obj.cheatWitnessInfoMap = {};
        entries.forEach(([k, v]) => {
          obj.cheatWitnessInfoMap[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeInfo>, I>>(base?: I): NodeInfo {
    return NodeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeInfo>, I>>(object: I): NodeInfo {
    const message = createBaseNodeInfo();
    message.beginSyncNum = (object.beginSyncNum !== undefined && object.beginSyncNum !== null)
      ? Long.fromValue(object.beginSyncNum)
      : Long.ZERO;
    message.block = object.block ?? "";
    message.solidityBlock = object.solidityBlock ?? "";
    message.currentConnectCount = object.currentConnectCount ?? 0;
    message.activeConnectCount = object.activeConnectCount ?? 0;
    message.passiveConnectCount = object.passiveConnectCount ?? 0;
    message.totalFlow = (object.totalFlow !== undefined && object.totalFlow !== null)
      ? Long.fromValue(object.totalFlow)
      : Long.ZERO;
    message.peerInfoList = object.peerInfoList?.map((e) => NodeInfo_PeerInfo.fromPartial(e)) || [];
    message.configNodeInfo = (object.configNodeInfo !== undefined && object.configNodeInfo !== null)
      ? NodeInfo_ConfigNodeInfo.fromPartial(object.configNodeInfo)
      : undefined;
    message.machineInfo = (object.machineInfo !== undefined && object.machineInfo !== null)
      ? NodeInfo_MachineInfo.fromPartial(object.machineInfo)
      : undefined;
    message.cheatWitnessInfoMap = Object.entries(object.cheatWitnessInfoMap ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseNodeInfo_CheatWitnessInfoMapEntry(): NodeInfo_CheatWitnessInfoMapEntry {
  return { key: "", value: "", _unknownFields: {} };
}

export const NodeInfo_CheatWitnessInfoMapEntry = {
  encode(message: NodeInfo_CheatWitnessInfoMapEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeInfo_CheatWitnessInfoMapEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeInfo_CheatWitnessInfoMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): NodeInfo_CheatWitnessInfoMapEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NodeInfo_CheatWitnessInfoMapEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeInfo_CheatWitnessInfoMapEntry>, I>>(
    base?: I,
  ): NodeInfo_CheatWitnessInfoMapEntry {
    return NodeInfo_CheatWitnessInfoMapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeInfo_CheatWitnessInfoMapEntry>, I>>(
    object: I,
  ): NodeInfo_CheatWitnessInfoMapEntry {
    const message = createBaseNodeInfo_CheatWitnessInfoMapEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNodeInfo_PeerInfo(): NodeInfo_PeerInfo {
  return {
    lastSyncBlock: "",
    remainNum: Long.ZERO,
    lastBlockUpdateTime: Long.ZERO,
    syncFlag: false,
    headBlockTimeWeBothHave: Long.ZERO,
    needSyncFromPeer: false,
    needSyncFromUs: false,
    host: "",
    port: 0,
    nodeId: "",
    connectTime: Long.ZERO,
    avgLatency: 0,
    syncToFetchSize: 0,
    syncToFetchSizePeekNum: Long.ZERO,
    syncBlockRequestedSize: 0,
    unFetchSynNum: Long.ZERO,
    blockInPorcSize: 0,
    headBlockWeBothHave: "",
    isActive: false,
    score: 0,
    nodeCount: 0,
    inFlow: Long.ZERO,
    disconnectTimes: 0,
    localDisconnectReason: "",
    remoteDisconnectReason: "",
    _unknownFields: {},
  };
}

export const NodeInfo_PeerInfo = {
  encode(message: NodeInfo_PeerInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lastSyncBlock !== "") {
      writer.uint32(10).string(message.lastSyncBlock);
    }
    if (!message.remainNum.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.remainNum);
    }
    if (!message.lastBlockUpdateTime.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.lastBlockUpdateTime);
    }
    if (message.syncFlag !== false) {
      writer.uint32(32).bool(message.syncFlag);
    }
    if (!message.headBlockTimeWeBothHave.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.headBlockTimeWeBothHave);
    }
    if (message.needSyncFromPeer !== false) {
      writer.uint32(48).bool(message.needSyncFromPeer);
    }
    if (message.needSyncFromUs !== false) {
      writer.uint32(56).bool(message.needSyncFromUs);
    }
    if (message.host !== "") {
      writer.uint32(66).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(72).int32(message.port);
    }
    if (message.nodeId !== "") {
      writer.uint32(82).string(message.nodeId);
    }
    if (!message.connectTime.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.connectTime);
    }
    if (message.avgLatency !== 0) {
      writer.uint32(97).double(message.avgLatency);
    }
    if (message.syncToFetchSize !== 0) {
      writer.uint32(104).int32(message.syncToFetchSize);
    }
    if (!message.syncToFetchSizePeekNum.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.syncToFetchSizePeekNum);
    }
    if (message.syncBlockRequestedSize !== 0) {
      writer.uint32(120).int32(message.syncBlockRequestedSize);
    }
    if (!message.unFetchSynNum.equals(Long.ZERO)) {
      writer.uint32(128).int64(message.unFetchSynNum);
    }
    if (message.blockInPorcSize !== 0) {
      writer.uint32(136).int32(message.blockInPorcSize);
    }
    if (message.headBlockWeBothHave !== "") {
      writer.uint32(146).string(message.headBlockWeBothHave);
    }
    if (message.isActive !== false) {
      writer.uint32(152).bool(message.isActive);
    }
    if (message.score !== 0) {
      writer.uint32(160).int32(message.score);
    }
    if (message.nodeCount !== 0) {
      writer.uint32(168).int32(message.nodeCount);
    }
    if (!message.inFlow.equals(Long.ZERO)) {
      writer.uint32(176).int64(message.inFlow);
    }
    if (message.disconnectTimes !== 0) {
      writer.uint32(184).int32(message.disconnectTimes);
    }
    if (message.localDisconnectReason !== "") {
      writer.uint32(194).string(message.localDisconnectReason);
    }
    if (message.remoteDisconnectReason !== "") {
      writer.uint32(202).string(message.remoteDisconnectReason);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeInfo_PeerInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeInfo_PeerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lastSyncBlock = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.remainNum = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.lastBlockUpdateTime = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.syncFlag = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.headBlockTimeWeBothHave = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.needSyncFromPeer = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.needSyncFromUs = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.host = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.port = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.connectTime = reader.int64() as Long;
          continue;
        case 12:
          if (tag !== 97) {
            break;
          }

          message.avgLatency = reader.double();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.syncToFetchSize = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.syncToFetchSizePeekNum = reader.int64() as Long;
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.syncBlockRequestedSize = reader.int32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.unFetchSynNum = reader.int64() as Long;
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.blockInPorcSize = reader.int32();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.headBlockWeBothHave = reader.string();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.score = reader.int32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.inFlow = reader.int64() as Long;
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.disconnectTimes = reader.int32();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.localDisconnectReason = reader.string();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.remoteDisconnectReason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): NodeInfo_PeerInfo {
    return {
      lastSyncBlock: isSet(object.lastSyncBlock) ? globalThis.String(object.lastSyncBlock) : "",
      remainNum: isSet(object.remainNum) ? Long.fromValue(object.remainNum) : Long.ZERO,
      lastBlockUpdateTime: isSet(object.lastBlockUpdateTime) ? Long.fromValue(object.lastBlockUpdateTime) : Long.ZERO,
      syncFlag: isSet(object.syncFlag) ? globalThis.Boolean(object.syncFlag) : false,
      headBlockTimeWeBothHave: isSet(object.headBlockTimeWeBothHave)
        ? Long.fromValue(object.headBlockTimeWeBothHave)
        : Long.ZERO,
      needSyncFromPeer: isSet(object.needSyncFromPeer) ? globalThis.Boolean(object.needSyncFromPeer) : false,
      needSyncFromUs: isSet(object.needSyncFromUs) ? globalThis.Boolean(object.needSyncFromUs) : false,
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      connectTime: isSet(object.connectTime) ? Long.fromValue(object.connectTime) : Long.ZERO,
      avgLatency: isSet(object.avgLatency) ? globalThis.Number(object.avgLatency) : 0,
      syncToFetchSize: isSet(object.syncToFetchSize) ? globalThis.Number(object.syncToFetchSize) : 0,
      syncToFetchSizePeekNum: isSet(object.syncToFetchSizePeekNum)
        ? Long.fromValue(object.syncToFetchSizePeekNum)
        : Long.ZERO,
      syncBlockRequestedSize: isSet(object.syncBlockRequestedSize)
        ? globalThis.Number(object.syncBlockRequestedSize)
        : 0,
      unFetchSynNum: isSet(object.unFetchSynNum) ? Long.fromValue(object.unFetchSynNum) : Long.ZERO,
      blockInPorcSize: isSet(object.blockInPorcSize) ? globalThis.Number(object.blockInPorcSize) : 0,
      headBlockWeBothHave: isSet(object.headBlockWeBothHave) ? globalThis.String(object.headBlockWeBothHave) : "",
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : 0,
      inFlow: isSet(object.inFlow) ? Long.fromValue(object.inFlow) : Long.ZERO,
      disconnectTimes: isSet(object.disconnectTimes) ? globalThis.Number(object.disconnectTimes) : 0,
      localDisconnectReason: isSet(object.localDisconnectReason) ? globalThis.String(object.localDisconnectReason) : "",
      remoteDisconnectReason: isSet(object.remoteDisconnectReason)
        ? globalThis.String(object.remoteDisconnectReason)
        : "",
    };
  },

  toJSON(message: NodeInfo_PeerInfo): unknown {
    const obj: any = {};
    if (message.lastSyncBlock !== "") {
      obj.lastSyncBlock = message.lastSyncBlock;
    }
    if (!message.remainNum.equals(Long.ZERO)) {
      obj.remainNum = (message.remainNum || Long.ZERO).toString();
    }
    if (!message.lastBlockUpdateTime.equals(Long.ZERO)) {
      obj.lastBlockUpdateTime = (message.lastBlockUpdateTime || Long.ZERO).toString();
    }
    if (message.syncFlag !== false) {
      obj.syncFlag = message.syncFlag;
    }
    if (!message.headBlockTimeWeBothHave.equals(Long.ZERO)) {
      obj.headBlockTimeWeBothHave = (message.headBlockTimeWeBothHave || Long.ZERO).toString();
    }
    if (message.needSyncFromPeer !== false) {
      obj.needSyncFromPeer = message.needSyncFromPeer;
    }
    if (message.needSyncFromUs !== false) {
      obj.needSyncFromUs = message.needSyncFromUs;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (!message.connectTime.equals(Long.ZERO)) {
      obj.connectTime = (message.connectTime || Long.ZERO).toString();
    }
    if (message.avgLatency !== 0) {
      obj.avgLatency = message.avgLatency;
    }
    if (message.syncToFetchSize !== 0) {
      obj.syncToFetchSize = Math.round(message.syncToFetchSize);
    }
    if (!message.syncToFetchSizePeekNum.equals(Long.ZERO)) {
      obj.syncToFetchSizePeekNum = (message.syncToFetchSizePeekNum || Long.ZERO).toString();
    }
    if (message.syncBlockRequestedSize !== 0) {
      obj.syncBlockRequestedSize = Math.round(message.syncBlockRequestedSize);
    }
    if (!message.unFetchSynNum.equals(Long.ZERO)) {
      obj.unFetchSynNum = (message.unFetchSynNum || Long.ZERO).toString();
    }
    if (message.blockInPorcSize !== 0) {
      obj.blockInPorcSize = Math.round(message.blockInPorcSize);
    }
    if (message.headBlockWeBothHave !== "") {
      obj.headBlockWeBothHave = message.headBlockWeBothHave;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.nodeCount !== 0) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (!message.inFlow.equals(Long.ZERO)) {
      obj.inFlow = (message.inFlow || Long.ZERO).toString();
    }
    if (message.disconnectTimes !== 0) {
      obj.disconnectTimes = Math.round(message.disconnectTimes);
    }
    if (message.localDisconnectReason !== "") {
      obj.localDisconnectReason = message.localDisconnectReason;
    }
    if (message.remoteDisconnectReason !== "") {
      obj.remoteDisconnectReason = message.remoteDisconnectReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeInfo_PeerInfo>, I>>(base?: I): NodeInfo_PeerInfo {
    return NodeInfo_PeerInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeInfo_PeerInfo>, I>>(object: I): NodeInfo_PeerInfo {
    const message = createBaseNodeInfo_PeerInfo();
    message.lastSyncBlock = object.lastSyncBlock ?? "";
    message.remainNum = (object.remainNum !== undefined && object.remainNum !== null)
      ? Long.fromValue(object.remainNum)
      : Long.ZERO;
    message.lastBlockUpdateTime = (object.lastBlockUpdateTime !== undefined && object.lastBlockUpdateTime !== null)
      ? Long.fromValue(object.lastBlockUpdateTime)
      : Long.ZERO;
    message.syncFlag = object.syncFlag ?? false;
    message.headBlockTimeWeBothHave =
      (object.headBlockTimeWeBothHave !== undefined && object.headBlockTimeWeBothHave !== null)
        ? Long.fromValue(object.headBlockTimeWeBothHave)
        : Long.ZERO;
    message.needSyncFromPeer = object.needSyncFromPeer ?? false;
    message.needSyncFromUs = object.needSyncFromUs ?? false;
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    message.nodeId = object.nodeId ?? "";
    message.connectTime = (object.connectTime !== undefined && object.connectTime !== null)
      ? Long.fromValue(object.connectTime)
      : Long.ZERO;
    message.avgLatency = object.avgLatency ?? 0;
    message.syncToFetchSize = object.syncToFetchSize ?? 0;
    message.syncToFetchSizePeekNum =
      (object.syncToFetchSizePeekNum !== undefined && object.syncToFetchSizePeekNum !== null)
        ? Long.fromValue(object.syncToFetchSizePeekNum)
        : Long.ZERO;
    message.syncBlockRequestedSize = object.syncBlockRequestedSize ?? 0;
    message.unFetchSynNum = (object.unFetchSynNum !== undefined && object.unFetchSynNum !== null)
      ? Long.fromValue(object.unFetchSynNum)
      : Long.ZERO;
    message.blockInPorcSize = object.blockInPorcSize ?? 0;
    message.headBlockWeBothHave = object.headBlockWeBothHave ?? "";
    message.isActive = object.isActive ?? false;
    message.score = object.score ?? 0;
    message.nodeCount = object.nodeCount ?? 0;
    message.inFlow = (object.inFlow !== undefined && object.inFlow !== null)
      ? Long.fromValue(object.inFlow)
      : Long.ZERO;
    message.disconnectTimes = object.disconnectTimes ?? 0;
    message.localDisconnectReason = object.localDisconnectReason ?? "";
    message.remoteDisconnectReason = object.remoteDisconnectReason ?? "";
    return message;
  },
};

function createBaseNodeInfo_ConfigNodeInfo(): NodeInfo_ConfigNodeInfo {
  return {
    codeVersion: "",
    p2pVersion: "",
    listenPort: 0,
    discoverEnable: false,
    activeNodeSize: 0,
    passiveNodeSize: 0,
    sendNodeSize: 0,
    maxConnectCount: 0,
    sameIpMaxConnectCount: 0,
    backupListenPort: 0,
    backupMemberSize: 0,
    backupPriority: 0,
    dbVersion: 0,
    minParticipationRate: 0,
    supportConstant: false,
    minTimeRatio: 0,
    maxTimeRatio: 0,
    allowCreationOfContracts: Long.ZERO,
    allowAdaptiveEnergy: Long.ZERO,
    _unknownFields: {},
  };
}

export const NodeInfo_ConfigNodeInfo = {
  encode(message: NodeInfo_ConfigNodeInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.codeVersion !== "") {
      writer.uint32(10).string(message.codeVersion);
    }
    if (message.p2pVersion !== "") {
      writer.uint32(18).string(message.p2pVersion);
    }
    if (message.listenPort !== 0) {
      writer.uint32(24).int32(message.listenPort);
    }
    if (message.discoverEnable !== false) {
      writer.uint32(32).bool(message.discoverEnable);
    }
    if (message.activeNodeSize !== 0) {
      writer.uint32(40).int32(message.activeNodeSize);
    }
    if (message.passiveNodeSize !== 0) {
      writer.uint32(48).int32(message.passiveNodeSize);
    }
    if (message.sendNodeSize !== 0) {
      writer.uint32(56).int32(message.sendNodeSize);
    }
    if (message.maxConnectCount !== 0) {
      writer.uint32(64).int32(message.maxConnectCount);
    }
    if (message.sameIpMaxConnectCount !== 0) {
      writer.uint32(72).int32(message.sameIpMaxConnectCount);
    }
    if (message.backupListenPort !== 0) {
      writer.uint32(80).int32(message.backupListenPort);
    }
    if (message.backupMemberSize !== 0) {
      writer.uint32(88).int32(message.backupMemberSize);
    }
    if (message.backupPriority !== 0) {
      writer.uint32(96).int32(message.backupPriority);
    }
    if (message.dbVersion !== 0) {
      writer.uint32(104).int32(message.dbVersion);
    }
    if (message.minParticipationRate !== 0) {
      writer.uint32(112).int32(message.minParticipationRate);
    }
    if (message.supportConstant !== false) {
      writer.uint32(120).bool(message.supportConstant);
    }
    if (message.minTimeRatio !== 0) {
      writer.uint32(129).double(message.minTimeRatio);
    }
    if (message.maxTimeRatio !== 0) {
      writer.uint32(137).double(message.maxTimeRatio);
    }
    if (!message.allowCreationOfContracts.equals(Long.ZERO)) {
      writer.uint32(144).int64(message.allowCreationOfContracts);
    }
    if (!message.allowAdaptiveEnergy.equals(Long.ZERO)) {
      writer.uint32(152).int64(message.allowAdaptiveEnergy);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeInfo_ConfigNodeInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeInfo_ConfigNodeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.codeVersion = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.p2pVersion = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.listenPort = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.discoverEnable = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.activeNodeSize = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.passiveNodeSize = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.sendNodeSize = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.maxConnectCount = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.sameIpMaxConnectCount = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.backupListenPort = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.backupMemberSize = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.backupPriority = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.dbVersion = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.minParticipationRate = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.supportConstant = reader.bool();
          continue;
        case 16:
          if (tag !== 129) {
            break;
          }

          message.minTimeRatio = reader.double();
          continue;
        case 17:
          if (tag !== 137) {
            break;
          }

          message.maxTimeRatio = reader.double();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.allowCreationOfContracts = reader.int64() as Long;
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.allowAdaptiveEnergy = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): NodeInfo_ConfigNodeInfo {
    return {
      codeVersion: isSet(object.codeVersion) ? globalThis.String(object.codeVersion) : "",
      p2pVersion: isSet(object.p2pVersion) ? globalThis.String(object.p2pVersion) : "",
      listenPort: isSet(object.listenPort) ? globalThis.Number(object.listenPort) : 0,
      discoverEnable: isSet(object.discoverEnable) ? globalThis.Boolean(object.discoverEnable) : false,
      activeNodeSize: isSet(object.activeNodeSize) ? globalThis.Number(object.activeNodeSize) : 0,
      passiveNodeSize: isSet(object.passiveNodeSize) ? globalThis.Number(object.passiveNodeSize) : 0,
      sendNodeSize: isSet(object.sendNodeSize) ? globalThis.Number(object.sendNodeSize) : 0,
      maxConnectCount: isSet(object.maxConnectCount) ? globalThis.Number(object.maxConnectCount) : 0,
      sameIpMaxConnectCount: isSet(object.sameIpMaxConnectCount) ? globalThis.Number(object.sameIpMaxConnectCount) : 0,
      backupListenPort: isSet(object.backupListenPort) ? globalThis.Number(object.backupListenPort) : 0,
      backupMemberSize: isSet(object.backupMemberSize) ? globalThis.Number(object.backupMemberSize) : 0,
      backupPriority: isSet(object.backupPriority) ? globalThis.Number(object.backupPriority) : 0,
      dbVersion: isSet(object.dbVersion) ? globalThis.Number(object.dbVersion) : 0,
      minParticipationRate: isSet(object.minParticipationRate) ? globalThis.Number(object.minParticipationRate) : 0,
      supportConstant: isSet(object.supportConstant) ? globalThis.Boolean(object.supportConstant) : false,
      minTimeRatio: isSet(object.minTimeRatio) ? globalThis.Number(object.minTimeRatio) : 0,
      maxTimeRatio: isSet(object.maxTimeRatio) ? globalThis.Number(object.maxTimeRatio) : 0,
      allowCreationOfContracts: isSet(object.allowCreationOfContracts)
        ? Long.fromValue(object.allowCreationOfContracts)
        : Long.ZERO,
      allowAdaptiveEnergy: isSet(object.allowAdaptiveEnergy) ? Long.fromValue(object.allowAdaptiveEnergy) : Long.ZERO,
    };
  },

  toJSON(message: NodeInfo_ConfigNodeInfo): unknown {
    const obj: any = {};
    if (message.codeVersion !== "") {
      obj.codeVersion = message.codeVersion;
    }
    if (message.p2pVersion !== "") {
      obj.p2pVersion = message.p2pVersion;
    }
    if (message.listenPort !== 0) {
      obj.listenPort = Math.round(message.listenPort);
    }
    if (message.discoverEnable !== false) {
      obj.discoverEnable = message.discoverEnable;
    }
    if (message.activeNodeSize !== 0) {
      obj.activeNodeSize = Math.round(message.activeNodeSize);
    }
    if (message.passiveNodeSize !== 0) {
      obj.passiveNodeSize = Math.round(message.passiveNodeSize);
    }
    if (message.sendNodeSize !== 0) {
      obj.sendNodeSize = Math.round(message.sendNodeSize);
    }
    if (message.maxConnectCount !== 0) {
      obj.maxConnectCount = Math.round(message.maxConnectCount);
    }
    if (message.sameIpMaxConnectCount !== 0) {
      obj.sameIpMaxConnectCount = Math.round(message.sameIpMaxConnectCount);
    }
    if (message.backupListenPort !== 0) {
      obj.backupListenPort = Math.round(message.backupListenPort);
    }
    if (message.backupMemberSize !== 0) {
      obj.backupMemberSize = Math.round(message.backupMemberSize);
    }
    if (message.backupPriority !== 0) {
      obj.backupPriority = Math.round(message.backupPriority);
    }
    if (message.dbVersion !== 0) {
      obj.dbVersion = Math.round(message.dbVersion);
    }
    if (message.minParticipationRate !== 0) {
      obj.minParticipationRate = Math.round(message.minParticipationRate);
    }
    if (message.supportConstant !== false) {
      obj.supportConstant = message.supportConstant;
    }
    if (message.minTimeRatio !== 0) {
      obj.minTimeRatio = message.minTimeRatio;
    }
    if (message.maxTimeRatio !== 0) {
      obj.maxTimeRatio = message.maxTimeRatio;
    }
    if (!message.allowCreationOfContracts.equals(Long.ZERO)) {
      obj.allowCreationOfContracts = (message.allowCreationOfContracts || Long.ZERO).toString();
    }
    if (!message.allowAdaptiveEnergy.equals(Long.ZERO)) {
      obj.allowAdaptiveEnergy = (message.allowAdaptiveEnergy || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeInfo_ConfigNodeInfo>, I>>(base?: I): NodeInfo_ConfigNodeInfo {
    return NodeInfo_ConfigNodeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeInfo_ConfigNodeInfo>, I>>(object: I): NodeInfo_ConfigNodeInfo {
    const message = createBaseNodeInfo_ConfigNodeInfo();
    message.codeVersion = object.codeVersion ?? "";
    message.p2pVersion = object.p2pVersion ?? "";
    message.listenPort = object.listenPort ?? 0;
    message.discoverEnable = object.discoverEnable ?? false;
    message.activeNodeSize = object.activeNodeSize ?? 0;
    message.passiveNodeSize = object.passiveNodeSize ?? 0;
    message.sendNodeSize = object.sendNodeSize ?? 0;
    message.maxConnectCount = object.maxConnectCount ?? 0;
    message.sameIpMaxConnectCount = object.sameIpMaxConnectCount ?? 0;
    message.backupListenPort = object.backupListenPort ?? 0;
    message.backupMemberSize = object.backupMemberSize ?? 0;
    message.backupPriority = object.backupPriority ?? 0;
    message.dbVersion = object.dbVersion ?? 0;
    message.minParticipationRate = object.minParticipationRate ?? 0;
    message.supportConstant = object.supportConstant ?? false;
    message.minTimeRatio = object.minTimeRatio ?? 0;
    message.maxTimeRatio = object.maxTimeRatio ?? 0;
    message.allowCreationOfContracts =
      (object.allowCreationOfContracts !== undefined && object.allowCreationOfContracts !== null)
        ? Long.fromValue(object.allowCreationOfContracts)
        : Long.ZERO;
    message.allowAdaptiveEnergy = (object.allowAdaptiveEnergy !== undefined && object.allowAdaptiveEnergy !== null)
      ? Long.fromValue(object.allowAdaptiveEnergy)
      : Long.ZERO;
    return message;
  },
};

function createBaseNodeInfo_MachineInfo(): NodeInfo_MachineInfo {
  return {
    threadCount: 0,
    deadLockThreadCount: 0,
    cpuCount: 0,
    totalMemory: Long.ZERO,
    freeMemory: Long.ZERO,
    cpuRate: 0,
    javaVersion: "",
    osName: "",
    jvmTotalMemory: Long.ZERO,
    jvmFreeMemory: Long.ZERO,
    processCpuRate: 0,
    memoryDescInfoList: [],
    deadLockThreadInfoList: [],
    _unknownFields: {},
  };
}

export const NodeInfo_MachineInfo = {
  encode(message: NodeInfo_MachineInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.threadCount !== 0) {
      writer.uint32(8).int32(message.threadCount);
    }
    if (message.deadLockThreadCount !== 0) {
      writer.uint32(16).int32(message.deadLockThreadCount);
    }
    if (message.cpuCount !== 0) {
      writer.uint32(24).int32(message.cpuCount);
    }
    if (!message.totalMemory.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.totalMemory);
    }
    if (!message.freeMemory.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.freeMemory);
    }
    if (message.cpuRate !== 0) {
      writer.uint32(49).double(message.cpuRate);
    }
    if (message.javaVersion !== "") {
      writer.uint32(58).string(message.javaVersion);
    }
    if (message.osName !== "") {
      writer.uint32(66).string(message.osName);
    }
    if (!message.jvmTotalMemory.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.jvmTotalMemory);
    }
    if (!message.jvmFreeMemory.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.jvmFreeMemory);
    }
    if (message.processCpuRate !== 0) {
      writer.uint32(89).double(message.processCpuRate);
    }
    for (const v of message.memoryDescInfoList) {
      NodeInfo_MachineInfo_MemoryDescInfo.encode(v!, writer.uint32(98).fork()).ldelim();
    }
    for (const v of message.deadLockThreadInfoList) {
      NodeInfo_MachineInfo_DeadLockThreadInfo.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeInfo_MachineInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeInfo_MachineInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.threadCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deadLockThreadCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cpuCount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalMemory = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.freeMemory = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.cpuRate = reader.double();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.javaVersion = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.osName = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.jvmTotalMemory = reader.int64() as Long;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.jvmFreeMemory = reader.int64() as Long;
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.processCpuRate = reader.double();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.memoryDescInfoList.push(NodeInfo_MachineInfo_MemoryDescInfo.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.deadLockThreadInfoList.push(NodeInfo_MachineInfo_DeadLockThreadInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): NodeInfo_MachineInfo {
    return {
      threadCount: isSet(object.threadCount) ? globalThis.Number(object.threadCount) : 0,
      deadLockThreadCount: isSet(object.deadLockThreadCount) ? globalThis.Number(object.deadLockThreadCount) : 0,
      cpuCount: isSet(object.cpuCount) ? globalThis.Number(object.cpuCount) : 0,
      totalMemory: isSet(object.totalMemory) ? Long.fromValue(object.totalMemory) : Long.ZERO,
      freeMemory: isSet(object.freeMemory) ? Long.fromValue(object.freeMemory) : Long.ZERO,
      cpuRate: isSet(object.cpuRate) ? globalThis.Number(object.cpuRate) : 0,
      javaVersion: isSet(object.javaVersion) ? globalThis.String(object.javaVersion) : "",
      osName: isSet(object.osName) ? globalThis.String(object.osName) : "",
      jvmTotalMemory: isSet(object.jvmTotalMemory) ? Long.fromValue(object.jvmTotalMemory) : Long.ZERO,
      jvmFreeMemory: isSet(object.jvmFreeMemory) ? Long.fromValue(object.jvmFreeMemory) : Long.ZERO,
      processCpuRate: isSet(object.processCpuRate) ? globalThis.Number(object.processCpuRate) : 0,
      memoryDescInfoList: globalThis.Array.isArray(object?.memoryDescInfoList)
        ? object.memoryDescInfoList.map((e: any) => NodeInfo_MachineInfo_MemoryDescInfo.fromJSON(e))
        : [],
      deadLockThreadInfoList: globalThis.Array.isArray(object?.deadLockThreadInfoList)
        ? object.deadLockThreadInfoList.map((e: any) => NodeInfo_MachineInfo_DeadLockThreadInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NodeInfo_MachineInfo): unknown {
    const obj: any = {};
    if (message.threadCount !== 0) {
      obj.threadCount = Math.round(message.threadCount);
    }
    if (message.deadLockThreadCount !== 0) {
      obj.deadLockThreadCount = Math.round(message.deadLockThreadCount);
    }
    if (message.cpuCount !== 0) {
      obj.cpuCount = Math.round(message.cpuCount);
    }
    if (!message.totalMemory.equals(Long.ZERO)) {
      obj.totalMemory = (message.totalMemory || Long.ZERO).toString();
    }
    if (!message.freeMemory.equals(Long.ZERO)) {
      obj.freeMemory = (message.freeMemory || Long.ZERO).toString();
    }
    if (message.cpuRate !== 0) {
      obj.cpuRate = message.cpuRate;
    }
    if (message.javaVersion !== "") {
      obj.javaVersion = message.javaVersion;
    }
    if (message.osName !== "") {
      obj.osName = message.osName;
    }
    if (!message.jvmTotalMemory.equals(Long.ZERO)) {
      obj.jvmTotalMemory = (message.jvmTotalMemory || Long.ZERO).toString();
    }
    if (!message.jvmFreeMemory.equals(Long.ZERO)) {
      obj.jvmFreeMemory = (message.jvmFreeMemory || Long.ZERO).toString();
    }
    if (message.processCpuRate !== 0) {
      obj.processCpuRate = message.processCpuRate;
    }
    if (message.memoryDescInfoList?.length) {
      obj.memoryDescInfoList = message.memoryDescInfoList.map((e) => NodeInfo_MachineInfo_MemoryDescInfo.toJSON(e));
    }
    if (message.deadLockThreadInfoList?.length) {
      obj.deadLockThreadInfoList = message.deadLockThreadInfoList.map((e) =>
        NodeInfo_MachineInfo_DeadLockThreadInfo.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeInfo_MachineInfo>, I>>(base?: I): NodeInfo_MachineInfo {
    return NodeInfo_MachineInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeInfo_MachineInfo>, I>>(object: I): NodeInfo_MachineInfo {
    const message = createBaseNodeInfo_MachineInfo();
    message.threadCount = object.threadCount ?? 0;
    message.deadLockThreadCount = object.deadLockThreadCount ?? 0;
    message.cpuCount = object.cpuCount ?? 0;
    message.totalMemory = (object.totalMemory !== undefined && object.totalMemory !== null)
      ? Long.fromValue(object.totalMemory)
      : Long.ZERO;
    message.freeMemory = (object.freeMemory !== undefined && object.freeMemory !== null)
      ? Long.fromValue(object.freeMemory)
      : Long.ZERO;
    message.cpuRate = object.cpuRate ?? 0;
    message.javaVersion = object.javaVersion ?? "";
    message.osName = object.osName ?? "";
    message.jvmTotalMemory = (object.jvmTotalMemory !== undefined && object.jvmTotalMemory !== null)
      ? Long.fromValue(object.jvmTotalMemory)
      : Long.ZERO;
    message.jvmFreeMemory = (object.jvmFreeMemory !== undefined && object.jvmFreeMemory !== null)
      ? Long.fromValue(object.jvmFreeMemory)
      : Long.ZERO;
    message.processCpuRate = object.processCpuRate ?? 0;
    message.memoryDescInfoList =
      object.memoryDescInfoList?.map((e) => NodeInfo_MachineInfo_MemoryDescInfo.fromPartial(e)) || [];
    message.deadLockThreadInfoList =
      object.deadLockThreadInfoList?.map((e) => NodeInfo_MachineInfo_DeadLockThreadInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNodeInfo_MachineInfo_MemoryDescInfo(): NodeInfo_MachineInfo_MemoryDescInfo {
  return { name: "", initSize: Long.ZERO, useSize: Long.ZERO, maxSize: Long.ZERO, useRate: 0, _unknownFields: {} };
}

export const NodeInfo_MachineInfo_MemoryDescInfo = {
  encode(message: NodeInfo_MachineInfo_MemoryDescInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.initSize.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.initSize);
    }
    if (!message.useSize.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.useSize);
    }
    if (!message.maxSize.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.maxSize);
    }
    if (message.useRate !== 0) {
      writer.uint32(41).double(message.useRate);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeInfo_MachineInfo_MemoryDescInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeInfo_MachineInfo_MemoryDescInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.initSize = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.useSize = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxSize = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.useRate = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): NodeInfo_MachineInfo_MemoryDescInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      initSize: isSet(object.initSize) ? Long.fromValue(object.initSize) : Long.ZERO,
      useSize: isSet(object.useSize) ? Long.fromValue(object.useSize) : Long.ZERO,
      maxSize: isSet(object.maxSize) ? Long.fromValue(object.maxSize) : Long.ZERO,
      useRate: isSet(object.useRate) ? globalThis.Number(object.useRate) : 0,
    };
  },

  toJSON(message: NodeInfo_MachineInfo_MemoryDescInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.initSize.equals(Long.ZERO)) {
      obj.initSize = (message.initSize || Long.ZERO).toString();
    }
    if (!message.useSize.equals(Long.ZERO)) {
      obj.useSize = (message.useSize || Long.ZERO).toString();
    }
    if (!message.maxSize.equals(Long.ZERO)) {
      obj.maxSize = (message.maxSize || Long.ZERO).toString();
    }
    if (message.useRate !== 0) {
      obj.useRate = message.useRate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeInfo_MachineInfo_MemoryDescInfo>, I>>(
    base?: I,
  ): NodeInfo_MachineInfo_MemoryDescInfo {
    return NodeInfo_MachineInfo_MemoryDescInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeInfo_MachineInfo_MemoryDescInfo>, I>>(
    object: I,
  ): NodeInfo_MachineInfo_MemoryDescInfo {
    const message = createBaseNodeInfo_MachineInfo_MemoryDescInfo();
    message.name = object.name ?? "";
    message.initSize = (object.initSize !== undefined && object.initSize !== null)
      ? Long.fromValue(object.initSize)
      : Long.ZERO;
    message.useSize = (object.useSize !== undefined && object.useSize !== null)
      ? Long.fromValue(object.useSize)
      : Long.ZERO;
    message.maxSize = (object.maxSize !== undefined && object.maxSize !== null)
      ? Long.fromValue(object.maxSize)
      : Long.ZERO;
    message.useRate = object.useRate ?? 0;
    return message;
  },
};

function createBaseNodeInfo_MachineInfo_DeadLockThreadInfo(): NodeInfo_MachineInfo_DeadLockThreadInfo {
  return {
    name: "",
    lockName: "",
    lockOwner: "",
    state: "",
    blockTime: Long.ZERO,
    waitTime: Long.ZERO,
    stackTrace: "",
    _unknownFields: {},
  };
}

export const NodeInfo_MachineInfo_DeadLockThreadInfo = {
  encode(message: NodeInfo_MachineInfo_DeadLockThreadInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.lockName !== "") {
      writer.uint32(18).string(message.lockName);
    }
    if (message.lockOwner !== "") {
      writer.uint32(26).string(message.lockOwner);
    }
    if (message.state !== "") {
      writer.uint32(34).string(message.state);
    }
    if (!message.blockTime.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.blockTime);
    }
    if (!message.waitTime.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.waitTime);
    }
    if (message.stackTrace !== "") {
      writer.uint32(58).string(message.stackTrace);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeInfo_MachineInfo_DeadLockThreadInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeInfo_MachineInfo_DeadLockThreadInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lockName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lockOwner = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.state = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.blockTime = reader.int64() as Long;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.waitTime = reader.int64() as Long;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.stackTrace = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): NodeInfo_MachineInfo_DeadLockThreadInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      lockName: isSet(object.lockName) ? globalThis.String(object.lockName) : "",
      lockOwner: isSet(object.lockOwner) ? globalThis.String(object.lockOwner) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      blockTime: isSet(object.blockTime) ? Long.fromValue(object.blockTime) : Long.ZERO,
      waitTime: isSet(object.waitTime) ? Long.fromValue(object.waitTime) : Long.ZERO,
      stackTrace: isSet(object.stackTrace) ? globalThis.String(object.stackTrace) : "",
    };
  },

  toJSON(message: NodeInfo_MachineInfo_DeadLockThreadInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.lockName !== "") {
      obj.lockName = message.lockName;
    }
    if (message.lockOwner !== "") {
      obj.lockOwner = message.lockOwner;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (!message.blockTime.equals(Long.ZERO)) {
      obj.blockTime = (message.blockTime || Long.ZERO).toString();
    }
    if (!message.waitTime.equals(Long.ZERO)) {
      obj.waitTime = (message.waitTime || Long.ZERO).toString();
    }
    if (message.stackTrace !== "") {
      obj.stackTrace = message.stackTrace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeInfo_MachineInfo_DeadLockThreadInfo>, I>>(
    base?: I,
  ): NodeInfo_MachineInfo_DeadLockThreadInfo {
    return NodeInfo_MachineInfo_DeadLockThreadInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeInfo_MachineInfo_DeadLockThreadInfo>, I>>(
    object: I,
  ): NodeInfo_MachineInfo_DeadLockThreadInfo {
    const message = createBaseNodeInfo_MachineInfo_DeadLockThreadInfo();
    message.name = object.name ?? "";
    message.lockName = object.lockName ?? "";
    message.lockOwner = object.lockOwner ?? "";
    message.state = object.state ?? "";
    message.blockTime = (object.blockTime !== undefined && object.blockTime !== null)
      ? Long.fromValue(object.blockTime)
      : Long.ZERO;
    message.waitTime = (object.waitTime !== undefined && object.waitTime !== null)
      ? Long.fromValue(object.waitTime)
      : Long.ZERO;
    message.stackTrace = object.stackTrace ?? "";
    return message;
  },
};

function createBaseMetricsInfo(): MetricsInfo {
  return { interval: Long.ZERO, node: undefined, blockchain: undefined, net: undefined, _unknownFields: {} };
}

export const MetricsInfo = {
  encode(message: MetricsInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.interval.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.interval);
    }
    if (message.node !== undefined) {
      MetricsInfo_NodeInfo.encode(message.node, writer.uint32(18).fork()).ldelim();
    }
    if (message.blockchain !== undefined) {
      MetricsInfo_BlockChainInfo.encode(message.blockchain, writer.uint32(26).fork()).ldelim();
    }
    if (message.net !== undefined) {
      MetricsInfo_NetInfo.encode(message.net, writer.uint32(34).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricsInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.interval = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.node = MetricsInfo_NodeInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blockchain = MetricsInfo_BlockChainInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.net = MetricsInfo_NetInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MetricsInfo {
    return {
      interval: isSet(object.interval) ? Long.fromValue(object.interval) : Long.ZERO,
      node: isSet(object.node) ? MetricsInfo_NodeInfo.fromJSON(object.node) : undefined,
      blockchain: isSet(object.blockchain) ? MetricsInfo_BlockChainInfo.fromJSON(object.blockchain) : undefined,
      net: isSet(object.net) ? MetricsInfo_NetInfo.fromJSON(object.net) : undefined,
    };
  },

  toJSON(message: MetricsInfo): unknown {
    const obj: any = {};
    if (!message.interval.equals(Long.ZERO)) {
      obj.interval = (message.interval || Long.ZERO).toString();
    }
    if (message.node !== undefined) {
      obj.node = MetricsInfo_NodeInfo.toJSON(message.node);
    }
    if (message.blockchain !== undefined) {
      obj.blockchain = MetricsInfo_BlockChainInfo.toJSON(message.blockchain);
    }
    if (message.net !== undefined) {
      obj.net = MetricsInfo_NetInfo.toJSON(message.net);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricsInfo>, I>>(base?: I): MetricsInfo {
    return MetricsInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricsInfo>, I>>(object: I): MetricsInfo {
    const message = createBaseMetricsInfo();
    message.interval = (object.interval !== undefined && object.interval !== null)
      ? Long.fromValue(object.interval)
      : Long.ZERO;
    message.node = (object.node !== undefined && object.node !== null)
      ? MetricsInfo_NodeInfo.fromPartial(object.node)
      : undefined;
    message.blockchain = (object.blockchain !== undefined && object.blockchain !== null)
      ? MetricsInfo_BlockChainInfo.fromPartial(object.blockchain)
      : undefined;
    message.net = (object.net !== undefined && object.net !== null)
      ? MetricsInfo_NetInfo.fromPartial(object.net)
      : undefined;
    return message;
  },
};

function createBaseMetricsInfo_NodeInfo(): MetricsInfo_NodeInfo {
  return { ip: "", nodeType: 0, version: "", backupStatus: 0, _unknownFields: {} };
}

export const MetricsInfo_NodeInfo = {
  encode(message: MetricsInfo_NodeInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ip !== "") {
      writer.uint32(10).string(message.ip);
    }
    if (message.nodeType !== 0) {
      writer.uint32(16).int32(message.nodeType);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.backupStatus !== 0) {
      writer.uint32(32).int32(message.backupStatus);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricsInfo_NodeInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsInfo_NodeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ip = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nodeType = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.backupStatus = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MetricsInfo_NodeInfo {
    return {
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      nodeType: isSet(object.nodeType) ? globalThis.Number(object.nodeType) : 0,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      backupStatus: isSet(object.backupStatus) ? globalThis.Number(object.backupStatus) : 0,
    };
  },

  toJSON(message: MetricsInfo_NodeInfo): unknown {
    const obj: any = {};
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.nodeType !== 0) {
      obj.nodeType = Math.round(message.nodeType);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.backupStatus !== 0) {
      obj.backupStatus = Math.round(message.backupStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricsInfo_NodeInfo>, I>>(base?: I): MetricsInfo_NodeInfo {
    return MetricsInfo_NodeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricsInfo_NodeInfo>, I>>(object: I): MetricsInfo_NodeInfo {
    const message = createBaseMetricsInfo_NodeInfo();
    message.ip = object.ip ?? "";
    message.nodeType = object.nodeType ?? 0;
    message.version = object.version ?? "";
    message.backupStatus = object.backupStatus ?? 0;
    return message;
  },
};

function createBaseMetricsInfo_BlockChainInfo(): MetricsInfo_BlockChainInfo {
  return {
    headBlockNum: Long.ZERO,
    headBlockTimestamp: Long.ZERO,
    headBlockHash: "",
    forkCount: 0,
    failForkCount: 0,
    blockProcessTime: undefined,
    tps: undefined,
    transactionCacheSize: 0,
    missedTransaction: undefined,
    witnesses: [],
    failProcessBlockNum: Long.ZERO,
    failProcessBlockReason: "",
    dupWitness: [],
    _unknownFields: {},
  };
}

export const MetricsInfo_BlockChainInfo = {
  encode(message: MetricsInfo_BlockChainInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.headBlockNum.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.headBlockNum);
    }
    if (!message.headBlockTimestamp.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.headBlockTimestamp);
    }
    if (message.headBlockHash !== "") {
      writer.uint32(26).string(message.headBlockHash);
    }
    if (message.forkCount !== 0) {
      writer.uint32(32).int32(message.forkCount);
    }
    if (message.failForkCount !== 0) {
      writer.uint32(40).int32(message.failForkCount);
    }
    if (message.blockProcessTime !== undefined) {
      MetricsInfo_RateInfo.encode(message.blockProcessTime, writer.uint32(50).fork()).ldelim();
    }
    if (message.tps !== undefined) {
      MetricsInfo_RateInfo.encode(message.tps, writer.uint32(58).fork()).ldelim();
    }
    if (message.transactionCacheSize !== 0) {
      writer.uint32(64).int32(message.transactionCacheSize);
    }
    if (message.missedTransaction !== undefined) {
      MetricsInfo_RateInfo.encode(message.missedTransaction, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.witnesses) {
      MetricsInfo_BlockChainInfo_Witness.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    if (!message.failProcessBlockNum.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.failProcessBlockNum);
    }
    if (message.failProcessBlockReason !== "") {
      writer.uint32(98).string(message.failProcessBlockReason);
    }
    for (const v of message.dupWitness) {
      MetricsInfo_BlockChainInfo_DupWitness.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricsInfo_BlockChainInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsInfo_BlockChainInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.headBlockNum = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.headBlockTimestamp = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.headBlockHash = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.forkCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.failForkCount = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.blockProcessTime = MetricsInfo_RateInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.tps = MetricsInfo_RateInfo.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.transactionCacheSize = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.missedTransaction = MetricsInfo_RateInfo.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.witnesses.push(MetricsInfo_BlockChainInfo_Witness.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.failProcessBlockNum = reader.int64() as Long;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.failProcessBlockReason = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.dupWitness.push(MetricsInfo_BlockChainInfo_DupWitness.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MetricsInfo_BlockChainInfo {
    return {
      headBlockNum: isSet(object.headBlockNum) ? Long.fromValue(object.headBlockNum) : Long.ZERO,
      headBlockTimestamp: isSet(object.headBlockTimestamp) ? Long.fromValue(object.headBlockTimestamp) : Long.ZERO,
      headBlockHash: isSet(object.headBlockHash) ? globalThis.String(object.headBlockHash) : "",
      forkCount: isSet(object.forkCount) ? globalThis.Number(object.forkCount) : 0,
      failForkCount: isSet(object.failForkCount) ? globalThis.Number(object.failForkCount) : 0,
      blockProcessTime: isSet(object.blockProcessTime)
        ? MetricsInfo_RateInfo.fromJSON(object.blockProcessTime)
        : undefined,
      tps: isSet(object.tps) ? MetricsInfo_RateInfo.fromJSON(object.tps) : undefined,
      transactionCacheSize: isSet(object.transactionCacheSize) ? globalThis.Number(object.transactionCacheSize) : 0,
      missedTransaction: isSet(object.missedTransaction)
        ? MetricsInfo_RateInfo.fromJSON(object.missedTransaction)
        : undefined,
      witnesses: globalThis.Array.isArray(object?.witnesses)
        ? object.witnesses.map((e: any) => MetricsInfo_BlockChainInfo_Witness.fromJSON(e))
        : [],
      failProcessBlockNum: isSet(object.failProcessBlockNum) ? Long.fromValue(object.failProcessBlockNum) : Long.ZERO,
      failProcessBlockReason: isSet(object.failProcessBlockReason)
        ? globalThis.String(object.failProcessBlockReason)
        : "",
      dupWitness: globalThis.Array.isArray(object?.dupWitness)
        ? object.dupWitness.map((e: any) => MetricsInfo_BlockChainInfo_DupWitness.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MetricsInfo_BlockChainInfo): unknown {
    const obj: any = {};
    if (!message.headBlockNum.equals(Long.ZERO)) {
      obj.headBlockNum = (message.headBlockNum || Long.ZERO).toString();
    }
    if (!message.headBlockTimestamp.equals(Long.ZERO)) {
      obj.headBlockTimestamp = (message.headBlockTimestamp || Long.ZERO).toString();
    }
    if (message.headBlockHash !== "") {
      obj.headBlockHash = message.headBlockHash;
    }
    if (message.forkCount !== 0) {
      obj.forkCount = Math.round(message.forkCount);
    }
    if (message.failForkCount !== 0) {
      obj.failForkCount = Math.round(message.failForkCount);
    }
    if (message.blockProcessTime !== undefined) {
      obj.blockProcessTime = MetricsInfo_RateInfo.toJSON(message.blockProcessTime);
    }
    if (message.tps !== undefined) {
      obj.tps = MetricsInfo_RateInfo.toJSON(message.tps);
    }
    if (message.transactionCacheSize !== 0) {
      obj.transactionCacheSize = Math.round(message.transactionCacheSize);
    }
    if (message.missedTransaction !== undefined) {
      obj.missedTransaction = MetricsInfo_RateInfo.toJSON(message.missedTransaction);
    }
    if (message.witnesses?.length) {
      obj.witnesses = message.witnesses.map((e) => MetricsInfo_BlockChainInfo_Witness.toJSON(e));
    }
    if (!message.failProcessBlockNum.equals(Long.ZERO)) {
      obj.failProcessBlockNum = (message.failProcessBlockNum || Long.ZERO).toString();
    }
    if (message.failProcessBlockReason !== "") {
      obj.failProcessBlockReason = message.failProcessBlockReason;
    }
    if (message.dupWitness?.length) {
      obj.dupWitness = message.dupWitness.map((e) => MetricsInfo_BlockChainInfo_DupWitness.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricsInfo_BlockChainInfo>, I>>(base?: I): MetricsInfo_BlockChainInfo {
    return MetricsInfo_BlockChainInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricsInfo_BlockChainInfo>, I>>(object: I): MetricsInfo_BlockChainInfo {
    const message = createBaseMetricsInfo_BlockChainInfo();
    message.headBlockNum = (object.headBlockNum !== undefined && object.headBlockNum !== null)
      ? Long.fromValue(object.headBlockNum)
      : Long.ZERO;
    message.headBlockTimestamp = (object.headBlockTimestamp !== undefined && object.headBlockTimestamp !== null)
      ? Long.fromValue(object.headBlockTimestamp)
      : Long.ZERO;
    message.headBlockHash = object.headBlockHash ?? "";
    message.forkCount = object.forkCount ?? 0;
    message.failForkCount = object.failForkCount ?? 0;
    message.blockProcessTime = (object.blockProcessTime !== undefined && object.blockProcessTime !== null)
      ? MetricsInfo_RateInfo.fromPartial(object.blockProcessTime)
      : undefined;
    message.tps = (object.tps !== undefined && object.tps !== null)
      ? MetricsInfo_RateInfo.fromPartial(object.tps)
      : undefined;
    message.transactionCacheSize = object.transactionCacheSize ?? 0;
    message.missedTransaction = (object.missedTransaction !== undefined && object.missedTransaction !== null)
      ? MetricsInfo_RateInfo.fromPartial(object.missedTransaction)
      : undefined;
    message.witnesses = object.witnesses?.map((e) => MetricsInfo_BlockChainInfo_Witness.fromPartial(e)) || [];
    message.failProcessBlockNum = (object.failProcessBlockNum !== undefined && object.failProcessBlockNum !== null)
      ? Long.fromValue(object.failProcessBlockNum)
      : Long.ZERO;
    message.failProcessBlockReason = object.failProcessBlockReason ?? "";
    message.dupWitness = object.dupWitness?.map((e) => MetricsInfo_BlockChainInfo_DupWitness.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMetricsInfo_BlockChainInfo_Witness(): MetricsInfo_BlockChainInfo_Witness {
  return { address: "", version: 0, _unknownFields: {} };
}

export const MetricsInfo_BlockChainInfo_Witness = {
  encode(message: MetricsInfo_BlockChainInfo_Witness, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricsInfo_BlockChainInfo_Witness {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsInfo_BlockChainInfo_Witness();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MetricsInfo_BlockChainInfo_Witness {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: MetricsInfo_BlockChainInfo_Witness): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricsInfo_BlockChainInfo_Witness>, I>>(
    base?: I,
  ): MetricsInfo_BlockChainInfo_Witness {
    return MetricsInfo_BlockChainInfo_Witness.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricsInfo_BlockChainInfo_Witness>, I>>(
    object: I,
  ): MetricsInfo_BlockChainInfo_Witness {
    const message = createBaseMetricsInfo_BlockChainInfo_Witness();
    message.address = object.address ?? "";
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseMetricsInfo_BlockChainInfo_DupWitness(): MetricsInfo_BlockChainInfo_DupWitness {
  return { address: "", blockNum: Long.ZERO, count: 0, _unknownFields: {} };
}

export const MetricsInfo_BlockChainInfo_DupWitness = {
  encode(message: MetricsInfo_BlockChainInfo_DupWitness, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (!message.blockNum.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.blockNum);
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricsInfo_BlockChainInfo_DupWitness {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsInfo_BlockChainInfo_DupWitness();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.blockNum = reader.int64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.count = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MetricsInfo_BlockChainInfo_DupWitness {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      blockNum: isSet(object.blockNum) ? Long.fromValue(object.blockNum) : Long.ZERO,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: MetricsInfo_BlockChainInfo_DupWitness): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (!message.blockNum.equals(Long.ZERO)) {
      obj.blockNum = (message.blockNum || Long.ZERO).toString();
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricsInfo_BlockChainInfo_DupWitness>, I>>(
    base?: I,
  ): MetricsInfo_BlockChainInfo_DupWitness {
    return MetricsInfo_BlockChainInfo_DupWitness.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricsInfo_BlockChainInfo_DupWitness>, I>>(
    object: I,
  ): MetricsInfo_BlockChainInfo_DupWitness {
    const message = createBaseMetricsInfo_BlockChainInfo_DupWitness();
    message.address = object.address ?? "";
    message.blockNum = (object.blockNum !== undefined && object.blockNum !== null)
      ? Long.fromValue(object.blockNum)
      : Long.ZERO;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseMetricsInfo_RateInfo(): MetricsInfo_RateInfo {
  return {
    count: Long.ZERO,
    meanRate: 0,
    oneMinuteRate: 0,
    fiveMinuteRate: 0,
    fifteenMinuteRate: 0,
    _unknownFields: {},
  };
}

export const MetricsInfo_RateInfo = {
  encode(message: MetricsInfo_RateInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.count);
    }
    if (message.meanRate !== 0) {
      writer.uint32(17).double(message.meanRate);
    }
    if (message.oneMinuteRate !== 0) {
      writer.uint32(25).double(message.oneMinuteRate);
    }
    if (message.fiveMinuteRate !== 0) {
      writer.uint32(33).double(message.fiveMinuteRate);
    }
    if (message.fifteenMinuteRate !== 0) {
      writer.uint32(41).double(message.fifteenMinuteRate);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricsInfo_RateInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsInfo_RateInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = reader.int64() as Long;
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.meanRate = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.oneMinuteRate = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.fiveMinuteRate = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.fifteenMinuteRate = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MetricsInfo_RateInfo {
    return {
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO,
      meanRate: isSet(object.meanRate) ? globalThis.Number(object.meanRate) : 0,
      oneMinuteRate: isSet(object.oneMinuteRate) ? globalThis.Number(object.oneMinuteRate) : 0,
      fiveMinuteRate: isSet(object.fiveMinuteRate) ? globalThis.Number(object.fiveMinuteRate) : 0,
      fifteenMinuteRate: isSet(object.fifteenMinuteRate) ? globalThis.Number(object.fifteenMinuteRate) : 0,
    };
  },

  toJSON(message: MetricsInfo_RateInfo): unknown {
    const obj: any = {};
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    if (message.meanRate !== 0) {
      obj.meanRate = message.meanRate;
    }
    if (message.oneMinuteRate !== 0) {
      obj.oneMinuteRate = message.oneMinuteRate;
    }
    if (message.fiveMinuteRate !== 0) {
      obj.fiveMinuteRate = message.fiveMinuteRate;
    }
    if (message.fifteenMinuteRate !== 0) {
      obj.fifteenMinuteRate = message.fifteenMinuteRate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricsInfo_RateInfo>, I>>(base?: I): MetricsInfo_RateInfo {
    return MetricsInfo_RateInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricsInfo_RateInfo>, I>>(object: I): MetricsInfo_RateInfo {
    const message = createBaseMetricsInfo_RateInfo();
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    message.meanRate = object.meanRate ?? 0;
    message.oneMinuteRate = object.oneMinuteRate ?? 0;
    message.fiveMinuteRate = object.fiveMinuteRate ?? 0;
    message.fifteenMinuteRate = object.fifteenMinuteRate ?? 0;
    return message;
  },
};

function createBaseMetricsInfo_NetInfo(): MetricsInfo_NetInfo {
  return {
    errorProtoCount: 0,
    api: undefined,
    connectionCount: 0,
    validConnectionCount: 0,
    tcpInTraffic: undefined,
    tcpOutTraffic: undefined,
    disconnectionCount: 0,
    disconnectionDetail: [],
    udpInTraffic: undefined,
    udpOutTraffic: undefined,
    latency: undefined,
    _unknownFields: {},
  };
}

export const MetricsInfo_NetInfo = {
  encode(message: MetricsInfo_NetInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.errorProtoCount !== 0) {
      writer.uint32(8).int32(message.errorProtoCount);
    }
    if (message.api !== undefined) {
      MetricsInfo_NetInfo_ApiInfo.encode(message.api, writer.uint32(18).fork()).ldelim();
    }
    if (message.connectionCount !== 0) {
      writer.uint32(24).int32(message.connectionCount);
    }
    if (message.validConnectionCount !== 0) {
      writer.uint32(32).int32(message.validConnectionCount);
    }
    if (message.tcpInTraffic !== undefined) {
      MetricsInfo_RateInfo.encode(message.tcpInTraffic, writer.uint32(42).fork()).ldelim();
    }
    if (message.tcpOutTraffic !== undefined) {
      MetricsInfo_RateInfo.encode(message.tcpOutTraffic, writer.uint32(50).fork()).ldelim();
    }
    if (message.disconnectionCount !== 0) {
      writer.uint32(56).int32(message.disconnectionCount);
    }
    for (const v of message.disconnectionDetail) {
      MetricsInfo_NetInfo_DisconnectionDetailInfo.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.udpInTraffic !== undefined) {
      MetricsInfo_RateInfo.encode(message.udpInTraffic, writer.uint32(74).fork()).ldelim();
    }
    if (message.udpOutTraffic !== undefined) {
      MetricsInfo_RateInfo.encode(message.udpOutTraffic, writer.uint32(82).fork()).ldelim();
    }
    if (message.latency !== undefined) {
      MetricsInfo_NetInfo_LatencyInfo.encode(message.latency, writer.uint32(90).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricsInfo_NetInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsInfo_NetInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.errorProtoCount = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.api = MetricsInfo_NetInfo_ApiInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.connectionCount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validConnectionCount = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tcpInTraffic = MetricsInfo_RateInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tcpOutTraffic = MetricsInfo_RateInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.disconnectionCount = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.disconnectionDetail.push(MetricsInfo_NetInfo_DisconnectionDetailInfo.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.udpInTraffic = MetricsInfo_RateInfo.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.udpOutTraffic = MetricsInfo_RateInfo.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.latency = MetricsInfo_NetInfo_LatencyInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MetricsInfo_NetInfo {
    return {
      errorProtoCount: isSet(object.errorProtoCount) ? globalThis.Number(object.errorProtoCount) : 0,
      api: isSet(object.api) ? MetricsInfo_NetInfo_ApiInfo.fromJSON(object.api) : undefined,
      connectionCount: isSet(object.connectionCount) ? globalThis.Number(object.connectionCount) : 0,
      validConnectionCount: isSet(object.validConnectionCount) ? globalThis.Number(object.validConnectionCount) : 0,
      tcpInTraffic: isSet(object.tcpInTraffic) ? MetricsInfo_RateInfo.fromJSON(object.tcpInTraffic) : undefined,
      tcpOutTraffic: isSet(object.tcpOutTraffic) ? MetricsInfo_RateInfo.fromJSON(object.tcpOutTraffic) : undefined,
      disconnectionCount: isSet(object.disconnectionCount) ? globalThis.Number(object.disconnectionCount) : 0,
      disconnectionDetail: globalThis.Array.isArray(object?.disconnectionDetail)
        ? object.disconnectionDetail.map((e: any) => MetricsInfo_NetInfo_DisconnectionDetailInfo.fromJSON(e))
        : [],
      udpInTraffic: isSet(object.udpInTraffic) ? MetricsInfo_RateInfo.fromJSON(object.udpInTraffic) : undefined,
      udpOutTraffic: isSet(object.udpOutTraffic) ? MetricsInfo_RateInfo.fromJSON(object.udpOutTraffic) : undefined,
      latency: isSet(object.latency) ? MetricsInfo_NetInfo_LatencyInfo.fromJSON(object.latency) : undefined,
    };
  },

  toJSON(message: MetricsInfo_NetInfo): unknown {
    const obj: any = {};
    if (message.errorProtoCount !== 0) {
      obj.errorProtoCount = Math.round(message.errorProtoCount);
    }
    if (message.api !== undefined) {
      obj.api = MetricsInfo_NetInfo_ApiInfo.toJSON(message.api);
    }
    if (message.connectionCount !== 0) {
      obj.connectionCount = Math.round(message.connectionCount);
    }
    if (message.validConnectionCount !== 0) {
      obj.validConnectionCount = Math.round(message.validConnectionCount);
    }
    if (message.tcpInTraffic !== undefined) {
      obj.tcpInTraffic = MetricsInfo_RateInfo.toJSON(message.tcpInTraffic);
    }
    if (message.tcpOutTraffic !== undefined) {
      obj.tcpOutTraffic = MetricsInfo_RateInfo.toJSON(message.tcpOutTraffic);
    }
    if (message.disconnectionCount !== 0) {
      obj.disconnectionCount = Math.round(message.disconnectionCount);
    }
    if (message.disconnectionDetail?.length) {
      obj.disconnectionDetail = message.disconnectionDetail.map((e) =>
        MetricsInfo_NetInfo_DisconnectionDetailInfo.toJSON(e)
      );
    }
    if (message.udpInTraffic !== undefined) {
      obj.udpInTraffic = MetricsInfo_RateInfo.toJSON(message.udpInTraffic);
    }
    if (message.udpOutTraffic !== undefined) {
      obj.udpOutTraffic = MetricsInfo_RateInfo.toJSON(message.udpOutTraffic);
    }
    if (message.latency !== undefined) {
      obj.latency = MetricsInfo_NetInfo_LatencyInfo.toJSON(message.latency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricsInfo_NetInfo>, I>>(base?: I): MetricsInfo_NetInfo {
    return MetricsInfo_NetInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricsInfo_NetInfo>, I>>(object: I): MetricsInfo_NetInfo {
    const message = createBaseMetricsInfo_NetInfo();
    message.errorProtoCount = object.errorProtoCount ?? 0;
    message.api = (object.api !== undefined && object.api !== null)
      ? MetricsInfo_NetInfo_ApiInfo.fromPartial(object.api)
      : undefined;
    message.connectionCount = object.connectionCount ?? 0;
    message.validConnectionCount = object.validConnectionCount ?? 0;
    message.tcpInTraffic = (object.tcpInTraffic !== undefined && object.tcpInTraffic !== null)
      ? MetricsInfo_RateInfo.fromPartial(object.tcpInTraffic)
      : undefined;
    message.tcpOutTraffic = (object.tcpOutTraffic !== undefined && object.tcpOutTraffic !== null)
      ? MetricsInfo_RateInfo.fromPartial(object.tcpOutTraffic)
      : undefined;
    message.disconnectionCount = object.disconnectionCount ?? 0;
    message.disconnectionDetail =
      object.disconnectionDetail?.map((e) => MetricsInfo_NetInfo_DisconnectionDetailInfo.fromPartial(e)) || [];
    message.udpInTraffic = (object.udpInTraffic !== undefined && object.udpInTraffic !== null)
      ? MetricsInfo_RateInfo.fromPartial(object.udpInTraffic)
      : undefined;
    message.udpOutTraffic = (object.udpOutTraffic !== undefined && object.udpOutTraffic !== null)
      ? MetricsInfo_RateInfo.fromPartial(object.udpOutTraffic)
      : undefined;
    message.latency = (object.latency !== undefined && object.latency !== null)
      ? MetricsInfo_NetInfo_LatencyInfo.fromPartial(object.latency)
      : undefined;
    return message;
  },
};

function createBaseMetricsInfo_NetInfo_ApiInfo(): MetricsInfo_NetInfo_ApiInfo {
  return { qps: undefined, failQps: undefined, outTraffic: undefined, detail: [], _unknownFields: {} };
}

export const MetricsInfo_NetInfo_ApiInfo = {
  encode(message: MetricsInfo_NetInfo_ApiInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.qps !== undefined) {
      MetricsInfo_RateInfo.encode(message.qps, writer.uint32(10).fork()).ldelim();
    }
    if (message.failQps !== undefined) {
      MetricsInfo_RateInfo.encode(message.failQps, writer.uint32(18).fork()).ldelim();
    }
    if (message.outTraffic !== undefined) {
      MetricsInfo_RateInfo.encode(message.outTraffic, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.detail) {
      MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricsInfo_NetInfo_ApiInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsInfo_NetInfo_ApiInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.qps = MetricsInfo_RateInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.failQps = MetricsInfo_RateInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outTraffic = MetricsInfo_RateInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.detail.push(MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MetricsInfo_NetInfo_ApiInfo {
    return {
      qps: isSet(object.qps) ? MetricsInfo_RateInfo.fromJSON(object.qps) : undefined,
      failQps: isSet(object.failQps) ? MetricsInfo_RateInfo.fromJSON(object.failQps) : undefined,
      outTraffic: isSet(object.outTraffic) ? MetricsInfo_RateInfo.fromJSON(object.outTraffic) : undefined,
      detail: globalThis.Array.isArray(object?.detail)
        ? object.detail.map((e: any) => MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MetricsInfo_NetInfo_ApiInfo): unknown {
    const obj: any = {};
    if (message.qps !== undefined) {
      obj.qps = MetricsInfo_RateInfo.toJSON(message.qps);
    }
    if (message.failQps !== undefined) {
      obj.failQps = MetricsInfo_RateInfo.toJSON(message.failQps);
    }
    if (message.outTraffic !== undefined) {
      obj.outTraffic = MetricsInfo_RateInfo.toJSON(message.outTraffic);
    }
    if (message.detail?.length) {
      obj.detail = message.detail.map((e) => MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricsInfo_NetInfo_ApiInfo>, I>>(base?: I): MetricsInfo_NetInfo_ApiInfo {
    return MetricsInfo_NetInfo_ApiInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricsInfo_NetInfo_ApiInfo>, I>>(object: I): MetricsInfo_NetInfo_ApiInfo {
    const message = createBaseMetricsInfo_NetInfo_ApiInfo();
    message.qps = (object.qps !== undefined && object.qps !== null)
      ? MetricsInfo_RateInfo.fromPartial(object.qps)
      : undefined;
    message.failQps = (object.failQps !== undefined && object.failQps !== null)
      ? MetricsInfo_RateInfo.fromPartial(object.failQps)
      : undefined;
    message.outTraffic = (object.outTraffic !== undefined && object.outTraffic !== null)
      ? MetricsInfo_RateInfo.fromPartial(object.outTraffic)
      : undefined;
    message.detail = object.detail?.map((e) => MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMetricsInfo_NetInfo_ApiInfo_ApiDetailInfo(): MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo {
  return { name: "", qps: undefined, failQps: undefined, outTraffic: undefined, _unknownFields: {} };
}

export const MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo = {
  encode(message: MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.qps !== undefined) {
      MetricsInfo_RateInfo.encode(message.qps, writer.uint32(18).fork()).ldelim();
    }
    if (message.failQps !== undefined) {
      MetricsInfo_RateInfo.encode(message.failQps, writer.uint32(26).fork()).ldelim();
    }
    if (message.outTraffic !== undefined) {
      MetricsInfo_RateInfo.encode(message.outTraffic, writer.uint32(34).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsInfo_NetInfo_ApiInfo_ApiDetailInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.qps = MetricsInfo_RateInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.failQps = MetricsInfo_RateInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.outTraffic = MetricsInfo_RateInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      qps: isSet(object.qps) ? MetricsInfo_RateInfo.fromJSON(object.qps) : undefined,
      failQps: isSet(object.failQps) ? MetricsInfo_RateInfo.fromJSON(object.failQps) : undefined,
      outTraffic: isSet(object.outTraffic) ? MetricsInfo_RateInfo.fromJSON(object.outTraffic) : undefined,
    };
  },

  toJSON(message: MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.qps !== undefined) {
      obj.qps = MetricsInfo_RateInfo.toJSON(message.qps);
    }
    if (message.failQps !== undefined) {
      obj.failQps = MetricsInfo_RateInfo.toJSON(message.failQps);
    }
    if (message.outTraffic !== undefined) {
      obj.outTraffic = MetricsInfo_RateInfo.toJSON(message.outTraffic);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo>, I>>(
    base?: I,
  ): MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo {
    return MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo>, I>>(
    object: I,
  ): MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo {
    const message = createBaseMetricsInfo_NetInfo_ApiInfo_ApiDetailInfo();
    message.name = object.name ?? "";
    message.qps = (object.qps !== undefined && object.qps !== null)
      ? MetricsInfo_RateInfo.fromPartial(object.qps)
      : undefined;
    message.failQps = (object.failQps !== undefined && object.failQps !== null)
      ? MetricsInfo_RateInfo.fromPartial(object.failQps)
      : undefined;
    message.outTraffic = (object.outTraffic !== undefined && object.outTraffic !== null)
      ? MetricsInfo_RateInfo.fromPartial(object.outTraffic)
      : undefined;
    return message;
  },
};

function createBaseMetricsInfo_NetInfo_DisconnectionDetailInfo(): MetricsInfo_NetInfo_DisconnectionDetailInfo {
  return { reason: "", count: 0, _unknownFields: {} };
}

export const MetricsInfo_NetInfo_DisconnectionDetailInfo = {
  encode(message: MetricsInfo_NetInfo_DisconnectionDetailInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricsInfo_NetInfo_DisconnectionDetailInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsInfo_NetInfo_DisconnectionDetailInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MetricsInfo_NetInfo_DisconnectionDetailInfo {
    return {
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: MetricsInfo_NetInfo_DisconnectionDetailInfo): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricsInfo_NetInfo_DisconnectionDetailInfo>, I>>(
    base?: I,
  ): MetricsInfo_NetInfo_DisconnectionDetailInfo {
    return MetricsInfo_NetInfo_DisconnectionDetailInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricsInfo_NetInfo_DisconnectionDetailInfo>, I>>(
    object: I,
  ): MetricsInfo_NetInfo_DisconnectionDetailInfo {
    const message = createBaseMetricsInfo_NetInfo_DisconnectionDetailInfo();
    message.reason = object.reason ?? "";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseMetricsInfo_NetInfo_LatencyInfo(): MetricsInfo_NetInfo_LatencyInfo {
  return {
    top99: 0,
    top95: 0,
    top75: 0,
    totalCount: 0,
    delay1S: 0,
    delay2S: 0,
    delay3S: 0,
    detail: [],
    _unknownFields: {},
  };
}

export const MetricsInfo_NetInfo_LatencyInfo = {
  encode(message: MetricsInfo_NetInfo_LatencyInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.top99 !== 0) {
      writer.uint32(8).int32(message.top99);
    }
    if (message.top95 !== 0) {
      writer.uint32(16).int32(message.top95);
    }
    if (message.top75 !== 0) {
      writer.uint32(24).int32(message.top75);
    }
    if (message.totalCount !== 0) {
      writer.uint32(32).int32(message.totalCount);
    }
    if (message.delay1S !== 0) {
      writer.uint32(40).int32(message.delay1S);
    }
    if (message.delay2S !== 0) {
      writer.uint32(48).int32(message.delay2S);
    }
    if (message.delay3S !== 0) {
      writer.uint32(56).int32(message.delay3S);
    }
    for (const v of message.detail) {
      MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricsInfo_NetInfo_LatencyInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsInfo_NetInfo_LatencyInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.top99 = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.top95 = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.top75 = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.delay1S = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.delay2S = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.delay3S = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.detail.push(MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MetricsInfo_NetInfo_LatencyInfo {
    return {
      top99: isSet(object.top99) ? globalThis.Number(object.top99) : 0,
      top95: isSet(object.top95) ? globalThis.Number(object.top95) : 0,
      top75: isSet(object.top75) ? globalThis.Number(object.top75) : 0,
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      delay1S: isSet(object.delay1S) ? globalThis.Number(object.delay1S) : 0,
      delay2S: isSet(object.delay2S) ? globalThis.Number(object.delay2S) : 0,
      delay3S: isSet(object.delay3S) ? globalThis.Number(object.delay3S) : 0,
      detail: globalThis.Array.isArray(object?.detail)
        ? object.detail.map((e: any) => MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MetricsInfo_NetInfo_LatencyInfo): unknown {
    const obj: any = {};
    if (message.top99 !== 0) {
      obj.top99 = Math.round(message.top99);
    }
    if (message.top95 !== 0) {
      obj.top95 = Math.round(message.top95);
    }
    if (message.top75 !== 0) {
      obj.top75 = Math.round(message.top75);
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.delay1S !== 0) {
      obj.delay1S = Math.round(message.delay1S);
    }
    if (message.delay2S !== 0) {
      obj.delay2S = Math.round(message.delay2S);
    }
    if (message.delay3S !== 0) {
      obj.delay3S = Math.round(message.delay3S);
    }
    if (message.detail?.length) {
      obj.detail = message.detail.map((e) => MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricsInfo_NetInfo_LatencyInfo>, I>>(base?: I): MetricsInfo_NetInfo_LatencyInfo {
    return MetricsInfo_NetInfo_LatencyInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricsInfo_NetInfo_LatencyInfo>, I>>(
    object: I,
  ): MetricsInfo_NetInfo_LatencyInfo {
    const message = createBaseMetricsInfo_NetInfo_LatencyInfo();
    message.top99 = object.top99 ?? 0;
    message.top95 = object.top95 ?? 0;
    message.top75 = object.top75 ?? 0;
    message.totalCount = object.totalCount ?? 0;
    message.delay1S = object.delay1S ?? 0;
    message.delay2S = object.delay2S ?? 0;
    message.delay3S = object.delay3S ?? 0;
    message.detail = object.detail?.map((e) => MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo(): MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo {
  return {
    witness: "",
    top99: 0,
    top95: 0,
    top75: 0,
    count: 0,
    delay1S: 0,
    delay2S: 0,
    delay3S: 0,
    _unknownFields: {},
  };
}

export const MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo = {
  encode(
    message: MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.witness !== "") {
      writer.uint32(10).string(message.witness);
    }
    if (message.top99 !== 0) {
      writer.uint32(16).int32(message.top99);
    }
    if (message.top95 !== 0) {
      writer.uint32(24).int32(message.top95);
    }
    if (message.top75 !== 0) {
      writer.uint32(32).int32(message.top75);
    }
    if (message.count !== 0) {
      writer.uint32(40).int32(message.count);
    }
    if (message.delay1S !== 0) {
      writer.uint32(48).int32(message.delay1S);
    }
    if (message.delay2S !== 0) {
      writer.uint32(56).int32(message.delay2S);
    }
    if (message.delay3S !== 0) {
      writer.uint32(64).int32(message.delay3S);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.witness = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.top99 = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.top95 = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.top75 = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.count = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.delay1S = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.delay2S = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.delay3S = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo {
    return {
      witness: isSet(object.witness) ? globalThis.String(object.witness) : "",
      top99: isSet(object.top99) ? globalThis.Number(object.top99) : 0,
      top95: isSet(object.top95) ? globalThis.Number(object.top95) : 0,
      top75: isSet(object.top75) ? globalThis.Number(object.top75) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      delay1S: isSet(object.delay1S) ? globalThis.Number(object.delay1S) : 0,
      delay2S: isSet(object.delay2S) ? globalThis.Number(object.delay2S) : 0,
      delay3S: isSet(object.delay3S) ? globalThis.Number(object.delay3S) : 0,
    };
  },

  toJSON(message: MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo): unknown {
    const obj: any = {};
    if (message.witness !== "") {
      obj.witness = message.witness;
    }
    if (message.top99 !== 0) {
      obj.top99 = Math.round(message.top99);
    }
    if (message.top95 !== 0) {
      obj.top95 = Math.round(message.top95);
    }
    if (message.top75 !== 0) {
      obj.top75 = Math.round(message.top75);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.delay1S !== 0) {
      obj.delay1S = Math.round(message.delay1S);
    }
    if (message.delay2S !== 0) {
      obj.delay2S = Math.round(message.delay2S);
    }
    if (message.delay3S !== 0) {
      obj.delay3S = Math.round(message.delay3S);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo>, I>>(
    base?: I,
  ): MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo {
    return MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo>, I>>(
    object: I,
  ): MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo {
    const message = createBaseMetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo();
    message.witness = object.witness ?? "";
    message.top99 = object.top99 ?? 0;
    message.top95 = object.top95 ?? 0;
    message.top75 = object.top75 ?? 0;
    message.count = object.count ?? 0;
    message.delay1S = object.delay1S ?? 0;
    message.delay2S = object.delay2S ?? 0;
    message.delay3S = object.delay3S ?? 0;
    return message;
  },
};

function createBasePBFTMessage(): PBFTMessage {
  return { rawData: undefined, signature: Buffer.alloc(0), _unknownFields: {} };
}

export const PBFTMessage = {
  encode(message: PBFTMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rawData !== undefined) {
      PBFTMessage_Raw.encode(message.rawData, writer.uint32(10).fork()).ldelim();
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PBFTMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePBFTMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rawData = PBFTMessage_Raw.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): PBFTMessage {
    return {
      rawData: isSet(object.rawData) ? PBFTMessage_Raw.fromJSON(object.rawData) : undefined,
      signature: isSet(object.signature) ? Buffer.from(bytesFromBase64(object.signature)) : Buffer.alloc(0),
    };
  },

  toJSON(message: PBFTMessage): unknown {
    const obj: any = {};
    if (message.rawData !== undefined) {
      obj.rawData = PBFTMessage_Raw.toJSON(message.rawData);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PBFTMessage>, I>>(base?: I): PBFTMessage {
    return PBFTMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PBFTMessage>, I>>(object: I): PBFTMessage {
    const message = createBasePBFTMessage();
    message.rawData = (object.rawData !== undefined && object.rawData !== null)
      ? PBFTMessage_Raw.fromPartial(object.rawData)
      : undefined;
    message.signature = object.signature ?? Buffer.alloc(0);
    return message;
  },
};

function createBasePBFTMessage_Raw(): PBFTMessage_Raw {
  return { msgType: 0, dataType: 0, viewN: Long.ZERO, epoch: Long.ZERO, data: Buffer.alloc(0), _unknownFields: {} };
}

export const PBFTMessage_Raw = {
  encode(message: PBFTMessage_Raw, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.msgType !== 0) {
      writer.uint32(8).int32(message.msgType);
    }
    if (message.dataType !== 0) {
      writer.uint32(16).int32(message.dataType);
    }
    if (!message.viewN.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.viewN);
    }
    if (!message.epoch.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.epoch);
    }
    if (message.data.length !== 0) {
      writer.uint32(42).bytes(message.data);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PBFTMessage_Raw {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePBFTMessage_Raw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.msgType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.viewN = reader.int64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.epoch = reader.int64() as Long;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): PBFTMessage_Raw {
    return {
      msgType: isSet(object.msgType) ? pBFTMessage_MsgTypeFromJSON(object.msgType) : 0,
      dataType: isSet(object.dataType) ? pBFTMessage_DataTypeFromJSON(object.dataType) : 0,
      viewN: isSet(object.viewN) ? Long.fromValue(object.viewN) : Long.ZERO,
      epoch: isSet(object.epoch) ? Long.fromValue(object.epoch) : Long.ZERO,
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
    };
  },

  toJSON(message: PBFTMessage_Raw): unknown {
    const obj: any = {};
    if (message.msgType !== 0) {
      obj.msgType = pBFTMessage_MsgTypeToJSON(message.msgType);
    }
    if (message.dataType !== 0) {
      obj.dataType = pBFTMessage_DataTypeToJSON(message.dataType);
    }
    if (!message.viewN.equals(Long.ZERO)) {
      obj.viewN = (message.viewN || Long.ZERO).toString();
    }
    if (!message.epoch.equals(Long.ZERO)) {
      obj.epoch = (message.epoch || Long.ZERO).toString();
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PBFTMessage_Raw>, I>>(base?: I): PBFTMessage_Raw {
    return PBFTMessage_Raw.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PBFTMessage_Raw>, I>>(object: I): PBFTMessage_Raw {
    const message = createBasePBFTMessage_Raw();
    message.msgType = object.msgType ?? 0;
    message.dataType = object.dataType ?? 0;
    message.viewN = (object.viewN !== undefined && object.viewN !== null) ? Long.fromValue(object.viewN) : Long.ZERO;
    message.epoch = (object.epoch !== undefined && object.epoch !== null) ? Long.fromValue(object.epoch) : Long.ZERO;
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBasePBFTCommitResult(): PBFTCommitResult {
  return { data: Buffer.alloc(0), signature: [], _unknownFields: {} };
}

export const PBFTCommitResult = {
  encode(message: PBFTCommitResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    for (const v of message.signature) {
      writer.uint32(18).bytes(v!);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PBFTCommitResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePBFTCommitResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature.push(reader.bytes() as Buffer);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): PBFTCommitResult {
    return {
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      signature: globalThis.Array.isArray(object?.signature)
        ? object.signature.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
    };
  },

  toJSON(message: PBFTCommitResult): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.signature?.length) {
      obj.signature = message.signature.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PBFTCommitResult>, I>>(base?: I): PBFTCommitResult {
    return PBFTCommitResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PBFTCommitResult>, I>>(object: I): PBFTCommitResult {
    const message = createBasePBFTCommitResult();
    message.data = object.data ?? Buffer.alloc(0);
    message.signature = object.signature?.map((e) => e) || [];
    return message;
  },
};

function createBaseSRL(): SRL {
  return { srAddress: [], _unknownFields: {} };
}

export const SRL = {
  encode(message: SRL, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.srAddress) {
      writer.uint32(10).bytes(v!);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag);
          (writer as any)["_push"](
            (val: Uint8Array, buf: Buffer, pos: number) => buf.set(val, pos),
            value.length,
            value,
          );
        }
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SRL {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSRL();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.srAddress.push(reader.bytes() as Buffer);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const startPos = reader.pos;
      reader.skipType(tag & 7);
      const buf = reader.buf.slice(startPos, reader.pos);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): SRL {
    return {
      srAddress: globalThis.Array.isArray(object?.srAddress)
        ? object.srAddress.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
    };
  },

  toJSON(message: SRL): unknown {
    const obj: any = {};
    if (message.srAddress?.length) {
      obj.srAddress = message.srAddress.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SRL>, I>>(base?: I): SRL {
    return SRL.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SRL>, I>>(object: I): SRL {
    const message = createBaseSRL();
    message.srAddress = object.srAddress?.map((e) => e) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
