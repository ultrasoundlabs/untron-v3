// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: core/Discover.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";

export const protobufPackage = "protocol";

export interface Endpoint {
  address: Buffer;
  port: number;
  nodeId: Buffer;
  addressIpv6: Buffer;
}

export interface PingMessage {
  from: Endpoint | undefined;
  to: Endpoint | undefined;
  version: number;
  timestamp: Long;
}

export interface PongMessage {
  from: Endpoint | undefined;
  echo: number;
  timestamp: Long;
}

export interface FindNeighbours {
  from: Endpoint | undefined;
  targetId: Buffer;
  timestamp: Long;
}

export interface Neighbours {
  from: Endpoint | undefined;
  neighbours: Endpoint[];
  timestamp: Long;
}

export interface BackupMessage {
  flag: boolean;
  priority: number;
}

function createBaseEndpoint(): Endpoint {
  return { address: Buffer.alloc(0), port: 0, nodeId: Buffer.alloc(0), addressIpv6: Buffer.alloc(0) };
}

export const Endpoint = {
  encode(message: Endpoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    if (message.nodeId.length !== 0) {
      writer.uint32(26).bytes(message.nodeId);
    }
    if (message.addressIpv6.length !== 0) {
      writer.uint32(34).bytes(message.addressIpv6);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Endpoint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes() as Buffer;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nodeId = reader.bytes() as Buffer;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.addressIpv6 = reader.bytes() as Buffer;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Endpoint {
    return {
      address: isSet(object.address) ? Buffer.from(bytesFromBase64(object.address)) : Buffer.alloc(0),
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      nodeId: isSet(object.nodeId) ? Buffer.from(bytesFromBase64(object.nodeId)) : Buffer.alloc(0),
      addressIpv6: isSet(object.addressIpv6) ? Buffer.from(bytesFromBase64(object.addressIpv6)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Endpoint): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.nodeId.length !== 0) {
      obj.nodeId = base64FromBytes(message.nodeId);
    }
    if (message.addressIpv6.length !== 0) {
      obj.addressIpv6 = base64FromBytes(message.addressIpv6);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Endpoint>, I>>(base?: I): Endpoint {
    return Endpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Endpoint>, I>>(object: I): Endpoint {
    const message = createBaseEndpoint();
    message.address = object.address ?? Buffer.alloc(0);
    message.port = object.port ?? 0;
    message.nodeId = object.nodeId ?? Buffer.alloc(0);
    message.addressIpv6 = object.addressIpv6 ?? Buffer.alloc(0);
    return message;
  },
};

function createBasePingMessage(): PingMessage {
  return { from: undefined, to: undefined, version: 0, timestamp: Long.ZERO };
}

export const PingMessage = {
  encode(message: PingMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Endpoint.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Endpoint.encode(message.to, writer.uint32(18).fork()).ldelim();
    }
    if (message.version !== 0) {
      writer.uint32(24).int32(message.version);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PingMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Endpoint.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = Endpoint.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PingMessage {
    return {
      from: isSet(object.from) ? Endpoint.fromJSON(object.from) : undefined,
      to: isSet(object.to) ? Endpoint.fromJSON(object.to) : undefined,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
    };
  },

  toJSON(message: PingMessage): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Endpoint.toJSON(message.from);
    }
    if (message.to !== undefined) {
      obj.to = Endpoint.toJSON(message.to);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PingMessage>, I>>(base?: I): PingMessage {
    return PingMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PingMessage>, I>>(object: I): PingMessage {
    const message = createBasePingMessage();
    message.from = (object.from !== undefined && object.from !== null) ? Endpoint.fromPartial(object.from) : undefined;
    message.to = (object.to !== undefined && object.to !== null) ? Endpoint.fromPartial(object.to) : undefined;
    message.version = object.version ?? 0;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    return message;
  },
};

function createBasePongMessage(): PongMessage {
  return { from: undefined, echo: 0, timestamp: Long.ZERO };
}

export const PongMessage = {
  encode(message: PongMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Endpoint.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.echo !== 0) {
      writer.uint32(16).int32(message.echo);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PongMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePongMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Endpoint.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.echo = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PongMessage {
    return {
      from: isSet(object.from) ? Endpoint.fromJSON(object.from) : undefined,
      echo: isSet(object.echo) ? globalThis.Number(object.echo) : 0,
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
    };
  },

  toJSON(message: PongMessage): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Endpoint.toJSON(message.from);
    }
    if (message.echo !== 0) {
      obj.echo = Math.round(message.echo);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PongMessage>, I>>(base?: I): PongMessage {
    return PongMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PongMessage>, I>>(object: I): PongMessage {
    const message = createBasePongMessage();
    message.from = (object.from !== undefined && object.from !== null) ? Endpoint.fromPartial(object.from) : undefined;
    message.echo = object.echo ?? 0;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    return message;
  },
};

function createBaseFindNeighbours(): FindNeighbours {
  return { from: undefined, targetId: Buffer.alloc(0), timestamp: Long.ZERO };
}

export const FindNeighbours = {
  encode(message: FindNeighbours, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Endpoint.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    if (message.targetId.length !== 0) {
      writer.uint32(18).bytes(message.targetId);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FindNeighbours {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindNeighbours();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Endpoint.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetId = reader.bytes() as Buffer;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindNeighbours {
    return {
      from: isSet(object.from) ? Endpoint.fromJSON(object.from) : undefined,
      targetId: isSet(object.targetId) ? Buffer.from(bytesFromBase64(object.targetId)) : Buffer.alloc(0),
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
    };
  },

  toJSON(message: FindNeighbours): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Endpoint.toJSON(message.from);
    }
    if (message.targetId.length !== 0) {
      obj.targetId = base64FromBytes(message.targetId);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindNeighbours>, I>>(base?: I): FindNeighbours {
    return FindNeighbours.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindNeighbours>, I>>(object: I): FindNeighbours {
    const message = createBaseFindNeighbours();
    message.from = (object.from !== undefined && object.from !== null) ? Endpoint.fromPartial(object.from) : undefined;
    message.targetId = object.targetId ?? Buffer.alloc(0);
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    return message;
  },
};

function createBaseNeighbours(): Neighbours {
  return { from: undefined, neighbours: [], timestamp: Long.ZERO };
}

export const Neighbours = {
  encode(message: Neighbours, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Endpoint.encode(message.from, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.neighbours) {
      Endpoint.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Neighbours {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNeighbours();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = Endpoint.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.neighbours.push(Endpoint.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp = reader.int64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Neighbours {
    return {
      from: isSet(object.from) ? Endpoint.fromJSON(object.from) : undefined,
      neighbours: globalThis.Array.isArray(object?.neighbours)
        ? object.neighbours.map((e: any) => Endpoint.fromJSON(e))
        : [],
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
    };
  },

  toJSON(message: Neighbours): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = Endpoint.toJSON(message.from);
    }
    if (message.neighbours?.length) {
      obj.neighbours = message.neighbours.map((e) => Endpoint.toJSON(e));
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Neighbours>, I>>(base?: I): Neighbours {
    return Neighbours.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Neighbours>, I>>(object: I): Neighbours {
    const message = createBaseNeighbours();
    message.from = (object.from !== undefined && object.from !== null) ? Endpoint.fromPartial(object.from) : undefined;
    message.neighbours = object.neighbours?.map((e) => Endpoint.fromPartial(e)) || [];
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    return message;
  },
};

function createBaseBackupMessage(): BackupMessage {
  return { flag: false, priority: 0 };
}

export const BackupMessage = {
  encode(message: BackupMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.flag !== false) {
      writer.uint32(8).bool(message.flag);
    }
    if (message.priority !== 0) {
      writer.uint32(16).int32(message.priority);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BackupMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.flag = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.priority = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupMessage {
    return {
      flag: isSet(object.flag) ? globalThis.Boolean(object.flag) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
    };
  },

  toJSON(message: BackupMessage): unknown {
    const obj: any = {};
    if (message.flag !== false) {
      obj.flag = message.flag;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BackupMessage>, I>>(base?: I): BackupMessage {
    return BackupMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BackupMessage>, I>>(object: I): BackupMessage {
    const message = createBaseBackupMessage();
    message.flag = object.flag ?? false;
    message.priority = object.priority ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
