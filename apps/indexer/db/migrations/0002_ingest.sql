/*
Ingestion layer written by the worker.

Core invariants:
-- chain.event_appended stores the canonical total order via
--   EventAppended(event_seq).
- reorgs are represented by flipping canonical=false (never deleting rows).
- projection tables are derived deterministically from canonical rows.

Also introduces chain.instance to enforce:
- one DB indexes exactly one deployment instance per stream
- the DB rejects "wrong chain / wrong contract" ingestion bugs
*/

-- =========================
-- INSTANCE CONFIG (one deployment per stream)
-- =========================
create table if not exists chain.instance (
    stream chain.stream primary key,

    -- numeric chain_id
    chain_id bigint not null,

    -- deployed index contract address for that stream
    contract_address chain_address not null,

    -- EventChainGenesis constant for that contract
    genesis_tip bytes32_hex not null,

    constraint instance_stream_chain_contract_unique
    -- UNIQUE required for composite FKs.
    -- (Stream PK still enforces one row per stream.)
    unique (stream, chain_id, contract_address)
);

alter table chain.instance
add constraint instance_contract_address_format_matches_stream
check (
    (stream = 'hub' and contract_address ~ '^0x[0-9a-fA-F]{40}$')
    or (
        stream = 'controller'
        and contract_address ~ '^T[1-9A-HJ-NP-Za-km-z]{33}$'
    )
);

-- =========================
-- CANONICAL EVENT STREAM: EventAppended logs
-- =========================
create table if not exists chain.event_appended (
    id bigint generated by default as identity primary key,

    -- "hub" or "controller"
    stream chain.stream not null,

    -- must match chain.instance for the given stream
    chain_id bigint not null,
    contract_address chain_address not null,

    block_number bigint not null,
    block_timestamp bigint not null,
    block_hash bytes32_hex not null,

    tx_hash txhash_hex not null,
    log_index integer not null,

    -- canonicality for reorg handling:
    -- worker flips canonical=false on removed fork logs
    canonical boolean not null default true,

    -- hash-chain payload from EventAppended
    event_seq bigint not null,
    prev_tip bytes32_hex not null,
    new_tip bytes32_hex not null,
    event_signature bytes32_hex not null,

    -- EXACT ABI bytes blob used in the onchain hash chain (hex string)
    abi_encoded_event_data bytes_hex not null,

    -- worker-decoded "semantic event"
    event_type text not null,   -- e.g. 'LeaseCreated'
    -- snake_case keys, values as strings/hex
    args jsonb not null default '{}'::jsonb,

    inserted_at timestamptz not null default now(),

    constraint event_appended_instance_fk
    foreign key (stream, chain_id, contract_address)
    references chain.instance (stream, chain_id, contract_address),

    constraint event_appended_timestamp_seconds_range
    check (block_timestamp >= 946684800 and block_timestamp < 20000000000),

    constraint event_appended_nonnegative
    check (
        block_number >= 0
        and block_timestamp >= 0
        and log_index >= 0
        and event_seq > 0
    )
);

alter table chain.event_appended
add constraint event_appended_contract_address_format_matches_stream
check (
    (stream = 'hub' and contract_address ~ '^0x[0-9a-fA-F]{40}$')
    or (
        stream = 'controller'
        and contract_address ~ '^T[1-9A-HJ-NP-Za-km-z]{33}$'
    )
);

-- idempotency: chain log identity
create unique index if not exists event_appended_uid
on chain.event_appended (chain_id, tx_hash, log_index);

-- at most one canonical event at a given seq per stream
create unique index if not exists event_appended_canonical_seq
on chain.event_appended (stream, event_seq)
where canonical;

-- projector scan index
create index if not exists event_appended_scan
on chain.event_appended (stream, canonical, event_seq);

-- API query patterns
create index if not exists event_appended_canonical_block
on chain.event_appended (stream, block_number desc, log_index desc)
where canonical;

create index if not exists event_appended_canonical_time
on chain.event_appended (stream, block_timestamp desc, event_seq desc)
where canonical;

-- =========================
-- CONTROLLER NON-CHAINED EVENT: IsEventChainTipCalled
-- =========================
/*
This event is intentionally NOT appended to the controller hash chain.
We store it separately as a "proof-carrying" log.
*/
create table if not exists chain.controller_tip_proofs (
    id bigint generated by default as identity primary key,

    -- always controller; stored so we can FK to chain.instance without triggers
    stream chain.stream not null default 'controller',

    chain_id bigint not null,
    contract_address chain_address not null,

    block_number bigint not null,
    block_timestamp bigint not null,
    block_hash bytes32_hex not null,

    tx_hash txhash_hex not null,
    log_index integer not null,

    canonical boolean not null default true,

    caller tron_address not null,
    proved_tip bytes32_hex not null,

    inserted_at timestamptz not null default now(),

    constraint controller_tip_proofs_stream_controller
    check (stream = 'controller'),

    constraint controller_tip_proofs_contract_address_format_tron
    check (contract_address ~ '^T[1-9A-HJ-NP-Za-km-z]{33}$'),

    constraint controller_tip_proofs_instance_fk
    foreign key (stream, chain_id, contract_address)
    references chain.instance (stream, chain_id, contract_address),

    constraint controller_tip_proofs_timestamp_seconds_range
    check (block_timestamp >= 946684800 and block_timestamp < 20000000000),

    constraint controller_tip_proofs_nonnegative
    check (block_number >= 0 and block_timestamp >= 0 and log_index >= 0)
);

create unique index if not exists controller_tip_proofs_uid
on chain.controller_tip_proofs (chain_id, tx_hash, log_index);

-- =========================
-- STREAM CURSORS (projection state machine)
-- =========================
/*
applied_through_seq:
- highest canonical event_seq already applied to projections

tip:
- expected prev_tip for the next event (event_seq = applied_through_seq + 1)
*/
create table if not exists chain.stream_cursor (
    stream chain.stream primary key,
    applied_through_seq bigint not null default 0,
    tip bytes32_hex not null,
    updated_at timestamptz not null default now(),

    constraint stream_cursor_instance_fk
    foreign key (stream)
    references chain.instance (stream),

    constraint stream_cursor_nonnegative
    check (applied_through_seq >= 0)
);

-- Seed + configure must happen explicitly so ingestion fails loudly until set.
create or replace function chain.configure_instance(
    p_stream chain.stream,
    p_chain_id bigint,
    p_contract_address chain_address,
    p_genesis_tip bytes32_hex
) returns void language plpgsql as $$
declare
  cur_applied bigint;
begin
  if p_chain_id <= 0 then
    raise exception 'chain_id must be > 0 (got %)', p_chain_id;
  end if;

  select applied_through_seq
    into cur_applied
    from chain.stream_cursor
   where stream = p_stream
   for update;

  if found and cur_applied <> 0 then
    raise exception 'cannot reconfigure stream %, already applied through seq %', p_stream, cur_applied;
  end if;

  insert into chain.instance(stream, chain_id, contract_address, genesis_tip)
  values (p_stream, p_chain_id, p_contract_address, p_genesis_tip)
  on conflict (stream) do update
    set chain_id = excluded.chain_id,
        contract_address = excluded.contract_address,
        genesis_tip = excluded.genesis_tip;

  insert into chain.stream_cursor(stream, applied_through_seq, tip)
  values (p_stream, 0, p_genesis_tip)
  on conflict (stream) do update
    set applied_through_seq = 0,
        tip = excluded.tip,
        updated_at = now();
end $$;

-- =============================================================================
-- POSTGREST / OPENAPI DOC COMMENTS (INGESTION LAYER)
-- =============================================================================

-- chain.instance
comment on table chain.instance is
$$Indexer configuration: one deployment instance per stream

The Untron indexer stores two independent event hash-chains:
- `hub` stream:      EVM-side `UntronV3Index` (UntronV3 hub emits events via this index contract)
- `controller` stream: Tron-side `UntronControllerIndex` (controller emits sweeps/rebalance events)

This table pins the database to a single deployment per stream to prevent accidental ingestion of
events from the wrong chain or wrong contract address.$$;

comment on column chain.instance.stream is
$$Stream identifier (`hub` or `controller`)

Determines which onchain index contract this row configures.$$;

comment on column chain.instance.chain_id is
$$Chain identifier for this stream

- For `hub`, this is the EVM `chainId` where `UntronV3Index` is deployed.
- For `controller`, this is the Tron network id as configured by the ingestion worker.

The DB does not attempt to interpret chain IDs beyond enforcing consistency.$$;

comment on column chain.instance.contract_address is
$$Deployed index contract address for this stream

- `hub`: EVM 0x-address of `UntronV3Index`
- `controller`: Tron base58 address of `UntronControllerIndex`

Format is validated by a CHECK constraint keyed on `stream`.$$;

comment on column chain.instance.genesis_tip is
$$Genesis hash-chain tip for this stream

Matches the `EventChainGenesis.*` constant used by the onchain index contract.
The projector starts at this tip and requires every ingested event to hash-link correctly.$$;

-- chain.event_appended
comment on table chain.event_appended is
$$Canonical onchain event stream: EventAppended logs (hash-chained)

Both Untron index contracts (`UntronV3Index` and `UntronControllerIndex`) emit a uniform event:

  EventAppended(event_seq, prev_tip, new_tip, event_signature, abi_encoded_event_data)

This table stores each observed EventAppended log along with its originating chain metadata.
It is the SINGLE source of truth for projections.

Reorg model:
- We never delete rows.
- The ingestion worker flips `canonical=false` for logs that were removed by a reorg.
- Projection tables are rolled back and re-applied from the earliest affected `event_seq`.$$;

comment on column chain.event_appended.id is
$$Synthetic primary key for internal use

Not part of any onchain identity; reorgs are modeled via `canonical` flags, not deletes.$$;

comment on column chain.event_appended.stream is
$$Which event hash-chain produced this log (`hub` or `controller`)$$;

comment on column chain.event_appended.chain_id is
$$Chain identifier for this log

Must match `chain.instance.chain_id` for the row's stream.$$;

comment on column chain.event_appended.contract_address is
$$Index contract address that emitted the EventAppended log

Must match `chain.instance.contract_address` for the row's stream.$$;

comment on column chain.event_appended.block_number is
$$Block number containing the onchain EventAppended log$$;

comment on column chain.event_appended.block_timestamp is
$$Block timestamp (seconds since epoch) for the log's block$$;

comment on column chain.event_appended.block_hash is
$$Block hash (bytes32 hex) for the log's block$$;

comment on column chain.event_appended.tx_hash is
$$Transaction hash (bytes32 hex) for the transaction containing the log$$;

comment on column chain.event_appended.log_index is
$$Log index within the transaction receipt (0-based)

Together with `(chain_id, tx_hash, log_index)` uniquely identifies a log.$$;

comment on column chain.event_appended.canonical is
$$Reorg flag: true if this log is currently canonical

The worker toggles this to false when a log is removed by a reorg. Projections treat
non-canonical rows as nonexistent.$$;

comment on column chain.event_appended.event_seq is
$$Monotonic event sequence number in the onchain hash-chain

This defines the canonical total order for projection. The DB enforces at most one canonical
row per `(stream, event_seq)`.$$;

comment on column chain.event_appended.prev_tip is
$$Previous hash-chain tip that this event links from$$;

comment on column chain.event_appended.new_tip is
$$New hash-chain tip after applying this event onchain$$;

comment on column chain.event_appended.event_signature is
$$Keccak256 hash (bytes32) of the *semantic event* signature

Example (hub): `keccak256("LeaseCreated(uint256,bytes32,uint256,address,address,uint64,uint64,uint32,uint64)")`

This is the signature that the onchain index contract hashed into its `eventChainTip`.$$;

comment on column chain.event_appended.abi_encoded_event_data is
$$Exact ABI-encoded event data bytes that were hashed onchain

This MUST match byte-for-byte the `abiEncodedEventData` passed to the onchain hash-chain logic.
We store it to allow deterministic recomputation/verification of the onchain tips.$$;

comment on column chain.event_appended.event_type is
$$Worker-decoded semantic event name

Examples: `LeaseCreated`, `ClaimCreated`, `PulledFromReceiver`.

Projection functions (`hub.apply_one`, `ctl.apply_one`) interpret this string to update derived state.$$;

comment on column chain.event_appended.args is
$$Worker-decoded event arguments as JSON

Keys are snake_case strings; values are stored as strings/hex and cast inside projector functions.
Projectors use `chain.require_json_keys` to validate required fields.$$;

comment on column chain.event_appended.inserted_at is
$$Ingestion timestamp (when this row was written by the worker)$$;

-- chain.controller_tip_proofs
comment on table chain.controller_tip_proofs is
$$Controller "tip proof" logs (NOT hash-chained)

`UntronControllerIndex.isEventChainTip(bytes32)` emits an `IsEventChainTipCalled` event on Tron,
but (by design) it is NOT appended into the controller event hash-chain.

These logs serve as proof-carrying transactions that an onchain call asserted a given `eventChainTip`.
The EVM hub uses proven Tron transactions of this call to accept controller event sequences.$$;

comment on column chain.controller_tip_proofs.caller is
$$Tron address that called `isEventChainTip`$$;

comment on column chain.controller_tip_proofs.proved_tip is
$$The hash-chain tip that the caller asserted equals the controller's current
tip$$;

-- chain.stream_cursor
comment on table chain.stream_cursor is
$$Projection cursor per stream

Tracks how far the DB projections have been deterministically derived from canonical `chain.event_appended` rows.

Fields:
- `applied_through_seq`: highest contiguous event_seq that has been applied
- `tip`: expected `prev_tip` of the next event (event_seq = applied_through_seq + 1)

The `hub.apply_catchup` / `ctl.apply_catchup` functions enforce tip continuity and apply events in order.$$;

comment on column chain.stream_cursor.applied_through_seq is
$$Highest contiguous canonical `event_seq` already applied to projections$$;

comment on column chain.stream_cursor.tip is
$$Expected previous tip for the next event to apply

If `applied_through_seq = 0`, this equals `chain.instance.genesis_tip`.$$;

comment on column chain.stream_cursor.updated_at is
$$Timestamp when the projector last advanced or rolled back this cursor$$;

-- chain.configure_instance
comment on function chain.configure_instance(
    chain.stream, bigint, public.chain_address, public.bytes32_hex
) is
$$Configure a stream deployment and initialize its projection cursor

This is an explicit setup step: ingestion/projection should fail loudly until `chain.instance` and
`chain.stream_cursor` are configured, to avoid silently indexing the wrong contract or chain.

Typical use:
- call once for `hub` with the EVM chain id, UntronV3Index address, and genesis tip
- call once for `controller` with the Tron chain id, UntronControllerIndex address, and genesis tip$$;
