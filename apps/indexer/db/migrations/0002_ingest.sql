/*
Ingestion layer written by the worker.

Core invariants:
-- chain.event_appended stores the canonical total order via
--   EventAppended(event_seq).
- reorgs are represented by flipping canonical=false (never deleting rows).
- projection tables are derived deterministically from canonical rows.

Also introduces chain.instance to enforce:
- one DB indexes exactly one deployment instance per stream
- the DB rejects "wrong chain / wrong contract" ingestion bugs
*/

-- =========================
-- INSTANCE CONFIG (one deployment per stream)
-- =========================
create table if not exists chain.instance (
    stream chain.stream primary key,

    -- numeric chain_id
    chain_id bigint not null,

    -- deployed index contract address for that stream
    contract_address evm_address not null,

    -- EventChainGenesis constant for that contract
    genesis_tip bytes32_hex not null,

    constraint instance_stream_chain_contract_unique
    -- UNIQUE required for composite FKs.
    -- (Stream PK still enforces one row per stream.)
    unique (stream, chain_id, contract_address)
);

-- =========================
-- CANONICAL EVENT STREAM: EventAppended logs
-- =========================
create table if not exists chain.event_appended (
    id bigint generated by default as identity primary key,

    -- "hub" or "controller"
    stream chain.stream not null,

    -- must match chain.instance for the given stream
    chain_id bigint not null,
    contract_address evm_address not null,

    block_number bigint not null,
    block_timestamp bigint not null,
    block_hash bytes32_hex not null,

    tx_hash txhash_hex not null,
    log_index integer not null,

    -- canonicality for reorg handling:
    -- worker flips canonical=false on removed fork logs
    canonical boolean not null default true,

    -- hash-chain payload from EventAppended
    event_seq bigint not null,
    prev_tip bytes32_hex not null,
    new_tip bytes32_hex not null,
    event_signature bytes32_hex not null,

    -- EXACT ABI bytes blob used in the onchain hash chain (hex string)
    abi_encoded_event_data bytes_hex not null,

    -- worker-decoded "semantic event"
    event_type text not null,   -- e.g. 'LeaseCreated'
    -- snake_case keys, values as strings/hex
    args jsonb not null default '{}'::jsonb,

    inserted_at timestamptz not null default now(),

    constraint event_appended_instance_fk
    foreign key (stream, chain_id, contract_address)
    references chain.instance (stream, chain_id, contract_address),

    constraint event_appended_timestamp_seconds_range
    check (block_timestamp >= 946684800 and block_timestamp < 20000000000),

    constraint event_appended_nonnegative
    check (
        block_number >= 0
        and block_timestamp >= 0
        and log_index >= 0
        and event_seq > 0
    )
);

-- idempotency: chain log identity
create unique index if not exists event_appended_uid
on chain.event_appended (chain_id, tx_hash, log_index);

-- at most one canonical event at a given seq per stream
create unique index if not exists event_appended_canonical_seq
on chain.event_appended (stream, event_seq)
where canonical;

-- projector scan index
create index if not exists event_appended_scan
on chain.event_appended (stream, canonical, event_seq);

-- API query patterns
create index if not exists event_appended_canonical_block
on chain.event_appended (stream, block_number desc, log_index desc)
where canonical;

create index if not exists event_appended_canonical_time
on chain.event_appended (stream, block_timestamp desc, event_seq desc)
where canonical;

-- =========================
-- CONTROLLER NON-CHAINED EVENT: IsEventChainTipCalled
-- =========================
/*
This event is intentionally NOT appended to the controller hash chain.
We store it separately as a "proof-carrying" log.
*/
create table if not exists chain.controller_tip_proofs (
    id bigint generated by default as identity primary key,

    -- always controller; stored so we can FK to chain.instance without triggers
    stream chain.stream not null default 'controller',

    chain_id bigint not null,
    contract_address evm_address not null,

    block_number bigint not null,
    block_timestamp bigint not null,
    block_hash bytes32_hex not null,

    tx_hash txhash_hex not null,
    log_index integer not null,

    canonical boolean not null default true,

    caller evm_address not null,
    proved_tip bytes32_hex not null,

    inserted_at timestamptz not null default now(),

    constraint controller_tip_proofs_stream_controller
    check (stream = 'controller'),

    constraint controller_tip_proofs_instance_fk
    foreign key (stream, chain_id, contract_address)
    references chain.instance (stream, chain_id, contract_address),

    constraint controller_tip_proofs_timestamp_seconds_range
    check (block_timestamp >= 946684800 and block_timestamp < 20000000000),

    constraint controller_tip_proofs_nonnegative
    check (block_number >= 0 and block_timestamp >= 0 and log_index >= 0)
);

create unique index if not exists controller_tip_proofs_uid
on chain.controller_tip_proofs (chain_id, tx_hash, log_index);

-- =========================
-- STREAM CURSORS (projection state machine)
-- =========================
/*
applied_through_seq:
- highest canonical event_seq already applied to projections

tip:
- expected prev_tip for the next event (event_seq = applied_through_seq + 1)
*/
create table if not exists chain.stream_cursor (
    stream chain.stream primary key,
    applied_through_seq bigint not null default 0,
    tip bytes32_hex not null,
    updated_at timestamptz not null default now(),

    constraint stream_cursor_instance_fk
    foreign key (stream)
    references chain.instance (stream),

    constraint stream_cursor_nonnegative
    check (applied_through_seq >= 0)
);

-- Seed + configure must happen explicitly so ingestion fails loudly until set.
create or replace function chain.configure_instance(
    p_stream chain.stream,
    p_chain_id bigint,
    p_contract_address evm_address,
    p_genesis_tip bytes32_hex
) returns void language plpgsql as $$
declare
  cur_applied bigint;
begin
  if p_chain_id <= 0 then
    raise exception 'chain_id must be > 0 (got %)', p_chain_id;
  end if;

  select applied_through_seq
    into cur_applied
    from chain.stream_cursor
   where stream = p_stream
   for update;

  if found and cur_applied <> 0 then
    raise exception 'cannot reconfigure stream %, already applied through seq %', p_stream, cur_applied;
  end if;

  insert into chain.instance(stream, chain_id, contract_address, genesis_tip)
  values (p_stream, p_chain_id, p_contract_address, p_genesis_tip)
  on conflict (stream) do update
    set chain_id = excluded.chain_id,
        contract_address = excluded.contract_address,
        genesis_tip = excluded.genesis_tip;

  insert into chain.stream_cursor(stream, applied_through_seq, tip)
  values (p_stream, 0, p_genesis_tip)
  on conflict (stream) do update
    set applied_through_seq = 0,
        tip = excluded.tip,
        updated_at = now();
end $$;
