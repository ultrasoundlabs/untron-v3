///Module containing a contract's types and functions.
/**

```solidity
library UntronV3 {
    struct ControllerEvent { bytes32 sig; bytes data; uint64 blockNumber; uint64 blockTimestamp; }
    struct PayoutConfig { uint256 targetChainId; address targetToken; address beneficiary; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod UntronV3 {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct ControllerEvent { bytes32 sig; bytes data; uint64 blockNumber; uint64 blockTimestamp; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ControllerEvent {
        #[allow(missing_docs)]
        pub sig: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub blockNumber: u64,
        #[allow(missing_docs)]
        pub blockTimestamp: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::Bytes,
            u64,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ControllerEvent> for UnderlyingRustTuple<'_> {
            fn from(value: ControllerEvent) -> Self {
                (value.sig, value.data, value.blockNumber, value.blockTimestamp)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ControllerEvent {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    sig: tuple.0,
                    data: tuple.1,
                    blockNumber: tuple.2,
                    blockTimestamp: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ControllerEvent {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ControllerEvent {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sig),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockTimestamp),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ControllerEvent {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ControllerEvent {
            const NAME: &'static str = "ControllerEvent";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ControllerEvent(bytes32 sig,bytes data,uint64 blockNumber,uint64 blockTimestamp)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.sig)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.data,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blockNumber)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.blockTimestamp,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ControllerEvent {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.sig)
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.data,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blockNumber,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blockTimestamp,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.sig, out);
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.data,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blockNumber,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blockTimestamp,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct PayoutConfig { uint256 targetChainId; address targetToken; address beneficiary; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PayoutConfig {
        #[allow(missing_docs)]
        pub targetChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub targetToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub beneficiary: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PayoutConfig> for UnderlyingRustTuple<'_> {
            fn from(value: PayoutConfig) -> Self {
                (value.targetChainId, value.targetToken, value.beneficiary)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PayoutConfig {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    targetChainId: tuple.0,
                    targetToken: tuple.1,
                    beneficiary: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for PayoutConfig {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for PayoutConfig {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.targetChainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.targetToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.beneficiary,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PayoutConfig {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for PayoutConfig {
            const NAME: &'static str = "PayoutConfig";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "PayoutConfig(uint256 targetChainId,address targetToken,address beneficiary)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.targetChainId)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.targetToken,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.beneficiary,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PayoutConfig {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.targetChainId,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.targetToken,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.beneficiary,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.targetChainId,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.targetToken,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.beneficiary,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`UntronV3`](self) contract instance.

See the [wrapper's documentation](`UntronV3Instance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> UntronV3Instance<P, N> {
        UntronV3Instance::<P, N>::new(address, __provider)
    }
    /**A [`UntronV3`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`UntronV3`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct UntronV3Instance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for UntronV3Instance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("UntronV3Instance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > UntronV3Instance<P, N> {
        /**Creates a new wrapper around an on-chain [`UntronV3`](self) contract instance.

See the [wrapper's documentation](`UntronV3Instance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> UntronV3Instance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> UntronV3Instance<P, N> {
            UntronV3Instance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > UntronV3Instance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > UntronV3Instance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
///Module containing a contract's types and functions.
/**

```solidity
library UntronV3Index {
    type ClaimOrigin is uint8;
    type PnlReason is uint8;
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod UntronV3Index {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ClaimOrigin(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<ClaimOrigin> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl ClaimOrigin {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for ClaimOrigin {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<ClaimOrigin> for u8 {
            fn from(value: ClaimOrigin) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ClaimOrigin {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ClaimOrigin {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PnlReason(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<PnlReason> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl PnlReason {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for PnlReason {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<PnlReason> for u8 {
            fn from(value: PnlReason) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PnlReason {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PnlReason {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`UntronV3Index`](self) contract instance.

See the [wrapper's documentation](`UntronV3IndexInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> UntronV3IndexInstance<P, N> {
        UntronV3IndexInstance::<P, N>::new(address, __provider)
    }
    /**A [`UntronV3Index`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`UntronV3Index`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct UntronV3IndexInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for UntronV3IndexInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("UntronV3IndexInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > UntronV3IndexInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`UntronV3Index`](self) contract instance.

See the [wrapper's documentation](`UntronV3IndexInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> UntronV3IndexInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> UntronV3IndexInstance<P, N> {
            UntronV3IndexInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > UntronV3IndexInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > UntronV3IndexInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
/**

Generated by the following Solidity interface...
```solidity
library UntronV3 {
    struct ControllerEvent {
        bytes32 sig;
        bytes data;
        uint64 blockNumber;
        uint64 blockTimestamp;
    }
    struct PayoutConfig {
        uint256 targetChainId;
        address targetToken;
        address beneficiary;
    }
}

library UntronV3Index {
    type ClaimOrigin is uint8;
    type PnlReason is uint8;
}

interface UntronV3Harness {
    struct Call {
        address to;
        uint256 value;
        bytes data;
    }

    error AlreadyInitialized();
    error AmountTooLargeForInt();
    error CannotRescueUSDT();
    error ChainDeprecated();
    error DepositAlreadyProcessed();
    error DepositNotAfterLastReceiverPull();
    error EnforcedPause();
    error EventRelayNoProgress();
    error EventTipMismatch();
    error ExpectedPause();
    error InsufficientLpPrincipal();
    error InsufficientProtocolProfit();
    error InsufficientUsdtBalance();
    error InvalidLeaseId();
    error InvalidLeaseTimeframe();
    error InvalidReceiverForSalt();
    error InvalidSignature();
    error InvalidTargetToken();
    error LeaseDurationTooLong();
    error LeaseFeeTooLow();
    error LeaseFlatFeeTooLow();
    error LeaseNotNukeableYet();
    error LeaseRateLimitConfigInvalid();
    error LeaseRateLimitExceeded();
    error LpNotAllowlisted();
    error NewOwnerIsZeroAddress();
    error NoActiveLease();
    error NoBridger();
    error NoEventChainTipInMulticall();
    error NotATrc20Transfer();
    error NotEventChainTip();
    error NotLessee();
    error NotRealtor();
    error NotTronUsdt();
    error PayoutConfigRateLimitConfigInvalid();
    error PayoutConfigRateLimitExceeded();
    error RateNotSet();
    error Reentrancy();
    error SignatureExpired();
    error SubjectiveNetOutZero();
    error SubjectivePreEntitlementAlreadyExists();
    error TronInvalidCalldataLength();
    error TronInvalidTrc20DataLength();
    error Unauthorized();
    error WithdrawExceedsPrincipal();
    error ZeroAmount();

    event BridgerSet(address indexed targetToken, uint256 indexed targetChainId, address bridger);
    event ChainDeprecatedSet(uint256 indexed targetChainId, bool deprecated);
    event ClaimCreated(uint256 indexed leaseId, uint256 indexed claimId, address targetToken, uint256 queueIndex, uint256 amountUsdt, uint256 targetChainId, address beneficiary, UntronV3Index.ClaimOrigin origin, bytes32 originId, address originActor, address originToken, uint64 originTimestamp, uint256 originRawAmount);
    event ClaimFilled(uint256 indexed leaseId, uint256 indexed claimId, address targetToken, uint256 queueIndex, uint256 amountUsdt, uint256 targetChainId, address beneficiary);
    event ControllerEventChainTipUpdated(bytes32 previousTip, uint256 indexed blockNumber, uint256 blockTimestamp, bytes32 indexed eventSignature, bytes abiEncodedEventData);
    event ControllerEventProcessed(uint256 indexed eventIndex, uint256 indexed blockNumber, uint256 blockTimestamp, bytes32 indexed eventSignature, bytes abiEncodedEventData);
    event EventAppended(uint256 indexed eventSeq, bytes32 indexed prevTip, bytes32 indexed newTip, bytes32 eventSignature, bytes abiEncodedEventData);
    event LeaseCreated(uint256 indexed leaseId, bytes32 indexed receiverSalt, uint256 indexed leaseNumber, address realtor, address lessee, uint64 startTime, uint64 nukeableAfter, uint32 leaseFeePpm, uint64 flatFee);
    event LeaseNonceUpdated(uint256 indexed leaseId, uint256 nonce);
    event LesseePayoutConfigRateLimitSet(uint256 maxUpdates, uint256 windowSeconds);
    event LpDeposited(address indexed lp, uint256 amount);
    event LpSet(address indexed lp, bool allowed);
    event LpWithdrawn(address indexed lp, uint256 amount);
    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);
    event Paused(address account);
    event PayoutConfigUpdated(uint256 indexed leaseId, uint256 targetChainId, address targetToken, address beneficiary);
    event ProtocolFlatFeeFloorSet(uint64 floorFlatFee);
    event ProtocolFloorSet(uint256 floorPpm);
    event ProtocolMaxLeaseDurationSet(uint32 maxLeaseDurationSeconds);
    event ProtocolPnlUpdated(int256 pnl, int256 delta, UntronV3Index.PnlReason reason);
    event RealtorLeaseRateLimitSet(address indexed realtor, uint256 maxLeases, uint256 windowSeconds);
    event RealtorMaxLeaseDurationSet(address indexed realtor, uint32 maxLeaseDurationSeconds);
    event RealtorMinFeeSet(address indexed realtor, uint256 minFeePpm);
    event RealtorMinFlatFeeSet(address indexed realtor, uint64 minFlatFee);
    event RealtorSet(address indexed realtor, bool allowed);
    event SwapRateSet(address indexed targetToken, uint256 ratePpm);
    event TokensRescued(address token, uint256 amount);
    event TronReaderSet(address indexed reader);
    event TronUsdtSet(address indexed tronUsdt);
    event Unpaused(address account);
    event UsdtSet(address indexed usdt);

    constructor(address controllerAddress, bytes1 create2Prefix, address receiverImplOverride);

    function CONTROLLER_ADDRESS() external view returns (address);
    function RECEIVER_IMPL() external view returns (address);
    function SWAP_EXECUTOR() external view returns (address);
    function bridgers(address, uint256) external view returns (address);
    function claimLocatorByLease(uint256, uint256) external view returns (address targetToken, uint256 queueIndex);
    function claimQueueLength(address targetToken) external view returns (uint256);
    function claimsByTargetToken(address, uint256) external view returns (uint256 claimId, uint256 amountUsdt, uint256 leaseId, uint256 targetChainId, address beneficiary);
    function controllerEventAt(uint256 idx) external view returns (bytes32 sig, bytes memory data, uint64 blockNumber, uint64 blockTimestamp);
    function controllerEventsLength() external view returns (uint256);
    function createLease(bytes32 receiverSalt, address lessee, uint64 nukeableAfter, uint32 leaseFeePpm, uint64 flatFee, uint256 targetChainId, address targetToken, address beneficiary) external returns (uint256 leaseId, uint256 leaseNumber);
    function deposit(uint256 amount) external;
    function depositProcessed(bytes32) external view returns (bool);
    function depositToPnl(uint256 amount) external;
    function effectiveLeaseRateLimit(address realtor) external view returns (bool enabled, uint256 maxLeases, uint256 windowSeconds);
    function effectiveMaxLeaseDurationSeconds(address realtor) external view returns (uint256);
    function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
    function enqueueClaim(address targetToken, uint256 amountUsdt, uint256 leaseId, uint256 targetChainId, address beneficiary) external returns (uint256 claimIndex);
    function eventChainTip() external view returns (bytes32);
    function eventSeq() external view returns (uint256);
    function evmToTron(address a) external pure returns (bytes21 tron);
    function exposedDecodeEventChainTip(bytes memory data) external pure returns (bytes32 tip);
    function exposedProcessReceiverPulled(bytes32 receiverSalt, address token, uint256 usdtAmount, uint64 dumpTimestamp) external;
    function fill(address targetToken, uint256 maxClaims, Call[] memory calls) external;
    function isChainDeprecated(uint256) external view returns (bool);
    function isLpAllowed(address) external view returns (bool);
    function isRealtor(address) external view returns (bool);
    function lastControllerEventSeq() external view returns (uint256);
    function lastControllerEventTip() external view returns (bytes32);
    function lastReceiverPullTimestampByToken(bytes32, address) external view returns (uint64);
    function leaseIdsByReceiver(bytes32 receiverSalt) external view returns (uint256[] memory ids);
    function leaseLocatorById(uint256 leaseId) external view returns (bytes32 receiverSalt, uint256 leaseNumber);
    function leaseNonces(uint256) external view returns (uint256);
    function leases(uint256 leaseId) external view returns (bytes32 receiverSalt, address realtor, address lessee, uint64 startTime, uint64 nukeableAfter, uint32 leaseFeePpm, uint64 flatFee, uint256 recognizedRaw, uint256 backedRaw, uint256 unbackedRaw, UntronV3.PayoutConfig memory payout);
    function leasesByReceiver(bytes32, uint256) external view returns (bytes32 receiverSalt, address realtor, address lessee, uint64 startTime, uint64 nukeableAfter, uint32 leaseFeePpm, uint64 flatFee, uint256 recognizedRaw, uint256 backedRaw, uint256 unbackedRaw, UntronV3.PayoutConfig memory payout);
    function lesseePayoutConfigRateLimit() external view returns (uint256 maxUpdates, uint256 windowSeconds);
    function lpPrincipal(address) external view returns (uint256);
    function nextClaimIdByLease(uint256) external view returns (uint256);
    function nextControllerEventIndex() external view returns (uint256);
    function nextIndexByTargetToken(address) external view returns (uint256);
    function nextLeaseId() external view returns (uint256);
    function nextLeaseNumberAtReceiver(bytes32 receiverSalt) external view returns (uint256 nextLeaseNumber);
    function owner() external view returns (address result);
    function pause() external;
    function paused() external view returns (bool);
    function preEntitle(bytes32 receiverSalt, bytes[20] memory blocks, bytes memory encodedTx, bytes32[] memory proof, uint256 index) external returns (uint256 queueIndex, uint256 leaseId, uint256 netOut);
    function predictReceiverAddress(bytes32 salt) external view returns (address predicted);
    function predictReceiverAddress(address controller, bytes32 salt) external view returns (address predicted);
    function processControllerEvents(uint256 maxEvents) external;
    function protocolFloorFlatFee() external view returns (uint256);
    function protocolFloorPpm() external view returns (uint256);
    function protocolMaxLeaseDurationSeconds() external view returns (uint256);
    function protocolPnl() external view returns (int256);
    function pushControllerEvent(bytes32 sig, bytes memory data, uint64 blockNumber, uint64 blockTimestamp) external;
    function realtorLeaseRateLimit(address realtor) external view returns (uint256 maxLeases, uint256 windowSeconds);
    function realtorMaxLeaseDurationSeconds(address realtor) external view returns (uint256);
    function realtorMinFeePpm(address realtor) external view returns (uint256);
    function realtorMinFlatFee(address realtor) external view returns (uint256);
    function receiverBytecode() external view returns (bytes memory);
    function relayControllerEventChain(bytes[20] memory blocks, bytes memory encodedTx, bytes32[] memory proof, uint256 index, UntronV3.ControllerEvent[] memory events) external returns (bytes32 tipNew);
    function renounceOwnership() external payable;
    function rescueTokens(address token, uint256 amount) external;
    function setBridger(address targetToken, uint256 targetChainId, address bridger) external;
    function setChainDeprecated(uint256 targetChainId, bool deprecated) external;
    function setLesseePayoutConfigRateLimit(uint256 maxUpdates, uint256 windowSeconds) external;
    function setLp(address lp, bool allowed) external;
    function setPayoutConfig(uint256 leaseId, uint256 targetChainId, address targetToken, address beneficiary) external;
    function setPayoutConfigWithSig(uint256 leaseId, UntronV3.PayoutConfig memory config, uint256 deadline, bytes memory signature) external;
    function setProtocolFloorFlatFee(uint64 floorFlatFee) external;
    function setProtocolFloorPpm(uint256 floorPpm) external;
    function setProtocolMaxLeaseDurationSeconds(uint32 maxLeaseDurationSeconds) external;
    function setRealtor(address realtor, bool allowed) external;
    function setRealtorLeaseRateLimit(address realtor, uint256 maxLeases, uint256 windowSeconds) external;
    function setRealtorMaxLeaseDurationSeconds(address realtor, uint32 maxLeaseDurationSeconds) external;
    function setRealtorMinFeePpm(address realtor, uint256 minFeePpm) external;
    function setRealtorMinFlatFee(address realtor, uint64 minFlatFee) external;
    function setSwapRate(address targetToken, uint256 ratePpm) external;
    function setTronReader(address reader) external;
    function setUsdt(address usdt_) external;
    function subjectivePreEntitle(bytes32 txId, uint256 leaseId, uint256 rawAmount) external returns (uint256 queueIndex, uint256 netOut);
    function subjectivePreEntitlementByTxId(bytes32) external view returns (address sponsor, uint256 leaseId, uint256 rawAmount, uint256 queueIndex, uint256 claimId);
    function swapRatePpm(address) external view returns (uint256);
    function transferOwnership(address newOwner) external payable;
    function tronReader() external view returns (address);
    function tronUsdt() external view returns (address);
    function unpause() external;
    function usdt() external view returns (address);
    function usdtBalance() external view returns (uint256);
    function withdraw(uint256 amount) external;
    function withdrawProtocolProfit(int256 amount) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "controllerAddress",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "create2Prefix",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "receiverImplOverride",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "CONTROLLER_ADDRESS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "RECEIVER_IMPL",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SWAP_EXECUTOR",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract SwapExecutor"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "bridgers",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBridger"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "claimLocatorByLease",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "targetToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "queueIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "claimQueueLength",
    "inputs": [
      {
        "name": "targetToken",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "claimsByTargetToken",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "claimId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amountUsdt",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "leaseId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "targetChainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "beneficiary",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "controllerEventAt",
    "inputs": [
      {
        "name": "idx",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "sig",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "blockNumber",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "blockTimestamp",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "controllerEventsLength",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "createLease",
    "inputs": [
      {
        "name": "receiverSalt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "lessee",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "nukeableAfter",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "leaseFeePpm",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "flatFee",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "targetChainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "targetToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "beneficiary",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "leaseId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "leaseNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "deposit",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "depositProcessed",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "depositToPnl",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "effectiveLeaseRateLimit",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "enabled",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "maxLeases",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "windowSeconds",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "effectiveMaxLeaseDurationSeconds",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eip712Domain",
    "inputs": [],
    "outputs": [
      {
        "name": "fields",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "version",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "verifyingContract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "extensions",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "enqueueClaim",
    "inputs": [
      {
        "name": "targetToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amountUsdt",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "leaseId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "targetChainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "beneficiary",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "claimIndex",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "eventChainTip",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eventSeq",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "evmToTron",
    "inputs": [
      {
        "name": "a",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "tron",
        "type": "bytes21",
        "internalType": "bytes21"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "exposedDecodeEventChainTip",
    "inputs": [
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "tip",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "exposedProcessReceiverPulled",
    "inputs": [
      {
        "name": "receiverSalt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "usdtAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "dumpTimestamp",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fill",
    "inputs": [
      {
        "name": "targetToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "maxClaims",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "calls",
        "type": "tuple[]",
        "internalType": "struct Call[]",
        "components": [
          {
            "name": "to",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "value",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "data",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isChainDeprecated",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isLpAllowed",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isRealtor",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "lastControllerEventSeq",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "lastControllerEventTip",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "lastReceiverPullTimestampByToken",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "leaseIdsByReceiver",
    "inputs": [
      {
        "name": "receiverSalt",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "ids",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "leaseLocatorById",
    "inputs": [
      {
        "name": "leaseId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "receiverSalt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "leaseNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "leaseNonces",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "leases",
    "inputs": [
      {
        "name": "leaseId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "receiverSalt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "realtor",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "lessee",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "startTime",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "nukeableAfter",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "leaseFeePpm",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "flatFee",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "recognizedRaw",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "backedRaw",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "unbackedRaw",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "payout",
        "type": "tuple",
        "internalType": "struct UntronV3.PayoutConfig",
        "components": [
          {
            "name": "targetChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "targetToken",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "beneficiary",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "leasesByReceiver",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "receiverSalt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "realtor",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "lessee",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "startTime",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "nukeableAfter",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "leaseFeePpm",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "flatFee",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "recognizedRaw",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "backedRaw",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "unbackedRaw",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "payout",
        "type": "tuple",
        "internalType": "struct UntronV3.PayoutConfig",
        "components": [
          {
            "name": "targetChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "targetToken",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "beneficiary",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "lesseePayoutConfigRateLimit",
    "inputs": [],
    "outputs": [
      {
        "name": "maxUpdates",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "windowSeconds",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "lpPrincipal",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nextClaimIdByLease",
    "inputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nextControllerEventIndex",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nextIndexByTargetToken",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nextLeaseId",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nextLeaseNumberAtReceiver",
    "inputs": [
      {
        "name": "receiverSalt",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "nextLeaseNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "result",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "preEntitle",
    "inputs": [
      {
        "name": "receiverSalt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "blocks",
        "type": "bytes[20]",
        "internalType": "bytes[20]"
      },
      {
        "name": "encodedTx",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "proof",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "queueIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "leaseId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "netOut",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "predictReceiverAddress",
    "inputs": [
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "predicted",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "predictReceiverAddress",
    "inputs": [
      {
        "name": "controller",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "predicted",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "processControllerEvents",
    "inputs": [
      {
        "name": "maxEvents",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "protocolFloorFlatFee",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "protocolFloorPpm",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "protocolMaxLeaseDurationSeconds",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "protocolPnl",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pushControllerEvent",
    "inputs": [
      {
        "name": "sig",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "blockNumber",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "blockTimestamp",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "realtorLeaseRateLimit",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "maxLeases",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "windowSeconds",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "realtorMaxLeaseDurationSeconds",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "realtorMinFeePpm",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "realtorMinFlatFee",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "receiverBytecode",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "relayControllerEventChain",
    "inputs": [
      {
        "name": "blocks",
        "type": "bytes[20]",
        "internalType": "bytes[20]"
      },
      {
        "name": "encodedTx",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "proof",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "events",
        "type": "tuple[]",
        "internalType": "struct UntronV3.ControllerEvent[]",
        "components": [
          {
            "name": "sig",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "data",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "blockNumber",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "blockTimestamp",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "tipNew",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "rescueTokens",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setBridger",
    "inputs": [
      {
        "name": "targetToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "targetChainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "bridger",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setChainDeprecated",
    "inputs": [
      {
        "name": "targetChainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "deprecated",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setLesseePayoutConfigRateLimit",
    "inputs": [
      {
        "name": "maxUpdates",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "windowSeconds",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setLp",
    "inputs": [
      {
        "name": "lp",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "allowed",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setPayoutConfig",
    "inputs": [
      {
        "name": "leaseId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "targetChainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "targetToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "beneficiary",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setPayoutConfigWithSig",
    "inputs": [
      {
        "name": "leaseId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "config",
        "type": "tuple",
        "internalType": "struct UntronV3.PayoutConfig",
        "components": [
          {
            "name": "targetChainId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "targetToken",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "beneficiary",
            "type": "address",
            "internalType": "address"
          }
        ]
      },
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setProtocolFloorFlatFee",
    "inputs": [
      {
        "name": "floorFlatFee",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setProtocolFloorPpm",
    "inputs": [
      {
        "name": "floorPpm",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setProtocolMaxLeaseDurationSeconds",
    "inputs": [
      {
        "name": "maxLeaseDurationSeconds",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setRealtor",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "allowed",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setRealtorLeaseRateLimit",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "maxLeases",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "windowSeconds",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setRealtorMaxLeaseDurationSeconds",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "maxLeaseDurationSeconds",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setRealtorMinFeePpm",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "minFeePpm",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setRealtorMinFlatFee",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "minFlatFee",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setSwapRate",
    "inputs": [
      {
        "name": "targetToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "ratePpm",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setTronReader",
    "inputs": [
      {
        "name": "reader",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setUsdt",
    "inputs": [
      {
        "name": "usdt_",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "subjectivePreEntitle",
    "inputs": [
      {
        "name": "txId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "leaseId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "rawAmount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "queueIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "netOut",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "subjectivePreEntitlementByTxId",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "sponsor",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "leaseId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "rawAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "queueIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "claimId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "swapRatePpm",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "tronReader",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract ITronTxReader"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "tronUsdt",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "usdt",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "usdtBalance",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "withdraw",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "withdrawProtocolProfit",
    "inputs": [
      {
        "name": "amount",
        "type": "int256",
        "internalType": "int256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "BridgerSet",
    "inputs": [
      {
        "name": "targetToken",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "targetChainId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "bridger",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ChainDeprecatedSet",
    "inputs": [
      {
        "name": "targetChainId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "deprecated",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ClaimCreated",
    "inputs": [
      {
        "name": "leaseId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "claimId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "targetToken",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "queueIndex",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amountUsdt",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "targetChainId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "beneficiary",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "origin",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum UntronV3Index.ClaimOrigin"
      },
      {
        "name": "originId",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "originActor",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "originToken",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "originTimestamp",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "originRawAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ClaimFilled",
    "inputs": [
      {
        "name": "leaseId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "claimId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "targetToken",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "queueIndex",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amountUsdt",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "targetChainId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "beneficiary",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ControllerEventChainTipUpdated",
    "inputs": [
      {
        "name": "previousTip",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "blockNumber",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "blockTimestamp",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "eventSignature",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "abiEncodedEventData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ControllerEventProcessed",
    "inputs": [
      {
        "name": "eventIndex",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "blockNumber",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "blockTimestamp",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "eventSignature",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "abiEncodedEventData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EventAppended",
    "inputs": [
      {
        "name": "eventSeq",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "prevTip",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newTip",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "eventSignature",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "abiEncodedEventData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "LeaseCreated",
    "inputs": [
      {
        "name": "leaseId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "receiverSalt",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "leaseNumber",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "realtor",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "lessee",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "startTime",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "nukeableAfter",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "leaseFeePpm",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      },
      {
        "name": "flatFee",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "LeaseNonceUpdated",
    "inputs": [
      {
        "name": "leaseId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "nonce",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "LesseePayoutConfigRateLimitSet",
    "inputs": [
      {
        "name": "maxUpdates",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "windowSeconds",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "LpDeposited",
    "inputs": [
      {
        "name": "lp",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "LpSet",
    "inputs": [
      {
        "name": "lp",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "allowed",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "LpWithdrawn",
    "inputs": [
      {
        "name": "lp",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "oldOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "PayoutConfigUpdated",
    "inputs": [
      {
        "name": "leaseId",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "targetChainId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "targetToken",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "beneficiary",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ProtocolFlatFeeFloorSet",
    "inputs": [
      {
        "name": "floorFlatFee",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ProtocolFloorSet",
    "inputs": [
      {
        "name": "floorPpm",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ProtocolMaxLeaseDurationSet",
    "inputs": [
      {
        "name": "maxLeaseDurationSeconds",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ProtocolPnlUpdated",
    "inputs": [
      {
        "name": "pnl",
        "type": "int256",
        "indexed": false,
        "internalType": "int256"
      },
      {
        "name": "delta",
        "type": "int256",
        "indexed": false,
        "internalType": "int256"
      },
      {
        "name": "reason",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum UntronV3Index.PnlReason"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RealtorLeaseRateLimitSet",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "maxLeases",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "windowSeconds",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RealtorMaxLeaseDurationSet",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "maxLeaseDurationSeconds",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RealtorMinFeeSet",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "minFeePpm",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RealtorMinFlatFeeSet",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "minFlatFee",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RealtorSet",
    "inputs": [
      {
        "name": "realtor",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "allowed",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SwapRateSet",
    "inputs": [
      {
        "name": "targetToken",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "ratePpm",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TokensRescued",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TronReaderSet",
    "inputs": [
      {
        "name": "reader",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TronUsdtSet",
    "inputs": [
      {
        "name": "tronUsdt",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "UsdtSet",
    "inputs": [
      {
        "name": "usdt",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AlreadyInitialized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AmountTooLargeForInt",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CannotRescueUSDT",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ChainDeprecated",
    "inputs": []
  },
  {
    "type": "error",
    "name": "DepositAlreadyProcessed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "DepositNotAfterLastReceiverPull",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EnforcedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EventRelayNoProgress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EventTipMismatch",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExpectedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientLpPrincipal",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientProtocolProfit",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientUsdtBalance",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidLeaseId",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidLeaseTimeframe",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidReceiverForSalt",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidTargetToken",
    "inputs": []
  },
  {
    "type": "error",
    "name": "LeaseDurationTooLong",
    "inputs": []
  },
  {
    "type": "error",
    "name": "LeaseFeeTooLow",
    "inputs": []
  },
  {
    "type": "error",
    "name": "LeaseFlatFeeTooLow",
    "inputs": []
  },
  {
    "type": "error",
    "name": "LeaseNotNukeableYet",
    "inputs": []
  },
  {
    "type": "error",
    "name": "LeaseRateLimitConfigInvalid",
    "inputs": []
  },
  {
    "type": "error",
    "name": "LeaseRateLimitExceeded",
    "inputs": []
  },
  {
    "type": "error",
    "name": "LpNotAllowlisted",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NewOwnerIsZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NoActiveLease",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NoBridger",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NoEventChainTipInMulticall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotATrc20Transfer",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotEventChainTip",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotLessee",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotRealtor",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotTronUsdt",
    "inputs": []
  },
  {
    "type": "error",
    "name": "PayoutConfigRateLimitConfigInvalid",
    "inputs": []
  },
  {
    "type": "error",
    "name": "PayoutConfigRateLimitExceeded",
    "inputs": []
  },
  {
    "type": "error",
    "name": "RateNotSet",
    "inputs": []
  },
  {
    "type": "error",
    "name": "Reentrancy",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SignatureExpired",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SubjectiveNetOutZero",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SubjectivePreEntitlementAlreadyExists",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TronInvalidCalldataLength",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TronInvalidTrc20DataLength",
    "inputs": []
  },
  {
    "type": "error",
    "name": "Unauthorized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "WithdrawExceedsPrincipal",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAmount",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod UntronV3Harness {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6103406040526101626101a08181526002916183a96101c03960405160200161002891906103e2565b60408051601f19818403018152908290526100429161040b565b602060405180830381855afa15801561005d573d5f5f3e3d5ffd5b5050506040513d601f19601f820116820180604052508101906100809190610416565b6001555f6006556002604051806101a0016040528061016281526020016183a961016291396040516020016100b5919061042d565b60408051601f19818403018152908290526100cf9161040b565b602060405180830381855afa1580156100ea573d5f5f3e3d5ffd5b5050506040513d601f19601f8201168201806040525081019061010d9190610416565b60155534801561011b575f5ffd5b5060405161852b38038061852b83398101604081905261013a91610479565b6001600160f81b0319821660a0526001600160a01b0381166080523060c0524660e05282828260608061019e60408051808201825260068152652ab73a3937b760d11b602080830191909152825180840190935260018352603160f81b9083015291565b8151602092830120815191830191909120610100829052610120819052604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f8152938401929092528282015246606083015230608083015260a0909120610140525161020f925090506103be565b604051809103905ff080158015610228573d5f5f3e3d5ffd5b506001600160a01b039081166101805283166101605261024733610252565b505050505050610539565b6001600160a01b0316638b78c6d81981905561026e5f82610271565b50565b806001600160a01b0316826001600160a01b03165f51602061850b5f395f51905f5260405160405180910390a36102ec5f51602061850b5f395f51905f5283836040516020016102d79291906001600160a01b0392831681529116602082015260400190565b60408051601f198184030181529190526102f0565b5050565b600280546001908101808355905460405190929161031b9184919043904290899089906020016104c8565b60408051601f19818403018152908290526103359161040b565b602060405180830381855afa158015610350573d5f5f3e3d5ffd5b5050506040513d601f19601f820116820180604052508101906103739190610416565b600181905550600154816002547f78160f0b1b2b32b52a0076d8f0f70888687ba702a4d993d55ac8d9327d57a12786866040516103b19291906104fd565b60405180910390a4505050565b61053980617e7083390190565b5f81518060208401855e5f93019283525090919050565b6d2ab73a3937b72b19a4b73232bc0560911b81525f610404600e8301846103cb565b9392505050565b5f61040482846103cb565b5f60208284031215610426575f5ffd5b5051919050565b7f556e74726f6e436f6e74726f6c6c6572496e6465780a0000000000000000000081525f61040460168301846103cb565b80516001600160a01b0381168114610474575f5ffd5b919050565b5f5f5f6060848603121561048b575f5ffd5b6104948461045e565b60208501519093506001600160f81b0319811681146104b1575f5ffd5b91506104bf6040850161045e565b90509250925092565b8681528560208201528460408201528360608201528260808201525f6104f160a08301846103cb565b98975050505050505050565b828152604060208201525f82518060408401528060208501606085015e5f606082850101526060601f19601f8301168401019150509392505050565b60805160a05160c05160e05161010051610120516101405161016051610180516178af6105c15f395f818161053f01528181614b090152614b4701525f8181610f1c01528181611d6a015261553901525f615ed501525f615f8f01525f615f6901525f615f1901525f615ef601525f612a5401525f81816110e3015261260301526178af5ff3fe6080604052600436106104c6575f3560e01c806384b0196e11610278578063b7ed020e11610155578063de40d89f116100c9578063f04e02c011610083578063f04e02c0146111a2578063f127a9b3146111cd578063f2fde38b146111e2578063f516a5b4146111f5578063f654b7d014611220578063f9fdcae61461123f575f5ffd5b8063de40d89f146110d2578063e24d5c3514611105578063e8be65041461111a578063ecf88bb014611139578063eeb9025914611158578063f03eb61a14611183575f5ffd5b8063ca02a81e1161011a578063ca02a81e14610fe2578063cef5f4821461100d578063d38b018b1461102c578063db14fb4114611058578063dc1f9adf14611094578063dc8f8633146110b3575f5ffd5b8063b7ed020e14610ef6578063b98e631d14610f0b578063bc5c595014610f3e578063c0283e6214610f6c578063c63bbf2914610f8b575f5ffd5b80639d61dd07116101ec578063a7ec9df9116101b1578063a7ec9df914610e44578063aa63e54514610e63578063aa94360c14610e82578063b133be7d14610ea1578063b371fa6914610ec2578063b6b55f2514610ed7575f5ffd5b80639d61dd0714610d9a5780639efaca7914610ddb578063a34d28eb14610dfc578063a630255914610e1b578063a6e92f3c14610e30575f5ffd5b80638927a1061161023d5780638927a10614610cf657806389f297bd14610d155780638da5cb5b14610d34578063902238e114610d4c57806393a9ee4614610d6157806399b4992514610d7b575f5ffd5b806384b0196e14610c445780638701d7b214610c6b578063878ba15614610c8a5780638842c57314610ca95780638892729614610cc8575f5ffd5b80634d53e931116103a6578063665e0eed1161031a57806378aaf25e116102df57806378aaf25e14610b2f5780637c4c4feb14610b7f5780637de89f3014610bae5780637e49447f14610bf257806380a72c8b14610c115780638456cb5914610c30575f5ffd5b8063665e0eed14610a5257806367de8b7e14610a715780636c835a8214610a95578063715018a614610abf578063718fbc2514610ac7575f5ffd5b806358979bfe1161036b57806358979bfe146109925780635c975abb146109b15780635cf88012146109c75780635ea63c6c146109e657806360b6bfdd14610a05578063636ee62414610a33575f5ffd5b80634d53e931146108f55780634da2f8991461090a5780635016c47b14610935578063506294dc146109545780635737619814610973575f5ffd5b80633627720d1161043d5780633fea3488116104025780633fea34881461081d57806342005c6c1461083c5780634341fc861461085b57806346de406f14610897578063481f9376146108b6578063482edb07146108e1575f5ffd5b80633627720d146106d15780633660fb921461070557806338ee72d0146107665780633d92af84146107855780633f4ba83a14610809575f5ffd5b80631dbf4c611161048e5780631dbf4c61146105b75780632e1a7d4d146105f65780632f48ab7d146106155780632f83d9af1461063457806333680d581461066a57806333d908ad146106b2575f5ffd5b80630465eab0146104ca57806304ec4294146104eb5780630b3458791461052e5780631376de52146105795780631cf1bd3a14610598575b5f5ffd5b3480156104d5575f5ffd5b506104e96104e436600461655e565b611279565b005b3480156104f6575f5ffd5b5061051961050536600461655e565b60146020525f908152604090205460ff1681565b60405190151581526020015b60405180910390f35b348015610539575f5ffd5b506105617f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610525565b348015610584575f5ffd5b506104e9610593366004616589565b6112f3565b3480156105a3575f5ffd5b506104e96105b236600461655e565b611322565b3480156105c2575f5ffd5b506105616105d13660046165c7565b601360209081525f92835260408084209091529082529020546001600160a01b031681565b348015610601575f5ffd5b506104e961061036600461655e565b61136c565b348015610620575f5ffd5b50600454610561906001600160a01b031681565b34801561063f575f5ffd5b5061065361064e3660046165f1565b61142b565b6040516105259b9a99989796959493929190616611565b348015610675575f5ffd5b506106a46106843660046166b3565b6001600160a01b03165f908152600d602052604090205463ffffffff1690565b604051908152602001610525565b3480156106bd575f5ffd5b506104e96106cc3660046166ce565b6114ec565b3480156106dc575f5ffd5b506106a46106eb3660046166b3565b6001600160a01b03165f9081526019602052604090205490565b348015610710575f5ffd5b5061075161071f3660046166b3565b6001600160a01b03165f908152600d602052604090205463ffffffff600160201b8204811692600160401b9092041690565b60408051928352602083019190915201610525565b348015610771575f5ffd5b506104e961078036600461672b565b6115d6565b348015610790575f5ffd5b506107d761079f36600461655e565b601e6020525f9081526040902080546001820154600283015460038401546004909401546001600160a01b0390931693919290919085565b604080516001600160a01b0390961686526020860194909452928401919091526060830152608082015260a001610525565b348015610814575f5ffd5b506104e96115e8565b348015610828575f5ffd5b5061056161083736600461655e565b6115fa565b348015610847575f5ffd5b506104e9610856366004616781565b61160b565b348015610866575f5ffd5b5061087a6108753660046166b3565b611650565b604080519315158452602084019290925290820152606001610525565b3480156108a2575f5ffd5b506104e96108b136600461655e565b61169a565b3480156108c1575f5ffd5b50600c5463ffffffff600160201b8204811691600160401b900416610751565b3480156108ec575f5ffd5b506106a461170e565b348015610900575f5ffd5b506106a460015481565b348015610915575f5ffd5b506106a46109243660046166b3565b60116020525f908152604090205481565b348015610940575f5ffd5b506104e961094f36600461655e565b611738565b34801561095f575f5ffd5b506104e961096e3660046167b8565b611c30565b34801561097e575f5ffd5b506104e961098d3660046165c7565b611c66565b34801561099d575f5ffd5b506104e96109ac3660046166b3565b611cb2565b3480156109bc575f5ffd5b505f5460ff16610519565b3480156109d2575f5ffd5b506106a46109e1366004616866565b611cde565b3480156109f1575f5ffd5b506104e9610a003660046165c7565b611e56565b348015610a10575f5ffd5b50610519610a1f3660046166b3565b600a6020525f908152604090205460ff1681565b348015610a3e575f5ffd5b506104e9610a4d3660046165f1565b611eb6565b348015610a5d575f5ffd5b506104e9610a6c366004616934565b611f5d565b348015610a7c575f5ffd5b50600c54600160601b90046001600160401b03166106a4565b348015610aa0575f5ffd5b506106a4610aaf36600461655e565b602080525f908152604090205481565b6104e9611ffb565b348015610ad2575f5ffd5b50610b10610ae13660046165f1565b601c60209081525f9283526040808420909152908252902080546001909101546001600160a01b039091169082565b604080516001600160a01b039093168352602083019190915201610525565b348015610b3a575f5ffd5b50610b4e610b493660046165c7565b61200c565b6040805195865260208601949094529284019190915260608301526001600160a01b0316608082015260a001610525565b348015610b8a575f5ffd5b50610b9e610b9936600461655e565b61205f565b60405161052594939291906169a1565b348015610bb9575f5ffd5b506106a4610bc83660046166b3565b6001600160a01b03165f908152600d6020526040902054600160601b90046001600160401b031690565b348015610bfd575f5ffd5b50610751610c0c3660046169da565b612147565b348015610c1c575f5ffd5b50600354610561906001600160a01b031681565b348015610c3b575f5ffd5b506104e96121bf565b348015610c4f575f5ffd5b50610c586121cf565b6040516105259796959493929190616aa2565b348015610c76575f5ffd5b506104e9610c85366004616b11565b612228565b348015610c95575f5ffd5b506104e9610ca4366004616b11565b61225d565b348015610cb4575f5ffd5b506106a4610cc33660046166b3565b612292565b348015610cd3575f5ffd5b50610519610ce236600461655e565b601d6020525f908152604090205460ff1681565b348015610d01575f5ffd5b50610653610d1036600461655e565b61229c565b348015610d20575f5ffd5b506106a4610d2f366004616bcd565b61246d565b348015610d3f575f5ffd5b50638b78c6d81954610561565b348015610d57575f5ffd5b506106a460065481565b348015610d6c575f5ffd5b50600c5463ffffffff166106a4565b348015610d86575f5ffd5b506104e9610d95366004616c46565b612477565b348015610da5575f5ffd5b506106a4610db43660046166b3565b6001600160a01b03165f908152600d6020526040902054600160a01b900463ffffffff1690565b348015610de6575f5ffd5b50610def6125d2565b6040516105259190616c9d565b348015610e07575f5ffd5b506104e9610e16366004616caf565b612658565b348015610e26575f5ffd5b506106a460155481565b348015610e3b575f5ffd5b506017546106a4565b348015610e4f575f5ffd5b50610751610e5e366004616d1c565b612763565b348015610e6e575f5ffd5b506104e9610e7d366004616d45565b612973565b348015610e8d575f5ffd5b50610561610e9c3660046165c7565b612a51565b348015610eac575f5ffd5b50600c54600160a01b900463ffffffff166106a4565b348015610ecd575f5ffd5b506106a460165481565b348015610ee2575f5ffd5b506104e9610ef136600461655e565b612ae8565b348015610f01575f5ffd5b506106a460105481565b348015610f16575f5ffd5b506105617f000000000000000000000000000000000000000000000000000000000000000081565b348015610f49575f5ffd5b50610519610f583660046166b3565b600b6020525f908152604090205460ff1681565b348015610f77575f5ffd5b506106a4610f86366004616dae565b612b85565b348015610f96575f5ffd5b50610fca610fa5366004616e00565b601f60209081525f92835260408084209091529082529020546001600160401b031681565b6040516001600160401b039091168152602001610525565b348015610fed575f5ffd5b506106a4610ffc36600461655e565b5f9081526007602052604090205490565b348015611018575f5ffd5b506104e96110273660046165c7565b612b9e565b348015611037575f5ffd5b5061104b61104636600461655e565b612c11565b6040516105259190616e23565b348015611063575f5ffd5b506110776110723660046166b3565b612c70565b6040516affffffffffffffffffffff199091168152602001610525565b34801561109f575f5ffd5b506104e96110ae366004616e35565b612c7a565b3480156110be575f5ffd5b50600554610561906001600160a01b031681565b3480156110dd575f5ffd5b506105617f000000000000000000000000000000000000000000000000000000000000000081565b348015611110575f5ffd5b506106a460025481565b348015611125575f5ffd5b5061075161113436600461655e565b612ca9565b348015611144575f5ffd5b506104e9611153366004616e50565b612ce9565b348015611163575f5ffd5b506106a46111723660046166b3565b601a6020525f908152604090205481565b34801561118e575f5ffd5b506104e961119d366004616e82565b612da6565b3480156111ad575f5ffd5b506106a46111bc3660046166b3565b60126020525f908152604090205481565b3480156111d8575f5ffd5b506106a460185481565b6104e96111f03660046166b3565b612df2565b348015611200575f5ffd5b506106a461120f36600461655e565b601b6020525f908152604090205481565b34801561122b575f5ffd5b506104e961123a3660046166b3565b612e18565b34801561124a575f5ffd5b5061125e611259366004616eac565b612e44565b60408051938452602084019290925290820152606001610525565b611281613135565b60018112156112a357604051631f2a200560e01b815260040160405180910390fd5b6010548113156112c657604051639d8c7d9960e01b815260040160405180910390fd5b6004546112dd906001600160a01b0316338361314f565b6112f06112e982616f68565b6002613173565b50565b6112fb613135565b5f828152601460205260409020805460ff191682151517905561131e82826131a2565b5050565b61132a613135565b620f424081111561134e57604051634a55946b60e11b815260040160405180910390fd5b600c805463ffffffff191663ffffffff83161790556112f081613234565b61137461329e565b805f0361139457604051631f2a200560e01b815260040160405180910390fd5b335f90815260116020526040902054808211156113c45760405163d4708ca560e01b815260040160405180910390fd5b6113cc61170e565b8211156113ec5760405163b55c1bad60e01b815260040160405180910390fd5b6113f68282616f82565b335f81815260116020526040902091909155600454611421916001600160a01b03909116908461314f565b61131e33836132c1565b6007602052815f5260405f208181548110611444575f80fd5b5f918252602091829020600a9091020180546001820154600283015460038401546004850154600586015460068701546040805160608101825260078a0154815260088a01546001600160a01b039081169b82019b909b526009909901548a16908901529599509387169750958216956001600160401b03600160a01b9093048316958284169563ffffffff600160401b85041695600160601b90940490941693919291908b565b6114f461329e565b5f6114fe8561334b565b60028101549091506001600160a01b0316331461152e5760405163389b7a7960e11b815260040160405180910390fd5b611537336133bb565b5f8481526014602052604090205460ff16156115665760405163d9259ca960e01b815260040160405180910390fd5b61157084846134d0565b604080516060810182528581526001600160a01b038086166020830181905290851691909201819052600783018690556008830180546001600160a01b031990811690931790556009830180549092161790556115cf858585856135c2565b5050505050565b6115e284848484613664565b50505050565b6115f0613135565b6115f86138a3565b565b5f6116053083612a51565b92915050565b611613613135565b6001600160a01b0382165f908152600d60205260409020805463ffffffff60a01b1916600160a01b63ffffffff84160217905561131e82826138f4565b6001600160a01b0381165f908152600d60205260408120805463ffffffff600160201b8204811692600160401b9092041690821580159061169057508115155b9350509193909250565b805f036116ba57604051631f2a200560e01b815260040160405180910390fd5b6004546001600160a01b03166116e357604051638562eb4560e01b815260040160405180910390fd5b6004546116fb906001600160a01b0316333084613987565b6112f0611707826139a2565b6005613173565b6004545f906001600160a01b031680611728575f91505090565b61173281306139cf565b91505090565b61174061329e565b6018546017545f5b818310801561175657508381105b15611c28575f6017848154811061176f5761176f616f95565b5f918252602090912060039091020180549091507ffcb44ffebd38e2fe82ab623ea3788854213c458cf9855525b5865b707d5f013e810161187e575f5f5f8460010180546117bc90616fa9565b80601f01602080910402602001604051908101604052809291908181526020018280546117e890616fa9565b80156118335780601f1061180a57610100808354040283529160200191611833565b820191905f5260205f20905b81548152906001019060200180831161181657829003601f168201915b505050505080602001905181019061184b9190616fe1565b94505050925092506118768383838860020160089054906101000a90046001600160401b0316613664565b505050611b66565b7fa44f293dfa9228916345a6016220f304fd4e10c2f25ef62c896b4946926a70f48103611970575f8260010180546118b590616fa9565b80601f01602080910402602001604051908101604052809291908181526020018280546118e190616fa9565b801561192c5780601f106119035761010080835404028352916020019161192c565b820191905f5260205f20905b81548152906001019060200180831161190f57829003601f168201915b50505050508060200190518101906119449190617027565b600580546001600160a01b0319166001600160a01b038316179055905061196a81613a5e565b50611b66565b7fc12dafb0c407b0b342623605e950ef39bc2e3c97a3e5ee574555b350677601b18103611a7f575f5f8360010180546119a890616fa9565b80601f01602080910402602001604051908101604052809291908181526020018280546119d490616fa9565b8015611a1f5780601f106119f657610100808354040283529160200191611a1f565b820191905f5260205f20905b815481529060010190602001808311611a0257829003601f168201915b5050505050806020019051810190611a379190617042565b50915091505f82821015611a6557611a57611a528385616f82565b6139a2565b611a6090616f68565b611a72565b611a72611a528484616f82565b9050611876816001613173565b7f47c6751e5abe122c1ca5828c0fd60c328b369e575227dfcc17e7623e895ec0458103611b66575f826001018054611ab690616fa9565b80601f0160208091040260200160405190810160405280929190818152602001828054611ae290616fa9565b8015611b2d5780601f10611b0457610100808354040283529160200191611b2d565b820191905f5260205f20905b815481529060010190602001808311611b1057829003601f168201915b5050505050806020019051810190611b45919061706e565b915050611b64611b54826139a2565b611b5d90616f68565b6004613173565b505b6002820154600183018054611c1a9288926001600160401b0380831693600160401b9093041691869190611b9990616fa9565b80601f0160208091040260200160405190810160405280929190818152602001828054611bc590616fa9565b8015611c105780601f10611be757610100808354040283529160200191611c10565b820191905f5260205f20905b815481529060010190602001808311611bf357829003601f168201915b5050505050613ad0565b505060019283019201611748565b505060185550565b611c38613135565b600c805467ffffffffffffffff60601b1916600160601b6001600160401b038416021790556112f081613b49565b611c6e613135565b6004546001600160a01b0390811690831603611c9d57604051631c4e1bff60e01b815260040160405180910390fd5b611ca882338361314f565b61131e8282613bc4565b611cba613135565b600480546001600160a01b0319166001600160a01b0383161790556112f081613c4d565b5f611ce761329e565b600354604051630939b3f360e31b81525f916001600160a01b0316906349cd9f9890611d21908d908d908d908d908d908d90600401617103565b5f60405180830381865afa158015611d3b573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052611d6291908101906171c7565b90505f611d8e7f0000000000000000000000000000000000000000000000000000000000000000613cbf565b9050806001600160581b03191682608001516001600160581b03191614611dc85760405163365b3e5360e11b815260040160405180910390fd5b611dd58260a00151613cd4565b601554909350808403611dfb576040516335b0519f60e21b815260040160405180910390fd5b6016545f80611e0c84848b8b613d80565b91509150868214611e3057604051630e521c4360e01b815260040160405180910390fd5b60158790556016819055611e448989613f02565b50505050505098975050505050505050565b611e5e613135565b620f4240811115611e8257604051634a55946b60e11b815260040160405180910390fd5b6001600160a01b0382165f908152600d60205260409020805463ffffffff191663ffffffff831617905561131e8282614045565b611ebe613135565b63ffffffff821180611ed3575063ffffffff81115b15611ef15760405163a17eea7760e01b815260040160405180910390fd5b8115811514611f135760405163a17eea7760e01b815260040160405180910390fd5b600c805463ffffffff838116600160401b0263ffffffff60401b19918616600160201b02919091166bffffffffffffffff00000000199092169190911717905561131e82826140cf565b611f65613135565b6001600160a01b038316611f8c57604051638562eb4560e01b815260040160405180910390fd5b6001600160a01b038116611fb35760405163b37c79ed60e01b815260040160405180910390fd5b6001600160a01b038381165f908152601360209081526040808320868452909152902080546001600160a01b031916918316919091179055611ff6838383614148565b505050565b612003613135565b6115f85f6141db565b6019602052815f5260405f208181548110612025575f80fd5b5f9182526020909120600590910201805460018201546002830154600384015460049094015492955090935091906001600160a01b031685565b5f60605f5f5f6017868154811061207857612078616f95565b5f91825260209091206003909102018054600282015460018301805493945091926001600160401b0380831692600160401b9004169083906120b990616fa9565b80601f01602080910402602001604051908101604052809291908181526020018280546120e590616fa9565b80156121305780601f1061210757610100808354040283529160200191612130565b820191905f5260205f20905b81548152906001019060200180831161211357829003601f168201915b505050505092509450945094509450509193509193565b5f5f61215161329e565b61215f338b8a8a8a8a614201565b61216985856134d0565b60065f8154612177906172b8565b9182905550915042612192838c338d858e8e8e8e8e8e6143f6565b91506121a5838c84338e868f8f8f61470c565b6121b1838787876135c2565b509850989650505050505050565b6121c7613135565b6115f861480c565b600f60f81b6060805f80808361221660408051808201825260068152652ab73a3937b760d11b602080830191909152825180840190935260018352603160f81b9083015291565b97989097965046955030945091925090565b612230613135565b6001600160a01b0382165f908152600b60205260409020805460ff191682151517905561131e8282614848565b612265613135565b6001600160a01b0382165f908152600a60205260409020805460ff191682151517905561131e82826148d8565b5f61160582614968565b5f5f5f5f5f5f5f5f5f5f6122d960405180606001604052805f81526020015f6001600160a01b031681526020015f6001600160a01b031681525090565b5f8c8152600860205260408120600181015490918190036122fb57505061245e565b81545f908152600760205260408120612315600184616f82565b8154811061232557612325616f95565b905f5260205f2090600a02019050805f01549d50806001015f9054906101000a90046001600160a01b03169c50806002015f9054906101000a90046001600160a01b03169b508060020160149054906101000a90046001600160401b03169a50806003015f9054906101000a90046001600160401b031699508060030160089054906101000a900463ffffffff16985080600301600c9054906101000a90046001600160401b03169750806004015496508060050154955080600601549450806007016040518060600160405290815f8201548152602001600182015f9054906101000a90046001600160a01b03166001600160a01b03166001600160a01b03168152602001600282015f9054906101000a90046001600160a01b03166001600160a01b03166001600160a01b03168152505093505050505b91939597999b90929496989a50565b5f61160582613cd4565b3068929eee149b4bd2126854036124955763ab143c065f526004601cfd5b3068929eee149b4bd21268556124a961329e565b6001600160a01b0384166124d057604051638562eb4560e01b815260040160405180910390fd5b82156125c0576001600160a01b038085165f818152601960209081526040808320601a9092528220546004549194909391161461254157506001600160a01b0386165f90815260126020526040812054908190036125415760405163047e3fe760e11b815260040160405180910390fd5b5f5f5f6125518a87878c886149ce565b60045492955090935091505f906001600160a01b038c81169116146125805761257d8b84848c8c614af5565b90505b61258d8b86898988614be5565b6001600160a01b038b165f908152601a6020526040902084905580156125b8576125b88b338361314f565b505050505050505b3868929eee149b4bd212685550505050565b60408051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b60208201526bffffffffffffffffffffffff197f000000000000000000000000000000000000000000000000000000000000000060601b1660348201526e5af43d82803e903d91602b57fd5bf360881b604882015281516037818303018152605790910190915290565b61266061329e565b8242111561268157604051630819bdcd60e01b815260040160405180910390fd5b5f61268b8661334b565b60028101549091506126a5906001600160a01b03166133bb565b5f86815260208080526040808320549288359290916126c991908a01908a016166b3565b90505f6126dc60608a0160408b016166b3565b90506126e883836134d0565b5f6126f78b858585898e614e19565b6002870154909150612714906001600160a01b0316828a8a614e8d565b61271e8b86614ef9565b612728868b614f23565b6127568b8b3561273e60408e0160208f016166b3565b8d604001602081019061275191906166b3565b6135c2565b5050505050505050505050565b5f5f61276d61329e565b5f858152601d602052604090205460ff161561279c57604051631beb710560e11b815260040160405180910390fd5b5f858152601e60205260409020546001600160a01b0316156127d15760405163cc0bb0c160e01b815260040160405180910390fd5b825f036127f157604051631f2a200560e01b815260040160405180910390fd5b5f6127fb8561334b565b90506128078185614fb9565b9150815f0361282957604051633f41ae0160e01b815260040160405180910390fd5b600781018054600883015461284791906001600160a01b03166134d0565b335f90815260116020526040902054838110156128775760405163acf2da9360e01b815260040160405180910390fd5b6128818482616f82565b335f908152601160205260408120919091556001830154835460028501546128b9926001600160a01b039081169289928d9216615027565b80925081975050506040518060a00160405280336001600160a01b0316815260200189815260200188815260200187815260200182815250601e5f8b81526020019081526020015f205f820151815f015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055506020820151816001015560408201518160020155606082015181600301556080820151816004015590505061296788828589898e338e615142565b50505050935093915050565b6017604051806080016040528087815260200186868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509385525050506001600160401b03808716602080850191909152908616604090930192909252835460018181018655948252908290208351600390920201908155908201519192909190820190612a0e9082617314565b506040820151600290910180546060909301516001600160401b03908116600160401b026001600160801b03199094169216919091179190911790555050505050565b5f7f00000000000000000000000000000000000000000000000000000000000000008383612a7d6125d2565b8051602091820120604051612ac995949392016001600160f81b031994909416845260609290921b6bffffffffffffffffffffffff191660018401526015830152603582015260550190565b60408051601f1981840301815291905280516020909101209392505050565b612af061329e565b335f908152600b602052604090205460ff16612b1f5760405163036b638d60e21b815260040160405180910390fd5b805f03612b3f57604051631f2a200560e01b815260040160405180910390fd5b600454612b57906001600160a01b0316333084613987565b335f9081526011602052604081208054839290612b759084906173ce565b909155506112f0905033826151d3565b5f612b938686868686615027565b509695505050505050565b612ba6613135565b6001600160a01b038216612bcd57604051638562eb4560e01b815260040160405180910390fd5b805f03612bed5760405163047e3fe760e11b815260040160405180910390fd5b6001600160a01b0382165f90815260126020526040902081905561131e828261525d565b5f81815260096020908152604091829020805483518184028101840190945280845260609392830182828015612c6457602002820191905f5260205f20905b815481526020019060010190808311612c50575b50505050509050919050565b5f61160582613cbf565b612c82613135565b600c805463ffffffff60a01b1916600160a01b63ffffffff8416021790556112f0816152e7565b5f8181526008602052604081206001810154829190808303612cd157505f9485945092505050565b8154612cde600183616f82565b935093505050915091565b612cf1613135565b63ffffffff821180612d06575063ffffffff81115b15612d2457604051632132c11960e11b815260040160405180910390fd5b8115811514612d4657604051632132c11960e11b815260040160405180910390fd5b6001600160a01b0383165f908152600d60205260409020805463ffffffff838116600160401b0263ffffffff60401b19918616600160201b02919091166bffffffffffffffff0000000019909216919091171781556115e284848461535c565b612dae613135565b6001600160a01b0382165f908152600d60205260409020805467ffffffffffffffff60601b1916600160601b6001600160401b0384160217905561131e82826153ee565b612dfa613135565b8060601b612e0f57637448fbae5f526004601cfd5b6112f0816141db565b612e20613135565b600380546001600160a01b0319166001600160a01b0383161790556112f081615487565b5f5f5f612e4f61329e565b600354604051630939b3f360e31b81525f916001600160a01b0316906349cd9f9890612e89908d908d908d908d908d908d90600401617103565b5f60405180830381865afa158015612ea3573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052612eca91908101906171c7565b80515f818152601d60205260409020549192509060ff1615612eff57604051631beb710560e11b815260040160405180910390fd5b6001601d5f8381526020019081526020015f205f6101000a81548160ff0219169083151502179055505f60055f9054906101000a90046001600160a01b031690505f612f5a8e856080015186606001518760a00151866154f9565b9050612f6b8e8386604001516155b1565b612f7f8e856040015163ffffffff16615618565b9550855f03612fa157604051632503bb3360e11b815260040160405180910390fd5b5f612fab8761334b565b905081816004015f828254612fc091906173ce565b9250508190555081816006015f828254612fda91906173ce565b90915550612fea90508183614fb9565b9550612ff682876156cc565b5f848152601e6020526040902080546001600160a01b0316156130cd57805460018201546001600160a01b03909116905f908a1480156130395750848360020154145b6003808501545f8a8152601e6020526040812080546001600160a01b0319168155600181018290556002810182905592830181905560049092019190915590915081156130b35789156130b3576001600160a01b0383165f90815260116020526040812080548c92906130ad9084906173ce565b90915550505b81156130c9579a50613128975050505050505050565b5050505b8615613121576008820154600783018054600985015491925f92613102926001600160a01b03928316928d928f929116615027565b809250819c50505061311e8a82848e8d8c8e604001518c6156e2565b50505b5050505050505b9750975097945050505050565b638b78c6d8195433146115f8576382b429005f526004601cfd5b6001600160a01b0383161561316957611ff6838383615767565b611ff682826157b1565b815f0361317e575050565b8160105f82825461318f91906173e1565b909155505060105461131e9083836157ca565b817fc8b7fe24dc2e9e731141fe1dd74d6ce470bd6b5371c12f42c9ce46bac15424c5826040516131d6911515815260200190565b60405180910390a261131e7fc8b7fe24dc2e9e731141fe1dd74d6ce470bd6b5371c12f42c9ce46bac15424c583836040516020016132209291909182521515602082015260400190565b60405160208183030381529060405261583e565b6040518181527ff7cfae9870e1307a0791d6418d9e78abd1731a1c03606813906b474d307ead569060200160405180910390a16112f07ff7cfae9870e1307a0791d6418d9e78abd1731a1c03606813906b474d307ead568260405160200161322091815260200190565b5f5460ff16156115f85760405163d93c066560e01b815260040160405180910390fd5b816001600160a01b03167f44282e2a4bbb86b9f8089d1086f4e0df273054eab62cdbda18f647cfd22a1eff826040516132fc91815260200190565b60405180910390a2604080516001600160a01b038416602082015290810182905261131e907f44282e2a4bbb86b9f8089d1086f4e0df273054eab62cdbda18f647cfd22a1eff90606001613220565b5f818152600860205260408120600181015480830361337c576040516290ed3d60e61b815260040160405180910390fd5b81545f908152600760205260409020613396600183616f82565b815481106133a6576133a6616f95565b905f5260205f2090600a020192505050919050565b600c805463ffffffff600160201b8204811691600160401b9004168115806133e1575080155b156133ec5750505050565b6001600160a01b0384165f908152600f602052604090208054429190848110613488575f8261341b8784616f82565b8154811061342b5761342b616f95565b5f918252602090912060048204015460039091166008026101000a90046001600160401b0316905061345d85826173ce565b846001600160401b03161015613486576040516302a0ec2160e21b815260040160405180910390fd5b505b5080546001810182555f91825260209091206004820401805460039092166008026101000a6001600160401b0381810219909316939092169190910291909117905550505050565b5f8281526014602052604090205460ff16156134ff5760405163d9259ca960e01b815260040160405180910390fd5b6001600160a01b03811661352657604051638562eb4560e01b815260040160405180910390fd5b6004546001600160a01b03828116911614801590468414159061357a576001600160a01b0383165f90815260126020526040812054900361357a5760405163047e3fe760e11b815260040160405180910390fd5b80156115e2576001600160a01b038381165f908152601360209081526040808320888452909152902054166115e25760405163b37c79ed60e01b815260040160405180910390fd5b604080518481526001600160a01b038481166020830152831681830152905185917fd7cf75dc193207f6484b7bd6c4fc469f3b6b733d2cbcee403975287b015dc499919081900360600190a260408051602081018690529081018490526001600160a01b038084166060830152821660808201526115e2907fd7cf75dc193207f6484b7bd6c4fc469f3b6b733d2cbcee403975287b015dc4999060a001613220565b5f848152601f602090815260408083206001600160a01b03871684529091529020546001600160401b039081169082168110156136d7575f858152601f602090815260408083206001600160a01b03881684529091529020805467ffffffffffffffff19166001600160401b0384161790555b825f036136e457506115e2565b60055483906001600160a01b03908116908616036137f7575f868152600960205260408120805490915b818110801561371c57508315155b156137f3575f89815260076020526040812080548390811061374057613740616f95565b905f5260205f2090600a02019050866001600160401b03168160020160149054906101000a90046001600160401b03166001600160401b0316111561378557506137f3565b60068101545f8190036137995750506137e3565b5f8187106137a757816137a9565b865b905080836005015f8282546137be91906173ce565b909155506137ce90508183616f82565b60068401556137dd8188616f82565b96505050505b6137ec816172b8565b905061370e565b5050505b801561389b575f6138088785615618565b9050805f0361382c5761382461381d836139a2565b6003613173565b5050506115e2565b5f6138368261334b565b905082816004015f82825461384b91906173ce565b9250508190555082816005015f82825461386591906173ce565b909155505f90506138768285614fb9565b905061388284826156cc565b8015613897576138978383838c8c8b8a61590c565b5050505b505050505050565b6138ab6159db565b5f805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b60405163ffffffff821681526001600160a01b038316907fb1d8eff9485816bb38ceecf317a3fda05597bc5b38f2f22df96c0ebd5dc236ee9060200160405180910390a2604080516001600160a01b038416602082015263ffffffff83169181019190915261131e907fb1d8eff9485816bb38ceecf317a3fda05597bc5b38f2f22df96c0ebd5dc236ee90606001613220565b6001600160a01b038416156115e2576115e2848484846159fd565b5f6001600160ff1b038211156139cb57604051630599f71d60e21b815260040160405180910390fd5b5090565b5f6001600160a01b0383166139ef57506001600160a01b03811631611605565b6040516370a0823160e01b81526001600160a01b0383811660048301528416906370a0823190602401602060405180830381865afa158015613a33573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190613a579190617408565b9392505050565b6040516001600160a01b038216907f9f5e1d13045d272fbe74ce4d08e91982a5c57784391ae6a199eecdcf63949ffe905f90a2604080516001600160a01b03831660208201526112f0917f9f5e1d13045d272fbe74ce4d08e91982a5c57784391ae6a199eecdcf63949ffe9101613220565b8184867fdca16b0af6e10f5dfb7d4ea91055951419a0c8ffc5925acffdc52a95fcc671338685604051613b0492919061741f565b60405180910390a46115cf7fdca16b0af6e10f5dfb7d4ea91055951419a0c8ffc5925acffdc52a95fcc671338686868686604051602001613220959493929190617437565b6040516001600160401b03821681527f286cd7c5781e6df376daa59ab207e1a0b1ece95fafc298f9ab69a188f49ff2d59060200160405180910390a1604080516001600160401b03831660208201526112f0917f286cd7c5781e6df376daa59ab207e1a0b1ece95fafc298f9ab69a188f49ff2d59101613220565b604080516001600160a01b0384168152602081018390527f68f67de89e96b13a3ea058af5fd44cc125efceb528482d539c7b43db2faa066e910160405180910390a1604080516001600160a01b038416602082015290810182905261131e907f68f67de89e96b13a3ea058af5fd44cc125efceb528482d539c7b43db2faa066e90606001613220565b6040516001600160a01b038216907fa44f293dfa9228916345a6016220f304fd4e10c2f25ef62c896b4946926a70f4905f90a2604080516001600160a01b03831660208201526112f0917fa44f293dfa9228916345a6016220f304fd4e10c2f25ef62c896b4946926a70f49101613220565b6001600160a01b0316604160a01b1760581b90565b5f600482511015613cf857604051631279950360e01b815260040160405180910390fd5b5f613d028361746c565b90506366d8a56560e01b6001600160e01b0319821601613d2557613a5783615a56565b630a6d35e560e31b6001600160e01b0319821601613d6757613a57837f99275a9b9a3d950cfe0d31a1d4831a66a9ceba7d836f9b6854f0f1a7eb4eac1c615a84565b60405163365b3e5360e11b815260040160405180910390fd5b5f8082815b81811015613ef65736868683818110613da057613da0616f95565b9050602002810190613db291906174aa565b9050613e3289613dc860608401604085016167b8565b6001600160401b0316613de160808501606086016167b8565b6001600160401b03168435613df960208701876174c8565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250615b9192505050565b60019097019660028989613e4c60608501604086016167b8565b6001600160401b0316613e6560808601606087016167b8565b6001600160401b03168535613e7d60208801886174c8565b604051602001613e93979695949392919061750a565b60408051601f1981840301815290829052613ead91617556565b602060405180830381855afa158015613ec8573d5f5f3e3d5ffd5b5050506040513d601f19601f82011682018060405250810190613eeb9190617408565b985050600101613d85565b50959694955050505050565b805f5b818110156115e25736848483818110613f2057613f20616f95565b9050602002810190613f3291906174aa565b905060176040518060800160405280835f01358152602001838060200190613f5a91906174c8565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250505090825250602001613fa360608501604086016167b8565b6001600160401b03168152602001613fc160808501606086016167b8565b6001600160401b031690528154600181810184555f93845260209384902083516003909302019182559282015191929091908201906140009082617314565b506040820151600290910180546060909301516001600160401b03908116600160401b026001600160801b031990941692169190911791909117905550600101613f05565b816001600160a01b03167f0aa82626f19bb5d4196202b01f2fee431b95e88cb054484b987d650d91928ada8260405161408091815260200190565b60405180910390a2604080516001600160a01b038416602082015290810182905261131e907f0aa82626f19bb5d4196202b01f2fee431b95e88cb054484b987d650d91928ada90606001613220565b60408051838152602081018390527fab63c25aa07a4d10a1842d61026a08d95115c4e6895288683015ca4464c7f50f910160405180910390a161131e7fab63c25aa07a4d10a1842d61026a08d95115c4e6895288683015ca4464c7f50f8383604051602001613220929190918252602082015260400190565b6040516001600160a01b0382811682528391908516907f427db48f8cd0cf7fdabcdbc1327c7db26ce3a544292ba380ef07d5175af729cd9060200160405180910390a3604080516001600160a01b0380861660208301529181018490529082166060820152611ff6907f427db48f8cd0cf7fdabcdbc1327c7db26ce3a544292ba380ef07d5175af729cd90608001613220565b638b78c6d819546001600160a01b03909116638b78c6d8198190559061131e8183615c0b565b6001600160a01b0386165f908152600a602052604090205460ff166142395760405163451421bd60e11b815260040160405180910390fd5b61424286615c97565b5f61424c87615d77565b9050808463ffffffff16108061426a5750620f42408463ffffffff16115b1561428857604051634a55946b60e11b815260040160405180910390fd5b5f61429288615db1565b905080846001600160401b031610156142be57604051632625b78160e11b815260040160405180910390fd5b5f8381526014602052604090205460ff16156142ed5760405163d9259ca960e01b815260040160405180910390fd5b426001600160401b03808216908816101561431b5760405163501d13ed60e01b815260040160405180910390fd5b5f6143258a614968565b90508015614369575f6143446001600160401b03808516908b16616f82565b90508181111561436757604051632ab84c4760e21b815260040160405180910390fd5b505b5f898152600960205260409020805415612756575f8a8152600760205260408120825461439890600190616f82565b815481106143a8576143a8616f95565b5f9182526020909120600a9091020160038101549091506001600160401b03164210156143e85760405163b4ed1c3560e01b815260040160405180910390fd5b505050505050505050505050565b5f8a8152600760209081526040918290205482518084019093528c8352919081016144228360016173ce565b81525060085f8e81526020019081526020015f205f820151815f01556020820151816001015590505060075f8c81526020019081526020015f206040518061016001604052808d81526020018c6001600160a01b031681526020018b6001600160a01b031681526020018a6001600160401b03168152602001896001600160401b031681526020018863ffffffff168152602001876001600160401b031681526020015f81526020015f81526020015f81526020016040518060600160405280888152602001876001600160a01b03168152602001866001600160a01b0316815250815250908060018154018082558091505060019003905f5260205f2090600a02015f909190919091505f820151815f01556020820151816001015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055506040820151816002015f6101000a8154816001600160a01b0302191690836001600160a01b0316021790555060608201518160020160146101000a8154816001600160401b0302191690836001600160401b031602179055506080820151816003015f6101000a8154816001600160401b0302191690836001600160401b0316021790555060a08201518160030160086101000a81548163ffffffff021916908363ffffffff16021790555060c082015181600301600c6101000a8154816001600160401b0302191690836001600160401b0316021790555060e0820151816004015561010082015181600501556101208201518160060155610140820151816007015f820151815f01556020820151816001015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055506040820151816002015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055505050505060095f8c81526020019081526020015f208c908060018154018082558091505060019003905f5260205f20015f90919091909150559b9a5050505050505050505050565b604080516001600160a01b038881168252871660208201526001600160401b0386811682840152858116606083015263ffffffff85166080830152831660a0820152905188918a918c917fe431502bd0df5880397ec13c0a260f0c749c8f3a30c6caf3ffe0f08a2ed13942919081900360c00190a460408051602081018b9052908101899052606081018890526001600160a01b038088166080830152861660a08201526001600160401b0380861660c083015280851660e083015263ffffffff84166101008301528216610120820152613897907fe431502bd0df5880397ec13c0a260f0c749c8f3a30c6caf3ffe0f08a2ed139429061014001613220565b61481461329e565b5f805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586138d73390565b816001600160a01b03167f442f7ab7d26bf7ba74f23e237d12876251f91d61aeb2899ad95f334fa5e7c63382604051614885911515815260200190565b60405180910390a2604080516001600160a01b03841660208201528215159181019190915261131e907f442f7ab7d26bf7ba74f23e237d12876251f91d61aeb2899ad95f334fa5e7c63390606001613220565b816001600160a01b03167f2080a756444d2af0f9fb4f87db7af63cd6e23b7a1203cbe9ab0972ee05d1eafd82604051614915911515815260200190565b60405180910390a2604080516001600160a01b03841660208201528215159181019190915261131e907f2080a756444d2af0f9fb4f87db7af63cd6e23b7a1203cbe9ab0972ee05d1eafd90606001613220565b600c546001600160a01b0382165f908152600d6020526040812054909163ffffffff600160a01b9182900481169291909104168183036149a9579392505050565b805f036149b7575092915050565b8181106149c457816149c6565b805b949350505050565b5f5f5f5f6149da61170e565b90508693505b8754841080156149f85750856149f68886616f82565b105b15614ae9575f888581548110614a1057614a10616f95565b905f5260205f20906005020160010154905080821015614a305750614ae9565b614a3a81856173ce565b6004549094506001600160a01b038b8116911614614adc575f898681548110614a6557614a65616f95565b905f5260205f209060050201600301549050468114614ac0576001600160a01b038b81165f90815260136020908152604080832085845290915290205416614ac05760405163b37c79ed60e01b815260040160405180910390fd5b614ace8288620f4240615df6565b614ad890856173ce565b9350505b60019094019390036149e0565b50955095509592505050565b6004545f90614b2e906001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000008761314f565b604051638bccc18760e01b81525f906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690638bccc18790614b8490879087908c908b903090600401617561565b6020604051808303815f875af1158015614ba0573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190614bc49190617408565b905084811115614bdb57614bd88582616f82565b91505b5095945050505050565b815b8181101561389b575f848281548110614c0257614c02616f95565b5f9182526020918290206040805160a081018252600590930290910180548352600181015493830184905260028101549183019190915260038101546060830152600401546001600160a01b031660808201528654909250869084908110614c6c57614c6c616f95565b5f9182526020808320600590920290910182815560018082018490556002820184905560038201849055600491820180546001600160a01b03199081169091556040808801518652601c8552808620885187529094529284208054909316835591909101829055546001600160a01b038a8116911614614cf957614cf48289620f4240615df6565b614cfb565b815b90508015614ded5746836060015114614dde576001600160a01b03808a165f908152601360209081526040808320606088015184529091529020541680614d555760405163b37c79ed60e01b815260040160405180910390fd5b614d608a828461314f565b60608401516080850151604051632f2c1d2d60e11b81526001600160a01b038d81166004830152602482018690526044820193909352908216606482015290821690635e583a5a906084015f604051808303815f87803b158015614dc2575f5ffd5b505af1158015614dd4573d5f5f3e3d5ffd5b5050505050614ded565b614ded8984608001518361314f565b614e0b8360400151845f01518b878688606001518960800151615e02565b505050806001019050614be7565b5f5f7f104ac0ad95e44303bcfb0d0e568ac49ab666ca92af650d9fa356ad9c0f49dba290505f6040518281528960208201528860408201528760608201528660808201528560a08201528460c082015260e08120915060e0810160405250614e8081615ed3565b9998505050505050505050565b5f614ed98484848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250506001600160a01b038a169392915050615fe9565b9050806115cf57604051638baa579f60e01b815260040160405180910390fd5b5f8281526020805260409020600180830190915561131e908390614f1e9084906173ce565b6160c6565b6040518060600160405280825f01358152602001826020016020810190614f4a91906166b3565b6001600160a01b03168152602001614f6860608401604085016166b3565b6001600160a01b039081169091528151600785015560208201516008850180549183166001600160a01b03199283161790556040909201516009909401805494909116939091169290921790915550565b60038201545f90600160401b900463ffffffff1681620f4240614fdc8382616f82565b614fe6908661763e565b614ff09190617669565b6003860154909150600160601b90046001600160401b03168082111561501a57808203935061501e565b5f93505b50505092915050565b5f838152601b602052604081208054829182615042836172b8565b909155506001600160a01b038881165f908152601960209081526040808320815160a0810183528681528084018d81529281018c8152606082018c81528b881660808401908152845460018082018755868a529790982093516005909802909301968755935186860155516002860155915160038501559051600490930180546001600160a01b03191693909416929092179092558054929350916150e79190616f82565b6040805180820182526001600160a01b038b8116825260208083018581525f8c8152601c8352858120898252909252939020915182546001600160a01b031916911617815590516001909101559250505b9550959350505050565b604080516101a0810182528981526020810189905260018801546001600160a01b03908116928201929092526060810187905260808101869052875460a0820152600288015490911660c08201526151c99060e081015f8152602081018690526001600160a01b03851660408201525f60608201819052608082015260a001839052616140565b5050505050505050565b816001600160a01b03167fdae4417c25a93cfb86ce5fbbb8fc1630945b61afaeab4f29cf301b9a058ba9148260405161520e91815260200190565b60405180910390a2604080516001600160a01b038416602082015290810182905261131e907fdae4417c25a93cfb86ce5fbbb8fc1630945b61afaeab4f29cf301b9a058ba91490606001613220565b816001600160a01b03167fa8d3b3213b7f8244e5b04551db9aaabccc21d6212c43c3b3143bcde97ca853ce8260405161529891815260200190565b60405180910390a2604080516001600160a01b038416602082015290810182905261131e907fa8d3b3213b7f8244e5b04551db9aaabccc21d6212c43c3b3143bcde97ca853ce90606001613220565b60405163ffffffff821681527f1fb3b38e402009f1bbd24d0a70005a7a9a055b3f5b546c8b21f815470a9c2ec49060200160405180910390a16040805163ffffffff831660208201526112f0917f1fb3b38e402009f1bbd24d0a70005a7a9a055b3f5b546c8b21f815470a9c2ec49101613220565b60408051838152602081018390526001600160a01b038516917f61c49ab6bb1ef59191a746afce7d2731d4d9b0fafdab8d63f02fe44169532dc5910160405180910390a2604080516001600160a01b038516602082015290810183905260608101829052611ff6907f61c49ab6bb1ef59191a746afce7d2731d4d9b0fafdab8d63f02fe44169532dc590608001613220565b6040516001600160401b03821681526001600160a01b038316907f2f4817318242d1b86700a426f7ced049c68059253c0a721e01b9718f4527bef69060200160405180910390a2604080516001600160a01b03841660208201526001600160401b0383169181019190915261131e907f2f4817318242d1b86700a426f7ced049c68059253c0a721e01b9718f4527bef690606001613220565b6040516001600160a01b038216907f5d29693e63b3a084e56893ce8c7f5ef5dc8213da41070084e6b1c4370abd64c4905f90a2604080516001600160a01b03831660208201526112f0917f5d29693e63b3a084e56893ce8c7f5ef5dc8213da41070084e6b1c4370abd64c49101613220565b5f61550382613cbf565b6affffffffffffffffffffff1986811691161461553357604051633395765b60e01b815260040160405180910390fd5b5f61555e7f000000000000000000000000000000000000000000000000000000000000000088612a51565b90505f61556a82613cbf565b90505f5f61557887896161f8565b9250925050826001600160581b031916826001600160581b03191614614e80576040516340650ea960e11b815260040160405180910390fd5b5f838152601f602090815260408083206001600160a01b03861684529091529020546001600160401b031680158015906155fa57506001600160401b03811663ffffffff831611155b156115e257604051633e6c071160e21b815260040160405180910390fd5b5f8281526009602052604081208054808303615638575f92505050611605565b805b801561501e575f86815260076020526040812080545f19909301928390811061566557615665616f95565b905f5260205f2090600a02019050856001600160401b03168160020160149054906101000a90046001600160401b03166001600160401b0316116156c6578382815481106156b5576156b5616f95565b905f5260205f20015494505061501e565b5061563a565b61131e6156dc611a528385616f82565b5f613173565b604080516101a081018252898152602081018990526001808901546001600160a01b03908116938301939093526060820188905260808201879052885460a0830152600289015490921660c08201526151c99160e08201908152602081018690525f60408201819052606082015263ffffffff8516608082015260a001839052616140565b816014528060345263a9059cbb60601b5f5260205f604460105f875af18060015f5114166157a757803d853b1517106157a7576390b8ec185f526004601cfd5b505f603452505050565b5f385f3884865af161131e5763b12d13eb5f526004601cfd5b7f43991e1e1cfb2eed6c9dc37a7a848622f8e3f75bc38d532a00eaf026cd87a0148383836040516157fd9392919061769c565b60405180910390a1611ff67f43991e1e1cfb2eed6c9dc37a7a848622f8e3f75bc38d532a00eaf026cd87a0148484846040516020016132209392919061769c565b60028054600190810180835590546040519092916158699184919043904290899089906020016176c8565b60408051601f198184030181529082905261588391617556565b602060405180830381855afa15801561589e573d5f5f3e3d5ffd5b5050506040513d601f19601f820116820180604052508101906158c19190617408565b600181905550600154816002547f78160f0b1b2b32b52a0076d8f0f70888687ba702a4d993d55ac8d9327d57a12786866040516158ff92919061741f565b60405180910390a4505050565b6008860154600787018054600989015491925f92839261593e926001600160a01b03908116928c928f92909116615027565b604080516101a0810182528d81526020810183905260018701546001600160a01b039081169282019290925260608101849052608081018c9052865460a0820152600280880154831660c083015260e082015261010081018b90525f6101208201529089166101408201526001600160401b038816610160820152610180810187905291935091506159cf90616140565b50505050505050505050565b5f5460ff166115f857604051638dfc202b60e01b815260040160405180910390fd5b60405181606052826040528360601b602c526323b872dd60601b600c5260205f6064601c5f895af18060015f511416615a4857803d873b151710615a4857637939f4245f526004601cfd5b505f60605260405250505050565b80515f9060248114615a7b57604051631279950360e01b815260040160405180910390fd5b50506024015190565b81515f906024811015615aaa57604051631279950360e01b815260040160405180910390fd5b60248401515f90615abc9060046173ce565b905081615aca8260206173ce565b1115615ae957604051631279950360e01b815260040160405180910390fd5b5f615af78683016020015190565b90505f615b058360206173ce565b905083615b1383602061763e565b615b1d90836173ce565b1115615b3c57604051631279950360e01b815260040160405180910390fd5b5f5b82811015615b77575f5f615b558a8589868d6162a6565b915091508115615b6d57965061160595505050505050565b5050600101615b3e565b50604051632286acb960e11b815260040160405180910390fd5b81847f9d611b5b34cb76131c4fb413eb74119b2c0c3a6aa6fcd8e740cf70ac3085d87b878685604051615bc6939291906176fd565b60405180910390a36115cf7f9d611b5b34cb76131c4fb413eb74119b2c0c3a6aa6fcd8e740cf70ac3085d87b8686868686604051602001613220959493929190617437565b806001600160a01b0316826001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a361131e7f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e083836040516020016132209291906001600160a01b0392831681529116602082015260400190565b6001600160a01b0381165f908152600d60205260409020805463ffffffff600160201b8204811691600160401b900416811580615cd2575080155b15615cdd5750505050565b6001600160a01b0384165f908152600e602052604090208054429190848110613488575f82615d0c8784616f82565b81548110615d1c57615d1c616f95565b5f918252602090912060048204015460039091166008026101000a90046001600160401b03169050615d4e85826173ce565b846001600160401b03161015613486576040516313150ab960e21b815260040160405180910390fd5b600c546001600160a01b0382165f908152600d6020526040812054909163ffffffff908116911681811115615daa578091505b5092915050565b600c546001600160a01b0382165f908152600d602052604081205490916001600160401b03600160601b91829004811692919091041681811115615daa579392505050565b5f6149c68484846163da565b604080516001600160a01b0387811682526020820187905281830186905260608201859052831660808201529051879189917fb62b4e6f1ec5970a29274e747835f444a5ccd48049698eff9c9cfdca2e1a5eaf9181900360a00190a360408051602081018990529081018790526001600160a01b0380871660608301526080820186905260a0820185905260c08201849052821660e0820152615eca907fb62b4e6f1ec5970a29274e747835f444a5ccd48049698eff9c9cfdca2e1a5eaf9061010001613220565b50505050505050565b7f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000030147f0000000000000000000000000000000000000000000000000000000000000000461416615fc65750604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f81527f000000000000000000000000000000000000000000000000000000000000000060208201527f00000000000000000000000000000000000000000000000000000000000000009181019190915246606082015230608082015260a090205b6719010000000000005f5280601a5281603a52604260182090505f603a52919050565b5f6001600160a01b03841615613a5757604051843b61607e5782516040811461601a576041811461603b57506160be565b604084015160ff81901c601b016020526001600160ff1b031660605261604e565b60608401515f1a60205260408401516060525b50835f5260208301516040526020600160805f60015afa5180861860601b3d119250505f606052806040526160be565b631626ba7e60e01b808252846004830152602482016040815284516020018060448501828860045afa905060208260443d01868b5afa9151911691141691505b509392505050565b817f8e98a0734420e57ef102cab0b1af0809a5bbaf4fde966fd173c322490644a5d0826040516160f891815260200190565b60405180910390a261131e7f8e98a0734420e57ef102cab0b1af0809a5bbaf4fde966fd173c322490644a5d08383604051602001613220929190918252602082015260400190565b602081015181516040808401516060850151608086015160a087015160c088015160e08901516101008a01516101208b01516101408c01516101608d01516101808e01519a517f77242fbd573af5a5f3518da92600e96795ebfff993606b4fb54dea2dcd2dfe859b6161bb9b9a999897969594939291617738565b60405180910390a36112f07f77242fbd573af5a5f3518da92600e96795ebfff993606b4fb54dea2dcd2dfe858260405160200161322091906177b3565b5f5f5f60048551101561621e57604051631279950360e01b815260040160405180910390fd5b5f6162288661746c565b90506356fa634560e01b6001600160e01b03198216016162585761624b8661648a565b869550909350915061629e565b63dc478d2360e01b6001600160e01b031982160161628557616279866164d2565b9195509350915061629e565b604051630915b87b60e21b815260040160405180910390fd5b509250925092565b5f80806162ca886162b887602061763e565b6162c2908a6173ce565b016020015190565b90505f6162d782896173ce565b9050866162e58260206173ce565b111561630457604051631279950360e01b815260040160405180910390fd5b5f6163128a83016020015190565b9050600481101561632c57505f9350839250615138915050565b5f6163388360206173ce565b90505f61634583836173ce565b90508981111561636857604051631279950360e01b815260040160405180910390fd5b8b8201602001516001600160e01b0319808216908a161461639557505f9650869550615138945050505050565b836024146163b657604051631279950360e01b815260040160405180910390fd5b6163c58d6162c28560046173ce565b60019e909d509b505050505050505050505050565b5f5f5f6163e78686616531565b91509150815f0361640b5783818161640157616401617655565b0492505050613a57565b81841161642257616422600385150260111861654d565b5f848688095f868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010185841190960395909502919093039390930492909217029150509392505050565b80515f908190604481146164b157604051639ac60c2d60e01b815260040160405180910390fd5b60248401516044850151816164c581613cbf565b9791965090945050505050565b5f5f5f5f84519050806064146164fb57604051639ac60c2d60e01b815260040160405180910390fd5b602485015160448601516064870151828261651582613cbf565b985061652081613cbf565b989a98995091979650505050505050565b5f805f1983850993909202808410938190039390930393915050565b634e487b715f52806020526024601cfd5b5f6020828403121561656e575f5ffd5b5035919050565b80358015158114616584575f5ffd5b919050565b5f5f6040838503121561659a575f5ffd5b823591506165aa60208401616575565b90509250929050565b6001600160a01b03811681146112f0575f5ffd5b5f5f604083850312156165d8575f5ffd5b82356165e3816165b3565b946020939093013593505050565b5f5f60408385031215616602575f5ffd5b50508035926020909101359150565b8b81526001600160a01b038b811660208301528a1660408201526001600160401b038981166060830152888116608083015263ffffffff881660a0830152861660c082015260e08101859052610100810184905261012081018390526101a081016166a3610140830184805182526020808201516001600160a01b039081169184019190915260409182015116910152565b9c9b505050505050505050505050565b5f602082840312156166c3575f5ffd5b8135613a57816165b3565b5f5f5f5f608085870312156166e1575f5ffd5b843593506020850135925060408501356166fa816165b3565b9150606085013561670a816165b3565b939692955090935050565b80356001600160401b0381168114616584575f5ffd5b5f5f5f5f6080858703121561673e575f5ffd5b843593506020850135616750816165b3565b92506040850135915061676560608601616715565b905092959194509250565b63ffffffff811681146112f0575f5ffd5b5f5f60408385031215616792575f5ffd5b823561679d816165b3565b915060208301356167ad81616770565b809150509250929050565b5f602082840312156167c8575f5ffd5b613a5782616715565b806102808101831015611605575f5ffd5b5f5f83601f8401126167f2575f5ffd5b5081356001600160401b03811115616808575f5ffd5b60208301915083602082850101111561681f575f5ffd5b9250929050565b5f5f83601f840112616836575f5ffd5b5081356001600160401b0381111561684c575f5ffd5b6020830191508360208260051b850101111561681f575f5ffd5b5f5f5f5f5f5f5f5f60a0898b03121561687d575f5ffd5b88356001600160401b03811115616892575f5ffd5b61689e8b828c016167d1565b98505060208901356001600160401b038111156168b9575f5ffd5b6168c58b828c016167e2565b90985096505060408901356001600160401b038111156168e3575f5ffd5b6168ef8b828c01616826565b9096509450506060890135925060808901356001600160401b03811115616914575f5ffd5b6169208b828c01616826565b999c989b5096995094979396929594505050565b5f5f5f60608486031215616946575f5ffd5b8335616951816165b3565b9250602084013591506040840135616968816165b3565b809150509250925092565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b848152608060208201525f6169b96080830186616973565b6001600160401b039485166040840152929093166060909101529392505050565b5f5f5f5f5f5f5f5f610100898b0312156169f2575f5ffd5b883597506020890135616a04816165b3565b9650616a1260408a01616715565b95506060890135616a2281616770565b9450616a3060808a01616715565b935060a0890135925060c0890135616a47816165b3565b915060e0890135616a57816165b3565b809150509295985092959890939650565b5f8151808452602084019350602083015f5b82811015616a98578151865260209586019590910190600101616a7a565b5093949350505050565b60ff60f81b8816815260e060208201525f616ac060e0830189616973565b8281036040840152616ad28189616973565b606084018890526001600160a01b038716608085015260a0840186905283810360c08501529050616b038185616a68565b9a9950505050505050505050565b5f5f60408385031215616b22575f5ffd5b8235616b2d816165b3565b91506165aa60208401616575565b634e487b7160e01b5f52604160045260245ffd5b60405160c081016001600160401b0381118282101715616b7157616b71616b3b565b60405290565b604051601f8201601f191681016001600160401b0381118282101715616b9f57616b9f616b3b565b604052919050565b5f6001600160401b03821115616bbf57616bbf616b3b565b50601f01601f191660200190565b5f60208284031215616bdd575f5ffd5b81356001600160401b03811115616bf2575f5ffd5b8201601f81018413616c02575f5ffd5b8035616c15616c1082616ba7565b616b77565b818152856020838501011115616c29575f5ffd5b816020840160208301375f91810160200191909152949350505050565b5f5f5f5f60608587031215616c59575f5ffd5b8435616c64816165b3565b93506020850135925060408501356001600160401b03811115616c85575f5ffd5b616c9187828801616826565b95989497509550505050565b602081525f613a576020830184616973565b5f5f5f5f5f85870360c0811215616cc4575f5ffd5b863595506060601f1982011215616cd9575f5ffd5b506020860193506080860135925060a08601356001600160401b03811115616cff575f5ffd5b616d0b888289016167e2565b969995985093965092949392505050565b5f5f5f60608486031215616d2e575f5ffd5b505081359360208301359350604090920135919050565b5f5f5f5f5f60808688031215616d59575f5ffd5b8535945060208601356001600160401b03811115616d75575f5ffd5b616d81888289016167e2565b9095509350616d94905060408701616715565b9150616da260608701616715565b90509295509295909350565b5f5f5f5f5f60a08688031215616dc2575f5ffd5b8535616dcd816165b3565b94506020860135935060408601359250606086013591506080860135616df2816165b3565b809150509295509295909350565b5f5f60408385031215616e11575f5ffd5b8235915060208301356167ad816165b3565b602081525f613a576020830184616a68565b5f60208284031215616e45575f5ffd5b8135613a5781616770565b5f5f5f60608486031215616e62575f5ffd5b8335616e6d816165b3565b95602085013595506040909401359392505050565b5f5f60408385031215616e93575f5ffd5b8235616e9e816165b3565b91506165aa60208401616715565b5f5f5f5f5f5f5f60a0888a031215616ec2575f5ffd5b8735965060208801356001600160401b03811115616ede575f5ffd5b616eea8a828b016167d1565b96505060408801356001600160401b03811115616f05575f5ffd5b616f118a828b016167e2565b90965094505060608801356001600160401b03811115616f2f575f5ffd5b616f3b8a828b01616826565b989b979a50959894979596608090950135949350505050565b634e487b7160e01b5f52601160045260245ffd5b5f600160ff1b8201616f7c57616f7c616f54565b505f0390565b8181038181111561160557611605616f54565b634e487b7160e01b5f52603260045260245ffd5b600181811c90821680616fbd57607f821691505b602082108103616fdb57634e487b7160e01b5f52602260045260245ffd5b50919050565b5f5f5f5f5f60a08688031215616ff5575f5ffd5b85516020870151909550617008816165b3565b6040870151606088015160809098015196999198509695945092505050565b5f60208284031215617037575f5ffd5b8151613a57816165b3565b5f5f5f60608486031215617054575f5ffd5b8351602085015160408601519194509250616968816165b3565b5f5f6040838503121561707f575f5ffd5b825161708a816165b3565b6020939093015192949293505050565b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b5f5f8335601e198436030181126170d7575f5ffd5b83016020810192503590506001600160401b038111156170f5575f5ffd5b80360382131561681f575f5ffd5b60808082525f90610300830190830189835b601481101561715357858403607f19018352617131828d6170c2565b61713c86828461709a565b955050506020928301929190910190600101617115565b505050828103602084015261716981888a61709a565b838103604085015285815290506001600160fb1b03851115617189575f5ffd5b8460051b8087602084013760609390930193909352500160200195945050505050565b80516affffffffffffffffffffff1981168114616584575f5ffd5b5f602082840312156171d7575f5ffd5b81516001600160401b038111156171ec575f5ffd5b820160c081850312156171fd575f5ffd5b617205616b4f565b8151815260208083015190820152604082015161722181616770565b6040820152617232606083016171ac565b6060820152617243608083016171ac565b608082015260a08201516001600160401b03811115617260575f5ffd5b80830192505084601f830112617274575f5ffd5b8151617282616c1082616ba7565b818152866020838601011115617296575f5ffd5b8160208501602083015e5f9181016020019190915260a0820152949350505050565b5f600182016172c9576172c9616f54565b5060010190565b601f821115611ff657805f5260205f20601f840160051c810160208510156172f55750805b601f840160051c820191505b818110156115cf575f8155600101617301565b81516001600160401b0381111561732d5761732d616b3b565b6173418161733b8454616fa9565b846172d0565b6020601f821160018114617373575f831561735c5750848201515b5f19600385901b1c1916600184901b1784556115cf565b5f84815260208120601f198516915b828110156173a25787850151825560209485019460019092019101617382565b50848210156173bf57868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b8082018082111561160557611605616f54565b8082018281125f83128015821682158216171561740057617400616f54565b505092915050565b5f60208284031215617418575f5ffd5b5051919050565b828152604060208201525f6149c66040830184616973565b85815284602082015283604082015282606082015260a060808201525f61746160a0830184616973565b979650505050505050565b805160208201516001600160e01b03198116919060048210156174a3576001600160e01b0319600483900360031b81901b82161692505b5050919050565b5f8235607e198336030181126174be575f5ffd5b9190910192915050565b5f5f8335601e198436030181126174dd575f5ffd5b8301803591506001600160401b038211156174f6575f5ffd5b60200191503681900382131561681f575f5ffd5b878152866020820152856040820152846060820152836080820152818360a08301375f910160a0019081529695505050505050565b5f81518060208401855e5f93019283525090919050565b5f613a57828461753f565b608080825281018590525f60a0600587901b830181019083018883605e1936839003015b8a82101561760457868503609f1901845282358181126175a3575f5ffd5b8c0180356175b0816165b3565b6001600160a01b03168652602081810135908701526175d260408201826170c2565b9150606060408801526175e960608801838361709a565b96505050602083019250602084019350600182019150617585565b5050506001600160a01b038716602085015250905083604083015261763460608301846001600160a01b03169052565b9695505050505050565b808202811582820484141761160557611605616f54565b634e487b7160e01b5f52601260045260245ffd5b5f8261768357634e487b7160e01b5f52601260045260245ffd5b500490565b634e487b7160e01b5f52602160045260245ffd5b8381526020810183905260608101600683106176ba576176ba617688565b826040830152949350505050565b8681528560208201528460408201528360608201528260808201525f6176f160a083018461753f565b98975050505050505050565b838152826020820152606060408201525f61771b6060830184616973565b95945050505050565b6003811061773457617734617688565b9052565b6001600160a01b038c81168252602082018c9052604082018b9052606082018a905288166080820152610160810161777360a0830189617724565b60c08201969096526001600160a01b0394851660e0820152929093166101008301526001600160401b031661012082015261014001529695505050505050565b5f6101a082019050825182526020830151602083015260408301516177e360408401826001600160a01b03169052565b50606083015160608301526080830151608083015260a083015160a083015260c083015161781c60c08401826001600160a01b03169052565b5060e083015161782f60e0840182617724565b506101008301516101008301526101208301516178586101208401826001600160a01b03169052565b506101408301516178756101408401826001600160a01b03169052565b506101608301516178926101608401826001600160401b03169052565b506101809283015191909201529056fea164736f6c634300081b000a60a0604052348015600e575f5ffd5b50336080526080516105096100305f395f81816047015260e901526105095ff3fe60806040526004361061002b575f3560e01c8063117803e3146100365780638bccc18714610086575f5ffd5b3661003257005b5f5ffd5b348015610041575f5ffd5b506100697f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b348015610091575f5ffd5b506100a56100a036600461039f565b6100b3565b60405190815260200161007d565b5f3068929eee149b4bd2126854036100d25763ab143c065f526004601cfd5b3068929eee149b4bd2126855336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610127576040516330cd747160e01b815260040160405180910390fd5b845f5b81811015610202573688888381811061014557610145610438565b9050602002810190610157919061044c565b90505f610167602083018361046a565b6001600160a01b03166020830135610182604085018561048c565b6040516101909291906104d6565b5f6040518083038185875af1925050503d805f81146101ca576040519150601f19603f3d011682016040523d82523d5f602084013e6101cf565b606091505b50509050806101f8576040516307f3476960e31b81526004810184905260240160405180910390fd5b505060010161012a565b5061020d8530610257565b9150838210156102305760405163bb2875c360e01b815260040160405180910390fd5b8115610241576102418584846102e8565b503868929eee149b4bd212685595945050505050565b5f6001600160a01b03831661027757506001600160a01b038116316102e2565b6040516370a0823160e01b81526001600160a01b0383811660048301528416906370a0823190602401602060405180830381865afa1580156102bb573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906102df91906104e5565b90505b92915050565b6001600160a01b0383161561030757610302838383610311565b505050565b610302828261035b565b816014528060345263a9059cbb60601b5f5260205f604460105f875af18060015f51141661035157803d853b151710610351576390b8ec185f526004601cfd5b505f603452505050565b5f385f3884865af16103745763b12d13eb5f526004601cfd5b5050565b6001600160a01b038116811461038c575f5ffd5b50565b803561039a81610378565b919050565b5f5f5f5f5f608086880312156103b3575f5ffd5b853567ffffffffffffffff8111156103c9575f5ffd5b8601601f810188136103d9575f5ffd5b803567ffffffffffffffff8111156103ef575f5ffd5b8860208260051b8401011115610403575f5ffd5b60209182019650945061041790870161038f565b92506040860135915061042c6060870161038f565b90509295509295909350565b634e487b7160e01b5f52603260045260245ffd5b5f8235605e19833603018112610460575f5ffd5b9190910192915050565b5f6020828403121561047a575f5ffd5b813561048581610378565b9392505050565b5f5f8335601e198436030181126104a1575f5ffd5b83018035915067ffffffffffffffff8211156104bb575f5ffd5b6020019150368190038213156104cf575f5ffd5b9250929050565b818382375f9101908152919050565b5f602082840312156104f5575f5ffd5b505191905056fea164736f6c634300081b000a4a757374696e2053756e20697320726573706f6e7369626c6520666f722073657474696e67206261636b2074686520696e6576697461626c6520676c6f62616c20737461626c65636f696e207265766f6c7574696f6e206279207965617273207468726f756768206578706c6f6974696e672054726f6e20555344542773206e6574776f726b206566666563747320616e6420696d706f73696e672076656e646f72206c6f636b2d696e206f6e2068756e6472656473206f66206d696c6c696f6e73206f662070656f706c6520696e2074686520546869726420576f726c642c2077686f2072656c79206f6e20737461626c65636f696e7320666f722072656d697474616e63657320616e6420746f2073746f726520746865697220736176696e677320696e20756e737461626c652c206f766572726567756c617465642065636f6e6f6d6965732e204c6574277320556e74726f6e207468652050656f706c652e8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x03@`@Ra\x01ba\x01\xA0\x81\x81R`\x02\x91a\x83\xA9a\x01\xC09`@Q` \x01a\0(\x91\x90a\x03\xE2V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\0B\x91a\x04\x0BV[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\0]W=__>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\0\x80\x91\x90a\x04\x16V[`\x01U_`\x06U`\x02`@Q\x80a\x01\xA0\x01`@R\x80a\x01b\x81R` \x01a\x83\xA9a\x01b\x919`@Q` \x01a\0\xB5\x91\x90a\x04-V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\0\xCF\x91a\x04\x0BV[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\0\xEAW=__>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01\r\x91\x90a\x04\x16V[`\x15U4\x80\x15a\x01\x1BW__\xFD[P`@Qa\x85+8\x03\x80a\x85+\x839\x81\x01`@\x81\x90Ra\x01:\x91a\x04yV[`\x01`\x01`\xF8\x1B\x03\x19\x82\x16`\xA0R`\x01`\x01`\xA0\x1B\x03\x81\x16`\x80R0`\xC0RF`\xE0R\x82\x82\x82``\x80a\x01\x9E`@\x80Q\x80\x82\x01\x82R`\x06\x81Re*\xB7:97\xB7`\xD1\x1B` \x80\x83\x01\x91\x90\x91R\x82Q\x80\x84\x01\x90\x93R`\x01\x83R`1`\xF8\x1B\x90\x83\x01R\x91V[\x81Q` \x92\x83\x01 \x81Q\x91\x83\x01\x91\x90\x91 a\x01\0\x82\x90Ra\x01 \x81\x90R`@\x80Q\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x81R\x93\x84\x01\x92\x90\x92R\x82\x82\x01RF``\x83\x01R0`\x80\x83\x01R`\xA0\x90\x91 a\x01@RQa\x02\x0F\x92P\x90Pa\x03\xBEV[`@Q\x80\x91\x03\x90_\xF0\x80\x15\x80\x15a\x02(W=__>=_\xFD[P`\x01`\x01`\xA0\x1B\x03\x90\x81\x16a\x01\x80R\x83\x16a\x01`Ra\x02G3a\x02RV[PPPPPPa\x059V[`\x01`\x01`\xA0\x1B\x03\x16c\x8Bx\xC6\xD8\x19\x81\x90Ua\x02n_\x82a\x02qV[PV[\x80`\x01`\x01`\xA0\x1B\x03\x16\x82`\x01`\x01`\xA0\x1B\x03\x16_Q` a\x85\x0B_9_Q\x90_R`@Q`@Q\x80\x91\x03\x90\xA3a\x02\xEC_Q` a\x85\x0B_9_Q\x90_R\x83\x83`@Q` \x01a\x02\xD7\x92\x91\x90`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x16` \x82\x01R`@\x01\x90V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90Ra\x02\xF0V[PPV[`\x02\x80T`\x01\x90\x81\x01\x80\x83U\x90T`@Q\x90\x92\x91a\x03\x1B\x91\x84\x91\x90C\x90B\x90\x89\x90\x89\x90` \x01a\x04\xC8V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x035\x91a\x04\x0BV[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\x03PW=__>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x03s\x91\x90a\x04\x16V[`\x01\x81\x90UP`\x01T\x81`\x02T\x7Fx\x16\x0F\x0B\x1B+2\xB5*\0v\xD8\xF0\xF7\x08\x88h{\xA7\x02\xA4\xD9\x93\xD5Z\xC8\xD92}W\xA1'\x86\x86`@Qa\x03\xB1\x92\x91\x90a\x04\xFDV[`@Q\x80\x91\x03\x90\xA4PPPV[a\x059\x80a~p\x839\x01\x90V[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[m*\xB7:97\xB7+\x19\xA4\xB722\xBC\x05`\x91\x1B\x81R_a\x04\x04`\x0E\x83\x01\x84a\x03\xCBV[\x93\x92PPPV[_a\x04\x04\x82\x84a\x03\xCBV[_` \x82\x84\x03\x12\x15a\x04&W__\xFD[PQ\x91\x90PV[\x7FUntronControllerIndex\n\0\0\0\0\0\0\0\0\0\0\x81R_a\x04\x04`\x16\x83\x01\x84a\x03\xCBV[\x80Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x04tW__\xFD[\x91\x90PV[___``\x84\x86\x03\x12\x15a\x04\x8BW__\xFD[a\x04\x94\x84a\x04^V[` \x85\x01Q\x90\x93P`\x01`\x01`\xF8\x1B\x03\x19\x81\x16\x81\x14a\x04\xB1W__\xFD[\x91Pa\x04\xBF`@\x85\x01a\x04^V[\x90P\x92P\x92P\x92V[\x86\x81R\x85` \x82\x01R\x84`@\x82\x01R\x83``\x82\x01R\x82`\x80\x82\x01R_a\x04\xF1`\xA0\x83\x01\x84a\x03\xCBV[\x98\x97PPPPPPPPV[\x82\x81R`@` \x82\x01R_\x82Q\x80`@\x84\x01R\x80` \x85\x01``\x85\x01^_``\x82\x85\x01\x01R```\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x93\x92PPPV[`\x80Q`\xA0Q`\xC0Q`\xE0Qa\x01\0Qa\x01 Qa\x01@Qa\x01`Qa\x01\x80Qax\xAFa\x05\xC1_9_\x81\x81a\x05?\x01R\x81\x81aK\t\x01RaKG\x01R_\x81\x81a\x0F\x1C\x01R\x81\x81a\x1Dj\x01RaU9\x01R_a^\xD5\x01R_a_\x8F\x01R_a_i\x01R_a_\x19\x01R_a^\xF6\x01R_a*T\x01R_\x81\x81a\x10\xE3\x01Ra&\x03\x01Rax\xAF_\xF3\xFE`\x80`@R`\x046\x10a\x04\xC6W_5`\xE0\x1C\x80c\x84\xB0\x19n\x11a\x02xW\x80c\xB7\xED\x02\x0E\x11a\x01UW\x80c\xDE@\xD8\x9F\x11a\0\xC9W\x80c\xF0N\x02\xC0\x11a\0\x83W\x80c\xF0N\x02\xC0\x14a\x11\xA2W\x80c\xF1'\xA9\xB3\x14a\x11\xCDW\x80c\xF2\xFD\xE3\x8B\x14a\x11\xE2W\x80c\xF5\x16\xA5\xB4\x14a\x11\xF5W\x80c\xF6T\xB7\xD0\x14a\x12 W\x80c\xF9\xFD\xCA\xE6\x14a\x12?W__\xFD[\x80c\xDE@\xD8\x9F\x14a\x10\xD2W\x80c\xE2M\\5\x14a\x11\x05W\x80c\xE8\xBEe\x04\x14a\x11\x1AW\x80c\xEC\xF8\x8B\xB0\x14a\x119W\x80c\xEE\xB9\x02Y\x14a\x11XW\x80c\xF0>\xB6\x1A\x14a\x11\x83W__\xFD[\x80c\xCA\x02\xA8\x1E\x11a\x01\x1AW\x80c\xCA\x02\xA8\x1E\x14a\x0F\xE2W\x80c\xCE\xF5\xF4\x82\x14a\x10\rW\x80c\xD3\x8B\x01\x8B\x14a\x10,W\x80c\xDB\x14\xFBA\x14a\x10XW\x80c\xDC\x1F\x9A\xDF\x14a\x10\x94W\x80c\xDC\x8F\x863\x14a\x10\xB3W__\xFD[\x80c\xB7\xED\x02\x0E\x14a\x0E\xF6W\x80c\xB9\x8Ec\x1D\x14a\x0F\x0BW\x80c\xBC\\YP\x14a\x0F>W\x80c\xC0(>b\x14a\x0FlW\x80c\xC6;\xBF)\x14a\x0F\x8BW__\xFD[\x80c\x9Da\xDD\x07\x11a\x01\xECW\x80c\xA7\xEC\x9D\xF9\x11a\x01\xB1W\x80c\xA7\xEC\x9D\xF9\x14a\x0EDW\x80c\xAAc\xE5E\x14a\x0EcW\x80c\xAA\x946\x0C\x14a\x0E\x82W\x80c\xB13\xBE}\x14a\x0E\xA1W\x80c\xB3q\xFAi\x14a\x0E\xC2W\x80c\xB6\xB5_%\x14a\x0E\xD7W__\xFD[\x80c\x9Da\xDD\x07\x14a\r\x9AW\x80c\x9E\xFA\xCAy\x14a\r\xDBW\x80c\xA3M(\xEB\x14a\r\xFCW\x80c\xA60%Y\x14a\x0E\x1BW\x80c\xA6\xE9/<\x14a\x0E0W__\xFD[\x80c\x89'\xA1\x06\x11a\x02=W\x80c\x89'\xA1\x06\x14a\x0C\xF6W\x80c\x89\xF2\x97\xBD\x14a\r\x15W\x80c\x8D\xA5\xCB[\x14a\r4W\x80c\x90\"8\xE1\x14a\rLW\x80c\x93\xA9\xEEF\x14a\raW\x80c\x99\xB4\x99%\x14a\r{W__\xFD[\x80c\x84\xB0\x19n\x14a\x0CDW\x80c\x87\x01\xD7\xB2\x14a\x0CkW\x80c\x87\x8B\xA1V\x14a\x0C\x8AW\x80c\x88B\xC5s\x14a\x0C\xA9W\x80c\x88\x92r\x96\x14a\x0C\xC8W__\xFD[\x80cMS\xE91\x11a\x03\xA6W\x80cf^\x0E\xED\x11a\x03\x1AW\x80cx\xAA\xF2^\x11a\x02\xDFW\x80cx\xAA\xF2^\x14a\x0B/W\x80c|LO\xEB\x14a\x0B\x7FW\x80c}\xE8\x9F0\x14a\x0B\xAEW\x80c~ID\x7F\x14a\x0B\xF2W\x80c\x80\xA7,\x8B\x14a\x0C\x11W\x80c\x84V\xCBY\x14a\x0C0W__\xFD[\x80cf^\x0E\xED\x14a\nRW\x80cg\xDE\x8B~\x14a\nqW\x80cl\x83Z\x82\x14a\n\x95W\x80cqP\x18\xA6\x14a\n\xBFW\x80cq\x8F\xBC%\x14a\n\xC7W__\xFD[\x80cX\x97\x9B\xFE\x11a\x03kW\x80cX\x97\x9B\xFE\x14a\t\x92W\x80c\\\x97Z\xBB\x14a\t\xB1W\x80c\\\xF8\x80\x12\x14a\t\xC7W\x80c^\xA6<l\x14a\t\xE6W\x80c`\xB6\xBF\xDD\x14a\n\x05W\x80ccn\xE6$\x14a\n3W__\xFD[\x80cMS\xE91\x14a\x08\xF5W\x80cM\xA2\xF8\x99\x14a\t\nW\x80cP\x16\xC4{\x14a\t5W\x80cPb\x94\xDC\x14a\tTW\x80cW7a\x98\x14a\tsW__\xFD[\x80c6'r\r\x11a\x04=W\x80c?\xEA4\x88\x11a\x04\x02W\x80c?\xEA4\x88\x14a\x08\x1DW\x80cB\0\\l\x14a\x08<W\x80cCA\xFC\x86\x14a\x08[W\x80cF\xDE@o\x14a\x08\x97W\x80cH\x1F\x93v\x14a\x08\xB6W\x80cH.\xDB\x07\x14a\x08\xE1W__\xFD[\x80c6'r\r\x14a\x06\xD1W\x80c6`\xFB\x92\x14a\x07\x05W\x80c8\xEEr\xD0\x14a\x07fW\x80c=\x92\xAF\x84\x14a\x07\x85W\x80c?K\xA8:\x14a\x08\tW__\xFD[\x80c\x1D\xBFLa\x11a\x04\x8EW\x80c\x1D\xBFLa\x14a\x05\xB7W\x80c.\x1A}M\x14a\x05\xF6W\x80c/H\xAB}\x14a\x06\x15W\x80c/\x83\xD9\xAF\x14a\x064W\x80c3h\rX\x14a\x06jW\x80c3\xD9\x08\xAD\x14a\x06\xB2W__\xFD[\x80c\x04e\xEA\xB0\x14a\x04\xCAW\x80c\x04\xECB\x94\x14a\x04\xEBW\x80c\x0B4Xy\x14a\x05.W\x80c\x13v\xDER\x14a\x05yW\x80c\x1C\xF1\xBD:\x14a\x05\x98W[__\xFD[4\x80\x15a\x04\xD5W__\xFD[Pa\x04\xE9a\x04\xE46`\x04ae^V[a\x12yV[\0[4\x80\x15a\x04\xF6W__\xFD[Pa\x05\x19a\x05\x056`\x04ae^V[`\x14` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x059W__\xFD[Pa\x05a\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x05%V[4\x80\x15a\x05\x84W__\xFD[Pa\x04\xE9a\x05\x936`\x04ae\x89V[a\x12\xF3V[4\x80\x15a\x05\xA3W__\xFD[Pa\x04\xE9a\x05\xB26`\x04ae^V[a\x13\"V[4\x80\x15a\x05\xC2W__\xFD[Pa\x05aa\x05\xD16`\x04ae\xC7V[`\x13` \x90\x81R_\x92\x83R`@\x80\x84 \x90\x91R\x90\x82R\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x81V[4\x80\x15a\x06\x01W__\xFD[Pa\x04\xE9a\x06\x106`\x04ae^V[a\x13lV[4\x80\x15a\x06 W__\xFD[P`\x04Ta\x05a\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[4\x80\x15a\x06?W__\xFD[Pa\x06Sa\x06N6`\x04ae\xF1V[a\x14+V[`@Qa\x05%\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90af\x11V[4\x80\x15a\x06uW__\xFD[Pa\x06\xA4a\x06\x846`\x04af\xB3V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\r` R`@\x90 Tc\xFF\xFF\xFF\xFF\x16\x90V[`@Q\x90\x81R` \x01a\x05%V[4\x80\x15a\x06\xBDW__\xFD[Pa\x04\xE9a\x06\xCC6`\x04af\xCEV[a\x14\xECV[4\x80\x15a\x06\xDCW__\xFD[Pa\x06\xA4a\x06\xEB6`\x04af\xB3V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x19` R`@\x90 T\x90V[4\x80\x15a\x07\x10W__\xFD[Pa\x07Qa\x07\x1F6`\x04af\xB3V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\r` R`@\x90 Tc\xFF\xFF\xFF\xFF`\x01` \x1B\x82\x04\x81\x16\x92`\x01`@\x1B\x90\x92\x04\x16\x90V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x05%V[4\x80\x15a\x07qW__\xFD[Pa\x04\xE9a\x07\x806`\x04ag+V[a\x15\xD6V[4\x80\x15a\x07\x90W__\xFD[Pa\x07\xD7a\x07\x9F6`\x04ae^V[`\x1E` R_\x90\x81R`@\x90 \x80T`\x01\x82\x01T`\x02\x83\x01T`\x03\x84\x01T`\x04\x90\x94\x01T`\x01`\x01`\xA0\x1B\x03\x90\x93\x16\x93\x91\x92\x90\x91\x90\x85V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x90\x96\x16\x86R` \x86\x01\x94\x90\x94R\x92\x84\x01\x91\x90\x91R``\x83\x01R`\x80\x82\x01R`\xA0\x01a\x05%V[4\x80\x15a\x08\x14W__\xFD[Pa\x04\xE9a\x15\xE8V[4\x80\x15a\x08(W__\xFD[Pa\x05aa\x0876`\x04ae^V[a\x15\xFAV[4\x80\x15a\x08GW__\xFD[Pa\x04\xE9a\x08V6`\x04ag\x81V[a\x16\x0BV[4\x80\x15a\x08fW__\xFD[Pa\x08za\x08u6`\x04af\xB3V[a\x16PV[`@\x80Q\x93\x15\x15\x84R` \x84\x01\x92\x90\x92R\x90\x82\x01R``\x01a\x05%V[4\x80\x15a\x08\xA2W__\xFD[Pa\x04\xE9a\x08\xB16`\x04ae^V[a\x16\x9AV[4\x80\x15a\x08\xC1W__\xFD[P`\x0CTc\xFF\xFF\xFF\xFF`\x01` \x1B\x82\x04\x81\x16\x91`\x01`@\x1B\x90\x04\x16a\x07QV[4\x80\x15a\x08\xECW__\xFD[Pa\x06\xA4a\x17\x0EV[4\x80\x15a\t\0W__\xFD[Pa\x06\xA4`\x01T\x81V[4\x80\x15a\t\x15W__\xFD[Pa\x06\xA4a\t$6`\x04af\xB3V[`\x11` R_\x90\x81R`@\x90 T\x81V[4\x80\x15a\t@W__\xFD[Pa\x04\xE9a\tO6`\x04ae^V[a\x178V[4\x80\x15a\t_W__\xFD[Pa\x04\xE9a\tn6`\x04ag\xB8V[a\x1C0V[4\x80\x15a\t~W__\xFD[Pa\x04\xE9a\t\x8D6`\x04ae\xC7V[a\x1CfV[4\x80\x15a\t\x9DW__\xFD[Pa\x04\xE9a\t\xAC6`\x04af\xB3V[a\x1C\xB2V[4\x80\x15a\t\xBCW__\xFD[P_T`\xFF\x16a\x05\x19V[4\x80\x15a\t\xD2W__\xFD[Pa\x06\xA4a\t\xE16`\x04ahfV[a\x1C\xDEV[4\x80\x15a\t\xF1W__\xFD[Pa\x04\xE9a\n\x006`\x04ae\xC7V[a\x1EVV[4\x80\x15a\n\x10W__\xFD[Pa\x05\x19a\n\x1F6`\x04af\xB3V[`\n` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[4\x80\x15a\n>W__\xFD[Pa\x04\xE9a\nM6`\x04ae\xF1V[a\x1E\xB6V[4\x80\x15a\n]W__\xFD[Pa\x04\xE9a\nl6`\x04ai4V[a\x1F]V[4\x80\x15a\n|W__\xFD[P`\x0CT`\x01``\x1B\x90\x04`\x01`\x01`@\x1B\x03\x16a\x06\xA4V[4\x80\x15a\n\xA0W__\xFD[Pa\x06\xA4a\n\xAF6`\x04ae^V[` \x80R_\x90\x81R`@\x90 T\x81V[a\x04\xE9a\x1F\xFBV[4\x80\x15a\n\xD2W__\xFD[Pa\x0B\x10a\n\xE16`\x04ae\xF1V[`\x1C` \x90\x81R_\x92\x83R`@\x80\x84 \x90\x91R\x90\x82R\x90 \x80T`\x01\x90\x91\x01T`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x82V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x90\x93\x16\x83R` \x83\x01\x91\x90\x91R\x01a\x05%V[4\x80\x15a\x0B:W__\xFD[Pa\x0BNa\x0BI6`\x04ae\xC7V[a \x0CV[`@\x80Q\x95\x86R` \x86\x01\x94\x90\x94R\x92\x84\x01\x91\x90\x91R``\x83\x01R`\x01`\x01`\xA0\x1B\x03\x16`\x80\x82\x01R`\xA0\x01a\x05%V[4\x80\x15a\x0B\x8AW__\xFD[Pa\x0B\x9Ea\x0B\x996`\x04ae^V[a _V[`@Qa\x05%\x94\x93\x92\x91\x90ai\xA1V[4\x80\x15a\x0B\xB9W__\xFD[Pa\x06\xA4a\x0B\xC86`\x04af\xB3V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\r` R`@\x90 T`\x01``\x1B\x90\x04`\x01`\x01`@\x1B\x03\x16\x90V[4\x80\x15a\x0B\xFDW__\xFD[Pa\x07Qa\x0C\x0C6`\x04ai\xDAV[a!GV[4\x80\x15a\x0C\x1CW__\xFD[P`\x03Ta\x05a\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[4\x80\x15a\x0C;W__\xFD[Pa\x04\xE9a!\xBFV[4\x80\x15a\x0COW__\xFD[Pa\x0CXa!\xCFV[`@Qa\x05%\x97\x96\x95\x94\x93\x92\x91\x90aj\xA2V[4\x80\x15a\x0CvW__\xFD[Pa\x04\xE9a\x0C\x856`\x04ak\x11V[a\"(V[4\x80\x15a\x0C\x95W__\xFD[Pa\x04\xE9a\x0C\xA46`\x04ak\x11V[a\"]V[4\x80\x15a\x0C\xB4W__\xFD[Pa\x06\xA4a\x0C\xC36`\x04af\xB3V[a\"\x92V[4\x80\x15a\x0C\xD3W__\xFD[Pa\x05\x19a\x0C\xE26`\x04ae^V[`\x1D` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[4\x80\x15a\r\x01W__\xFD[Pa\x06Sa\r\x106`\x04ae^V[a\"\x9CV[4\x80\x15a\r W__\xFD[Pa\x06\xA4a\r/6`\x04ak\xCDV[a$mV[4\x80\x15a\r?W__\xFD[Pc\x8Bx\xC6\xD8\x19Ta\x05aV[4\x80\x15a\rWW__\xFD[Pa\x06\xA4`\x06T\x81V[4\x80\x15a\rlW__\xFD[P`\x0CTc\xFF\xFF\xFF\xFF\x16a\x06\xA4V[4\x80\x15a\r\x86W__\xFD[Pa\x04\xE9a\r\x956`\x04alFV[a$wV[4\x80\x15a\r\xA5W__\xFD[Pa\x06\xA4a\r\xB46`\x04af\xB3V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\r` R`@\x90 T`\x01`\xA0\x1B\x90\x04c\xFF\xFF\xFF\xFF\x16\x90V[4\x80\x15a\r\xE6W__\xFD[Pa\r\xEFa%\xD2V[`@Qa\x05%\x91\x90al\x9DV[4\x80\x15a\x0E\x07W__\xFD[Pa\x04\xE9a\x0E\x166`\x04al\xAFV[a&XV[4\x80\x15a\x0E&W__\xFD[Pa\x06\xA4`\x15T\x81V[4\x80\x15a\x0E;W__\xFD[P`\x17Ta\x06\xA4V[4\x80\x15a\x0EOW__\xFD[Pa\x07Qa\x0E^6`\x04am\x1CV[a'cV[4\x80\x15a\x0EnW__\xFD[Pa\x04\xE9a\x0E}6`\x04amEV[a)sV[4\x80\x15a\x0E\x8DW__\xFD[Pa\x05aa\x0E\x9C6`\x04ae\xC7V[a*QV[4\x80\x15a\x0E\xACW__\xFD[P`\x0CT`\x01`\xA0\x1B\x90\x04c\xFF\xFF\xFF\xFF\x16a\x06\xA4V[4\x80\x15a\x0E\xCDW__\xFD[Pa\x06\xA4`\x16T\x81V[4\x80\x15a\x0E\xE2W__\xFD[Pa\x04\xE9a\x0E\xF16`\x04ae^V[a*\xE8V[4\x80\x15a\x0F\x01W__\xFD[Pa\x06\xA4`\x10T\x81V[4\x80\x15a\x0F\x16W__\xFD[Pa\x05a\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[4\x80\x15a\x0FIW__\xFD[Pa\x05\x19a\x0FX6`\x04af\xB3V[`\x0B` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[4\x80\x15a\x0FwW__\xFD[Pa\x06\xA4a\x0F\x866`\x04am\xAEV[a+\x85V[4\x80\x15a\x0F\x96W__\xFD[Pa\x0F\xCAa\x0F\xA56`\x04an\0V[`\x1F` \x90\x81R_\x92\x83R`@\x80\x84 \x90\x91R\x90\x82R\x90 T`\x01`\x01`@\x1B\x03\x16\x81V[`@Q`\x01`\x01`@\x1B\x03\x90\x91\x16\x81R` \x01a\x05%V[4\x80\x15a\x0F\xEDW__\xFD[Pa\x06\xA4a\x0F\xFC6`\x04ae^V[_\x90\x81R`\x07` R`@\x90 T\x90V[4\x80\x15a\x10\x18W__\xFD[Pa\x04\xE9a\x10'6`\x04ae\xC7V[a+\x9EV[4\x80\x15a\x107W__\xFD[Pa\x10Ka\x10F6`\x04ae^V[a,\x11V[`@Qa\x05%\x91\x90an#V[4\x80\x15a\x10cW__\xFD[Pa\x10wa\x10r6`\x04af\xB3V[a,pV[`@Qj\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x91\x16\x81R` \x01a\x05%V[4\x80\x15a\x10\x9FW__\xFD[Pa\x04\xE9a\x10\xAE6`\x04an5V[a,zV[4\x80\x15a\x10\xBEW__\xFD[P`\x05Ta\x05a\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[4\x80\x15a\x10\xDDW__\xFD[Pa\x05a\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[4\x80\x15a\x11\x10W__\xFD[Pa\x06\xA4`\x02T\x81V[4\x80\x15a\x11%W__\xFD[Pa\x07Qa\x1146`\x04ae^V[a,\xA9V[4\x80\x15a\x11DW__\xFD[Pa\x04\xE9a\x11S6`\x04anPV[a,\xE9V[4\x80\x15a\x11cW__\xFD[Pa\x06\xA4a\x11r6`\x04af\xB3V[`\x1A` R_\x90\x81R`@\x90 T\x81V[4\x80\x15a\x11\x8EW__\xFD[Pa\x04\xE9a\x11\x9D6`\x04an\x82V[a-\xA6V[4\x80\x15a\x11\xADW__\xFD[Pa\x06\xA4a\x11\xBC6`\x04af\xB3V[`\x12` R_\x90\x81R`@\x90 T\x81V[4\x80\x15a\x11\xD8W__\xFD[Pa\x06\xA4`\x18T\x81V[a\x04\xE9a\x11\xF06`\x04af\xB3V[a-\xF2V[4\x80\x15a\x12\0W__\xFD[Pa\x06\xA4a\x12\x0F6`\x04ae^V[`\x1B` R_\x90\x81R`@\x90 T\x81V[4\x80\x15a\x12+W__\xFD[Pa\x04\xE9a\x12:6`\x04af\xB3V[a.\x18V[4\x80\x15a\x12JW__\xFD[Pa\x12^a\x12Y6`\x04an\xACV[a.DV[`@\x80Q\x93\x84R` \x84\x01\x92\x90\x92R\x90\x82\x01R``\x01a\x05%V[a\x12\x81a15V[`\x01\x81\x12\x15a\x12\xA3W`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x10T\x81\x13\x15a\x12\xC6W`@Qc\x9D\x8C}\x99`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x04Ta\x12\xDD\x90`\x01`\x01`\xA0\x1B\x03\x163\x83a1OV[a\x12\xF0a\x12\xE9\x82aohV[`\x02a1sV[PV[a\x12\xFBa15V[_\x82\x81R`\x14` R`@\x90 \x80T`\xFF\x19\x16\x82\x15\x15\x17\x90Ua\x13\x1E\x82\x82a1\xA2V[PPV[a\x13*a15V[b\x0FB@\x81\x11\x15a\x13NW`@QcJU\x94k`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x0C\x80Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x83\x16\x17\x90Ua\x12\xF0\x81a24V[a\x13ta2\x9EV[\x80_\x03a\x13\x94W`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[3_\x90\x81R`\x11` R`@\x90 T\x80\x82\x11\x15a\x13\xC4W`@Qc\xD4p\x8C\xA5`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x13\xCCa\x17\x0EV[\x82\x11\x15a\x13\xECW`@Qc\xB5\\\x1B\xAD`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x13\xF6\x82\x82ao\x82V[3_\x81\x81R`\x11` R`@\x90 \x91\x90\x91U`\x04Ta\x14!\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x84a1OV[a\x13\x1E3\x83a2\xC1V[`\x07` R\x81_R`@_ \x81\x81T\x81\x10a\x14DW_\x80\xFD[_\x91\x82R` \x91\x82\x90 `\n\x90\x91\x02\x01\x80T`\x01\x82\x01T`\x02\x83\x01T`\x03\x84\x01T`\x04\x85\x01T`\x05\x86\x01T`\x06\x87\x01T`@\x80Q``\x81\x01\x82R`\x07\x8A\x01T\x81R`\x08\x8A\x01T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x9B\x82\x01\x9B\x90\x9BR`\t\x90\x99\x01T\x8A\x16\x90\x89\x01R\x95\x99P\x93\x87\x16\x97P\x95\x82\x16\x95`\x01`\x01`@\x1B\x03`\x01`\xA0\x1B\x90\x93\x04\x83\x16\x95\x82\x84\x16\x95c\xFF\xFF\xFF\xFF`\x01`@\x1B\x85\x04\x16\x95`\x01``\x1B\x90\x94\x04\x90\x94\x16\x93\x91\x92\x91\x90\x8BV[a\x14\xF4a2\x9EV[_a\x14\xFE\x85a3KV[`\x02\x81\x01T\x90\x91P`\x01`\x01`\xA0\x1B\x03\x163\x14a\x15.W`@Qc8\x9Bzy`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x1573a3\xBBV[_\x84\x81R`\x14` R`@\x90 T`\xFF\x16\x15a\x15fW`@Qc\xD9%\x9C\xA9`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x15p\x84\x84a4\xD0V[`@\x80Q``\x81\x01\x82R\x85\x81R`\x01`\x01`\xA0\x1B\x03\x80\x86\x16` \x83\x01\x81\x90R\x90\x85\x16\x91\x90\x92\x01\x81\x90R`\x07\x83\x01\x86\x90U`\x08\x83\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x16\x90\x93\x17\x90U`\t\x83\x01\x80T\x90\x92\x16\x17\x90Ua\x15\xCF\x85\x85\x85\x85a5\xC2V[PPPPPV[a\x15\xE2\x84\x84\x84\x84a6dV[PPPPV[a\x15\xF0a15V[a\x15\xF8a8\xA3V[V[_a\x16\x050\x83a*QV[\x92\x91PPV[a\x16\x13a15V[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\r` R`@\x90 \x80Tc\xFF\xFF\xFF\xFF`\xA0\x1B\x19\x16`\x01`\xA0\x1Bc\xFF\xFF\xFF\xFF\x84\x16\x02\x17\x90Ua\x13\x1E\x82\x82a8\xF4V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\r` R`@\x81 \x80Tc\xFF\xFF\xFF\xFF`\x01` \x1B\x82\x04\x81\x16\x92`\x01`@\x1B\x90\x92\x04\x16\x90\x82\x15\x80\x15\x90a\x16\x90WP\x81\x15\x15[\x93PP\x91\x93\x90\x92PV[\x80_\x03a\x16\xBAW`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x04T`\x01`\x01`\xA0\x1B\x03\x16a\x16\xE3W`@Qc\x85b\xEBE`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x04Ta\x16\xFB\x90`\x01`\x01`\xA0\x1B\x03\x1630\x84a9\x87V[a\x12\xF0a\x17\x07\x82a9\xA2V[`\x05a1sV[`\x04T_\x90`\x01`\x01`\xA0\x1B\x03\x16\x80a\x17(W_\x91PP\x90V[a\x172\x810a9\xCFV[\x91PP\x90V[a\x17@a2\x9EV[`\x18T`\x17T_[\x81\x83\x10\x80\x15a\x17VWP\x83\x81\x10[\x15a\x1C(W_`\x17\x84\x81T\x81\x10a\x17oWa\x17oao\x95V[_\x91\x82R` \x90\x91 `\x03\x90\x91\x02\x01\x80T\x90\x91P\x7F\xFC\xB4O\xFE\xBD8\xE2\xFE\x82\xABb>\xA3x\x88T!<E\x8C\xF9\x85U%\xB5\x86[p}_\x01>\x81\x01a\x18~W___\x84`\x01\x01\x80Ta\x17\xBC\x90ao\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x17\xE8\x90ao\xA9V[\x80\x15a\x183W\x80`\x1F\x10a\x18\nWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x183V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x18\x16W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x80` \x01\x90Q\x81\x01\x90a\x18K\x91\x90ao\xE1V[\x94PPP\x92P\x92Pa\x18v\x83\x83\x83\x88`\x02\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16a6dV[PPPa\x1BfV[\x7F\xA4O)=\xFA\x92(\x91cE\xA6\x01b \xF3\x04\xFDN\x10\xC2\xF2^\xF6,\x89kIF\x92jp\xF4\x81\x03a\x19pW_\x82`\x01\x01\x80Ta\x18\xB5\x90ao\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x18\xE1\x90ao\xA9V[\x80\x15a\x19,W\x80`\x1F\x10a\x19\x03Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x19,V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x19\x0FW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x80` \x01\x90Q\x81\x01\x90a\x19D\x91\x90ap'V[`\x05\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x83\x16\x17\x90U\x90Pa\x19j\x81a:^V[Pa\x1BfV[\x7F\xC1-\xAF\xB0\xC4\x07\xB0\xB3Bb6\x05\xE9P\xEF9\xBC.<\x97\xA3\xE5\xEEWEU\xB3Pgv\x01\xB1\x81\x03a\x1A\x7FW__\x83`\x01\x01\x80Ta\x19\xA8\x90ao\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x19\xD4\x90ao\xA9V[\x80\x15a\x1A\x1FW\x80`\x1F\x10a\x19\xF6Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x1A\x1FV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1A\x02W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x80` \x01\x90Q\x81\x01\x90a\x1A7\x91\x90apBV[P\x91P\x91P_\x82\x82\x10\x15a\x1AeWa\x1AWa\x1AR\x83\x85ao\x82V[a9\xA2V[a\x1A`\x90aohV[a\x1ArV[a\x1Ara\x1AR\x84\x84ao\x82V[\x90Pa\x18v\x81`\x01a1sV[\x7FG\xC6u\x1EZ\xBE\x12,\x1C\xA5\x82\x8C\x0F\xD6\x0C2\x8B6\x9EWR'\xDF\xCC\x17\xE7b>\x89^\xC0E\x81\x03a\x1BfW_\x82`\x01\x01\x80Ta\x1A\xB6\x90ao\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x1A\xE2\x90ao\xA9V[\x80\x15a\x1B-W\x80`\x1F\x10a\x1B\x04Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x1B-V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1B\x10W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x80` \x01\x90Q\x81\x01\x90a\x1BE\x91\x90apnV[\x91PPa\x1Bda\x1BT\x82a9\xA2V[a\x1B]\x90aohV[`\x04a1sV[P[`\x02\x82\x01T`\x01\x83\x01\x80Ta\x1C\x1A\x92\x88\x92`\x01`\x01`@\x1B\x03\x80\x83\x16\x93`\x01`@\x1B\x90\x93\x04\x16\x91\x86\x91\x90a\x1B\x99\x90ao\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x1B\xC5\x90ao\xA9V[\x80\x15a\x1C\x10W\x80`\x1F\x10a\x1B\xE7Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x1C\x10V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1B\xF3W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPPa:\xD0V[PP`\x01\x92\x83\x01\x92\x01a\x17HV[PP`\x18UPV[a\x1C8a15V[`\x0C\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x1B\x19\x16`\x01``\x1B`\x01`\x01`@\x1B\x03\x84\x16\x02\x17\x90Ua\x12\xF0\x81a;IV[a\x1Cna15V[`\x04T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x90\x83\x16\x03a\x1C\x9DW`@Qc\x1CN\x1B\xFF`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x1C\xA8\x823\x83a1OV[a\x13\x1E\x82\x82a;\xC4V[a\x1C\xBAa15V[`\x04\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x83\x16\x17\x90Ua\x12\xF0\x81a<MV[_a\x1C\xE7a2\x9EV[`\x03T`@Qc\t9\xB3\xF3`\xE3\x1B\x81R_\x91`\x01`\x01`\xA0\x1B\x03\x16\x90cI\xCD\x9F\x98\x90a\x1D!\x90\x8D\x90\x8D\x90\x8D\x90\x8D\x90\x8D\x90\x8D\x90`\x04\x01aq\x03V[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1D;W=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x1Db\x91\x90\x81\x01\x90aq\xC7V[\x90P_a\x1D\x8E\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a<\xBFV[\x90P\x80`\x01`\x01`X\x1B\x03\x19\x16\x82`\x80\x01Q`\x01`\x01`X\x1B\x03\x19\x16\x14a\x1D\xC8W`@Qc6[>S`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x1D\xD5\x82`\xA0\x01Qa<\xD4V[`\x15T\x90\x93P\x80\x84\x03a\x1D\xFBW`@Qc5\xB0Q\x9F`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x16T_\x80a\x1E\x0C\x84\x84\x8B\x8Ba=\x80V[\x91P\x91P\x86\x82\x14a\x1E0W`@Qc\x0ER\x1CC`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x15\x87\x90U`\x16\x81\x90Ua\x1ED\x89\x89a?\x02V[PPPPPP\x98\x97PPPPPPPPV[a\x1E^a15V[b\x0FB@\x81\x11\x15a\x1E\x82W`@QcJU\x94k`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\r` R`@\x90 \x80Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x83\x16\x17\x90Ua\x13\x1E\x82\x82a@EV[a\x1E\xBEa15V[c\xFF\xFF\xFF\xFF\x82\x11\x80a\x1E\xD3WPc\xFF\xFF\xFF\xFF\x81\x11[\x15a\x1E\xF1W`@Qc\xA1~\xEAw`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x15\x81\x15\x14a\x1F\x13W`@Qc\xA1~\xEAw`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x0C\x80Tc\xFF\xFF\xFF\xFF\x83\x81\x16`\x01`@\x1B\x02c\xFF\xFF\xFF\xFF`@\x1B\x19\x91\x86\x16`\x01` \x1B\x02\x91\x90\x91\x16k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\x19\x90\x92\x16\x91\x90\x91\x17\x17\x90Ua\x13\x1E\x82\x82a@\xCFV[a\x1Fea15V[`\x01`\x01`\xA0\x1B\x03\x83\x16a\x1F\x8CW`@Qc\x85b\xEBE`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x1F\xB3W`@Qc\xB3|y\xED`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x83\x81\x16_\x90\x81R`\x13` \x90\x81R`@\x80\x83 \x86\x84R\x90\x91R\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x91\x83\x16\x91\x90\x91\x17\x90Ua\x1F\xF6\x83\x83\x83aAHV[PPPV[a \x03a15V[a\x15\xF8_aA\xDBV[`\x19` R\x81_R`@_ \x81\x81T\x81\x10a %W_\x80\xFD[_\x91\x82R` \x90\x91 `\x05\x90\x91\x02\x01\x80T`\x01\x82\x01T`\x02\x83\x01T`\x03\x84\x01T`\x04\x90\x94\x01T\x92\x95P\x90\x93P\x91\x90`\x01`\x01`\xA0\x1B\x03\x16\x85V[_``___`\x17\x86\x81T\x81\x10a xWa xao\x95V[_\x91\x82R` \x90\x91 `\x03\x90\x91\x02\x01\x80T`\x02\x82\x01T`\x01\x83\x01\x80T\x93\x94P\x91\x92`\x01`\x01`@\x1B\x03\x80\x83\x16\x92`\x01`@\x1B\x90\x04\x16\x90\x83\x90a \xB9\x90ao\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta \xE5\x90ao\xA9V[\x80\x15a!0W\x80`\x1F\x10a!\x07Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a!0V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a!\x13W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x92P\x94P\x94P\x94P\x94PP\x91\x93P\x91\x93V[__a!Qa2\x9EV[a!_3\x8B\x8A\x8A\x8A\x8AaB\x01V[a!i\x85\x85a4\xD0V[`\x06_\x81Ta!w\x90ar\xB8V[\x91\x82\x90UP\x91PBa!\x92\x83\x8C3\x8D\x85\x8E\x8E\x8E\x8E\x8E\x8EaC\xF6V[\x91Pa!\xA5\x83\x8C\x843\x8E\x86\x8F\x8F\x8FaG\x0CV[a!\xB1\x83\x87\x87\x87a5\xC2V[P\x98P\x98\x96PPPPPPPV[a!\xC7a15V[a\x15\xF8aH\x0CV[`\x0F`\xF8\x1B``\x80_\x80\x80\x83a\"\x16`@\x80Q\x80\x82\x01\x82R`\x06\x81Re*\xB7:97\xB7`\xD1\x1B` \x80\x83\x01\x91\x90\x91R\x82Q\x80\x84\x01\x90\x93R`\x01\x83R`1`\xF8\x1B\x90\x83\x01R\x91V[\x97\x98\x90\x97\x96PF\x95P0\x94P\x91\x92P\x90V[a\"0a15V[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\x0B` R`@\x90 \x80T`\xFF\x19\x16\x82\x15\x15\x17\x90Ua\x13\x1E\x82\x82aHHV[a\"ea15V[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\n` R`@\x90 \x80T`\xFF\x19\x16\x82\x15\x15\x17\x90Ua\x13\x1E\x82\x82aH\xD8V[_a\x16\x05\x82aIhV[__________a\"\xD9`@Q\x80``\x01`@R\x80_\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81RP\x90V[_\x8C\x81R`\x08` R`@\x81 `\x01\x81\x01T\x90\x91\x81\x90\x03a\"\xFBWPPa$^V[\x81T_\x90\x81R`\x07` R`@\x81 a#\x15`\x01\x84ao\x82V[\x81T\x81\x10a#%Wa#%ao\x95V[\x90_R` _ \x90`\n\x02\x01\x90P\x80_\x01T\x9DP\x80`\x01\x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x9CP\x80`\x02\x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x9BP\x80`\x02\x01`\x14\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16\x9AP\x80`\x03\x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16\x99P\x80`\x03\x01`\x08\x90T\x90a\x01\0\n\x90\x04c\xFF\xFF\xFF\xFF\x16\x98P\x80`\x03\x01`\x0C\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16\x97P\x80`\x04\x01T\x96P\x80`\x05\x01T\x95P\x80`\x06\x01T\x94P\x80`\x07\x01`@Q\x80``\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16\x81RPP\x93PPPP[\x91\x93\x95\x97\x99\x9B\x90\x92\x94\x96\x98\x9APV[_a\x16\x05\x82a<\xD4V[0h\x92\x9E\xEE\x14\x9BK\xD2\x12hT\x03a$\x95Wc\xAB\x14<\x06_R`\x04`\x1C\xFD[0h\x92\x9E\xEE\x14\x9BK\xD2\x12hUa$\xA9a2\x9EV[`\x01`\x01`\xA0\x1B\x03\x84\x16a$\xD0W`@Qc\x85b\xEBE`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82\x15a%\xC0W`\x01`\x01`\xA0\x1B\x03\x80\x85\x16_\x81\x81R`\x19` \x90\x81R`@\x80\x83 `\x1A\x90\x92R\x82 T`\x04T\x91\x94\x90\x93\x91\x16\x14a%AWP`\x01`\x01`\xA0\x1B\x03\x86\x16_\x90\x81R`\x12` R`@\x81 T\x90\x81\x90\x03a%AW`@Qc\x04~?\xE7`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[___a%Q\x8A\x87\x87\x8C\x88aI\xCEV[`\x04T\x92\x95P\x90\x93P\x91P_\x90`\x01`\x01`\xA0\x1B\x03\x8C\x81\x16\x91\x16\x14a%\x80Wa%}\x8B\x84\x84\x8C\x8CaJ\xF5V[\x90P[a%\x8D\x8B\x86\x89\x89\x88aK\xE5V[`\x01`\x01`\xA0\x1B\x03\x8B\x16_\x90\x81R`\x1A` R`@\x90 \x84\x90U\x80\x15a%\xB8Wa%\xB8\x8B3\x83a1OV[PPPPPPP[8h\x92\x9E\xEE\x14\x9BK\xD2\x12hUPPPPV[`@\x80Qs=`-\x80`\n=9\x81\xF36==7===6=s``\x1B` \x82\x01Rk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0``\x1B\x16`4\x82\x01RnZ\xF4=\x82\x80>\x90=\x91`+W\xFD[\xF3`\x88\x1B`H\x82\x01R\x81Q`7\x81\x83\x03\x01\x81R`W\x90\x91\x01\x90\x91R\x90V[a&`a2\x9EV[\x82B\x11\x15a&\x81W`@Qc\x08\x19\xBD\xCD`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a&\x8B\x86a3KV[`\x02\x81\x01T\x90\x91Pa&\xA5\x90`\x01`\x01`\xA0\x1B\x03\x16a3\xBBV[_\x86\x81R` \x80\x80R`@\x80\x83 T\x92\x885\x92\x90\x91a&\xC9\x91\x90\x8A\x01\x90\x8A\x01af\xB3V[\x90P_a&\xDC``\x8A\x01`@\x8B\x01af\xB3V[\x90Pa&\xE8\x83\x83a4\xD0V[_a&\xF7\x8B\x85\x85\x85\x89\x8EaN\x19V[`\x02\x87\x01T\x90\x91Pa'\x14\x90`\x01`\x01`\xA0\x1B\x03\x16\x82\x8A\x8AaN\x8DV[a'\x1E\x8B\x86aN\xF9V[a'(\x86\x8BaO#V[a'V\x8B\x8B5a'>`@\x8E\x01` \x8F\x01af\xB3V[\x8D`@\x01` \x81\x01\x90a'Q\x91\x90af\xB3V[a5\xC2V[PPPPPPPPPPPV[__a'ma2\x9EV[_\x85\x81R`\x1D` R`@\x90 T`\xFF\x16\x15a'\x9CW`@Qc\x1B\xEBq\x05`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x85\x81R`\x1E` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x15a'\xD1W`@Qc\xCC\x0B\xB0\xC1`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82_\x03a'\xF1W`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a'\xFB\x85a3KV[\x90Pa(\x07\x81\x85aO\xB9V[\x91P\x81_\x03a()W`@Qc?A\xAE\x01`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x07\x81\x01\x80T`\x08\x83\x01Ta(G\x91\x90`\x01`\x01`\xA0\x1B\x03\x16a4\xD0V[3_\x90\x81R`\x11` R`@\x90 T\x83\x81\x10\x15a(wW`@Qc\xAC\xF2\xDA\x93`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a(\x81\x84\x82ao\x82V[3_\x90\x81R`\x11` R`@\x81 \x91\x90\x91U`\x01\x83\x01T\x83T`\x02\x85\x01Ta(\xB9\x92`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x89\x92\x8D\x92\x16aP'V[\x80\x92P\x81\x97PPP`@Q\x80`\xA0\x01`@R\x803`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x89\x81R` \x01\x88\x81R` \x01\x87\x81R` \x01\x82\x81RP`\x1E_\x8B\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01_a\x01\0\n\x81T\x81`\x01`\x01`\xA0\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`\xA0\x1B\x03\x16\x02\x17\x90UP` \x82\x01Q\x81`\x01\x01U`@\x82\x01Q\x81`\x02\x01U``\x82\x01Q\x81`\x03\x01U`\x80\x82\x01Q\x81`\x04\x01U\x90PPa)g\x88\x82\x85\x89\x89\x8E3\x8EaQBV[PPPP\x93P\x93\x91PPV[`\x17`@Q\x80`\x80\x01`@R\x80\x87\x81R` \x01\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x82\x90RP\x93\x85RPPP`\x01`\x01`@\x1B\x03\x80\x87\x16` \x80\x85\x01\x91\x90\x91R\x90\x86\x16`@\x90\x93\x01\x92\x90\x92R\x83T`\x01\x81\x81\x01\x86U\x94\x82R\x90\x82\x90 \x83Q`\x03\x90\x92\x02\x01\x90\x81U\x90\x82\x01Q\x91\x92\x90\x91\x90\x82\x01\x90a*\x0E\x90\x82as\x14V[P`@\x82\x01Q`\x02\x90\x91\x01\x80T``\x90\x93\x01Q`\x01`\x01`@\x1B\x03\x90\x81\x16`\x01`@\x1B\x02`\x01`\x01`\x80\x1B\x03\x19\x90\x94\x16\x92\x16\x91\x90\x91\x17\x91\x90\x91\x17\x90UPPPPPV[_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83\x83a*}a%\xD2V[\x80Q` \x91\x82\x01 `@Qa*\xC9\x95\x94\x93\x92\x01`\x01`\x01`\xF8\x1B\x03\x19\x94\x90\x94\x16\x84R``\x92\x90\x92\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01\x84\x01R`\x15\x83\x01R`5\x82\x01R`U\x01\x90V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x93\x92PPPV[a*\xF0a2\x9EV[3_\x90\x81R`\x0B` R`@\x90 T`\xFF\x16a+\x1FW`@Qc\x03kc\x8D`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80_\x03a+?W`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x04Ta+W\x90`\x01`\x01`\xA0\x1B\x03\x1630\x84a9\x87V[3_\x90\x81R`\x11` R`@\x81 \x80T\x83\x92\x90a+u\x90\x84\x90as\xCEV[\x90\x91UPa\x12\xF0\x90P3\x82aQ\xD3V[_a+\x93\x86\x86\x86\x86\x86aP'V[P\x96\x95PPPPPPV[a+\xA6a15V[`\x01`\x01`\xA0\x1B\x03\x82\x16a+\xCDW`@Qc\x85b\xEBE`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80_\x03a+\xEDW`@Qc\x04~?\xE7`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\x12` R`@\x90 \x81\x90Ua\x13\x1E\x82\x82aR]V[_\x81\x81R`\t` \x90\x81R`@\x91\x82\x90 \x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R``\x93\x92\x83\x01\x82\x82\x80\x15a,dW` \x02\x82\x01\x91\x90_R` _ \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a,PW[PPPPP\x90P\x91\x90PV[_a\x16\x05\x82a<\xBFV[a,\x82a15V[`\x0C\x80Tc\xFF\xFF\xFF\xFF`\xA0\x1B\x19\x16`\x01`\xA0\x1Bc\xFF\xFF\xFF\xFF\x84\x16\x02\x17\x90Ua\x12\xF0\x81aR\xE7V[_\x81\x81R`\x08` R`@\x81 `\x01\x81\x01T\x82\x91\x90\x80\x83\x03a,\xD1WP_\x94\x85\x94P\x92PPPV[\x81Ta,\xDE`\x01\x83ao\x82V[\x93P\x93PPP\x91P\x91V[a,\xF1a15V[c\xFF\xFF\xFF\xFF\x82\x11\x80a-\x06WPc\xFF\xFF\xFF\xFF\x81\x11[\x15a-$W`@Qc!2\xC1\x19`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x15\x81\x15\x14a-FW`@Qc!2\xC1\x19`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\r` R`@\x90 \x80Tc\xFF\xFF\xFF\xFF\x83\x81\x16`\x01`@\x1B\x02c\xFF\xFF\xFF\xFF`@\x1B\x19\x91\x86\x16`\x01` \x1B\x02\x91\x90\x91\x16k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\x19\x90\x92\x16\x91\x90\x91\x17\x17\x81Ua\x15\xE2\x84\x84\x84aS\\V[a-\xAEa15V[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\r` R`@\x90 \x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x1B\x19\x16`\x01``\x1B`\x01`\x01`@\x1B\x03\x84\x16\x02\x17\x90Ua\x13\x1E\x82\x82aS\xEEV[a-\xFAa15V[\x80``\x1Ba.\x0FWctH\xFB\xAE_R`\x04`\x1C\xFD[a\x12\xF0\x81aA\xDBV[a. a15V[`\x03\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x83\x16\x17\x90Ua\x12\xF0\x81aT\x87V[___a.Oa2\x9EV[`\x03T`@Qc\t9\xB3\xF3`\xE3\x1B\x81R_\x91`\x01`\x01`\xA0\x1B\x03\x16\x90cI\xCD\x9F\x98\x90a.\x89\x90\x8D\x90\x8D\x90\x8D\x90\x8D\x90\x8D\x90\x8D\x90`\x04\x01aq\x03V[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a.\xA3W=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra.\xCA\x91\x90\x81\x01\x90aq\xC7V[\x80Q_\x81\x81R`\x1D` R`@\x90 T\x91\x92P\x90`\xFF\x16\x15a.\xFFW`@Qc\x1B\xEBq\x05`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x1D_\x83\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP_`\x05_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90P_a/Z\x8E\x85`\x80\x01Q\x86``\x01Q\x87`\xA0\x01Q\x86aT\xF9V[\x90Pa/k\x8E\x83\x86`@\x01QaU\xB1V[a/\x7F\x8E\x85`@\x01Qc\xFF\xFF\xFF\xFF\x16aV\x18V[\x95P\x85_\x03a/\xA1W`@Qc%\x03\xBB3`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a/\xAB\x87a3KV[\x90P\x81\x81`\x04\x01_\x82\x82Ta/\xC0\x91\x90as\xCEV[\x92PP\x81\x90UP\x81\x81`\x06\x01_\x82\x82Ta/\xDA\x91\x90as\xCEV[\x90\x91UPa/\xEA\x90P\x81\x83aO\xB9V[\x95Pa/\xF6\x82\x87aV\xCCV[_\x84\x81R`\x1E` R`@\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x16\x15a0\xCDW\x80T`\x01\x82\x01T`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90_\x90\x8A\x14\x80\x15a09WP\x84\x83`\x02\x01T\x14[`\x03\x80\x85\x01T_\x8A\x81R`\x1E` R`@\x81 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x81U`\x01\x81\x01\x82\x90U`\x02\x81\x01\x82\x90U\x92\x83\x01\x81\x90U`\x04\x90\x92\x01\x91\x90\x91U\x90\x91P\x81\x15a0\xB3W\x89\x15a0\xB3W`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x11` R`@\x81 \x80T\x8C\x92\x90a0\xAD\x90\x84\x90as\xCEV[\x90\x91UPP[\x81\x15a0\xC9W\x9APa1(\x97PPPPPPPPV[PPP[\x86\x15a1!W`\x08\x82\x01T`\x07\x83\x01\x80T`\t\x85\x01T\x91\x92_\x92a1\x02\x92`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x92\x8D\x92\x8F\x92\x91\x16aP'V[\x80\x92P\x81\x9CPPPa1\x1E\x8A\x82\x84\x8E\x8D\x8C\x8E`@\x01Q\x8CaV\xE2V[PP[PPPPPP[\x97P\x97P\x97\x94PPPPPV[c\x8Bx\xC6\xD8\x19T3\x14a\x15\xF8Wc\x82\xB4)\0_R`\x04`\x1C\xFD[`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a1iWa\x1F\xF6\x83\x83\x83aWgV[a\x1F\xF6\x82\x82aW\xB1V[\x81_\x03a1~WPPV[\x81`\x10_\x82\x82Ta1\x8F\x91\x90as\xE1V[\x90\x91UPP`\x10Ta\x13\x1E\x90\x83\x83aW\xCAV[\x81\x7F\xC8\xB7\xFE$\xDC.\x9Es\x11A\xFE\x1D\xD7Ml\xE4p\xBDkSq\xC1/B\xC9\xCEF\xBA\xC1T$\xC5\x82`@Qa1\xD6\x91\x15\x15\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2a\x13\x1E\x7F\xC8\xB7\xFE$\xDC.\x9Es\x11A\xFE\x1D\xD7Ml\xE4p\xBDkSq\xC1/B\xC9\xCEF\xBA\xC1T$\xC5\x83\x83`@Q` \x01a2 \x92\x91\x90\x91\x82R\x15\x15` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@RaX>V[`@Q\x81\x81R\x7F\xF7\xCF\xAE\x98p\xE10z\x07\x91\xD6A\x8D\x9Ex\xAB\xD1s\x1A\x1C\x03`h\x13\x90kGM0~\xADV\x90` \x01`@Q\x80\x91\x03\x90\xA1a\x12\xF0\x7F\xF7\xCF\xAE\x98p\xE10z\x07\x91\xD6A\x8D\x9Ex\xAB\xD1s\x1A\x1C\x03`h\x13\x90kGM0~\xADV\x82`@Q` \x01a2 \x91\x81R` \x01\x90V[_T`\xFF\x16\x15a\x15\xF8W`@Qc\xD9<\x06e`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81`\x01`\x01`\xA0\x1B\x03\x16\x7FD(.*K\xBB\x86\xB9\xF8\x08\x9D\x10\x86\xF4\xE0\xDF'0T\xEA\xB6,\xDB\xDA\x18\xF6G\xCF\xD2*\x1E\xFF\x82`@Qa2\xFC\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R\x90\x81\x01\x82\x90Ra\x13\x1E\x90\x7FD(.*K\xBB\x86\xB9\xF8\x08\x9D\x10\x86\xF4\xE0\xDF'0T\xEA\xB6,\xDB\xDA\x18\xF6G\xCF\xD2*\x1E\xFF\x90``\x01a2 V[_\x81\x81R`\x08` R`@\x81 `\x01\x81\x01T\x80\x83\x03a3|W`@Qb\x90\xED=`\xE6\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81T_\x90\x81R`\x07` R`@\x90 a3\x96`\x01\x83ao\x82V[\x81T\x81\x10a3\xA6Wa3\xA6ao\x95V[\x90_R` _ \x90`\n\x02\x01\x92PPP\x91\x90PV[`\x0C\x80Tc\xFF\xFF\xFF\xFF`\x01` \x1B\x82\x04\x81\x16\x91`\x01`@\x1B\x90\x04\x16\x81\x15\x80a3\xE1WP\x80\x15[\x15a3\xECWPPPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`\x0F` R`@\x90 \x80TB\x91\x90\x84\x81\x10a4\x88W_\x82a4\x1B\x87\x84ao\x82V[\x81T\x81\x10a4+Wa4+ao\x95V[_\x91\x82R` \x90\x91 `\x04\x82\x04\x01T`\x03\x90\x91\x16`\x08\x02a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16\x90Pa4]\x85\x82as\xCEV[\x84`\x01`\x01`@\x1B\x03\x16\x10\x15a4\x86W`@Qc\x02\xA0\xEC!`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[P[P\x80T`\x01\x81\x01\x82U_\x91\x82R` \x90\x91 `\x04\x82\x04\x01\x80T`\x03\x90\x92\x16`\x08\x02a\x01\0\n`\x01`\x01`@\x1B\x03\x81\x81\x02\x19\x90\x93\x16\x93\x90\x92\x16\x91\x90\x91\x02\x91\x90\x91\x17\x90UPPPPV[_\x82\x81R`\x14` R`@\x90 T`\xFF\x16\x15a4\xFFW`@Qc\xD9%\x9C\xA9`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16a5&W`@Qc\x85b\xEBE`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x04T`\x01`\x01`\xA0\x1B\x03\x82\x81\x16\x91\x16\x14\x80\x15\x90F\x84\x14\x15\x90a5zW`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x12` R`@\x81 T\x90\x03a5zW`@Qc\x04~?\xE7`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80\x15a\x15\xE2W`\x01`\x01`\xA0\x1B\x03\x83\x81\x16_\x90\x81R`\x13` \x90\x81R`@\x80\x83 \x88\x84R\x90\x91R\x90 T\x16a\x15\xE2W`@Qc\xB3|y\xED`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@\x80Q\x84\x81R`\x01`\x01`\xA0\x1B\x03\x84\x81\x16` \x83\x01R\x83\x16\x81\x83\x01R\x90Q\x85\x91\x7F\xD7\xCFu\xDC\x192\x07\xF6HK{\xD6\xC4\xFCF\x9F;ks=,\xBC\xEE@9u({\x01]\xC4\x99\x91\x90\x81\x90\x03``\x01\x90\xA2`@\x80Q` \x81\x01\x86\x90R\x90\x81\x01\x84\x90R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16``\x83\x01R\x82\x16`\x80\x82\x01Ra\x15\xE2\x90\x7F\xD7\xCFu\xDC\x192\x07\xF6HK{\xD6\xC4\xFCF\x9F;ks=,\xBC\xEE@9u({\x01]\xC4\x99\x90`\xA0\x01a2 V[_\x84\x81R`\x1F` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x87\x16\x84R\x90\x91R\x90 T`\x01`\x01`@\x1B\x03\x90\x81\x16\x90\x82\x16\x81\x10\x15a6\xD7W_\x85\x81R`\x1F` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x88\x16\x84R\x90\x91R\x90 \x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`@\x1B\x03\x84\x16\x17\x90U[\x82_\x03a6\xE4WPa\x15\xE2V[`\x05T\x83\x90`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x90\x86\x16\x03a7\xF7W_\x86\x81R`\t` R`@\x81 \x80T\x90\x91[\x81\x81\x10\x80\x15a7\x1CWP\x83\x15\x15[\x15a7\xF3W_\x89\x81R`\x07` R`@\x81 \x80T\x83\x90\x81\x10a7@Wa7@ao\x95V[\x90_R` _ \x90`\n\x02\x01\x90P\x86`\x01`\x01`@\x1B\x03\x16\x81`\x02\x01`\x14\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x16\x11\x15a7\x85WPa7\xF3V[`\x06\x81\x01T_\x81\x90\x03a7\x99WPPa7\xE3V[_\x81\x87\x10a7\xA7W\x81a7\xA9V[\x86[\x90P\x80\x83`\x05\x01_\x82\x82Ta7\xBE\x91\x90as\xCEV[\x90\x91UPa7\xCE\x90P\x81\x83ao\x82V[`\x06\x84\x01Ua7\xDD\x81\x88ao\x82V[\x96PPPP[a7\xEC\x81ar\xB8V[\x90Pa7\x0EV[PPP[\x80\x15a8\x9BW_a8\x08\x87\x85aV\x18V[\x90P\x80_\x03a8,Wa8$a8\x1D\x83a9\xA2V[`\x03a1sV[PPPa\x15\xE2V[_a86\x82a3KV[\x90P\x82\x81`\x04\x01_\x82\x82Ta8K\x91\x90as\xCEV[\x92PP\x81\x90UP\x82\x81`\x05\x01_\x82\x82Ta8e\x91\x90as\xCEV[\x90\x91UP_\x90Pa8v\x82\x85aO\xB9V[\x90Pa8\x82\x84\x82aV\xCCV[\x80\x15a8\x97Wa8\x97\x83\x83\x83\x8C\x8C\x8B\x8AaY\x0CV[PPP[PPPPPPV[a8\xABaY\xDBV[_\x80T`\xFF\x19\x16\x90U\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA3[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01`@Q\x80\x91\x03\x90\xA1V[`@Qc\xFF\xFF\xFF\xFF\x82\x16\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90\x7F\xB1\xD8\xEF\xF9HX\x16\xBB8\xCE\xEC\xF3\x17\xA3\xFD\xA0U\x97\xBC[8\xF2\xF2-\xF9l\x0E\xBD]\xC26\xEE\x90` \x01`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01Rc\xFF\xFF\xFF\xFF\x83\x16\x91\x81\x01\x91\x90\x91Ra\x13\x1E\x90\x7F\xB1\xD8\xEF\xF9HX\x16\xBB8\xCE\xEC\xF3\x17\xA3\xFD\xA0U\x97\xBC[8\xF2\xF2-\xF9l\x0E\xBD]\xC26\xEE\x90``\x01a2 V[`\x01`\x01`\xA0\x1B\x03\x84\x16\x15a\x15\xE2Wa\x15\xE2\x84\x84\x84\x84aY\xFDV[_`\x01`\x01`\xFF\x1B\x03\x82\x11\x15a9\xCBW`@Qc\x05\x99\xF7\x1D`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[P\x90V[_`\x01`\x01`\xA0\x1B\x03\x83\x16a9\xEFWP`\x01`\x01`\xA0\x1B\x03\x81\x161a\x16\x05V[`@Qcp\xA0\x821`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R\x84\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a:3W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a:W\x91\x90at\x08V[\x93\x92PPPV[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\x9F^\x1D\x13\x04]'/\xBEt\xCEM\x08\xE9\x19\x82\xA5\xC5w\x849\x1A\xE6\xA1\x99\xEE\xCD\xCFc\x94\x9F\xFE\x90_\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x83\x16` \x82\x01Ra\x12\xF0\x91\x7F\x9F^\x1D\x13\x04]'/\xBEt\xCEM\x08\xE9\x19\x82\xA5\xC5w\x849\x1A\xE6\xA1\x99\xEE\xCD\xCFc\x94\x9F\xFE\x91\x01a2 V[\x81\x84\x86\x7F\xDC\xA1k\n\xF6\xE1\x0F]\xFB}N\xA9\x10U\x95\x14\x19\xA0\xC8\xFF\xC5\x92Z\xCF\xFD\xC5*\x95\xFC\xC6q3\x86\x85`@Qa;\x04\x92\x91\x90at\x1FV[`@Q\x80\x91\x03\x90\xA4a\x15\xCF\x7F\xDC\xA1k\n\xF6\xE1\x0F]\xFB}N\xA9\x10U\x95\x14\x19\xA0\xC8\xFF\xC5\x92Z\xCF\xFD\xC5*\x95\xFC\xC6q3\x86\x86\x86\x86\x86`@Q` \x01a2 \x95\x94\x93\x92\x91\x90at7V[`@Q`\x01`\x01`@\x1B\x03\x82\x16\x81R\x7F(l\xD7\xC5x\x1Em\xF3v\xDA\xA5\x9A\xB2\x07\xE1\xA0\xB1\xEC\xE9_\xAF\xC2\x98\xF9\xABi\xA1\x88\xF4\x9F\xF2\xD5\x90` \x01`@Q\x80\x91\x03\x90\xA1`@\x80Q`\x01`\x01`@\x1B\x03\x83\x16` \x82\x01Ra\x12\xF0\x91\x7F(l\xD7\xC5x\x1Em\xF3v\xDA\xA5\x9A\xB2\x07\xE1\xA0\xB1\xEC\xE9_\xAF\xC2\x98\xF9\xABi\xA1\x88\xF4\x9F\xF2\xD5\x91\x01a2 V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16\x81R` \x81\x01\x83\x90R\x7Fh\xF6}\xE8\x9E\x96\xB1:>\xA0X\xAF_\xD4L\xC1%\xEF\xCE\xB5(H-S\x9C{C\xDB/\xAA\x06n\x91\x01`@Q\x80\x91\x03\x90\xA1`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R\x90\x81\x01\x82\x90Ra\x13\x1E\x90\x7Fh\xF6}\xE8\x9E\x96\xB1:>\xA0X\xAF_\xD4L\xC1%\xEF\xCE\xB5(H-S\x9C{C\xDB/\xAA\x06n\x90``\x01a2 V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xA4O)=\xFA\x92(\x91cE\xA6\x01b \xF3\x04\xFDN\x10\xC2\xF2^\xF6,\x89kIF\x92jp\xF4\x90_\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x83\x16` \x82\x01Ra\x12\xF0\x91\x7F\xA4O)=\xFA\x92(\x91cE\xA6\x01b \xF3\x04\xFDN\x10\xC2\xF2^\xF6,\x89kIF\x92jp\xF4\x91\x01a2 V[`\x01`\x01`\xA0\x1B\x03\x16`A`\xA0\x1B\x17`X\x1B\x90V[_`\x04\x82Q\x10\x15a<\xF8W`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a=\x02\x83atlV[\x90Pcf\xD8\xA5e`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x82\x16\x01a=%Wa:W\x83aZVV[c\nm5\xE5`\xE3\x1B`\x01`\x01`\xE0\x1B\x03\x19\x82\x16\x01a=gWa:W\x83\x7F\x99'Z\x9B\x9A=\x95\x0C\xFE\r1\xA1\xD4\x83\x1Af\xA9\xCE\xBA}\x83o\x9BhT\xF0\xF1\xA7\xEBN\xAC\x1CaZ\x84V[`@Qc6[>S`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x82\x81[\x81\x81\x10\x15a>\xF6W6\x86\x86\x83\x81\x81\x10a=\xA0Wa=\xA0ao\x95V[\x90P` \x02\x81\x01\x90a=\xB2\x91\x90at\xAAV[\x90Pa>2\x89a=\xC8``\x84\x01`@\x85\x01ag\xB8V[`\x01`\x01`@\x1B\x03\x16a=\xE1`\x80\x85\x01``\x86\x01ag\xB8V[`\x01`\x01`@\x1B\x03\x16\x845a=\xF9` \x87\x01\x87at\xC8V[\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPa[\x91\x92PPPV[`\x01\x90\x97\x01\x96`\x02\x89\x89a>L``\x85\x01`@\x86\x01ag\xB8V[`\x01`\x01`@\x1B\x03\x16a>e`\x80\x86\x01``\x87\x01ag\xB8V[`\x01`\x01`@\x1B\x03\x16\x855a>}` \x88\x01\x88at\xC8V[`@Q` \x01a>\x93\x97\x96\x95\x94\x93\x92\x91\x90au\nV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra>\xAD\x91auVV[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a>\xC8W=__>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a>\xEB\x91\x90at\x08V[\x98PP`\x01\x01a=\x85V[P\x95\x96\x94\x95PPPPPV[\x80_[\x81\x81\x10\x15a\x15\xE2W6\x84\x84\x83\x81\x81\x10a? Wa? ao\x95V[\x90P` \x02\x81\x01\x90a?2\x91\x90at\xAAV[\x90P`\x17`@Q\x80`\x80\x01`@R\x80\x83_\x015\x81R` \x01\x83\x80` \x01\x90a?Z\x91\x90at\xC8V[\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPPP\x90\x82RP` \x01a?\xA3``\x85\x01`@\x86\x01ag\xB8V[`\x01`\x01`@\x1B\x03\x16\x81R` \x01a?\xC1`\x80\x85\x01``\x86\x01ag\xB8V[`\x01`\x01`@\x1B\x03\x16\x90R\x81T`\x01\x81\x81\x01\x84U_\x93\x84R` \x93\x84\x90 \x83Q`\x03\x90\x93\x02\x01\x91\x82U\x92\x82\x01Q\x91\x92\x90\x91\x90\x82\x01\x90a@\0\x90\x82as\x14V[P`@\x82\x01Q`\x02\x90\x91\x01\x80T``\x90\x93\x01Q`\x01`\x01`@\x1B\x03\x90\x81\x16`\x01`@\x1B\x02`\x01`\x01`\x80\x1B\x03\x19\x90\x94\x16\x92\x16\x91\x90\x91\x17\x91\x90\x91\x17\x90UP`\x01\x01a?\x05V[\x81`\x01`\x01`\xA0\x1B\x03\x16\x7F\n\xA8&&\xF1\x9B\xB5\xD4\x19b\x02\xB0\x1F/\xEEC\x1B\x95\xE8\x8C\xB0THK\x98}e\r\x91\x92\x8A\xDA\x82`@Qa@\x80\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R\x90\x81\x01\x82\x90Ra\x13\x1E\x90\x7F\n\xA8&&\xF1\x9B\xB5\xD4\x19b\x02\xB0\x1F/\xEEC\x1B\x95\xE8\x8C\xB0THK\x98}e\r\x91\x92\x8A\xDA\x90``\x01a2 V[`@\x80Q\x83\x81R` \x81\x01\x83\x90R\x7F\xABc\xC2Z\xA0zM\x10\xA1\x84-a\x02j\x08\xD9Q\x15\xC4\xE6\x89R\x88h0\x15\xCADd\xC7\xF5\x0F\x91\x01`@Q\x80\x91\x03\x90\xA1a\x13\x1E\x7F\xABc\xC2Z\xA0zM\x10\xA1\x84-a\x02j\x08\xD9Q\x15\xC4\xE6\x89R\x88h0\x15\xCADd\xC7\xF5\x0F\x83\x83`@Q` \x01a2 \x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x81\x16\x82R\x83\x91\x90\x85\x16\x90\x7FB}\xB4\x8F\x8C\xD0\xCF\x7F\xDA\xBC\xDB\xC12|}\xB2l\xE3\xA5D)+\xA3\x80\xEF\x07\xD5\x17Z\xF7)\xCD\x90` \x01`@Q\x80\x91\x03\x90\xA3`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x86\x16` \x83\x01R\x91\x81\x01\x84\x90R\x90\x82\x16``\x82\x01Ra\x1F\xF6\x90\x7FB}\xB4\x8F\x8C\xD0\xCF\x7F\xDA\xBC\xDB\xC12|}\xB2l\xE3\xA5D)+\xA3\x80\xEF\x07\xD5\x17Z\xF7)\xCD\x90`\x80\x01a2 V[c\x8Bx\xC6\xD8\x19T`\x01`\x01`\xA0\x1B\x03\x90\x91\x16c\x8Bx\xC6\xD8\x19\x81\x90U\x90a\x13\x1E\x81\x83a\\\x0BV[`\x01`\x01`\xA0\x1B\x03\x86\x16_\x90\x81R`\n` R`@\x90 T`\xFF\x16aB9W`@QcE\x14!\xBD`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aBB\x86a\\\x97V[_aBL\x87a]wV[\x90P\x80\x84c\xFF\xFF\xFF\xFF\x16\x10\x80aBjWPb\x0FB@\x84c\xFF\xFF\xFF\xFF\x16\x11[\x15aB\x88W`@QcJU\x94k`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_aB\x92\x88a]\xB1V[\x90P\x80\x84`\x01`\x01`@\x1B\x03\x16\x10\x15aB\xBEW`@Qc&%\xB7\x81`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x83\x81R`\x14` R`@\x90 T`\xFF\x16\x15aB\xEDW`@Qc\xD9%\x9C\xA9`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[B`\x01`\x01`@\x1B\x03\x80\x82\x16\x90\x88\x16\x10\x15aC\x1BW`@QcP\x1D\x13\xED`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_aC%\x8AaIhV[\x90P\x80\x15aCiW_aCD`\x01`\x01`@\x1B\x03\x80\x85\x16\x90\x8B\x16ao\x82V[\x90P\x81\x81\x11\x15aCgW`@Qc*\xB8LG`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[P[_\x89\x81R`\t` R`@\x90 \x80T\x15a'VW_\x8A\x81R`\x07` R`@\x81 \x82TaC\x98\x90`\x01\x90ao\x82V[\x81T\x81\x10aC\xA8WaC\xA8ao\x95V[_\x91\x82R` \x90\x91 `\n\x90\x91\x02\x01`\x03\x81\x01T\x90\x91P`\x01`\x01`@\x1B\x03\x16B\x10\x15aC\xE8W`@Qc\xB4\xED\x1C5`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPPPPPPPPPPPV[_\x8A\x81R`\x07` \x90\x81R`@\x91\x82\x90 T\x82Q\x80\x84\x01\x90\x93R\x8C\x83R\x91\x90\x81\x01aD\"\x83`\x01as\xCEV[\x81RP`\x08_\x8E\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01U` \x82\x01Q\x81`\x01\x01U\x90PP`\x07_\x8C\x81R` \x01\x90\x81R` \x01_ `@Q\x80a\x01`\x01`@R\x80\x8D\x81R` \x01\x8C`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x8B`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x8A`\x01`\x01`@\x1B\x03\x16\x81R` \x01\x89`\x01`\x01`@\x1B\x03\x16\x81R` \x01\x88c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x87`\x01`\x01`@\x1B\x03\x16\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01`@Q\x80``\x01`@R\x80\x88\x81R` \x01\x87`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x86`\x01`\x01`\xA0\x1B\x03\x16\x81RP\x81RP\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\n\x02\x01_\x90\x91\x90\x91\x90\x91P_\x82\x01Q\x81_\x01U` \x82\x01Q\x81`\x01\x01_a\x01\0\n\x81T\x81`\x01`\x01`\xA0\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`\xA0\x1B\x03\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x02\x01_a\x01\0\n\x81T\x81`\x01`\x01`\xA0\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`\xA0\x1B\x03\x16\x02\x17\x90UP``\x82\x01Q\x81`\x02\x01`\x14a\x01\0\n\x81T\x81`\x01`\x01`@\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`@\x1B\x03\x16\x02\x17\x90UP`\x80\x82\x01Q\x81`\x03\x01_a\x01\0\n\x81T\x81`\x01`\x01`@\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`@\x1B\x03\x16\x02\x17\x90UP`\xA0\x82\x01Q\x81`\x03\x01`\x08a\x01\0\n\x81T\x81c\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83c\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\xC0\x82\x01Q\x81`\x03\x01`\x0Ca\x01\0\n\x81T\x81`\x01`\x01`@\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`@\x1B\x03\x16\x02\x17\x90UP`\xE0\x82\x01Q\x81`\x04\x01Ua\x01\0\x82\x01Q\x81`\x05\x01Ua\x01 \x82\x01Q\x81`\x06\x01Ua\x01@\x82\x01Q\x81`\x07\x01_\x82\x01Q\x81_\x01U` \x82\x01Q\x81`\x01\x01_a\x01\0\n\x81T\x81`\x01`\x01`\xA0\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`\xA0\x1B\x03\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x02\x01_a\x01\0\n\x81T\x81`\x01`\x01`\xA0\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`\xA0\x1B\x03\x16\x02\x17\x90UPPPPP`\t_\x8C\x81R` \x01\x90\x81R` \x01_ \x8C\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91PU\x9B\x9APPPPPPPPPPPV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x88\x81\x16\x82R\x87\x16` \x82\x01R`\x01`\x01`@\x1B\x03\x86\x81\x16\x82\x84\x01R\x85\x81\x16``\x83\x01Rc\xFF\xFF\xFF\xFF\x85\x16`\x80\x83\x01R\x83\x16`\xA0\x82\x01R\x90Q\x88\x91\x8A\x91\x8C\x91\x7F\xE41P+\xD0\xDFX\x809~\xC1<\n&\x0F\x0Ct\x9C\x8F:0\xC6\xCA\xF3\xFF\xE0\xF0\x8A.\xD19B\x91\x90\x81\x90\x03`\xC0\x01\x90\xA4`@\x80Q` \x81\x01\x8B\x90R\x90\x81\x01\x89\x90R``\x81\x01\x88\x90R`\x01`\x01`\xA0\x1B\x03\x80\x88\x16`\x80\x83\x01R\x86\x16`\xA0\x82\x01R`\x01`\x01`@\x1B\x03\x80\x86\x16`\xC0\x83\x01R\x80\x85\x16`\xE0\x83\x01Rc\xFF\xFF\xFF\xFF\x84\x16a\x01\0\x83\x01R\x82\x16a\x01 \x82\x01Ra8\x97\x90\x7F\xE41P+\xD0\xDFX\x809~\xC1<\n&\x0F\x0Ct\x9C\x8F:0\xC6\xCA\xF3\xFF\xE0\xF0\x8A.\xD19B\x90a\x01@\x01a2 V[aH\x14a2\x9EV[_\x80T`\xFF\x19\x16`\x01\x17\x90U\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2Xa8\xD73\x90V[\x81`\x01`\x01`\xA0\x1B\x03\x16\x7FD/z\xB7\xD2k\xF7\xBAt\xF2>#}\x12\x87bQ\xF9\x1Da\xAE\xB2\x89\x9A\xD9_3O\xA5\xE7\xC63\x82`@QaH\x85\x91\x15\x15\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R\x82\x15\x15\x91\x81\x01\x91\x90\x91Ra\x13\x1E\x90\x7FD/z\xB7\xD2k\xF7\xBAt\xF2>#}\x12\x87bQ\xF9\x1Da\xAE\xB2\x89\x9A\xD9_3O\xA5\xE7\xC63\x90``\x01a2 V[\x81`\x01`\x01`\xA0\x1B\x03\x16\x7F \x80\xA7VDM*\xF0\xF9\xFBO\x87\xDBz\xF6<\xD6\xE2;z\x12\x03\xCB\xE9\xAB\tr\xEE\x05\xD1\xEA\xFD\x82`@QaI\x15\x91\x15\x15\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R\x82\x15\x15\x91\x81\x01\x91\x90\x91Ra\x13\x1E\x90\x7F \x80\xA7VDM*\xF0\xF9\xFBO\x87\xDBz\xF6<\xD6\xE2;z\x12\x03\xCB\xE9\xAB\tr\xEE\x05\xD1\xEA\xFD\x90``\x01a2 V[`\x0CT`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\r` R`@\x81 T\x90\x91c\xFF\xFF\xFF\xFF`\x01`\xA0\x1B\x91\x82\x90\x04\x81\x16\x92\x91\x90\x91\x04\x16\x81\x83\x03aI\xA9W\x93\x92PPPV[\x80_\x03aI\xB7WP\x92\x91PPV[\x81\x81\x10aI\xC4W\x81aI\xC6V[\x80[\x94\x93PPPPV[____aI\xDAa\x17\x0EV[\x90P\x86\x93P[\x87T\x84\x10\x80\x15aI\xF8WP\x85aI\xF6\x88\x86ao\x82V[\x10[\x15aJ\xE9W_\x88\x85\x81T\x81\x10aJ\x10WaJ\x10ao\x95V[\x90_R` _ \x90`\x05\x02\x01`\x01\x01T\x90P\x80\x82\x10\x15aJ0WPaJ\xE9V[aJ:\x81\x85as\xCEV[`\x04T\x90\x94P`\x01`\x01`\xA0\x1B\x03\x8B\x81\x16\x91\x16\x14aJ\xDCW_\x89\x86\x81T\x81\x10aJeWaJeao\x95V[\x90_R` _ \x90`\x05\x02\x01`\x03\x01T\x90PF\x81\x14aJ\xC0W`\x01`\x01`\xA0\x1B\x03\x8B\x81\x16_\x90\x81R`\x13` \x90\x81R`@\x80\x83 \x85\x84R\x90\x91R\x90 T\x16aJ\xC0W`@Qc\xB3|y\xED`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aJ\xCE\x82\x88b\x0FB@a]\xF6V[aJ\xD8\x90\x85as\xCEV[\x93PP[`\x01\x90\x94\x01\x93\x90\x03aI\xE0V[P\x95P\x95P\x95\x92PPPV[`\x04T_\x90aK.\x90`\x01`\x01`\xA0\x1B\x03\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87a1OV[`@Qc\x8B\xCC\xC1\x87`\xE0\x1B\x81R_\x90`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\x8B\xCC\xC1\x87\x90aK\x84\x90\x87\x90\x87\x90\x8C\x90\x8B\x900\x90`\x04\x01auaV[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15aK\xA0W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aK\xC4\x91\x90at\x08V[\x90P\x84\x81\x11\x15aK\xDBWaK\xD8\x85\x82ao\x82V[\x91P[P\x95\x94PPPPPV[\x81[\x81\x81\x10\x15a8\x9BW_\x84\x82\x81T\x81\x10aL\x02WaL\x02ao\x95V[_\x91\x82R` \x91\x82\x90 `@\x80Q`\xA0\x81\x01\x82R`\x05\x90\x93\x02\x90\x91\x01\x80T\x83R`\x01\x81\x01T\x93\x83\x01\x84\x90R`\x02\x81\x01T\x91\x83\x01\x91\x90\x91R`\x03\x81\x01T``\x83\x01R`\x04\x01T`\x01`\x01`\xA0\x1B\x03\x16`\x80\x82\x01R\x86T\x90\x92P\x86\x90\x84\x90\x81\x10aLlWaLlao\x95V[_\x91\x82R` \x80\x83 `\x05\x90\x92\x02\x90\x91\x01\x82\x81U`\x01\x80\x82\x01\x84\x90U`\x02\x82\x01\x84\x90U`\x03\x82\x01\x84\x90U`\x04\x91\x82\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x16\x90\x91U`@\x80\x88\x01Q\x86R`\x1C\x85R\x80\x86 \x88Q\x87R\x90\x94R\x92\x84 \x80T\x90\x93\x16\x83U\x91\x90\x91\x01\x82\x90UT`\x01`\x01`\xA0\x1B\x03\x8A\x81\x16\x91\x16\x14aL\xF9WaL\xF4\x82\x89b\x0FB@a]\xF6V[aL\xFBV[\x81[\x90P\x80\x15aM\xEDWF\x83``\x01Q\x14aM\xDEW`\x01`\x01`\xA0\x1B\x03\x80\x8A\x16_\x90\x81R`\x13` \x90\x81R`@\x80\x83 ``\x88\x01Q\x84R\x90\x91R\x90 T\x16\x80aMUW`@Qc\xB3|y\xED`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aM`\x8A\x82\x84a1OV[``\x84\x01Q`\x80\x85\x01Q`@Qc/,\x1D-`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x8D\x81\x16`\x04\x83\x01R`$\x82\x01\x86\x90R`D\x82\x01\x93\x90\x93R\x90\x82\x16`d\x82\x01R\x90\x82\x16\x90c^X:Z\x90`\x84\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aM\xC2W__\xFD[PZ\xF1\x15\x80\x15aM\xD4W=__>=_\xFD[PPPPPaM\xEDV[aM\xED\x89\x84`\x80\x01Q\x83a1OV[aN\x0B\x83`@\x01Q\x84_\x01Q\x8B\x87\x86\x88``\x01Q\x89`\x80\x01Qa^\x02V[PPP\x80`\x01\x01\x90PaK\xE7V[__\x7F\x10J\xC0\xAD\x95\xE4C\x03\xBC\xFB\r\x0EV\x8A\xC4\x9A\xB6f\xCA\x92\xAFe\r\x9F\xA3V\xAD\x9C\x0FI\xDB\xA2\x90P_`@Q\x82\x81R\x89` \x82\x01R\x88`@\x82\x01R\x87``\x82\x01R\x86`\x80\x82\x01R\x85`\xA0\x82\x01R\x84`\xC0\x82\x01R`\xE0\x81 \x91P`\xE0\x81\x01`@RPaN\x80\x81a^\xD3V[\x99\x98PPPPPPPPPV[_aN\xD9\x84\x84\x84\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPP`\x01`\x01`\xA0\x1B\x03\x8A\x16\x93\x92\x91PPa_\xE9V[\x90P\x80a\x15\xCFW`@Qc\x8B\xAAW\x9F`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x82\x81R` \x80R`@\x90 `\x01\x80\x83\x01\x90\x91Ua\x13\x1E\x90\x83\x90aO\x1E\x90\x84\x90as\xCEV[a`\xC6V[`@Q\x80``\x01`@R\x80\x82_\x015\x81R` \x01\x82` \x01` \x81\x01\x90aOJ\x91\x90af\xB3V[`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01aOh``\x84\x01`@\x85\x01af\xB3V[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x90\x91R\x81Q`\x07\x85\x01U` \x82\x01Q`\x08\x85\x01\x80T\x91\x83\x16`\x01`\x01`\xA0\x1B\x03\x19\x92\x83\x16\x17\x90U`@\x90\x92\x01Q`\t\x90\x94\x01\x80T\x94\x90\x91\x16\x93\x90\x91\x16\x92\x90\x92\x17\x90\x91UPV[`\x03\x82\x01T_\x90`\x01`@\x1B\x90\x04c\xFF\xFF\xFF\xFF\x16\x81b\x0FB@aO\xDC\x83\x82ao\x82V[aO\xE6\x90\x86av>V[aO\xF0\x91\x90aviV[`\x03\x86\x01T\x90\x91P`\x01``\x1B\x90\x04`\x01`\x01`@\x1B\x03\x16\x80\x82\x11\x15aP\x1AW\x80\x82\x03\x93PaP\x1EV[_\x93P[PPP\x92\x91PPV[_\x83\x81R`\x1B` R`@\x81 \x80T\x82\x91\x82aPB\x83ar\xB8V[\x90\x91UP`\x01`\x01`\xA0\x1B\x03\x88\x81\x16_\x90\x81R`\x19` \x90\x81R`@\x80\x83 \x81Q`\xA0\x81\x01\x83R\x86\x81R\x80\x84\x01\x8D\x81R\x92\x81\x01\x8C\x81R``\x82\x01\x8C\x81R\x8B\x88\x16`\x80\x84\x01\x90\x81R\x84T`\x01\x80\x82\x01\x87U\x86\x8AR\x97\x90\x98 \x93Q`\x05\x90\x98\x02\x90\x93\x01\x96\x87U\x93Q\x86\x86\x01UQ`\x02\x86\x01U\x91Q`\x03\x85\x01U\x90Q`\x04\x90\x93\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x93\x90\x94\x16\x92\x90\x92\x17\x90\x92U\x80T\x92\x93P\x91aP\xE7\x91\x90ao\x82V[`@\x80Q\x80\x82\x01\x82R`\x01`\x01`\xA0\x1B\x03\x8B\x81\x16\x82R` \x80\x83\x01\x85\x81R_\x8C\x81R`\x1C\x83R\x85\x81 \x89\x82R\x90\x92R\x93\x90 \x91Q\x82T`\x01`\x01`\xA0\x1B\x03\x19\x16\x91\x16\x17\x81U\x90Q`\x01\x90\x91\x01U\x92PP[\x95P\x95\x93PPPPV[`@\x80Qa\x01\xA0\x81\x01\x82R\x89\x81R` \x81\x01\x89\x90R`\x01\x88\x01T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x82\x01\x92\x90\x92R``\x81\x01\x87\x90R`\x80\x81\x01\x86\x90R\x87T`\xA0\x82\x01R`\x02\x88\x01T\x90\x91\x16`\xC0\x82\x01RaQ\xC9\x90`\xE0\x81\x01_\x81R` \x81\x01\x86\x90R`\x01`\x01`\xA0\x1B\x03\x85\x16`@\x82\x01R_``\x82\x01\x81\x90R`\x80\x82\x01R`\xA0\x01\x83\x90Raa@V[PPPPPPPPV[\x81`\x01`\x01`\xA0\x1B\x03\x16\x7F\xDA\xE4A|%\xA9<\xFB\x86\xCE_\xBB\xB8\xFC\x160\x94[a\xAF\xAE\xABO)\xCF0\x1B\x9A\x05\x8B\xA9\x14\x82`@QaR\x0E\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R\x90\x81\x01\x82\x90Ra\x13\x1E\x90\x7F\xDA\xE4A|%\xA9<\xFB\x86\xCE_\xBB\xB8\xFC\x160\x94[a\xAF\xAE\xABO)\xCF0\x1B\x9A\x05\x8B\xA9\x14\x90``\x01a2 V[\x81`\x01`\x01`\xA0\x1B\x03\x16\x7F\xA8\xD3\xB3!;\x7F\x82D\xE5\xB0EQ\xDB\x9A\xAA\xBC\xCC!\xD6!,C\xC3\xB3\x14;\xCD\xE9|\xA8S\xCE\x82`@QaR\x98\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R\x90\x81\x01\x82\x90Ra\x13\x1E\x90\x7F\xA8\xD3\xB3!;\x7F\x82D\xE5\xB0EQ\xDB\x9A\xAA\xBC\xCC!\xD6!,C\xC3\xB3\x14;\xCD\xE9|\xA8S\xCE\x90``\x01a2 V[`@Qc\xFF\xFF\xFF\xFF\x82\x16\x81R\x7F\x1F\xB3\xB3\x8E@ \t\xF1\xBB\xD2M\np\0Zz\x9A\x05[?[Tl\x8B!\xF8\x15G\n\x9C.\xC4\x90` \x01`@Q\x80\x91\x03\x90\xA1`@\x80Qc\xFF\xFF\xFF\xFF\x83\x16` \x82\x01Ra\x12\xF0\x91\x7F\x1F\xB3\xB3\x8E@ \t\xF1\xBB\xD2M\np\0Zz\x9A\x05[?[Tl\x8B!\xF8\x15G\n\x9C.\xC4\x91\x01a2 V[`@\x80Q\x83\x81R` \x81\x01\x83\x90R`\x01`\x01`\xA0\x1B\x03\x85\x16\x91\x7Fa\xC4\x9A\xB6\xBB\x1E\xF5\x91\x91\xA7F\xAF\xCE}'1\xD4\xD9\xB0\xFA\xFD\xAB\x8Dc\xF0/\xE4AiS-\xC5\x91\x01`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x85\x16` \x82\x01R\x90\x81\x01\x83\x90R``\x81\x01\x82\x90Ra\x1F\xF6\x90\x7Fa\xC4\x9A\xB6\xBB\x1E\xF5\x91\x91\xA7F\xAF\xCE}'1\xD4\xD9\xB0\xFA\xFD\xAB\x8Dc\xF0/\xE4AiS-\xC5\x90`\x80\x01a2 V[`@Q`\x01`\x01`@\x1B\x03\x82\x16\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90\x7F/H\x171\x82B\xD1\xB8g\0\xA4&\xF7\xCE\xD0I\xC6\x80Y%<\nr\x1E\x01\xB9q\x8FE'\xBE\xF6\x90` \x01`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R`\x01`\x01`@\x1B\x03\x83\x16\x91\x81\x01\x91\x90\x91Ra\x13\x1E\x90\x7F/H\x171\x82B\xD1\xB8g\0\xA4&\xF7\xCE\xD0I\xC6\x80Y%<\nr\x1E\x01\xB9q\x8FE'\xBE\xF6\x90``\x01a2 V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F])i>c\xB3\xA0\x84\xE5h\x93\xCE\x8C\x7F^\xF5\xDC\x82\x13\xDAA\x07\0\x84\xE6\xB1\xC47\n\xBDd\xC4\x90_\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x83\x16` \x82\x01Ra\x12\xF0\x91\x7F])i>c\xB3\xA0\x84\xE5h\x93\xCE\x8C\x7F^\xF5\xDC\x82\x13\xDAA\x07\0\x84\xE6\xB1\xC47\n\xBDd\xC4\x91\x01a2 V[_aU\x03\x82a<\xBFV[j\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x86\x81\x16\x91\x16\x14aU3W`@Qc3\x95v[`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_aU^\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x88a*QV[\x90P_aUj\x82a<\xBFV[\x90P__aUx\x87\x89aa\xF8V[\x92P\x92PP\x82`\x01`\x01`X\x1B\x03\x19\x16\x82`\x01`\x01`X\x1B\x03\x19\x16\x14aN\x80W`@Qc@e\x0E\xA9`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x83\x81R`\x1F` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 T`\x01`\x01`@\x1B\x03\x16\x80\x15\x80\x15\x90aU\xFAWP`\x01`\x01`@\x1B\x03\x81\x16c\xFF\xFF\xFF\xFF\x83\x16\x11\x15[\x15a\x15\xE2W`@Qc>l\x07\x11`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x82\x81R`\t` R`@\x81 \x80T\x80\x83\x03aV8W_\x92PPPa\x16\x05V[\x80[\x80\x15aP\x1EW_\x86\x81R`\x07` R`@\x81 \x80T_\x19\x90\x93\x01\x92\x83\x90\x81\x10aVeWaVeao\x95V[\x90_R` _ \x90`\n\x02\x01\x90P\x85`\x01`\x01`@\x1B\x03\x16\x81`\x02\x01`\x14\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x16\x11aV\xC6W\x83\x82\x81T\x81\x10aV\xB5WaV\xB5ao\x95V[\x90_R` _ \x01T\x94PPaP\x1EV[PaV:V[a\x13\x1EaV\xDCa\x1AR\x83\x85ao\x82V[_a1sV[`@\x80Qa\x01\xA0\x81\x01\x82R\x89\x81R` \x81\x01\x89\x90R`\x01\x80\x89\x01T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x93\x83\x01\x93\x90\x93R``\x82\x01\x88\x90R`\x80\x82\x01\x87\x90R\x88T`\xA0\x83\x01R`\x02\x89\x01T\x90\x92\x16`\xC0\x82\x01RaQ\xC9\x91`\xE0\x82\x01\x90\x81R` \x81\x01\x86\x90R_`@\x82\x01\x81\x90R``\x82\x01Rc\xFF\xFF\xFF\xFF\x85\x16`\x80\x82\x01R`\xA0\x01\x83\x90Raa@V[\x81`\x14R\x80`4Rc\xA9\x05\x9C\xBB``\x1B_R` _`D`\x10_\x87Z\xF1\x80`\x01_Q\x14\x16aW\xA7W\x80=\x85;\x15\x17\x10aW\xA7Wc\x90\xB8\xEC\x18_R`\x04`\x1C\xFD[P_`4RPPPV[_8_8\x84\x86Z\xF1a\x13\x1EWc\xB1-\x13\xEB_R`\x04`\x1C\xFD[\x7FC\x99\x1E\x1E\x1C\xFB.\xEDl\x9D\xC3zz\x84\x86\"\xF8\xE3\xF7[\xC3\x8DS*\0\xEA\xF0&\xCD\x87\xA0\x14\x83\x83\x83`@QaW\xFD\x93\x92\x91\x90av\x9CV[`@Q\x80\x91\x03\x90\xA1a\x1F\xF6\x7FC\x99\x1E\x1E\x1C\xFB.\xEDl\x9D\xC3zz\x84\x86\"\xF8\xE3\xF7[\xC3\x8DS*\0\xEA\xF0&\xCD\x87\xA0\x14\x84\x84\x84`@Q` \x01a2 \x93\x92\x91\x90av\x9CV[`\x02\x80T`\x01\x90\x81\x01\x80\x83U\x90T`@Q\x90\x92\x91aXi\x91\x84\x91\x90C\x90B\x90\x89\x90\x89\x90` \x01av\xC8V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90RaX\x83\x91auVV[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15aX\x9EW=__>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aX\xC1\x91\x90at\x08V[`\x01\x81\x90UP`\x01T\x81`\x02T\x7Fx\x16\x0F\x0B\x1B+2\xB5*\0v\xD8\xF0\xF7\x08\x88h{\xA7\x02\xA4\xD9\x93\xD5Z\xC8\xD92}W\xA1'\x86\x86`@QaX\xFF\x92\x91\x90at\x1FV[`@Q\x80\x91\x03\x90\xA4PPPV[`\x08\x86\x01T`\x07\x87\x01\x80T`\t\x89\x01T\x91\x92_\x92\x83\x92aY>\x92`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x8C\x92\x8F\x92\x90\x91\x16aP'V[`@\x80Qa\x01\xA0\x81\x01\x82R\x8D\x81R` \x81\x01\x83\x90R`\x01\x87\x01T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x82\x01\x92\x90\x92R``\x81\x01\x84\x90R`\x80\x81\x01\x8C\x90R\x86T`\xA0\x82\x01R`\x02\x80\x88\x01T\x83\x16`\xC0\x83\x01R`\xE0\x82\x01Ra\x01\0\x81\x01\x8B\x90R_a\x01 \x82\x01R\x90\x89\x16a\x01@\x82\x01R`\x01`\x01`@\x1B\x03\x88\x16a\x01`\x82\x01Ra\x01\x80\x81\x01\x87\x90R\x91\x93P\x91PaY\xCF\x90aa@V[PPPPPPPPPPV[_T`\xFF\x16a\x15\xF8W`@Qc\x8D\xFC +`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x81``R\x82`@R\x83``\x1B`,Rc#\xB8r\xDD``\x1B`\x0CR` _`d`\x1C_\x89Z\xF1\x80`\x01_Q\x14\x16aZHW\x80=\x87;\x15\x17\x10aZHWcy9\xF4$_R`\x04`\x1C\xFD[P_``R`@RPPPPV[\x80Q_\x90`$\x81\x14aZ{W`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP`$\x01Q\x90V[\x81Q_\x90`$\x81\x10\x15aZ\xAAW`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`$\x84\x01Q_\x90aZ\xBC\x90`\x04as\xCEV[\x90P\x81aZ\xCA\x82` as\xCEV[\x11\x15aZ\xE9W`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_aZ\xF7\x86\x83\x01` \x01Q\x90V[\x90P_a[\x05\x83` as\xCEV[\x90P\x83a[\x13\x83` av>V[a[\x1D\x90\x83as\xCEV[\x11\x15a[<W`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_[\x82\x81\x10\x15a[wW__a[U\x8A\x85\x89\x86\x8Dab\xA6V[\x91P\x91P\x81\x15a[mW\x96Pa\x16\x05\x95PPPPPPV[PP`\x01\x01a[>V[P`@Qc\"\x86\xAC\xB9`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x84\x7F\x9Da\x1B[4\xCBv\x13\x1CO\xB4\x13\xEBt\x11\x9B,\x0C:j\xA6\xFC\xD8\xE7@\xCFp\xAC0\x85\xD8{\x87\x86\x85`@Qa[\xC6\x93\x92\x91\x90av\xFDV[`@Q\x80\x91\x03\x90\xA3a\x15\xCF\x7F\x9Da\x1B[4\xCBv\x13\x1CO\xB4\x13\xEBt\x11\x9B,\x0C:j\xA6\xFC\xD8\xE7@\xCFp\xAC0\x85\xD8{\x86\x86\x86\x86\x86`@Q` \x01a2 \x95\x94\x93\x92\x91\x90at7V[\x80`\x01`\x01`\xA0\x1B\x03\x16\x82`\x01`\x01`\xA0\x1B\x03\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3a\x13\x1E\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x83\x83`@Q` \x01a2 \x92\x91\x90`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x16` \x82\x01R`@\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\r` R`@\x90 \x80Tc\xFF\xFF\xFF\xFF`\x01` \x1B\x82\x04\x81\x16\x91`\x01`@\x1B\x90\x04\x16\x81\x15\x80a\\\xD2WP\x80\x15[\x15a\\\xDDWPPPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`\x0E` R`@\x90 \x80TB\x91\x90\x84\x81\x10a4\x88W_\x82a]\x0C\x87\x84ao\x82V[\x81T\x81\x10a]\x1CWa]\x1Cao\x95V[_\x91\x82R` \x90\x91 `\x04\x82\x04\x01T`\x03\x90\x91\x16`\x08\x02a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16\x90Pa]N\x85\x82as\xCEV[\x84`\x01`\x01`@\x1B\x03\x16\x10\x15a4\x86W`@Qc\x13\x15\n\xB9`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x0CT`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\r` R`@\x81 T\x90\x91c\xFF\xFF\xFF\xFF\x90\x81\x16\x91\x16\x81\x81\x11\x15a]\xAAW\x80\x91P[P\x92\x91PPV[`\x0CT`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\r` R`@\x81 T\x90\x91`\x01`\x01`@\x1B\x03`\x01``\x1B\x91\x82\x90\x04\x81\x16\x92\x91\x90\x91\x04\x16\x81\x81\x11\x15a]\xAAW\x93\x92PPPV[_aI\xC6\x84\x84\x84ac\xDAV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x87\x81\x16\x82R` \x82\x01\x87\x90R\x81\x83\x01\x86\x90R``\x82\x01\x85\x90R\x83\x16`\x80\x82\x01R\x90Q\x87\x91\x89\x91\x7F\xB6+No\x1E\xC5\x97\n)'Ntx5\xF4D\xA5\xCC\xD4\x80Ii\x8E\xFF\x9C\x9C\xFD\xCA.\x1A^\xAF\x91\x81\x90\x03`\xA0\x01\x90\xA3`@\x80Q` \x81\x01\x89\x90R\x90\x81\x01\x87\x90R`\x01`\x01`\xA0\x1B\x03\x80\x87\x16``\x83\x01R`\x80\x82\x01\x86\x90R`\xA0\x82\x01\x85\x90R`\xC0\x82\x01\x84\x90R\x82\x16`\xE0\x82\x01Ra^\xCA\x90\x7F\xB6+No\x1E\xC5\x97\n)'Ntx5\xF4D\xA5\xCC\xD4\x80Ii\x8E\xFF\x9C\x9C\xFD\xCA.\x1A^\xAF\x90a\x01\0\x01a2 V[PPPPPPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x14\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0F\x14\x16a_\xC6WP`@\x80Q\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x81R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x81\x01\x91\x90\x91RF``\x82\x01R0`\x80\x82\x01R`\xA0\x90 [g\x19\x01\0\0\0\0\0\0_R\x80`\x1AR\x81`:R`B`\x18 \x90P_`:R\x91\x90PV[_`\x01`\x01`\xA0\x1B\x03\x84\x16\x15a:WW`@Q\x84;a`~W\x82Q`@\x81\x14a`\x1AW`A\x81\x14a`;WPa`\xBEV[`@\x84\x01Q`\xFF\x81\x90\x1C`\x1B\x01` R`\x01`\x01`\xFF\x1B\x03\x16``Ra`NV[``\x84\x01Q_\x1A` R`@\x84\x01Q``R[P\x83_R` \x83\x01Q`@R` `\x01`\x80_`\x01Z\xFAQ\x80\x86\x18``\x1B=\x11\x92PP_``R\x80`@Ra`\xBEV[c\x16&\xBA~`\xE0\x1B\x80\x82R\x84`\x04\x83\x01R`$\x82\x01`@\x81R\x84Q` \x01\x80`D\x85\x01\x82\x88`\x04Z\xFA\x90P` \x82`D=\x01\x86\x8BZ\xFA\x91Q\x91\x16\x91\x14\x16\x91P[P\x93\x92PPPV[\x81\x7F\x8E\x98\xA0sD \xE5~\xF1\x02\xCA\xB0\xB1\xAF\x08\t\xA5\xBB\xAFO\xDE\x96o\xD1s\xC3\"I\x06D\xA5\xD0\x82`@Qa`\xF8\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2a\x13\x1E\x7F\x8E\x98\xA0sD \xE5~\xF1\x02\xCA\xB0\xB1\xAF\x08\t\xA5\xBB\xAFO\xDE\x96o\xD1s\xC3\"I\x06D\xA5\xD0\x83\x83`@Q` \x01a2 \x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[` \x81\x01Q\x81Q`@\x80\x84\x01Q``\x85\x01Q`\x80\x86\x01Q`\xA0\x87\x01Q`\xC0\x88\x01Q`\xE0\x89\x01Qa\x01\0\x8A\x01Qa\x01 \x8B\x01Qa\x01@\x8C\x01Qa\x01`\x8D\x01Qa\x01\x80\x8E\x01Q\x9AQ\x7Fw$/\xBDW:\xF5\xA5\xF3Q\x8D\xA9&\0\xE9g\x95\xEB\xFF\xF9\x93`kO\xB5M\xEA-\xCD-\xFE\x85\x9Baa\xBB\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91aw8V[`@Q\x80\x91\x03\x90\xA3a\x12\xF0\x7Fw$/\xBDW:\xF5\xA5\xF3Q\x8D\xA9&\0\xE9g\x95\xEB\xFF\xF9\x93`kO\xB5M\xEA-\xCD-\xFE\x85\x82`@Q` \x01a2 \x91\x90aw\xB3V[___`\x04\x85Q\x10\x15ab\x1EW`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_ab(\x86atlV[\x90PcV\xFAcE`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x82\x16\x01abXWabK\x86ad\x8AV[\x86\x95P\x90\x93P\x91Pab\x9EV[c\xDCG\x8D#`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x82\x16\x01ab\x85Waby\x86ad\xD2V[\x91\x95P\x93P\x91Pab\x9EV[`@Qc\t\x15\xB8{`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[P\x92P\x92P\x92V[_\x80\x80ab\xCA\x88ab\xB8\x87` av>V[ab\xC2\x90\x8Aas\xCEV[\x01` \x01Q\x90V[\x90P_ab\xD7\x82\x89as\xCEV[\x90P\x86ab\xE5\x82` as\xCEV[\x11\x15ac\x04W`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_ac\x12\x8A\x83\x01` \x01Q\x90V[\x90P`\x04\x81\x10\x15ac,WP_\x93P\x83\x92PaQ8\x91PPV[_ac8\x83` as\xCEV[\x90P_acE\x83\x83as\xCEV[\x90P\x89\x81\x11\x15achW`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x8B\x82\x01` \x01Q`\x01`\x01`\xE0\x1B\x03\x19\x80\x82\x16\x90\x8A\x16\x14ac\x95WP_\x96P\x86\x95PaQ8\x94PPPPPV[\x83`$\x14ac\xB6W`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[ac\xC5\x8Dab\xC2\x85`\x04as\xCEV[`\x01\x9E\x90\x9DP\x9BPPPPPPPPPPPPV[___ac\xE7\x86\x86ae1V[\x91P\x91P\x81_\x03ad\x0BW\x83\x81\x81ad\x01Wad\x01avUV[\x04\x92PPPa:WV[\x81\x84\x11ad\"Wad\"`\x03\x85\x15\x02`\x11\x18aeMV[_\x84\x86\x88\t_\x86\x81\x03\x87\x16\x96\x87\x90\x04\x96`\x02`\x03\x89\x02\x81\x18\x80\x8A\x02\x82\x03\x02\x80\x8A\x02\x82\x03\x02\x80\x8A\x02\x82\x03\x02\x80\x8A\x02\x82\x03\x02\x80\x8A\x02\x82\x03\x02\x80\x8A\x02\x90\x91\x03\x02\x91\x81\x90\x03\x81\x90\x04`\x01\x01\x85\x84\x11\x90\x96\x03\x95\x90\x95\x02\x91\x90\x93\x03\x93\x90\x93\x04\x92\x90\x92\x17\x02\x91PP\x93\x92PPPV[\x80Q_\x90\x81\x90`D\x81\x14ad\xB1W`@Qc\x9A\xC6\x0C-`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`$\x84\x01Q`D\x85\x01Q\x81ad\xC5\x81a<\xBFV[\x97\x91\x96P\x90\x94PPPPPV[____\x84Q\x90P\x80`d\x14ad\xFBW`@Qc\x9A\xC6\x0C-`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`$\x85\x01Q`D\x86\x01Q`d\x87\x01Q\x82\x82ae\x15\x82a<\xBFV[\x98Pae \x81a<\xBFV[\x98\x9A\x98\x99P\x91\x97\x96PPPPPPPV[_\x80_\x19\x83\x85\t\x93\x90\x92\x02\x80\x84\x10\x93\x81\x90\x03\x93\x90\x93\x03\x93\x91PPV[cNH{q_R\x80` R`$`\x1C\xFD[_` \x82\x84\x03\x12\x15aenW__\xFD[P5\x91\x90PV[\x805\x80\x15\x15\x81\x14ae\x84W__\xFD[\x91\x90PV[__`@\x83\x85\x03\x12\x15ae\x9AW__\xFD[\x825\x91Pae\xAA` \x84\x01aeuV[\x90P\x92P\x92\x90PV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x12\xF0W__\xFD[__`@\x83\x85\x03\x12\x15ae\xD8W__\xFD[\x825ae\xE3\x81ae\xB3V[\x94` \x93\x90\x93\x015\x93PPPV[__`@\x83\x85\x03\x12\x15af\x02W__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[\x8B\x81R`\x01`\x01`\xA0\x1B\x03\x8B\x81\x16` \x83\x01R\x8A\x16`@\x82\x01R`\x01`\x01`@\x1B\x03\x89\x81\x16``\x83\x01R\x88\x81\x16`\x80\x83\x01Rc\xFF\xFF\xFF\xFF\x88\x16`\xA0\x83\x01R\x86\x16`\xC0\x82\x01R`\xE0\x81\x01\x85\x90Ra\x01\0\x81\x01\x84\x90Ra\x01 \x81\x01\x83\x90Ra\x01\xA0\x81\x01af\xA3a\x01@\x83\x01\x84\x80Q\x82R` \x80\x82\x01Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x91\x84\x01\x91\x90\x91R`@\x91\x82\x01Q\x16\x91\x01RV[\x9C\x9BPPPPPPPPPPPPV[_` \x82\x84\x03\x12\x15af\xC3W__\xFD[\x815a:W\x81ae\xB3V[____`\x80\x85\x87\x03\x12\x15af\xE1W__\xFD[\x845\x93P` \x85\x015\x92P`@\x85\x015af\xFA\x81ae\xB3V[\x91P``\x85\x015ag\n\x81ae\xB3V[\x93\x96\x92\x95P\x90\x93PPV[\x805`\x01`\x01`@\x1B\x03\x81\x16\x81\x14ae\x84W__\xFD[____`\x80\x85\x87\x03\x12\x15ag>W__\xFD[\x845\x93P` \x85\x015agP\x81ae\xB3V[\x92P`@\x85\x015\x91Page``\x86\x01ag\x15V[\x90P\x92\x95\x91\x94P\x92PV[c\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x12\xF0W__\xFD[__`@\x83\x85\x03\x12\x15ag\x92W__\xFD[\x825ag\x9D\x81ae\xB3V[\x91P` \x83\x015ag\xAD\x81agpV[\x80\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15ag\xC8W__\xFD[a:W\x82ag\x15V[\x80a\x02\x80\x81\x01\x83\x10\x15a\x16\x05W__\xFD[__\x83`\x1F\x84\x01\x12ag\xF2W__\xFD[P\x815`\x01`\x01`@\x1B\x03\x81\x11\x15ah\x08W__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15ah\x1FW__\xFD[\x92P\x92\x90PV[__\x83`\x1F\x84\x01\x12ah6W__\xFD[P\x815`\x01`\x01`@\x1B\x03\x81\x11\x15ahLW__\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15ah\x1FW__\xFD[________`\xA0\x89\x8B\x03\x12\x15ah}W__\xFD[\x885`\x01`\x01`@\x1B\x03\x81\x11\x15ah\x92W__\xFD[ah\x9E\x8B\x82\x8C\x01ag\xD1V[\x98PP` \x89\x015`\x01`\x01`@\x1B\x03\x81\x11\x15ah\xB9W__\xFD[ah\xC5\x8B\x82\x8C\x01ag\xE2V[\x90\x98P\x96PP`@\x89\x015`\x01`\x01`@\x1B\x03\x81\x11\x15ah\xE3W__\xFD[ah\xEF\x8B\x82\x8C\x01ah&V[\x90\x96P\x94PP``\x89\x015\x92P`\x80\x89\x015`\x01`\x01`@\x1B\x03\x81\x11\x15ai\x14W__\xFD[ai \x8B\x82\x8C\x01ah&V[\x99\x9C\x98\x9BP\x96\x99P\x94\x97\x93\x96\x92\x95\x94PPPV[___``\x84\x86\x03\x12\x15aiFW__\xFD[\x835aiQ\x81ae\xB3V[\x92P` \x84\x015\x91P`@\x84\x015aih\x81ae\xB3V[\x80\x91PP\x92P\x92P\x92V[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[\x84\x81R`\x80` \x82\x01R_ai\xB9`\x80\x83\x01\x86aisV[`\x01`\x01`@\x1B\x03\x94\x85\x16`@\x84\x01R\x92\x90\x93\x16``\x90\x91\x01R\x93\x92PPPV[________a\x01\0\x89\x8B\x03\x12\x15ai\xF2W__\xFD[\x885\x97P` \x89\x015aj\x04\x81ae\xB3V[\x96Paj\x12`@\x8A\x01ag\x15V[\x95P``\x89\x015aj\"\x81agpV[\x94Paj0`\x80\x8A\x01ag\x15V[\x93P`\xA0\x89\x015\x92P`\xC0\x89\x015ajG\x81ae\xB3V[\x91P`\xE0\x89\x015ajW\x81ae\xB3V[\x80\x91PP\x92\x95\x98P\x92\x95\x98\x90\x93\x96PV[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15aj\x98W\x81Q\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01ajzV[P\x93\x94\x93PPPPV[`\xFF`\xF8\x1B\x88\x16\x81R`\xE0` \x82\x01R_aj\xC0`\xE0\x83\x01\x89aisV[\x82\x81\x03`@\x84\x01Raj\xD2\x81\x89aisV[``\x84\x01\x88\x90R`\x01`\x01`\xA0\x1B\x03\x87\x16`\x80\x85\x01R`\xA0\x84\x01\x86\x90R\x83\x81\x03`\xC0\x85\x01R\x90Pak\x03\x81\x85ajhV[\x9A\x99PPPPPPPPPPV[__`@\x83\x85\x03\x12\x15ak\"W__\xFD[\x825ak-\x81ae\xB3V[\x91Pae\xAA` \x84\x01aeuV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q`\xC0\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15akqWakqak;V[`@R\x90V[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15ak\x9FWak\x9Fak;V[`@R\x91\x90PV[_`\x01`\x01`@\x1B\x03\x82\x11\x15ak\xBFWak\xBFak;V[P`\x1F\x01`\x1F\x19\x16` \x01\x90V[_` \x82\x84\x03\x12\x15ak\xDDW__\xFD[\x815`\x01`\x01`@\x1B\x03\x81\x11\x15ak\xF2W__\xFD[\x82\x01`\x1F\x81\x01\x84\x13al\x02W__\xFD[\x805al\x15al\x10\x82ak\xA7V[akwV[\x81\x81R\x85` \x83\x85\x01\x01\x11\x15al)W__\xFD[\x81` \x84\x01` \x83\x017_\x91\x81\x01` \x01\x91\x90\x91R\x94\x93PPPPV[____``\x85\x87\x03\x12\x15alYW__\xFD[\x845ald\x81ae\xB3V[\x93P` \x85\x015\x92P`@\x85\x015`\x01`\x01`@\x1B\x03\x81\x11\x15al\x85W__\xFD[al\x91\x87\x82\x88\x01ah&V[\x95\x98\x94\x97P\x95PPPPV[` \x81R_a:W` \x83\x01\x84aisV[_____\x85\x87\x03`\xC0\x81\x12\x15al\xC4W__\xFD[\x865\x95P```\x1F\x19\x82\x01\x12\x15al\xD9W__\xFD[P` \x86\x01\x93P`\x80\x86\x015\x92P`\xA0\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15al\xFFW__\xFD[am\x0B\x88\x82\x89\x01ag\xE2V[\x96\x99\x95\x98P\x93\x96P\x92\x94\x93\x92PPPV[___``\x84\x86\x03\x12\x15am.W__\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[_____`\x80\x86\x88\x03\x12\x15amYW__\xFD[\x855\x94P` \x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15amuW__\xFD[am\x81\x88\x82\x89\x01ag\xE2V[\x90\x95P\x93Pam\x94\x90P`@\x87\x01ag\x15V[\x91Pam\xA2``\x87\x01ag\x15V[\x90P\x92\x95P\x92\x95\x90\x93PV[_____`\xA0\x86\x88\x03\x12\x15am\xC2W__\xFD[\x855am\xCD\x81ae\xB3V[\x94P` \x86\x015\x93P`@\x86\x015\x92P``\x86\x015\x91P`\x80\x86\x015am\xF2\x81ae\xB3V[\x80\x91PP\x92\x95P\x92\x95\x90\x93PV[__`@\x83\x85\x03\x12\x15an\x11W__\xFD[\x825\x91P` \x83\x015ag\xAD\x81ae\xB3V[` \x81R_a:W` \x83\x01\x84ajhV[_` \x82\x84\x03\x12\x15anEW__\xFD[\x815a:W\x81agpV[___``\x84\x86\x03\x12\x15anbW__\xFD[\x835anm\x81ae\xB3V[\x95` \x85\x015\x95P`@\x90\x94\x015\x93\x92PPPV[__`@\x83\x85\x03\x12\x15an\x93W__\xFD[\x825an\x9E\x81ae\xB3V[\x91Pae\xAA` \x84\x01ag\x15V[_______`\xA0\x88\x8A\x03\x12\x15an\xC2W__\xFD[\x875\x96P` \x88\x015`\x01`\x01`@\x1B\x03\x81\x11\x15an\xDEW__\xFD[an\xEA\x8A\x82\x8B\x01ag\xD1V[\x96PP`@\x88\x015`\x01`\x01`@\x1B\x03\x81\x11\x15ao\x05W__\xFD[ao\x11\x8A\x82\x8B\x01ag\xE2V[\x90\x96P\x94PP``\x88\x015`\x01`\x01`@\x1B\x03\x81\x11\x15ao/W__\xFD[ao;\x8A\x82\x8B\x01ah&V[\x98\x9B\x97\x9AP\x95\x98\x94\x97\x95\x96`\x80\x90\x95\x015\x94\x93PPPPV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[_`\x01`\xFF\x1B\x82\x01ao|Wao|aoTV[P_\x03\x90V[\x81\x81\x03\x81\x81\x11\x15a\x16\x05Wa\x16\x05aoTV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[`\x01\x81\x81\x1C\x90\x82\x16\x80ao\xBDW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03ao\xDBWcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[_____`\xA0\x86\x88\x03\x12\x15ao\xF5W__\xFD[\x85Q` \x87\x01Q\x90\x95Pap\x08\x81ae\xB3V[`@\x87\x01Q``\x88\x01Q`\x80\x90\x98\x01Q\x96\x99\x91\x98P\x96\x95\x94P\x92PPPV[_` \x82\x84\x03\x12\x15ap7W__\xFD[\x81Qa:W\x81ae\xB3V[___``\x84\x86\x03\x12\x15apTW__\xFD[\x83Q` \x85\x01Q`@\x86\x01Q\x91\x94P\x92Paih\x81ae\xB3V[__`@\x83\x85\x03\x12\x15ap\x7FW__\xFD[\x82Qap\x8A\x81ae\xB3V[` \x93\x90\x93\x01Q\x92\x94\x92\x93PPPV[\x81\x83R\x81\x81` \x85\x017P_\x82\x82\x01` \x90\x81\x01\x91\x90\x91R`\x1F\x90\x91\x01`\x1F\x19\x16\x90\x91\x01\x01\x90V[__\x835`\x1E\x19\x846\x03\x01\x81\x12ap\xD7W__\xFD[\x83\x01` \x81\x01\x92P5\x90P`\x01`\x01`@\x1B\x03\x81\x11\x15ap\xF5W__\xFD[\x806\x03\x82\x13\x15ah\x1FW__\xFD[`\x80\x80\x82R_\x90a\x03\0\x83\x01\x90\x83\x01\x89\x83[`\x14\x81\x10\x15aqSW\x85\x84\x03`\x7F\x19\x01\x83Raq1\x82\x8Dap\xC2V[aq<\x86\x82\x84ap\x9AV[\x95PPP` \x92\x83\x01\x92\x91\x90\x91\x01\x90`\x01\x01aq\x15V[PPP\x82\x81\x03` \x84\x01Raqi\x81\x88\x8Aap\x9AV[\x83\x81\x03`@\x85\x01R\x85\x81R\x90P`\x01`\x01`\xFB\x1B\x03\x85\x11\x15aq\x89W__\xFD[\x84`\x05\x1B\x80\x87` \x84\x017``\x93\x90\x93\x01\x93\x90\x93RP\x01` \x01\x95\x94PPPPPV[\x80Qj\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x81\x16\x81\x14ae\x84W__\xFD[_` \x82\x84\x03\x12\x15aq\xD7W__\xFD[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15aq\xECW__\xFD[\x82\x01`\xC0\x81\x85\x03\x12\x15aq\xFDW__\xFD[ar\x05akOV[\x81Q\x81R` \x80\x83\x01Q\x90\x82\x01R`@\x82\x01Qar!\x81agpV[`@\x82\x01Rar2``\x83\x01aq\xACV[``\x82\x01RarC`\x80\x83\x01aq\xACV[`\x80\x82\x01R`\xA0\x82\x01Q`\x01`\x01`@\x1B\x03\x81\x11\x15ar`W__\xFD[\x80\x83\x01\x92PP\x84`\x1F\x83\x01\x12artW__\xFD[\x81Qar\x82al\x10\x82ak\xA7V[\x81\x81R\x86` \x83\x86\x01\x01\x11\x15ar\x96W__\xFD[\x81` \x85\x01` \x83\x01^_\x91\x81\x01` \x01\x91\x90\x91R`\xA0\x82\x01R\x94\x93PPPPV[_`\x01\x82\x01ar\xC9War\xC9aoTV[P`\x01\x01\x90V[`\x1F\x82\x11\x15a\x1F\xF6W\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15ar\xF5WP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x15\xCFW_\x81U`\x01\x01as\x01V[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15as-Was-ak;V[asA\x81as;\x84Tao\xA9V[\x84ar\xD0V[` `\x1F\x82\x11`\x01\x81\x14assW_\x83\x15as\\WP\x84\x82\x01Q[_\x19`\x03\x85\x90\x1B\x1C\x19\x16`\x01\x84\x90\x1B\x17\x84Ua\x15\xCFV[_\x84\x81R` \x81 `\x1F\x19\x85\x16\x91[\x82\x81\x10\x15as\xA2W\x87\x85\x01Q\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01as\x82V[P\x84\x82\x10\x15as\xBFW\x86\x84\x01Q_\x19`\x03\x87\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPP`\x01\x90\x81\x1B\x01\x90UPV[\x80\x82\x01\x80\x82\x11\x15a\x16\x05Wa\x16\x05aoTV[\x80\x82\x01\x82\x81\x12_\x83\x12\x80\x15\x82\x16\x82\x15\x82\x16\x17\x15at\0Wat\0aoTV[PP\x92\x91PPV[_` \x82\x84\x03\x12\x15at\x18W__\xFD[PQ\x91\x90PV[\x82\x81R`@` \x82\x01R_aI\xC6`@\x83\x01\x84aisV[\x85\x81R\x84` \x82\x01R\x83`@\x82\x01R\x82``\x82\x01R`\xA0`\x80\x82\x01R_ata`\xA0\x83\x01\x84aisV[\x97\x96PPPPPPPV[\x80Q` \x82\x01Q`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x91\x90`\x04\x82\x10\x15at\xA3W`\x01`\x01`\xE0\x1B\x03\x19`\x04\x83\x90\x03`\x03\x1B\x81\x90\x1B\x82\x16\x16\x92P[PP\x91\x90PV[_\x825`~\x19\x836\x03\x01\x81\x12at\xBEW__\xFD[\x91\x90\x91\x01\x92\x91PPV[__\x835`\x1E\x19\x846\x03\x01\x81\x12at\xDDW__\xFD[\x83\x01\x805\x91P`\x01`\x01`@\x1B\x03\x82\x11\x15at\xF6W__\xFD[` \x01\x91P6\x81\x90\x03\x82\x13\x15ah\x1FW__\xFD[\x87\x81R\x86` \x82\x01R\x85`@\x82\x01R\x84``\x82\x01R\x83`\x80\x82\x01R\x81\x83`\xA0\x83\x017_\x91\x01`\xA0\x01\x90\x81R\x96\x95PPPPPPV[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[_a:W\x82\x84au?V[`\x80\x80\x82R\x81\x01\x85\x90R_`\xA0`\x05\x87\x90\x1B\x83\x01\x81\x01\x90\x83\x01\x88\x83`^\x196\x83\x90\x03\x01[\x8A\x82\x10\x15av\x04W\x86\x85\x03`\x9F\x19\x01\x84R\x825\x81\x81\x12au\xA3W__\xFD[\x8C\x01\x805au\xB0\x81ae\xB3V[`\x01`\x01`\xA0\x1B\x03\x16\x86R` \x81\x81\x015\x90\x87\x01Rau\xD2`@\x82\x01\x82ap\xC2V[\x91P```@\x88\x01Rau\xE9``\x88\x01\x83\x83ap\x9AV[\x96PPP` \x83\x01\x92P` \x84\x01\x93P`\x01\x82\x01\x91Pau\x85V[PPP`\x01`\x01`\xA0\x1B\x03\x87\x16` \x85\x01RP\x90P\x83`@\x83\x01Rav4``\x83\x01\x84`\x01`\x01`\xA0\x1B\x03\x16\x90RV[\x96\x95PPPPPPV[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x16\x05Wa\x16\x05aoTV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_\x82av\x83WcNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[P\x04\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x83\x81R` \x81\x01\x83\x90R``\x81\x01`\x06\x83\x10av\xBAWav\xBAav\x88V[\x82`@\x83\x01R\x94\x93PPPPV[\x86\x81R\x85` \x82\x01R\x84`@\x82\x01R\x83``\x82\x01R\x82`\x80\x82\x01R_av\xF1`\xA0\x83\x01\x84au?V[\x98\x97PPPPPPPPV[\x83\x81R\x82` \x82\x01R```@\x82\x01R_aw\x1B``\x83\x01\x84aisV[\x95\x94PPPPPV[`\x03\x81\x10aw4Waw4av\x88V[\x90RV[`\x01`\x01`\xA0\x1B\x03\x8C\x81\x16\x82R` \x82\x01\x8C\x90R`@\x82\x01\x8B\x90R``\x82\x01\x8A\x90R\x88\x16`\x80\x82\x01Ra\x01`\x81\x01aws`\xA0\x83\x01\x89aw$V[`\xC0\x82\x01\x96\x90\x96R`\x01`\x01`\xA0\x1B\x03\x94\x85\x16`\xE0\x82\x01R\x92\x90\x93\x16a\x01\0\x83\x01R`\x01`\x01`@\x1B\x03\x16a\x01 \x82\x01Ra\x01@\x01R\x96\x95PPPPPPV[_a\x01\xA0\x82\x01\x90P\x82Q\x82R` \x83\x01Q` \x83\x01R`@\x83\x01Qaw\xE3`@\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P``\x83\x01Q``\x83\x01R`\x80\x83\x01Q`\x80\x83\x01R`\xA0\x83\x01Q`\xA0\x83\x01R`\xC0\x83\x01Qax\x1C`\xC0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xE0\x83\x01Qax/`\xE0\x84\x01\x82aw$V[Pa\x01\0\x83\x01Qa\x01\0\x83\x01Ra\x01 \x83\x01QaxXa\x01 \x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[Pa\x01@\x83\x01Qaxua\x01@\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[Pa\x01`\x83\x01Qax\x92a\x01`\x84\x01\x82`\x01`\x01`@\x1B\x03\x16\x90RV[Pa\x01\x80\x92\x83\x01Q\x91\x90\x92\x01R\x90V\xFE\xA1dsolcC\0\x08\x1B\0\n`\xA0`@R4\x80\x15`\x0EW__\xFD[P3`\x80R`\x80Qa\x05\ta\x000_9_\x81\x81`G\x01R`\xE9\x01Ra\x05\t_\xF3\xFE`\x80`@R`\x046\x10a\0+W_5`\xE0\x1C\x80c\x11x\x03\xE3\x14a\x006W\x80c\x8B\xCC\xC1\x87\x14a\0\x86W__\xFD[6a\x002W\0[__\xFD[4\x80\x15a\0AW__\xFD[Pa\0i\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\0\x91W__\xFD[Pa\0\xA5a\0\xA06`\x04a\x03\x9FV[a\0\xB3V[`@Q\x90\x81R` \x01a\0}V[_0h\x92\x9E\xEE\x14\x9BK\xD2\x12hT\x03a\0\xD2Wc\xAB\x14<\x06_R`\x04`\x1C\xFD[0h\x92\x9E\xEE\x14\x9BK\xD2\x12hU3`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14a\x01'W`@Qc0\xCDtq`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x84_[\x81\x81\x10\x15a\x02\x02W6\x88\x88\x83\x81\x81\x10a\x01EWa\x01Ea\x048V[\x90P` \x02\x81\x01\x90a\x01W\x91\x90a\x04LV[\x90P_a\x01g` \x83\x01\x83a\x04jV[`\x01`\x01`\xA0\x1B\x03\x16` \x83\x015a\x01\x82`@\x85\x01\x85a\x04\x8CV[`@Qa\x01\x90\x92\x91\x90a\x04\xD6V[_`@Q\x80\x83\x03\x81\x85\x87Z\xF1\x92PPP=\x80_\x81\x14a\x01\xCAW`@Q\x91P`\x1F\x19`?=\x01\x16\x82\x01`@R=\x82R=_` \x84\x01>a\x01\xCFV[``\x91P[PP\x90P\x80a\x01\xF8W`@Qc\x07\xF3Gi`\xE3\x1B\x81R`\x04\x81\x01\x84\x90R`$\x01`@Q\x80\x91\x03\x90\xFD[PP`\x01\x01a\x01*V[Pa\x02\r\x850a\x02WV[\x91P\x83\x82\x10\x15a\x020W`@Qc\xBB(u\xC3`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x15a\x02AWa\x02A\x85\x84\x84a\x02\xE8V[P8h\x92\x9E\xEE\x14\x9BK\xD2\x12hU\x95\x94PPPPPV[_`\x01`\x01`\xA0\x1B\x03\x83\x16a\x02wWP`\x01`\x01`\xA0\x1B\x03\x81\x161a\x02\xE2V[`@Qcp\xA0\x821`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R\x84\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x02\xBBW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x02\xDF\x91\x90a\x04\xE5V[\x90P[\x92\x91PPV[`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a\x03\x07Wa\x03\x02\x83\x83\x83a\x03\x11V[PPPV[a\x03\x02\x82\x82a\x03[V[\x81`\x14R\x80`4Rc\xA9\x05\x9C\xBB``\x1B_R` _`D`\x10_\x87Z\xF1\x80`\x01_Q\x14\x16a\x03QW\x80=\x85;\x15\x17\x10a\x03QWc\x90\xB8\xEC\x18_R`\x04`\x1C\xFD[P_`4RPPPV[_8_8\x84\x86Z\xF1a\x03tWc\xB1-\x13\xEB_R`\x04`\x1C\xFD[PPV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x03\x8CW__\xFD[PV[\x805a\x03\x9A\x81a\x03xV[\x91\x90PV[_____`\x80\x86\x88\x03\x12\x15a\x03\xB3W__\xFD[\x855g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x03\xC9W__\xFD[\x86\x01`\x1F\x81\x01\x88\x13a\x03\xD9W__\xFD[\x805g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x03\xEFW__\xFD[\x88` \x82`\x05\x1B\x84\x01\x01\x11\x15a\x04\x03W__\xFD[` \x91\x82\x01\x96P\x94Pa\x04\x17\x90\x87\x01a\x03\x8FV[\x92P`@\x86\x015\x91Pa\x04,``\x87\x01a\x03\x8FV[\x90P\x92\x95P\x92\x95\x90\x93PV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[_\x825`^\x19\x836\x03\x01\x81\x12a\x04`W__\xFD[\x91\x90\x91\x01\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x04zW__\xFD[\x815a\x04\x85\x81a\x03xV[\x93\x92PPPV[__\x835`\x1E\x19\x846\x03\x01\x81\x12a\x04\xA1W__\xFD[\x83\x01\x805\x91Pg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x15a\x04\xBBW__\xFD[` \x01\x91P6\x81\x90\x03\x82\x13\x15a\x04\xCFW__\xFD[\x92P\x92\x90PV[\x81\x83\x827_\x91\x01\x90\x81R\x91\x90PV[_` \x82\x84\x03\x12\x15a\x04\xF5W__\xFD[PQ\x91\x90PV\xFE\xA1dsolcC\0\x08\x1B\0\nJustin Sun is responsible for setting back the inevitable global stablecoin revolution by years through exploiting Tron USDT's network effects and imposing vendor lock-in on hundreds of millions of people in the Third World, who rely on stablecoins for remittances and to store their savings in unstable, overregulated economies. Let's Untron the People.\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080604052600436106104c6575f3560e01c806384b0196e11610278578063b7ed020e11610155578063de40d89f116100c9578063f04e02c011610083578063f04e02c0146111a2578063f127a9b3146111cd578063f2fde38b146111e2578063f516a5b4146111f5578063f654b7d014611220578063f9fdcae61461123f575f5ffd5b8063de40d89f146110d2578063e24d5c3514611105578063e8be65041461111a578063ecf88bb014611139578063eeb9025914611158578063f03eb61a14611183575f5ffd5b8063ca02a81e1161011a578063ca02a81e14610fe2578063cef5f4821461100d578063d38b018b1461102c578063db14fb4114611058578063dc1f9adf14611094578063dc8f8633146110b3575f5ffd5b8063b7ed020e14610ef6578063b98e631d14610f0b578063bc5c595014610f3e578063c0283e6214610f6c578063c63bbf2914610f8b575f5ffd5b80639d61dd07116101ec578063a7ec9df9116101b1578063a7ec9df914610e44578063aa63e54514610e63578063aa94360c14610e82578063b133be7d14610ea1578063b371fa6914610ec2578063b6b55f2514610ed7575f5ffd5b80639d61dd0714610d9a5780639efaca7914610ddb578063a34d28eb14610dfc578063a630255914610e1b578063a6e92f3c14610e30575f5ffd5b80638927a1061161023d5780638927a10614610cf657806389f297bd14610d155780638da5cb5b14610d34578063902238e114610d4c57806393a9ee4614610d6157806399b4992514610d7b575f5ffd5b806384b0196e14610c445780638701d7b214610c6b578063878ba15614610c8a5780638842c57314610ca95780638892729614610cc8575f5ffd5b80634d53e931116103a6578063665e0eed1161031a57806378aaf25e116102df57806378aaf25e14610b2f5780637c4c4feb14610b7f5780637de89f3014610bae5780637e49447f14610bf257806380a72c8b14610c115780638456cb5914610c30575f5ffd5b8063665e0eed14610a5257806367de8b7e14610a715780636c835a8214610a95578063715018a614610abf578063718fbc2514610ac7575f5ffd5b806358979bfe1161036b57806358979bfe146109925780635c975abb146109b15780635cf88012146109c75780635ea63c6c146109e657806360b6bfdd14610a05578063636ee62414610a33575f5ffd5b80634d53e931146108f55780634da2f8991461090a5780635016c47b14610935578063506294dc146109545780635737619814610973575f5ffd5b80633627720d1161043d5780633fea3488116104025780633fea34881461081d57806342005c6c1461083c5780634341fc861461085b57806346de406f14610897578063481f9376146108b6578063482edb07146108e1575f5ffd5b80633627720d146106d15780633660fb921461070557806338ee72d0146107665780633d92af84146107855780633f4ba83a14610809575f5ffd5b80631dbf4c611161048e5780631dbf4c61146105b75780632e1a7d4d146105f65780632f48ab7d146106155780632f83d9af1461063457806333680d581461066a57806333d908ad146106b2575f5ffd5b80630465eab0146104ca57806304ec4294146104eb5780630b3458791461052e5780631376de52146105795780631cf1bd3a14610598575b5f5ffd5b3480156104d5575f5ffd5b506104e96104e436600461655e565b611279565b005b3480156104f6575f5ffd5b5061051961050536600461655e565b60146020525f908152604090205460ff1681565b60405190151581526020015b60405180910390f35b348015610539575f5ffd5b506105617f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610525565b348015610584575f5ffd5b506104e9610593366004616589565b6112f3565b3480156105a3575f5ffd5b506104e96105b236600461655e565b611322565b3480156105c2575f5ffd5b506105616105d13660046165c7565b601360209081525f92835260408084209091529082529020546001600160a01b031681565b348015610601575f5ffd5b506104e961061036600461655e565b61136c565b348015610620575f5ffd5b50600454610561906001600160a01b031681565b34801561063f575f5ffd5b5061065361064e3660046165f1565b61142b565b6040516105259b9a99989796959493929190616611565b348015610675575f5ffd5b506106a46106843660046166b3565b6001600160a01b03165f908152600d602052604090205463ffffffff1690565b604051908152602001610525565b3480156106bd575f5ffd5b506104e96106cc3660046166ce565b6114ec565b3480156106dc575f5ffd5b506106a46106eb3660046166b3565b6001600160a01b03165f9081526019602052604090205490565b348015610710575f5ffd5b5061075161071f3660046166b3565b6001600160a01b03165f908152600d602052604090205463ffffffff600160201b8204811692600160401b9092041690565b60408051928352602083019190915201610525565b348015610771575f5ffd5b506104e961078036600461672b565b6115d6565b348015610790575f5ffd5b506107d761079f36600461655e565b601e6020525f9081526040902080546001820154600283015460038401546004909401546001600160a01b0390931693919290919085565b604080516001600160a01b0390961686526020860194909452928401919091526060830152608082015260a001610525565b348015610814575f5ffd5b506104e96115e8565b348015610828575f5ffd5b5061056161083736600461655e565b6115fa565b348015610847575f5ffd5b506104e9610856366004616781565b61160b565b348015610866575f5ffd5b5061087a6108753660046166b3565b611650565b604080519315158452602084019290925290820152606001610525565b3480156108a2575f5ffd5b506104e96108b136600461655e565b61169a565b3480156108c1575f5ffd5b50600c5463ffffffff600160201b8204811691600160401b900416610751565b3480156108ec575f5ffd5b506106a461170e565b348015610900575f5ffd5b506106a460015481565b348015610915575f5ffd5b506106a46109243660046166b3565b60116020525f908152604090205481565b348015610940575f5ffd5b506104e961094f36600461655e565b611738565b34801561095f575f5ffd5b506104e961096e3660046167b8565b611c30565b34801561097e575f5ffd5b506104e961098d3660046165c7565b611c66565b34801561099d575f5ffd5b506104e96109ac3660046166b3565b611cb2565b3480156109bc575f5ffd5b505f5460ff16610519565b3480156109d2575f5ffd5b506106a46109e1366004616866565b611cde565b3480156109f1575f5ffd5b506104e9610a003660046165c7565b611e56565b348015610a10575f5ffd5b50610519610a1f3660046166b3565b600a6020525f908152604090205460ff1681565b348015610a3e575f5ffd5b506104e9610a4d3660046165f1565b611eb6565b348015610a5d575f5ffd5b506104e9610a6c366004616934565b611f5d565b348015610a7c575f5ffd5b50600c54600160601b90046001600160401b03166106a4565b348015610aa0575f5ffd5b506106a4610aaf36600461655e565b602080525f908152604090205481565b6104e9611ffb565b348015610ad2575f5ffd5b50610b10610ae13660046165f1565b601c60209081525f9283526040808420909152908252902080546001909101546001600160a01b039091169082565b604080516001600160a01b039093168352602083019190915201610525565b348015610b3a575f5ffd5b50610b4e610b493660046165c7565b61200c565b6040805195865260208601949094529284019190915260608301526001600160a01b0316608082015260a001610525565b348015610b8a575f5ffd5b50610b9e610b9936600461655e565b61205f565b60405161052594939291906169a1565b348015610bb9575f5ffd5b506106a4610bc83660046166b3565b6001600160a01b03165f908152600d6020526040902054600160601b90046001600160401b031690565b348015610bfd575f5ffd5b50610751610c0c3660046169da565b612147565b348015610c1c575f5ffd5b50600354610561906001600160a01b031681565b348015610c3b575f5ffd5b506104e96121bf565b348015610c4f575f5ffd5b50610c586121cf565b6040516105259796959493929190616aa2565b348015610c76575f5ffd5b506104e9610c85366004616b11565b612228565b348015610c95575f5ffd5b506104e9610ca4366004616b11565b61225d565b348015610cb4575f5ffd5b506106a4610cc33660046166b3565b612292565b348015610cd3575f5ffd5b50610519610ce236600461655e565b601d6020525f908152604090205460ff1681565b348015610d01575f5ffd5b50610653610d1036600461655e565b61229c565b348015610d20575f5ffd5b506106a4610d2f366004616bcd565b61246d565b348015610d3f575f5ffd5b50638b78c6d81954610561565b348015610d57575f5ffd5b506106a460065481565b348015610d6c575f5ffd5b50600c5463ffffffff166106a4565b348015610d86575f5ffd5b506104e9610d95366004616c46565b612477565b348015610da5575f5ffd5b506106a4610db43660046166b3565b6001600160a01b03165f908152600d6020526040902054600160a01b900463ffffffff1690565b348015610de6575f5ffd5b50610def6125d2565b6040516105259190616c9d565b348015610e07575f5ffd5b506104e9610e16366004616caf565b612658565b348015610e26575f5ffd5b506106a460155481565b348015610e3b575f5ffd5b506017546106a4565b348015610e4f575f5ffd5b50610751610e5e366004616d1c565b612763565b348015610e6e575f5ffd5b506104e9610e7d366004616d45565b612973565b348015610e8d575f5ffd5b50610561610e9c3660046165c7565b612a51565b348015610eac575f5ffd5b50600c54600160a01b900463ffffffff166106a4565b348015610ecd575f5ffd5b506106a460165481565b348015610ee2575f5ffd5b506104e9610ef136600461655e565b612ae8565b348015610f01575f5ffd5b506106a460105481565b348015610f16575f5ffd5b506105617f000000000000000000000000000000000000000000000000000000000000000081565b348015610f49575f5ffd5b50610519610f583660046166b3565b600b6020525f908152604090205460ff1681565b348015610f77575f5ffd5b506106a4610f86366004616dae565b612b85565b348015610f96575f5ffd5b50610fca610fa5366004616e00565b601f60209081525f92835260408084209091529082529020546001600160401b031681565b6040516001600160401b039091168152602001610525565b348015610fed575f5ffd5b506106a4610ffc36600461655e565b5f9081526007602052604090205490565b348015611018575f5ffd5b506104e96110273660046165c7565b612b9e565b348015611037575f5ffd5b5061104b61104636600461655e565b612c11565b6040516105259190616e23565b348015611063575f5ffd5b506110776110723660046166b3565b612c70565b6040516affffffffffffffffffffff199091168152602001610525565b34801561109f575f5ffd5b506104e96110ae366004616e35565b612c7a565b3480156110be575f5ffd5b50600554610561906001600160a01b031681565b3480156110dd575f5ffd5b506105617f000000000000000000000000000000000000000000000000000000000000000081565b348015611110575f5ffd5b506106a460025481565b348015611125575f5ffd5b5061075161113436600461655e565b612ca9565b348015611144575f5ffd5b506104e9611153366004616e50565b612ce9565b348015611163575f5ffd5b506106a46111723660046166b3565b601a6020525f908152604090205481565b34801561118e575f5ffd5b506104e961119d366004616e82565b612da6565b3480156111ad575f5ffd5b506106a46111bc3660046166b3565b60126020525f908152604090205481565b3480156111d8575f5ffd5b506106a460185481565b6104e96111f03660046166b3565b612df2565b348015611200575f5ffd5b506106a461120f36600461655e565b601b6020525f908152604090205481565b34801561122b575f5ffd5b506104e961123a3660046166b3565b612e18565b34801561124a575f5ffd5b5061125e611259366004616eac565b612e44565b60408051938452602084019290925290820152606001610525565b611281613135565b60018112156112a357604051631f2a200560e01b815260040160405180910390fd5b6010548113156112c657604051639d8c7d9960e01b815260040160405180910390fd5b6004546112dd906001600160a01b0316338361314f565b6112f06112e982616f68565b6002613173565b50565b6112fb613135565b5f828152601460205260409020805460ff191682151517905561131e82826131a2565b5050565b61132a613135565b620f424081111561134e57604051634a55946b60e11b815260040160405180910390fd5b600c805463ffffffff191663ffffffff83161790556112f081613234565b61137461329e565b805f0361139457604051631f2a200560e01b815260040160405180910390fd5b335f90815260116020526040902054808211156113c45760405163d4708ca560e01b815260040160405180910390fd5b6113cc61170e565b8211156113ec5760405163b55c1bad60e01b815260040160405180910390fd5b6113f68282616f82565b335f81815260116020526040902091909155600454611421916001600160a01b03909116908461314f565b61131e33836132c1565b6007602052815f5260405f208181548110611444575f80fd5b5f918252602091829020600a9091020180546001820154600283015460038401546004850154600586015460068701546040805160608101825260078a0154815260088a01546001600160a01b039081169b82019b909b526009909901548a16908901529599509387169750958216956001600160401b03600160a01b9093048316958284169563ffffffff600160401b85041695600160601b90940490941693919291908b565b6114f461329e565b5f6114fe8561334b565b60028101549091506001600160a01b0316331461152e5760405163389b7a7960e11b815260040160405180910390fd5b611537336133bb565b5f8481526014602052604090205460ff16156115665760405163d9259ca960e01b815260040160405180910390fd5b61157084846134d0565b604080516060810182528581526001600160a01b038086166020830181905290851691909201819052600783018690556008830180546001600160a01b031990811690931790556009830180549092161790556115cf858585856135c2565b5050505050565b6115e284848484613664565b50505050565b6115f0613135565b6115f86138a3565b565b5f6116053083612a51565b92915050565b611613613135565b6001600160a01b0382165f908152600d60205260409020805463ffffffff60a01b1916600160a01b63ffffffff84160217905561131e82826138f4565b6001600160a01b0381165f908152600d60205260408120805463ffffffff600160201b8204811692600160401b9092041690821580159061169057508115155b9350509193909250565b805f036116ba57604051631f2a200560e01b815260040160405180910390fd5b6004546001600160a01b03166116e357604051638562eb4560e01b815260040160405180910390fd5b6004546116fb906001600160a01b0316333084613987565b6112f0611707826139a2565b6005613173565b6004545f906001600160a01b031680611728575f91505090565b61173281306139cf565b91505090565b61174061329e565b6018546017545f5b818310801561175657508381105b15611c28575f6017848154811061176f5761176f616f95565b5f918252602090912060039091020180549091507ffcb44ffebd38e2fe82ab623ea3788854213c458cf9855525b5865b707d5f013e810161187e575f5f5f8460010180546117bc90616fa9565b80601f01602080910402602001604051908101604052809291908181526020018280546117e890616fa9565b80156118335780601f1061180a57610100808354040283529160200191611833565b820191905f5260205f20905b81548152906001019060200180831161181657829003601f168201915b505050505080602001905181019061184b9190616fe1565b94505050925092506118768383838860020160089054906101000a90046001600160401b0316613664565b505050611b66565b7fa44f293dfa9228916345a6016220f304fd4e10c2f25ef62c896b4946926a70f48103611970575f8260010180546118b590616fa9565b80601f01602080910402602001604051908101604052809291908181526020018280546118e190616fa9565b801561192c5780601f106119035761010080835404028352916020019161192c565b820191905f5260205f20905b81548152906001019060200180831161190f57829003601f168201915b50505050508060200190518101906119449190617027565b600580546001600160a01b0319166001600160a01b038316179055905061196a81613a5e565b50611b66565b7fc12dafb0c407b0b342623605e950ef39bc2e3c97a3e5ee574555b350677601b18103611a7f575f5f8360010180546119a890616fa9565b80601f01602080910402602001604051908101604052809291908181526020018280546119d490616fa9565b8015611a1f5780601f106119f657610100808354040283529160200191611a1f565b820191905f5260205f20905b815481529060010190602001808311611a0257829003601f168201915b5050505050806020019051810190611a379190617042565b50915091505f82821015611a6557611a57611a528385616f82565b6139a2565b611a6090616f68565b611a72565b611a72611a528484616f82565b9050611876816001613173565b7f47c6751e5abe122c1ca5828c0fd60c328b369e575227dfcc17e7623e895ec0458103611b66575f826001018054611ab690616fa9565b80601f0160208091040260200160405190810160405280929190818152602001828054611ae290616fa9565b8015611b2d5780601f10611b0457610100808354040283529160200191611b2d565b820191905f5260205f20905b815481529060010190602001808311611b1057829003601f168201915b5050505050806020019051810190611b45919061706e565b915050611b64611b54826139a2565b611b5d90616f68565b6004613173565b505b6002820154600183018054611c1a9288926001600160401b0380831693600160401b9093041691869190611b9990616fa9565b80601f0160208091040260200160405190810160405280929190818152602001828054611bc590616fa9565b8015611c105780601f10611be757610100808354040283529160200191611c10565b820191905f5260205f20905b815481529060010190602001808311611bf357829003601f168201915b5050505050613ad0565b505060019283019201611748565b505060185550565b611c38613135565b600c805467ffffffffffffffff60601b1916600160601b6001600160401b038416021790556112f081613b49565b611c6e613135565b6004546001600160a01b0390811690831603611c9d57604051631c4e1bff60e01b815260040160405180910390fd5b611ca882338361314f565b61131e8282613bc4565b611cba613135565b600480546001600160a01b0319166001600160a01b0383161790556112f081613c4d565b5f611ce761329e565b600354604051630939b3f360e31b81525f916001600160a01b0316906349cd9f9890611d21908d908d908d908d908d908d90600401617103565b5f60405180830381865afa158015611d3b573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052611d6291908101906171c7565b90505f611d8e7f0000000000000000000000000000000000000000000000000000000000000000613cbf565b9050806001600160581b03191682608001516001600160581b03191614611dc85760405163365b3e5360e11b815260040160405180910390fd5b611dd58260a00151613cd4565b601554909350808403611dfb576040516335b0519f60e21b815260040160405180910390fd5b6016545f80611e0c84848b8b613d80565b91509150868214611e3057604051630e521c4360e01b815260040160405180910390fd5b60158790556016819055611e448989613f02565b50505050505098975050505050505050565b611e5e613135565b620f4240811115611e8257604051634a55946b60e11b815260040160405180910390fd5b6001600160a01b0382165f908152600d60205260409020805463ffffffff191663ffffffff831617905561131e8282614045565b611ebe613135565b63ffffffff821180611ed3575063ffffffff81115b15611ef15760405163a17eea7760e01b815260040160405180910390fd5b8115811514611f135760405163a17eea7760e01b815260040160405180910390fd5b600c805463ffffffff838116600160401b0263ffffffff60401b19918616600160201b02919091166bffffffffffffffff00000000199092169190911717905561131e82826140cf565b611f65613135565b6001600160a01b038316611f8c57604051638562eb4560e01b815260040160405180910390fd5b6001600160a01b038116611fb35760405163b37c79ed60e01b815260040160405180910390fd5b6001600160a01b038381165f908152601360209081526040808320868452909152902080546001600160a01b031916918316919091179055611ff6838383614148565b505050565b612003613135565b6115f85f6141db565b6019602052815f5260405f208181548110612025575f80fd5b5f9182526020909120600590910201805460018201546002830154600384015460049094015492955090935091906001600160a01b031685565b5f60605f5f5f6017868154811061207857612078616f95565b5f91825260209091206003909102018054600282015460018301805493945091926001600160401b0380831692600160401b9004169083906120b990616fa9565b80601f01602080910402602001604051908101604052809291908181526020018280546120e590616fa9565b80156121305780601f1061210757610100808354040283529160200191612130565b820191905f5260205f20905b81548152906001019060200180831161211357829003601f168201915b505050505092509450945094509450509193509193565b5f5f61215161329e565b61215f338b8a8a8a8a614201565b61216985856134d0565b60065f8154612177906172b8565b9182905550915042612192838c338d858e8e8e8e8e8e6143f6565b91506121a5838c84338e868f8f8f61470c565b6121b1838787876135c2565b509850989650505050505050565b6121c7613135565b6115f861480c565b600f60f81b6060805f80808361221660408051808201825260068152652ab73a3937b760d11b602080830191909152825180840190935260018352603160f81b9083015291565b97989097965046955030945091925090565b612230613135565b6001600160a01b0382165f908152600b60205260409020805460ff191682151517905561131e8282614848565b612265613135565b6001600160a01b0382165f908152600a60205260409020805460ff191682151517905561131e82826148d8565b5f61160582614968565b5f5f5f5f5f5f5f5f5f5f6122d960405180606001604052805f81526020015f6001600160a01b031681526020015f6001600160a01b031681525090565b5f8c8152600860205260408120600181015490918190036122fb57505061245e565b81545f908152600760205260408120612315600184616f82565b8154811061232557612325616f95565b905f5260205f2090600a02019050805f01549d50806001015f9054906101000a90046001600160a01b03169c50806002015f9054906101000a90046001600160a01b03169b508060020160149054906101000a90046001600160401b03169a50806003015f9054906101000a90046001600160401b031699508060030160089054906101000a900463ffffffff16985080600301600c9054906101000a90046001600160401b03169750806004015496508060050154955080600601549450806007016040518060600160405290815f8201548152602001600182015f9054906101000a90046001600160a01b03166001600160a01b03166001600160a01b03168152602001600282015f9054906101000a90046001600160a01b03166001600160a01b03166001600160a01b03168152505093505050505b91939597999b90929496989a50565b5f61160582613cd4565b3068929eee149b4bd2126854036124955763ab143c065f526004601cfd5b3068929eee149b4bd21268556124a961329e565b6001600160a01b0384166124d057604051638562eb4560e01b815260040160405180910390fd5b82156125c0576001600160a01b038085165f818152601960209081526040808320601a9092528220546004549194909391161461254157506001600160a01b0386165f90815260126020526040812054908190036125415760405163047e3fe760e11b815260040160405180910390fd5b5f5f5f6125518a87878c886149ce565b60045492955090935091505f906001600160a01b038c81169116146125805761257d8b84848c8c614af5565b90505b61258d8b86898988614be5565b6001600160a01b038b165f908152601a6020526040902084905580156125b8576125b88b338361314f565b505050505050505b3868929eee149b4bd212685550505050565b60408051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b60208201526bffffffffffffffffffffffff197f000000000000000000000000000000000000000000000000000000000000000060601b1660348201526e5af43d82803e903d91602b57fd5bf360881b604882015281516037818303018152605790910190915290565b61266061329e565b8242111561268157604051630819bdcd60e01b815260040160405180910390fd5b5f61268b8661334b565b60028101549091506126a5906001600160a01b03166133bb565b5f86815260208080526040808320549288359290916126c991908a01908a016166b3565b90505f6126dc60608a0160408b016166b3565b90506126e883836134d0565b5f6126f78b858585898e614e19565b6002870154909150612714906001600160a01b0316828a8a614e8d565b61271e8b86614ef9565b612728868b614f23565b6127568b8b3561273e60408e0160208f016166b3565b8d604001602081019061275191906166b3565b6135c2565b5050505050505050505050565b5f5f61276d61329e565b5f858152601d602052604090205460ff161561279c57604051631beb710560e11b815260040160405180910390fd5b5f858152601e60205260409020546001600160a01b0316156127d15760405163cc0bb0c160e01b815260040160405180910390fd5b825f036127f157604051631f2a200560e01b815260040160405180910390fd5b5f6127fb8561334b565b90506128078185614fb9565b9150815f0361282957604051633f41ae0160e01b815260040160405180910390fd5b600781018054600883015461284791906001600160a01b03166134d0565b335f90815260116020526040902054838110156128775760405163acf2da9360e01b815260040160405180910390fd5b6128818482616f82565b335f908152601160205260408120919091556001830154835460028501546128b9926001600160a01b039081169289928d9216615027565b80925081975050506040518060a00160405280336001600160a01b0316815260200189815260200188815260200187815260200182815250601e5f8b81526020019081526020015f205f820151815f015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055506020820151816001015560408201518160020155606082015181600301556080820151816004015590505061296788828589898e338e615142565b50505050935093915050565b6017604051806080016040528087815260200186868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201829052509385525050506001600160401b03808716602080850191909152908616604090930192909252835460018181018655948252908290208351600390920201908155908201519192909190820190612a0e9082617314565b506040820151600290910180546060909301516001600160401b03908116600160401b026001600160801b03199094169216919091179190911790555050505050565b5f7f00000000000000000000000000000000000000000000000000000000000000008383612a7d6125d2565b8051602091820120604051612ac995949392016001600160f81b031994909416845260609290921b6bffffffffffffffffffffffff191660018401526015830152603582015260550190565b60408051601f1981840301815291905280516020909101209392505050565b612af061329e565b335f908152600b602052604090205460ff16612b1f5760405163036b638d60e21b815260040160405180910390fd5b805f03612b3f57604051631f2a200560e01b815260040160405180910390fd5b600454612b57906001600160a01b0316333084613987565b335f9081526011602052604081208054839290612b759084906173ce565b909155506112f0905033826151d3565b5f612b938686868686615027565b509695505050505050565b612ba6613135565b6001600160a01b038216612bcd57604051638562eb4560e01b815260040160405180910390fd5b805f03612bed5760405163047e3fe760e11b815260040160405180910390fd5b6001600160a01b0382165f90815260126020526040902081905561131e828261525d565b5f81815260096020908152604091829020805483518184028101840190945280845260609392830182828015612c6457602002820191905f5260205f20905b815481526020019060010190808311612c50575b50505050509050919050565b5f61160582613cbf565b612c82613135565b600c805463ffffffff60a01b1916600160a01b63ffffffff8416021790556112f0816152e7565b5f8181526008602052604081206001810154829190808303612cd157505f9485945092505050565b8154612cde600183616f82565b935093505050915091565b612cf1613135565b63ffffffff821180612d06575063ffffffff81115b15612d2457604051632132c11960e11b815260040160405180910390fd5b8115811514612d4657604051632132c11960e11b815260040160405180910390fd5b6001600160a01b0383165f908152600d60205260409020805463ffffffff838116600160401b0263ffffffff60401b19918616600160201b02919091166bffffffffffffffff0000000019909216919091171781556115e284848461535c565b612dae613135565b6001600160a01b0382165f908152600d60205260409020805467ffffffffffffffff60601b1916600160601b6001600160401b0384160217905561131e82826153ee565b612dfa613135565b8060601b612e0f57637448fbae5f526004601cfd5b6112f0816141db565b612e20613135565b600380546001600160a01b0319166001600160a01b0383161790556112f081615487565b5f5f5f612e4f61329e565b600354604051630939b3f360e31b81525f916001600160a01b0316906349cd9f9890612e89908d908d908d908d908d908d90600401617103565b5f60405180830381865afa158015612ea3573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052612eca91908101906171c7565b80515f818152601d60205260409020549192509060ff1615612eff57604051631beb710560e11b815260040160405180910390fd5b6001601d5f8381526020019081526020015f205f6101000a81548160ff0219169083151502179055505f60055f9054906101000a90046001600160a01b031690505f612f5a8e856080015186606001518760a00151866154f9565b9050612f6b8e8386604001516155b1565b612f7f8e856040015163ffffffff16615618565b9550855f03612fa157604051632503bb3360e11b815260040160405180910390fd5b5f612fab8761334b565b905081816004015f828254612fc091906173ce565b9250508190555081816006015f828254612fda91906173ce565b90915550612fea90508183614fb9565b9550612ff682876156cc565b5f848152601e6020526040902080546001600160a01b0316156130cd57805460018201546001600160a01b03909116905f908a1480156130395750848360020154145b6003808501545f8a8152601e6020526040812080546001600160a01b0319168155600181018290556002810182905592830181905560049092019190915590915081156130b35789156130b3576001600160a01b0383165f90815260116020526040812080548c92906130ad9084906173ce565b90915550505b81156130c9579a50613128975050505050505050565b5050505b8615613121576008820154600783018054600985015491925f92613102926001600160a01b03928316928d928f929116615027565b809250819c50505061311e8a82848e8d8c8e604001518c6156e2565b50505b5050505050505b9750975097945050505050565b638b78c6d8195433146115f8576382b429005f526004601cfd5b6001600160a01b0383161561316957611ff6838383615767565b611ff682826157b1565b815f0361317e575050565b8160105f82825461318f91906173e1565b909155505060105461131e9083836157ca565b817fc8b7fe24dc2e9e731141fe1dd74d6ce470bd6b5371c12f42c9ce46bac15424c5826040516131d6911515815260200190565b60405180910390a261131e7fc8b7fe24dc2e9e731141fe1dd74d6ce470bd6b5371c12f42c9ce46bac15424c583836040516020016132209291909182521515602082015260400190565b60405160208183030381529060405261583e565b6040518181527ff7cfae9870e1307a0791d6418d9e78abd1731a1c03606813906b474d307ead569060200160405180910390a16112f07ff7cfae9870e1307a0791d6418d9e78abd1731a1c03606813906b474d307ead568260405160200161322091815260200190565b5f5460ff16156115f85760405163d93c066560e01b815260040160405180910390fd5b816001600160a01b03167f44282e2a4bbb86b9f8089d1086f4e0df273054eab62cdbda18f647cfd22a1eff826040516132fc91815260200190565b60405180910390a2604080516001600160a01b038416602082015290810182905261131e907f44282e2a4bbb86b9f8089d1086f4e0df273054eab62cdbda18f647cfd22a1eff90606001613220565b5f818152600860205260408120600181015480830361337c576040516290ed3d60e61b815260040160405180910390fd5b81545f908152600760205260409020613396600183616f82565b815481106133a6576133a6616f95565b905f5260205f2090600a020192505050919050565b600c805463ffffffff600160201b8204811691600160401b9004168115806133e1575080155b156133ec5750505050565b6001600160a01b0384165f908152600f602052604090208054429190848110613488575f8261341b8784616f82565b8154811061342b5761342b616f95565b5f918252602090912060048204015460039091166008026101000a90046001600160401b0316905061345d85826173ce565b846001600160401b03161015613486576040516302a0ec2160e21b815260040160405180910390fd5b505b5080546001810182555f91825260209091206004820401805460039092166008026101000a6001600160401b0381810219909316939092169190910291909117905550505050565b5f8281526014602052604090205460ff16156134ff5760405163d9259ca960e01b815260040160405180910390fd5b6001600160a01b03811661352657604051638562eb4560e01b815260040160405180910390fd5b6004546001600160a01b03828116911614801590468414159061357a576001600160a01b0383165f90815260126020526040812054900361357a5760405163047e3fe760e11b815260040160405180910390fd5b80156115e2576001600160a01b038381165f908152601360209081526040808320888452909152902054166115e25760405163b37c79ed60e01b815260040160405180910390fd5b604080518481526001600160a01b038481166020830152831681830152905185917fd7cf75dc193207f6484b7bd6c4fc469f3b6b733d2cbcee403975287b015dc499919081900360600190a260408051602081018690529081018490526001600160a01b038084166060830152821660808201526115e2907fd7cf75dc193207f6484b7bd6c4fc469f3b6b733d2cbcee403975287b015dc4999060a001613220565b5f848152601f602090815260408083206001600160a01b03871684529091529020546001600160401b039081169082168110156136d7575f858152601f602090815260408083206001600160a01b03881684529091529020805467ffffffffffffffff19166001600160401b0384161790555b825f036136e457506115e2565b60055483906001600160a01b03908116908616036137f7575f868152600960205260408120805490915b818110801561371c57508315155b156137f3575f89815260076020526040812080548390811061374057613740616f95565b905f5260205f2090600a02019050866001600160401b03168160020160149054906101000a90046001600160401b03166001600160401b0316111561378557506137f3565b60068101545f8190036137995750506137e3565b5f8187106137a757816137a9565b865b905080836005015f8282546137be91906173ce565b909155506137ce90508183616f82565b60068401556137dd8188616f82565b96505050505b6137ec816172b8565b905061370e565b5050505b801561389b575f6138088785615618565b9050805f0361382c5761382461381d836139a2565b6003613173565b5050506115e2565b5f6138368261334b565b905082816004015f82825461384b91906173ce565b9250508190555082816005015f82825461386591906173ce565b909155505f90506138768285614fb9565b905061388284826156cc565b8015613897576138978383838c8c8b8a61590c565b5050505b505050505050565b6138ab6159db565b5f805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b60405163ffffffff821681526001600160a01b038316907fb1d8eff9485816bb38ceecf317a3fda05597bc5b38f2f22df96c0ebd5dc236ee9060200160405180910390a2604080516001600160a01b038416602082015263ffffffff83169181019190915261131e907fb1d8eff9485816bb38ceecf317a3fda05597bc5b38f2f22df96c0ebd5dc236ee90606001613220565b6001600160a01b038416156115e2576115e2848484846159fd565b5f6001600160ff1b038211156139cb57604051630599f71d60e21b815260040160405180910390fd5b5090565b5f6001600160a01b0383166139ef57506001600160a01b03811631611605565b6040516370a0823160e01b81526001600160a01b0383811660048301528416906370a0823190602401602060405180830381865afa158015613a33573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190613a579190617408565b9392505050565b6040516001600160a01b038216907f9f5e1d13045d272fbe74ce4d08e91982a5c57784391ae6a199eecdcf63949ffe905f90a2604080516001600160a01b03831660208201526112f0917f9f5e1d13045d272fbe74ce4d08e91982a5c57784391ae6a199eecdcf63949ffe9101613220565b8184867fdca16b0af6e10f5dfb7d4ea91055951419a0c8ffc5925acffdc52a95fcc671338685604051613b0492919061741f565b60405180910390a46115cf7fdca16b0af6e10f5dfb7d4ea91055951419a0c8ffc5925acffdc52a95fcc671338686868686604051602001613220959493929190617437565b6040516001600160401b03821681527f286cd7c5781e6df376daa59ab207e1a0b1ece95fafc298f9ab69a188f49ff2d59060200160405180910390a1604080516001600160401b03831660208201526112f0917f286cd7c5781e6df376daa59ab207e1a0b1ece95fafc298f9ab69a188f49ff2d59101613220565b604080516001600160a01b0384168152602081018390527f68f67de89e96b13a3ea058af5fd44cc125efceb528482d539c7b43db2faa066e910160405180910390a1604080516001600160a01b038416602082015290810182905261131e907f68f67de89e96b13a3ea058af5fd44cc125efceb528482d539c7b43db2faa066e90606001613220565b6040516001600160a01b038216907fa44f293dfa9228916345a6016220f304fd4e10c2f25ef62c896b4946926a70f4905f90a2604080516001600160a01b03831660208201526112f0917fa44f293dfa9228916345a6016220f304fd4e10c2f25ef62c896b4946926a70f49101613220565b6001600160a01b0316604160a01b1760581b90565b5f600482511015613cf857604051631279950360e01b815260040160405180910390fd5b5f613d028361746c565b90506366d8a56560e01b6001600160e01b0319821601613d2557613a5783615a56565b630a6d35e560e31b6001600160e01b0319821601613d6757613a57837f99275a9b9a3d950cfe0d31a1d4831a66a9ceba7d836f9b6854f0f1a7eb4eac1c615a84565b60405163365b3e5360e11b815260040160405180910390fd5b5f8082815b81811015613ef65736868683818110613da057613da0616f95565b9050602002810190613db291906174aa565b9050613e3289613dc860608401604085016167b8565b6001600160401b0316613de160808501606086016167b8565b6001600160401b03168435613df960208701876174c8565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250615b9192505050565b60019097019660028989613e4c60608501604086016167b8565b6001600160401b0316613e6560808601606087016167b8565b6001600160401b03168535613e7d60208801886174c8565b604051602001613e93979695949392919061750a565b60408051601f1981840301815290829052613ead91617556565b602060405180830381855afa158015613ec8573d5f5f3e3d5ffd5b5050506040513d601f19601f82011682018060405250810190613eeb9190617408565b985050600101613d85565b50959694955050505050565b805f5b818110156115e25736848483818110613f2057613f20616f95565b9050602002810190613f3291906174aa565b905060176040518060800160405280835f01358152602001838060200190613f5a91906174c8565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250505090825250602001613fa360608501604086016167b8565b6001600160401b03168152602001613fc160808501606086016167b8565b6001600160401b031690528154600181810184555f93845260209384902083516003909302019182559282015191929091908201906140009082617314565b506040820151600290910180546060909301516001600160401b03908116600160401b026001600160801b031990941692169190911791909117905550600101613f05565b816001600160a01b03167f0aa82626f19bb5d4196202b01f2fee431b95e88cb054484b987d650d91928ada8260405161408091815260200190565b60405180910390a2604080516001600160a01b038416602082015290810182905261131e907f0aa82626f19bb5d4196202b01f2fee431b95e88cb054484b987d650d91928ada90606001613220565b60408051838152602081018390527fab63c25aa07a4d10a1842d61026a08d95115c4e6895288683015ca4464c7f50f910160405180910390a161131e7fab63c25aa07a4d10a1842d61026a08d95115c4e6895288683015ca4464c7f50f8383604051602001613220929190918252602082015260400190565b6040516001600160a01b0382811682528391908516907f427db48f8cd0cf7fdabcdbc1327c7db26ce3a544292ba380ef07d5175af729cd9060200160405180910390a3604080516001600160a01b0380861660208301529181018490529082166060820152611ff6907f427db48f8cd0cf7fdabcdbc1327c7db26ce3a544292ba380ef07d5175af729cd90608001613220565b638b78c6d819546001600160a01b03909116638b78c6d8198190559061131e8183615c0b565b6001600160a01b0386165f908152600a602052604090205460ff166142395760405163451421bd60e11b815260040160405180910390fd5b61424286615c97565b5f61424c87615d77565b9050808463ffffffff16108061426a5750620f42408463ffffffff16115b1561428857604051634a55946b60e11b815260040160405180910390fd5b5f61429288615db1565b905080846001600160401b031610156142be57604051632625b78160e11b815260040160405180910390fd5b5f8381526014602052604090205460ff16156142ed5760405163d9259ca960e01b815260040160405180910390fd5b426001600160401b03808216908816101561431b5760405163501d13ed60e01b815260040160405180910390fd5b5f6143258a614968565b90508015614369575f6143446001600160401b03808516908b16616f82565b90508181111561436757604051632ab84c4760e21b815260040160405180910390fd5b505b5f898152600960205260409020805415612756575f8a8152600760205260408120825461439890600190616f82565b815481106143a8576143a8616f95565b5f9182526020909120600a9091020160038101549091506001600160401b03164210156143e85760405163b4ed1c3560e01b815260040160405180910390fd5b505050505050505050505050565b5f8a8152600760209081526040918290205482518084019093528c8352919081016144228360016173ce565b81525060085f8e81526020019081526020015f205f820151815f01556020820151816001015590505060075f8c81526020019081526020015f206040518061016001604052808d81526020018c6001600160a01b031681526020018b6001600160a01b031681526020018a6001600160401b03168152602001896001600160401b031681526020018863ffffffff168152602001876001600160401b031681526020015f81526020015f81526020015f81526020016040518060600160405280888152602001876001600160a01b03168152602001866001600160a01b0316815250815250908060018154018082558091505060019003905f5260205f2090600a02015f909190919091505f820151815f01556020820151816001015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055506040820151816002015f6101000a8154816001600160a01b0302191690836001600160a01b0316021790555060608201518160020160146101000a8154816001600160401b0302191690836001600160401b031602179055506080820151816003015f6101000a8154816001600160401b0302191690836001600160401b0316021790555060a08201518160030160086101000a81548163ffffffff021916908363ffffffff16021790555060c082015181600301600c6101000a8154816001600160401b0302191690836001600160401b0316021790555060e0820151816004015561010082015181600501556101208201518160060155610140820151816007015f820151815f01556020820151816001015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055506040820151816002015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055505050505060095f8c81526020019081526020015f208c908060018154018082558091505060019003905f5260205f20015f90919091909150559b9a5050505050505050505050565b604080516001600160a01b038881168252871660208201526001600160401b0386811682840152858116606083015263ffffffff85166080830152831660a0820152905188918a918c917fe431502bd0df5880397ec13c0a260f0c749c8f3a30c6caf3ffe0f08a2ed13942919081900360c00190a460408051602081018b9052908101899052606081018890526001600160a01b038088166080830152861660a08201526001600160401b0380861660c083015280851660e083015263ffffffff84166101008301528216610120820152613897907fe431502bd0df5880397ec13c0a260f0c749c8f3a30c6caf3ffe0f08a2ed139429061014001613220565b61481461329e565b5f805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586138d73390565b816001600160a01b03167f442f7ab7d26bf7ba74f23e237d12876251f91d61aeb2899ad95f334fa5e7c63382604051614885911515815260200190565b60405180910390a2604080516001600160a01b03841660208201528215159181019190915261131e907f442f7ab7d26bf7ba74f23e237d12876251f91d61aeb2899ad95f334fa5e7c63390606001613220565b816001600160a01b03167f2080a756444d2af0f9fb4f87db7af63cd6e23b7a1203cbe9ab0972ee05d1eafd82604051614915911515815260200190565b60405180910390a2604080516001600160a01b03841660208201528215159181019190915261131e907f2080a756444d2af0f9fb4f87db7af63cd6e23b7a1203cbe9ab0972ee05d1eafd90606001613220565b600c546001600160a01b0382165f908152600d6020526040812054909163ffffffff600160a01b9182900481169291909104168183036149a9579392505050565b805f036149b7575092915050565b8181106149c457816149c6565b805b949350505050565b5f5f5f5f6149da61170e565b90508693505b8754841080156149f85750856149f68886616f82565b105b15614ae9575f888581548110614a1057614a10616f95565b905f5260205f20906005020160010154905080821015614a305750614ae9565b614a3a81856173ce565b6004549094506001600160a01b038b8116911614614adc575f898681548110614a6557614a65616f95565b905f5260205f209060050201600301549050468114614ac0576001600160a01b038b81165f90815260136020908152604080832085845290915290205416614ac05760405163b37c79ed60e01b815260040160405180910390fd5b614ace8288620f4240615df6565b614ad890856173ce565b9350505b60019094019390036149e0565b50955095509592505050565b6004545f90614b2e906001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000008761314f565b604051638bccc18760e01b81525f906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690638bccc18790614b8490879087908c908b903090600401617561565b6020604051808303815f875af1158015614ba0573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190614bc49190617408565b905084811115614bdb57614bd88582616f82565b91505b5095945050505050565b815b8181101561389b575f848281548110614c0257614c02616f95565b5f9182526020918290206040805160a081018252600590930290910180548352600181015493830184905260028101549183019190915260038101546060830152600401546001600160a01b031660808201528654909250869084908110614c6c57614c6c616f95565b5f9182526020808320600590920290910182815560018082018490556002820184905560038201849055600491820180546001600160a01b03199081169091556040808801518652601c8552808620885187529094529284208054909316835591909101829055546001600160a01b038a8116911614614cf957614cf48289620f4240615df6565b614cfb565b815b90508015614ded5746836060015114614dde576001600160a01b03808a165f908152601360209081526040808320606088015184529091529020541680614d555760405163b37c79ed60e01b815260040160405180910390fd5b614d608a828461314f565b60608401516080850151604051632f2c1d2d60e11b81526001600160a01b038d81166004830152602482018690526044820193909352908216606482015290821690635e583a5a906084015f604051808303815f87803b158015614dc2575f5ffd5b505af1158015614dd4573d5f5f3e3d5ffd5b5050505050614ded565b614ded8984608001518361314f565b614e0b8360400151845f01518b878688606001518960800151615e02565b505050806001019050614be7565b5f5f7f104ac0ad95e44303bcfb0d0e568ac49ab666ca92af650d9fa356ad9c0f49dba290505f6040518281528960208201528860408201528760608201528660808201528560a08201528460c082015260e08120915060e0810160405250614e8081615ed3565b9998505050505050505050565b5f614ed98484848080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250506001600160a01b038a169392915050615fe9565b9050806115cf57604051638baa579f60e01b815260040160405180910390fd5b5f8281526020805260409020600180830190915561131e908390614f1e9084906173ce565b6160c6565b6040518060600160405280825f01358152602001826020016020810190614f4a91906166b3565b6001600160a01b03168152602001614f6860608401604085016166b3565b6001600160a01b039081169091528151600785015560208201516008850180549183166001600160a01b03199283161790556040909201516009909401805494909116939091169290921790915550565b60038201545f90600160401b900463ffffffff1681620f4240614fdc8382616f82565b614fe6908661763e565b614ff09190617669565b6003860154909150600160601b90046001600160401b03168082111561501a57808203935061501e565b5f93505b50505092915050565b5f838152601b602052604081208054829182615042836172b8565b909155506001600160a01b038881165f908152601960209081526040808320815160a0810183528681528084018d81529281018c8152606082018c81528b881660808401908152845460018082018755868a529790982093516005909802909301968755935186860155516002860155915160038501559051600490930180546001600160a01b03191693909416929092179092558054929350916150e79190616f82565b6040805180820182526001600160a01b038b8116825260208083018581525f8c8152601c8352858120898252909252939020915182546001600160a01b031916911617815590516001909101559250505b9550959350505050565b604080516101a0810182528981526020810189905260018801546001600160a01b03908116928201929092526060810187905260808101869052875460a0820152600288015490911660c08201526151c99060e081015f8152602081018690526001600160a01b03851660408201525f60608201819052608082015260a001839052616140565b5050505050505050565b816001600160a01b03167fdae4417c25a93cfb86ce5fbbb8fc1630945b61afaeab4f29cf301b9a058ba9148260405161520e91815260200190565b60405180910390a2604080516001600160a01b038416602082015290810182905261131e907fdae4417c25a93cfb86ce5fbbb8fc1630945b61afaeab4f29cf301b9a058ba91490606001613220565b816001600160a01b03167fa8d3b3213b7f8244e5b04551db9aaabccc21d6212c43c3b3143bcde97ca853ce8260405161529891815260200190565b60405180910390a2604080516001600160a01b038416602082015290810182905261131e907fa8d3b3213b7f8244e5b04551db9aaabccc21d6212c43c3b3143bcde97ca853ce90606001613220565b60405163ffffffff821681527f1fb3b38e402009f1bbd24d0a70005a7a9a055b3f5b546c8b21f815470a9c2ec49060200160405180910390a16040805163ffffffff831660208201526112f0917f1fb3b38e402009f1bbd24d0a70005a7a9a055b3f5b546c8b21f815470a9c2ec49101613220565b60408051838152602081018390526001600160a01b038516917f61c49ab6bb1ef59191a746afce7d2731d4d9b0fafdab8d63f02fe44169532dc5910160405180910390a2604080516001600160a01b038516602082015290810183905260608101829052611ff6907f61c49ab6bb1ef59191a746afce7d2731d4d9b0fafdab8d63f02fe44169532dc590608001613220565b6040516001600160401b03821681526001600160a01b038316907f2f4817318242d1b86700a426f7ced049c68059253c0a721e01b9718f4527bef69060200160405180910390a2604080516001600160a01b03841660208201526001600160401b0383169181019190915261131e907f2f4817318242d1b86700a426f7ced049c68059253c0a721e01b9718f4527bef690606001613220565b6040516001600160a01b038216907f5d29693e63b3a084e56893ce8c7f5ef5dc8213da41070084e6b1c4370abd64c4905f90a2604080516001600160a01b03831660208201526112f0917f5d29693e63b3a084e56893ce8c7f5ef5dc8213da41070084e6b1c4370abd64c49101613220565b5f61550382613cbf565b6affffffffffffffffffffff1986811691161461553357604051633395765b60e01b815260040160405180910390fd5b5f61555e7f000000000000000000000000000000000000000000000000000000000000000088612a51565b90505f61556a82613cbf565b90505f5f61557887896161f8565b9250925050826001600160581b031916826001600160581b03191614614e80576040516340650ea960e11b815260040160405180910390fd5b5f838152601f602090815260408083206001600160a01b03861684529091529020546001600160401b031680158015906155fa57506001600160401b03811663ffffffff831611155b156115e257604051633e6c071160e21b815260040160405180910390fd5b5f8281526009602052604081208054808303615638575f92505050611605565b805b801561501e575f86815260076020526040812080545f19909301928390811061566557615665616f95565b905f5260205f2090600a02019050856001600160401b03168160020160149054906101000a90046001600160401b03166001600160401b0316116156c6578382815481106156b5576156b5616f95565b905f5260205f20015494505061501e565b5061563a565b61131e6156dc611a528385616f82565b5f613173565b604080516101a081018252898152602081018990526001808901546001600160a01b03908116938301939093526060820188905260808201879052885460a0830152600289015490921660c08201526151c99160e08201908152602081018690525f60408201819052606082015263ffffffff8516608082015260a001839052616140565b816014528060345263a9059cbb60601b5f5260205f604460105f875af18060015f5114166157a757803d853b1517106157a7576390b8ec185f526004601cfd5b505f603452505050565b5f385f3884865af161131e5763b12d13eb5f526004601cfd5b7f43991e1e1cfb2eed6c9dc37a7a848622f8e3f75bc38d532a00eaf026cd87a0148383836040516157fd9392919061769c565b60405180910390a1611ff67f43991e1e1cfb2eed6c9dc37a7a848622f8e3f75bc38d532a00eaf026cd87a0148484846040516020016132209392919061769c565b60028054600190810180835590546040519092916158699184919043904290899089906020016176c8565b60408051601f198184030181529082905261588391617556565b602060405180830381855afa15801561589e573d5f5f3e3d5ffd5b5050506040513d601f19601f820116820180604052508101906158c19190617408565b600181905550600154816002547f78160f0b1b2b32b52a0076d8f0f70888687ba702a4d993d55ac8d9327d57a12786866040516158ff92919061741f565b60405180910390a4505050565b6008860154600787018054600989015491925f92839261593e926001600160a01b03908116928c928f92909116615027565b604080516101a0810182528d81526020810183905260018701546001600160a01b039081169282019290925260608101849052608081018c9052865460a0820152600280880154831660c083015260e082015261010081018b90525f6101208201529089166101408201526001600160401b038816610160820152610180810187905291935091506159cf90616140565b50505050505050505050565b5f5460ff166115f857604051638dfc202b60e01b815260040160405180910390fd5b60405181606052826040528360601b602c526323b872dd60601b600c5260205f6064601c5f895af18060015f511416615a4857803d873b151710615a4857637939f4245f526004601cfd5b505f60605260405250505050565b80515f9060248114615a7b57604051631279950360e01b815260040160405180910390fd5b50506024015190565b81515f906024811015615aaa57604051631279950360e01b815260040160405180910390fd5b60248401515f90615abc9060046173ce565b905081615aca8260206173ce565b1115615ae957604051631279950360e01b815260040160405180910390fd5b5f615af78683016020015190565b90505f615b058360206173ce565b905083615b1383602061763e565b615b1d90836173ce565b1115615b3c57604051631279950360e01b815260040160405180910390fd5b5f5b82811015615b77575f5f615b558a8589868d6162a6565b915091508115615b6d57965061160595505050505050565b5050600101615b3e565b50604051632286acb960e11b815260040160405180910390fd5b81847f9d611b5b34cb76131c4fb413eb74119b2c0c3a6aa6fcd8e740cf70ac3085d87b878685604051615bc6939291906176fd565b60405180910390a36115cf7f9d611b5b34cb76131c4fb413eb74119b2c0c3a6aa6fcd8e740cf70ac3085d87b8686868686604051602001613220959493929190617437565b806001600160a01b0316826001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a361131e7f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e083836040516020016132209291906001600160a01b0392831681529116602082015260400190565b6001600160a01b0381165f908152600d60205260409020805463ffffffff600160201b8204811691600160401b900416811580615cd2575080155b15615cdd5750505050565b6001600160a01b0384165f908152600e602052604090208054429190848110613488575f82615d0c8784616f82565b81548110615d1c57615d1c616f95565b5f918252602090912060048204015460039091166008026101000a90046001600160401b03169050615d4e85826173ce565b846001600160401b03161015613486576040516313150ab960e21b815260040160405180910390fd5b600c546001600160a01b0382165f908152600d6020526040812054909163ffffffff908116911681811115615daa578091505b5092915050565b600c546001600160a01b0382165f908152600d602052604081205490916001600160401b03600160601b91829004811692919091041681811115615daa579392505050565b5f6149c68484846163da565b604080516001600160a01b0387811682526020820187905281830186905260608201859052831660808201529051879189917fb62b4e6f1ec5970a29274e747835f444a5ccd48049698eff9c9cfdca2e1a5eaf9181900360a00190a360408051602081018990529081018790526001600160a01b0380871660608301526080820186905260a0820185905260c08201849052821660e0820152615eca907fb62b4e6f1ec5970a29274e747835f444a5ccd48049698eff9c9cfdca2e1a5eaf9061010001613220565b50505050505050565b7f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000030147f0000000000000000000000000000000000000000000000000000000000000000461416615fc65750604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f81527f000000000000000000000000000000000000000000000000000000000000000060208201527f00000000000000000000000000000000000000000000000000000000000000009181019190915246606082015230608082015260a090205b6719010000000000005f5280601a5281603a52604260182090505f603a52919050565b5f6001600160a01b03841615613a5757604051843b61607e5782516040811461601a576041811461603b57506160be565b604084015160ff81901c601b016020526001600160ff1b031660605261604e565b60608401515f1a60205260408401516060525b50835f5260208301516040526020600160805f60015afa5180861860601b3d119250505f606052806040526160be565b631626ba7e60e01b808252846004830152602482016040815284516020018060448501828860045afa905060208260443d01868b5afa9151911691141691505b509392505050565b817f8e98a0734420e57ef102cab0b1af0809a5bbaf4fde966fd173c322490644a5d0826040516160f891815260200190565b60405180910390a261131e7f8e98a0734420e57ef102cab0b1af0809a5bbaf4fde966fd173c322490644a5d08383604051602001613220929190918252602082015260400190565b602081015181516040808401516060850151608086015160a087015160c088015160e08901516101008a01516101208b01516101408c01516101608d01516101808e01519a517f77242fbd573af5a5f3518da92600e96795ebfff993606b4fb54dea2dcd2dfe859b6161bb9b9a999897969594939291617738565b60405180910390a36112f07f77242fbd573af5a5f3518da92600e96795ebfff993606b4fb54dea2dcd2dfe858260405160200161322091906177b3565b5f5f5f60048551101561621e57604051631279950360e01b815260040160405180910390fd5b5f6162288661746c565b90506356fa634560e01b6001600160e01b03198216016162585761624b8661648a565b869550909350915061629e565b63dc478d2360e01b6001600160e01b031982160161628557616279866164d2565b9195509350915061629e565b604051630915b87b60e21b815260040160405180910390fd5b509250925092565b5f80806162ca886162b887602061763e565b6162c2908a6173ce565b016020015190565b90505f6162d782896173ce565b9050866162e58260206173ce565b111561630457604051631279950360e01b815260040160405180910390fd5b5f6163128a83016020015190565b9050600481101561632c57505f9350839250615138915050565b5f6163388360206173ce565b90505f61634583836173ce565b90508981111561636857604051631279950360e01b815260040160405180910390fd5b8b8201602001516001600160e01b0319808216908a161461639557505f9650869550615138945050505050565b836024146163b657604051631279950360e01b815260040160405180910390fd5b6163c58d6162c28560046173ce565b60019e909d509b505050505050505050505050565b5f5f5f6163e78686616531565b91509150815f0361640b5783818161640157616401617655565b0492505050613a57565b81841161642257616422600385150260111861654d565b5f848688095f868103871696879004966002600389028118808a02820302808a02820302808a02820302808a02820302808a02820302808a02909103029181900381900460010185841190960395909502919093039390930492909217029150509392505050565b80515f908190604481146164b157604051639ac60c2d60e01b815260040160405180910390fd5b60248401516044850151816164c581613cbf565b9791965090945050505050565b5f5f5f5f84519050806064146164fb57604051639ac60c2d60e01b815260040160405180910390fd5b602485015160448601516064870151828261651582613cbf565b985061652081613cbf565b989a98995091979650505050505050565b5f805f1983850993909202808410938190039390930393915050565b634e487b715f52806020526024601cfd5b5f6020828403121561656e575f5ffd5b5035919050565b80358015158114616584575f5ffd5b919050565b5f5f6040838503121561659a575f5ffd5b823591506165aa60208401616575565b90509250929050565b6001600160a01b03811681146112f0575f5ffd5b5f5f604083850312156165d8575f5ffd5b82356165e3816165b3565b946020939093013593505050565b5f5f60408385031215616602575f5ffd5b50508035926020909101359150565b8b81526001600160a01b038b811660208301528a1660408201526001600160401b038981166060830152888116608083015263ffffffff881660a0830152861660c082015260e08101859052610100810184905261012081018390526101a081016166a3610140830184805182526020808201516001600160a01b039081169184019190915260409182015116910152565b9c9b505050505050505050505050565b5f602082840312156166c3575f5ffd5b8135613a57816165b3565b5f5f5f5f608085870312156166e1575f5ffd5b843593506020850135925060408501356166fa816165b3565b9150606085013561670a816165b3565b939692955090935050565b80356001600160401b0381168114616584575f5ffd5b5f5f5f5f6080858703121561673e575f5ffd5b843593506020850135616750816165b3565b92506040850135915061676560608601616715565b905092959194509250565b63ffffffff811681146112f0575f5ffd5b5f5f60408385031215616792575f5ffd5b823561679d816165b3565b915060208301356167ad81616770565b809150509250929050565b5f602082840312156167c8575f5ffd5b613a5782616715565b806102808101831015611605575f5ffd5b5f5f83601f8401126167f2575f5ffd5b5081356001600160401b03811115616808575f5ffd5b60208301915083602082850101111561681f575f5ffd5b9250929050565b5f5f83601f840112616836575f5ffd5b5081356001600160401b0381111561684c575f5ffd5b6020830191508360208260051b850101111561681f575f5ffd5b5f5f5f5f5f5f5f5f60a0898b03121561687d575f5ffd5b88356001600160401b03811115616892575f5ffd5b61689e8b828c016167d1565b98505060208901356001600160401b038111156168b9575f5ffd5b6168c58b828c016167e2565b90985096505060408901356001600160401b038111156168e3575f5ffd5b6168ef8b828c01616826565b9096509450506060890135925060808901356001600160401b03811115616914575f5ffd5b6169208b828c01616826565b999c989b5096995094979396929594505050565b5f5f5f60608486031215616946575f5ffd5b8335616951816165b3565b9250602084013591506040840135616968816165b3565b809150509250925092565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b848152608060208201525f6169b96080830186616973565b6001600160401b039485166040840152929093166060909101529392505050565b5f5f5f5f5f5f5f5f610100898b0312156169f2575f5ffd5b883597506020890135616a04816165b3565b9650616a1260408a01616715565b95506060890135616a2281616770565b9450616a3060808a01616715565b935060a0890135925060c0890135616a47816165b3565b915060e0890135616a57816165b3565b809150509295985092959890939650565b5f8151808452602084019350602083015f5b82811015616a98578151865260209586019590910190600101616a7a565b5093949350505050565b60ff60f81b8816815260e060208201525f616ac060e0830189616973565b8281036040840152616ad28189616973565b606084018890526001600160a01b038716608085015260a0840186905283810360c08501529050616b038185616a68565b9a9950505050505050505050565b5f5f60408385031215616b22575f5ffd5b8235616b2d816165b3565b91506165aa60208401616575565b634e487b7160e01b5f52604160045260245ffd5b60405160c081016001600160401b0381118282101715616b7157616b71616b3b565b60405290565b604051601f8201601f191681016001600160401b0381118282101715616b9f57616b9f616b3b565b604052919050565b5f6001600160401b03821115616bbf57616bbf616b3b565b50601f01601f191660200190565b5f60208284031215616bdd575f5ffd5b81356001600160401b03811115616bf2575f5ffd5b8201601f81018413616c02575f5ffd5b8035616c15616c1082616ba7565b616b77565b818152856020838501011115616c29575f5ffd5b816020840160208301375f91810160200191909152949350505050565b5f5f5f5f60608587031215616c59575f5ffd5b8435616c64816165b3565b93506020850135925060408501356001600160401b03811115616c85575f5ffd5b616c9187828801616826565b95989497509550505050565b602081525f613a576020830184616973565b5f5f5f5f5f85870360c0811215616cc4575f5ffd5b863595506060601f1982011215616cd9575f5ffd5b506020860193506080860135925060a08601356001600160401b03811115616cff575f5ffd5b616d0b888289016167e2565b969995985093965092949392505050565b5f5f5f60608486031215616d2e575f5ffd5b505081359360208301359350604090920135919050565b5f5f5f5f5f60808688031215616d59575f5ffd5b8535945060208601356001600160401b03811115616d75575f5ffd5b616d81888289016167e2565b9095509350616d94905060408701616715565b9150616da260608701616715565b90509295509295909350565b5f5f5f5f5f60a08688031215616dc2575f5ffd5b8535616dcd816165b3565b94506020860135935060408601359250606086013591506080860135616df2816165b3565b809150509295509295909350565b5f5f60408385031215616e11575f5ffd5b8235915060208301356167ad816165b3565b602081525f613a576020830184616a68565b5f60208284031215616e45575f5ffd5b8135613a5781616770565b5f5f5f60608486031215616e62575f5ffd5b8335616e6d816165b3565b95602085013595506040909401359392505050565b5f5f60408385031215616e93575f5ffd5b8235616e9e816165b3565b91506165aa60208401616715565b5f5f5f5f5f5f5f60a0888a031215616ec2575f5ffd5b8735965060208801356001600160401b03811115616ede575f5ffd5b616eea8a828b016167d1565b96505060408801356001600160401b03811115616f05575f5ffd5b616f118a828b016167e2565b90965094505060608801356001600160401b03811115616f2f575f5ffd5b616f3b8a828b01616826565b989b979a50959894979596608090950135949350505050565b634e487b7160e01b5f52601160045260245ffd5b5f600160ff1b8201616f7c57616f7c616f54565b505f0390565b8181038181111561160557611605616f54565b634e487b7160e01b5f52603260045260245ffd5b600181811c90821680616fbd57607f821691505b602082108103616fdb57634e487b7160e01b5f52602260045260245ffd5b50919050565b5f5f5f5f5f60a08688031215616ff5575f5ffd5b85516020870151909550617008816165b3565b6040870151606088015160809098015196999198509695945092505050565b5f60208284031215617037575f5ffd5b8151613a57816165b3565b5f5f5f60608486031215617054575f5ffd5b8351602085015160408601519194509250616968816165b3565b5f5f6040838503121561707f575f5ffd5b825161708a816165b3565b6020939093015192949293505050565b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b5f5f8335601e198436030181126170d7575f5ffd5b83016020810192503590506001600160401b038111156170f5575f5ffd5b80360382131561681f575f5ffd5b60808082525f90610300830190830189835b601481101561715357858403607f19018352617131828d6170c2565b61713c86828461709a565b955050506020928301929190910190600101617115565b505050828103602084015261716981888a61709a565b838103604085015285815290506001600160fb1b03851115617189575f5ffd5b8460051b8087602084013760609390930193909352500160200195945050505050565b80516affffffffffffffffffffff1981168114616584575f5ffd5b5f602082840312156171d7575f5ffd5b81516001600160401b038111156171ec575f5ffd5b820160c081850312156171fd575f5ffd5b617205616b4f565b8151815260208083015190820152604082015161722181616770565b6040820152617232606083016171ac565b6060820152617243608083016171ac565b608082015260a08201516001600160401b03811115617260575f5ffd5b80830192505084601f830112617274575f5ffd5b8151617282616c1082616ba7565b818152866020838601011115617296575f5ffd5b8160208501602083015e5f9181016020019190915260a0820152949350505050565b5f600182016172c9576172c9616f54565b5060010190565b601f821115611ff657805f5260205f20601f840160051c810160208510156172f55750805b601f840160051c820191505b818110156115cf575f8155600101617301565b81516001600160401b0381111561732d5761732d616b3b565b6173418161733b8454616fa9565b846172d0565b6020601f821160018114617373575f831561735c5750848201515b5f19600385901b1c1916600184901b1784556115cf565b5f84815260208120601f198516915b828110156173a25787850151825560209485019460019092019101617382565b50848210156173bf57868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b8082018082111561160557611605616f54565b8082018281125f83128015821682158216171561740057617400616f54565b505092915050565b5f60208284031215617418575f5ffd5b5051919050565b828152604060208201525f6149c66040830184616973565b85815284602082015283604082015282606082015260a060808201525f61746160a0830184616973565b979650505050505050565b805160208201516001600160e01b03198116919060048210156174a3576001600160e01b0319600483900360031b81901b82161692505b5050919050565b5f8235607e198336030181126174be575f5ffd5b9190910192915050565b5f5f8335601e198436030181126174dd575f5ffd5b8301803591506001600160401b038211156174f6575f5ffd5b60200191503681900382131561681f575f5ffd5b878152866020820152856040820152846060820152836080820152818360a08301375f910160a0019081529695505050505050565b5f81518060208401855e5f93019283525090919050565b5f613a57828461753f565b608080825281018590525f60a0600587901b830181019083018883605e1936839003015b8a82101561760457868503609f1901845282358181126175a3575f5ffd5b8c0180356175b0816165b3565b6001600160a01b03168652602081810135908701526175d260408201826170c2565b9150606060408801526175e960608801838361709a565b96505050602083019250602084019350600182019150617585565b5050506001600160a01b038716602085015250905083604083015261763460608301846001600160a01b03169052565b9695505050505050565b808202811582820484141761160557611605616f54565b634e487b7160e01b5f52601260045260245ffd5b5f8261768357634e487b7160e01b5f52601260045260245ffd5b500490565b634e487b7160e01b5f52602160045260245ffd5b8381526020810183905260608101600683106176ba576176ba617688565b826040830152949350505050565b8681528560208201528460408201528360608201528260808201525f6176f160a083018461753f565b98975050505050505050565b838152826020820152606060408201525f61771b6060830184616973565b95945050505050565b6003811061773457617734617688565b9052565b6001600160a01b038c81168252602082018c9052604082018b9052606082018a905288166080820152610160810161777360a0830189617724565b60c08201969096526001600160a01b0394851660e0820152929093166101008301526001600160401b031661012082015261014001529695505050505050565b5f6101a082019050825182526020830151602083015260408301516177e360408401826001600160a01b03169052565b50606083015160608301526080830151608083015260a083015160a083015260c083015161781c60c08401826001600160a01b03169052565b5060e083015161782f60e0840182617724565b506101008301516101008301526101208301516178586101208401826001600160a01b03169052565b506101408301516178756101408401826001600160a01b03169052565b506101608301516178926101608401826001600160401b03169052565b506101809283015191909201529056fea164736f6c634300081b000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10a\x04\xC6W_5`\xE0\x1C\x80c\x84\xB0\x19n\x11a\x02xW\x80c\xB7\xED\x02\x0E\x11a\x01UW\x80c\xDE@\xD8\x9F\x11a\0\xC9W\x80c\xF0N\x02\xC0\x11a\0\x83W\x80c\xF0N\x02\xC0\x14a\x11\xA2W\x80c\xF1'\xA9\xB3\x14a\x11\xCDW\x80c\xF2\xFD\xE3\x8B\x14a\x11\xE2W\x80c\xF5\x16\xA5\xB4\x14a\x11\xF5W\x80c\xF6T\xB7\xD0\x14a\x12 W\x80c\xF9\xFD\xCA\xE6\x14a\x12?W__\xFD[\x80c\xDE@\xD8\x9F\x14a\x10\xD2W\x80c\xE2M\\5\x14a\x11\x05W\x80c\xE8\xBEe\x04\x14a\x11\x1AW\x80c\xEC\xF8\x8B\xB0\x14a\x119W\x80c\xEE\xB9\x02Y\x14a\x11XW\x80c\xF0>\xB6\x1A\x14a\x11\x83W__\xFD[\x80c\xCA\x02\xA8\x1E\x11a\x01\x1AW\x80c\xCA\x02\xA8\x1E\x14a\x0F\xE2W\x80c\xCE\xF5\xF4\x82\x14a\x10\rW\x80c\xD3\x8B\x01\x8B\x14a\x10,W\x80c\xDB\x14\xFBA\x14a\x10XW\x80c\xDC\x1F\x9A\xDF\x14a\x10\x94W\x80c\xDC\x8F\x863\x14a\x10\xB3W__\xFD[\x80c\xB7\xED\x02\x0E\x14a\x0E\xF6W\x80c\xB9\x8Ec\x1D\x14a\x0F\x0BW\x80c\xBC\\YP\x14a\x0F>W\x80c\xC0(>b\x14a\x0FlW\x80c\xC6;\xBF)\x14a\x0F\x8BW__\xFD[\x80c\x9Da\xDD\x07\x11a\x01\xECW\x80c\xA7\xEC\x9D\xF9\x11a\x01\xB1W\x80c\xA7\xEC\x9D\xF9\x14a\x0EDW\x80c\xAAc\xE5E\x14a\x0EcW\x80c\xAA\x946\x0C\x14a\x0E\x82W\x80c\xB13\xBE}\x14a\x0E\xA1W\x80c\xB3q\xFAi\x14a\x0E\xC2W\x80c\xB6\xB5_%\x14a\x0E\xD7W__\xFD[\x80c\x9Da\xDD\x07\x14a\r\x9AW\x80c\x9E\xFA\xCAy\x14a\r\xDBW\x80c\xA3M(\xEB\x14a\r\xFCW\x80c\xA60%Y\x14a\x0E\x1BW\x80c\xA6\xE9/<\x14a\x0E0W__\xFD[\x80c\x89'\xA1\x06\x11a\x02=W\x80c\x89'\xA1\x06\x14a\x0C\xF6W\x80c\x89\xF2\x97\xBD\x14a\r\x15W\x80c\x8D\xA5\xCB[\x14a\r4W\x80c\x90\"8\xE1\x14a\rLW\x80c\x93\xA9\xEEF\x14a\raW\x80c\x99\xB4\x99%\x14a\r{W__\xFD[\x80c\x84\xB0\x19n\x14a\x0CDW\x80c\x87\x01\xD7\xB2\x14a\x0CkW\x80c\x87\x8B\xA1V\x14a\x0C\x8AW\x80c\x88B\xC5s\x14a\x0C\xA9W\x80c\x88\x92r\x96\x14a\x0C\xC8W__\xFD[\x80cMS\xE91\x11a\x03\xA6W\x80cf^\x0E\xED\x11a\x03\x1AW\x80cx\xAA\xF2^\x11a\x02\xDFW\x80cx\xAA\xF2^\x14a\x0B/W\x80c|LO\xEB\x14a\x0B\x7FW\x80c}\xE8\x9F0\x14a\x0B\xAEW\x80c~ID\x7F\x14a\x0B\xF2W\x80c\x80\xA7,\x8B\x14a\x0C\x11W\x80c\x84V\xCBY\x14a\x0C0W__\xFD[\x80cf^\x0E\xED\x14a\nRW\x80cg\xDE\x8B~\x14a\nqW\x80cl\x83Z\x82\x14a\n\x95W\x80cqP\x18\xA6\x14a\n\xBFW\x80cq\x8F\xBC%\x14a\n\xC7W__\xFD[\x80cX\x97\x9B\xFE\x11a\x03kW\x80cX\x97\x9B\xFE\x14a\t\x92W\x80c\\\x97Z\xBB\x14a\t\xB1W\x80c\\\xF8\x80\x12\x14a\t\xC7W\x80c^\xA6<l\x14a\t\xE6W\x80c`\xB6\xBF\xDD\x14a\n\x05W\x80ccn\xE6$\x14a\n3W__\xFD[\x80cMS\xE91\x14a\x08\xF5W\x80cM\xA2\xF8\x99\x14a\t\nW\x80cP\x16\xC4{\x14a\t5W\x80cPb\x94\xDC\x14a\tTW\x80cW7a\x98\x14a\tsW__\xFD[\x80c6'r\r\x11a\x04=W\x80c?\xEA4\x88\x11a\x04\x02W\x80c?\xEA4\x88\x14a\x08\x1DW\x80cB\0\\l\x14a\x08<W\x80cCA\xFC\x86\x14a\x08[W\x80cF\xDE@o\x14a\x08\x97W\x80cH\x1F\x93v\x14a\x08\xB6W\x80cH.\xDB\x07\x14a\x08\xE1W__\xFD[\x80c6'r\r\x14a\x06\xD1W\x80c6`\xFB\x92\x14a\x07\x05W\x80c8\xEEr\xD0\x14a\x07fW\x80c=\x92\xAF\x84\x14a\x07\x85W\x80c?K\xA8:\x14a\x08\tW__\xFD[\x80c\x1D\xBFLa\x11a\x04\x8EW\x80c\x1D\xBFLa\x14a\x05\xB7W\x80c.\x1A}M\x14a\x05\xF6W\x80c/H\xAB}\x14a\x06\x15W\x80c/\x83\xD9\xAF\x14a\x064W\x80c3h\rX\x14a\x06jW\x80c3\xD9\x08\xAD\x14a\x06\xB2W__\xFD[\x80c\x04e\xEA\xB0\x14a\x04\xCAW\x80c\x04\xECB\x94\x14a\x04\xEBW\x80c\x0B4Xy\x14a\x05.W\x80c\x13v\xDER\x14a\x05yW\x80c\x1C\xF1\xBD:\x14a\x05\x98W[__\xFD[4\x80\x15a\x04\xD5W__\xFD[Pa\x04\xE9a\x04\xE46`\x04ae^V[a\x12yV[\0[4\x80\x15a\x04\xF6W__\xFD[Pa\x05\x19a\x05\x056`\x04ae^V[`\x14` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[`@Q\x90\x15\x15\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[4\x80\x15a\x059W__\xFD[Pa\x05a\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x05%V[4\x80\x15a\x05\x84W__\xFD[Pa\x04\xE9a\x05\x936`\x04ae\x89V[a\x12\xF3V[4\x80\x15a\x05\xA3W__\xFD[Pa\x04\xE9a\x05\xB26`\x04ae^V[a\x13\"V[4\x80\x15a\x05\xC2W__\xFD[Pa\x05aa\x05\xD16`\x04ae\xC7V[`\x13` \x90\x81R_\x92\x83R`@\x80\x84 \x90\x91R\x90\x82R\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x81V[4\x80\x15a\x06\x01W__\xFD[Pa\x04\xE9a\x06\x106`\x04ae^V[a\x13lV[4\x80\x15a\x06 W__\xFD[P`\x04Ta\x05a\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[4\x80\x15a\x06?W__\xFD[Pa\x06Sa\x06N6`\x04ae\xF1V[a\x14+V[`@Qa\x05%\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90af\x11V[4\x80\x15a\x06uW__\xFD[Pa\x06\xA4a\x06\x846`\x04af\xB3V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\r` R`@\x90 Tc\xFF\xFF\xFF\xFF\x16\x90V[`@Q\x90\x81R` \x01a\x05%V[4\x80\x15a\x06\xBDW__\xFD[Pa\x04\xE9a\x06\xCC6`\x04af\xCEV[a\x14\xECV[4\x80\x15a\x06\xDCW__\xFD[Pa\x06\xA4a\x06\xEB6`\x04af\xB3V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x19` R`@\x90 T\x90V[4\x80\x15a\x07\x10W__\xFD[Pa\x07Qa\x07\x1F6`\x04af\xB3V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\r` R`@\x90 Tc\xFF\xFF\xFF\xFF`\x01` \x1B\x82\x04\x81\x16\x92`\x01`@\x1B\x90\x92\x04\x16\x90V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x05%V[4\x80\x15a\x07qW__\xFD[Pa\x04\xE9a\x07\x806`\x04ag+V[a\x15\xD6V[4\x80\x15a\x07\x90W__\xFD[Pa\x07\xD7a\x07\x9F6`\x04ae^V[`\x1E` R_\x90\x81R`@\x90 \x80T`\x01\x82\x01T`\x02\x83\x01T`\x03\x84\x01T`\x04\x90\x94\x01T`\x01`\x01`\xA0\x1B\x03\x90\x93\x16\x93\x91\x92\x90\x91\x90\x85V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x90\x96\x16\x86R` \x86\x01\x94\x90\x94R\x92\x84\x01\x91\x90\x91R``\x83\x01R`\x80\x82\x01R`\xA0\x01a\x05%V[4\x80\x15a\x08\x14W__\xFD[Pa\x04\xE9a\x15\xE8V[4\x80\x15a\x08(W__\xFD[Pa\x05aa\x0876`\x04ae^V[a\x15\xFAV[4\x80\x15a\x08GW__\xFD[Pa\x04\xE9a\x08V6`\x04ag\x81V[a\x16\x0BV[4\x80\x15a\x08fW__\xFD[Pa\x08za\x08u6`\x04af\xB3V[a\x16PV[`@\x80Q\x93\x15\x15\x84R` \x84\x01\x92\x90\x92R\x90\x82\x01R``\x01a\x05%V[4\x80\x15a\x08\xA2W__\xFD[Pa\x04\xE9a\x08\xB16`\x04ae^V[a\x16\x9AV[4\x80\x15a\x08\xC1W__\xFD[P`\x0CTc\xFF\xFF\xFF\xFF`\x01` \x1B\x82\x04\x81\x16\x91`\x01`@\x1B\x90\x04\x16a\x07QV[4\x80\x15a\x08\xECW__\xFD[Pa\x06\xA4a\x17\x0EV[4\x80\x15a\t\0W__\xFD[Pa\x06\xA4`\x01T\x81V[4\x80\x15a\t\x15W__\xFD[Pa\x06\xA4a\t$6`\x04af\xB3V[`\x11` R_\x90\x81R`@\x90 T\x81V[4\x80\x15a\t@W__\xFD[Pa\x04\xE9a\tO6`\x04ae^V[a\x178V[4\x80\x15a\t_W__\xFD[Pa\x04\xE9a\tn6`\x04ag\xB8V[a\x1C0V[4\x80\x15a\t~W__\xFD[Pa\x04\xE9a\t\x8D6`\x04ae\xC7V[a\x1CfV[4\x80\x15a\t\x9DW__\xFD[Pa\x04\xE9a\t\xAC6`\x04af\xB3V[a\x1C\xB2V[4\x80\x15a\t\xBCW__\xFD[P_T`\xFF\x16a\x05\x19V[4\x80\x15a\t\xD2W__\xFD[Pa\x06\xA4a\t\xE16`\x04ahfV[a\x1C\xDEV[4\x80\x15a\t\xF1W__\xFD[Pa\x04\xE9a\n\x006`\x04ae\xC7V[a\x1EVV[4\x80\x15a\n\x10W__\xFD[Pa\x05\x19a\n\x1F6`\x04af\xB3V[`\n` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[4\x80\x15a\n>W__\xFD[Pa\x04\xE9a\nM6`\x04ae\xF1V[a\x1E\xB6V[4\x80\x15a\n]W__\xFD[Pa\x04\xE9a\nl6`\x04ai4V[a\x1F]V[4\x80\x15a\n|W__\xFD[P`\x0CT`\x01``\x1B\x90\x04`\x01`\x01`@\x1B\x03\x16a\x06\xA4V[4\x80\x15a\n\xA0W__\xFD[Pa\x06\xA4a\n\xAF6`\x04ae^V[` \x80R_\x90\x81R`@\x90 T\x81V[a\x04\xE9a\x1F\xFBV[4\x80\x15a\n\xD2W__\xFD[Pa\x0B\x10a\n\xE16`\x04ae\xF1V[`\x1C` \x90\x81R_\x92\x83R`@\x80\x84 \x90\x91R\x90\x82R\x90 \x80T`\x01\x90\x91\x01T`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x82V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x90\x93\x16\x83R` \x83\x01\x91\x90\x91R\x01a\x05%V[4\x80\x15a\x0B:W__\xFD[Pa\x0BNa\x0BI6`\x04ae\xC7V[a \x0CV[`@\x80Q\x95\x86R` \x86\x01\x94\x90\x94R\x92\x84\x01\x91\x90\x91R``\x83\x01R`\x01`\x01`\xA0\x1B\x03\x16`\x80\x82\x01R`\xA0\x01a\x05%V[4\x80\x15a\x0B\x8AW__\xFD[Pa\x0B\x9Ea\x0B\x996`\x04ae^V[a _V[`@Qa\x05%\x94\x93\x92\x91\x90ai\xA1V[4\x80\x15a\x0B\xB9W__\xFD[Pa\x06\xA4a\x0B\xC86`\x04af\xB3V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\r` R`@\x90 T`\x01``\x1B\x90\x04`\x01`\x01`@\x1B\x03\x16\x90V[4\x80\x15a\x0B\xFDW__\xFD[Pa\x07Qa\x0C\x0C6`\x04ai\xDAV[a!GV[4\x80\x15a\x0C\x1CW__\xFD[P`\x03Ta\x05a\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[4\x80\x15a\x0C;W__\xFD[Pa\x04\xE9a!\xBFV[4\x80\x15a\x0COW__\xFD[Pa\x0CXa!\xCFV[`@Qa\x05%\x97\x96\x95\x94\x93\x92\x91\x90aj\xA2V[4\x80\x15a\x0CvW__\xFD[Pa\x04\xE9a\x0C\x856`\x04ak\x11V[a\"(V[4\x80\x15a\x0C\x95W__\xFD[Pa\x04\xE9a\x0C\xA46`\x04ak\x11V[a\"]V[4\x80\x15a\x0C\xB4W__\xFD[Pa\x06\xA4a\x0C\xC36`\x04af\xB3V[a\"\x92V[4\x80\x15a\x0C\xD3W__\xFD[Pa\x05\x19a\x0C\xE26`\x04ae^V[`\x1D` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[4\x80\x15a\r\x01W__\xFD[Pa\x06Sa\r\x106`\x04ae^V[a\"\x9CV[4\x80\x15a\r W__\xFD[Pa\x06\xA4a\r/6`\x04ak\xCDV[a$mV[4\x80\x15a\r?W__\xFD[Pc\x8Bx\xC6\xD8\x19Ta\x05aV[4\x80\x15a\rWW__\xFD[Pa\x06\xA4`\x06T\x81V[4\x80\x15a\rlW__\xFD[P`\x0CTc\xFF\xFF\xFF\xFF\x16a\x06\xA4V[4\x80\x15a\r\x86W__\xFD[Pa\x04\xE9a\r\x956`\x04alFV[a$wV[4\x80\x15a\r\xA5W__\xFD[Pa\x06\xA4a\r\xB46`\x04af\xB3V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\r` R`@\x90 T`\x01`\xA0\x1B\x90\x04c\xFF\xFF\xFF\xFF\x16\x90V[4\x80\x15a\r\xE6W__\xFD[Pa\r\xEFa%\xD2V[`@Qa\x05%\x91\x90al\x9DV[4\x80\x15a\x0E\x07W__\xFD[Pa\x04\xE9a\x0E\x166`\x04al\xAFV[a&XV[4\x80\x15a\x0E&W__\xFD[Pa\x06\xA4`\x15T\x81V[4\x80\x15a\x0E;W__\xFD[P`\x17Ta\x06\xA4V[4\x80\x15a\x0EOW__\xFD[Pa\x07Qa\x0E^6`\x04am\x1CV[a'cV[4\x80\x15a\x0EnW__\xFD[Pa\x04\xE9a\x0E}6`\x04amEV[a)sV[4\x80\x15a\x0E\x8DW__\xFD[Pa\x05aa\x0E\x9C6`\x04ae\xC7V[a*QV[4\x80\x15a\x0E\xACW__\xFD[P`\x0CT`\x01`\xA0\x1B\x90\x04c\xFF\xFF\xFF\xFF\x16a\x06\xA4V[4\x80\x15a\x0E\xCDW__\xFD[Pa\x06\xA4`\x16T\x81V[4\x80\x15a\x0E\xE2W__\xFD[Pa\x04\xE9a\x0E\xF16`\x04ae^V[a*\xE8V[4\x80\x15a\x0F\x01W__\xFD[Pa\x06\xA4`\x10T\x81V[4\x80\x15a\x0F\x16W__\xFD[Pa\x05a\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[4\x80\x15a\x0FIW__\xFD[Pa\x05\x19a\x0FX6`\x04af\xB3V[`\x0B` R_\x90\x81R`@\x90 T`\xFF\x16\x81V[4\x80\x15a\x0FwW__\xFD[Pa\x06\xA4a\x0F\x866`\x04am\xAEV[a+\x85V[4\x80\x15a\x0F\x96W__\xFD[Pa\x0F\xCAa\x0F\xA56`\x04an\0V[`\x1F` \x90\x81R_\x92\x83R`@\x80\x84 \x90\x91R\x90\x82R\x90 T`\x01`\x01`@\x1B\x03\x16\x81V[`@Q`\x01`\x01`@\x1B\x03\x90\x91\x16\x81R` \x01a\x05%V[4\x80\x15a\x0F\xEDW__\xFD[Pa\x06\xA4a\x0F\xFC6`\x04ae^V[_\x90\x81R`\x07` R`@\x90 T\x90V[4\x80\x15a\x10\x18W__\xFD[Pa\x04\xE9a\x10'6`\x04ae\xC7V[a+\x9EV[4\x80\x15a\x107W__\xFD[Pa\x10Ka\x10F6`\x04ae^V[a,\x11V[`@Qa\x05%\x91\x90an#V[4\x80\x15a\x10cW__\xFD[Pa\x10wa\x10r6`\x04af\xB3V[a,pV[`@Qj\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x91\x16\x81R` \x01a\x05%V[4\x80\x15a\x10\x9FW__\xFD[Pa\x04\xE9a\x10\xAE6`\x04an5V[a,zV[4\x80\x15a\x10\xBEW__\xFD[P`\x05Ta\x05a\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[4\x80\x15a\x10\xDDW__\xFD[Pa\x05a\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[4\x80\x15a\x11\x10W__\xFD[Pa\x06\xA4`\x02T\x81V[4\x80\x15a\x11%W__\xFD[Pa\x07Qa\x1146`\x04ae^V[a,\xA9V[4\x80\x15a\x11DW__\xFD[Pa\x04\xE9a\x11S6`\x04anPV[a,\xE9V[4\x80\x15a\x11cW__\xFD[Pa\x06\xA4a\x11r6`\x04af\xB3V[`\x1A` R_\x90\x81R`@\x90 T\x81V[4\x80\x15a\x11\x8EW__\xFD[Pa\x04\xE9a\x11\x9D6`\x04an\x82V[a-\xA6V[4\x80\x15a\x11\xADW__\xFD[Pa\x06\xA4a\x11\xBC6`\x04af\xB3V[`\x12` R_\x90\x81R`@\x90 T\x81V[4\x80\x15a\x11\xD8W__\xFD[Pa\x06\xA4`\x18T\x81V[a\x04\xE9a\x11\xF06`\x04af\xB3V[a-\xF2V[4\x80\x15a\x12\0W__\xFD[Pa\x06\xA4a\x12\x0F6`\x04ae^V[`\x1B` R_\x90\x81R`@\x90 T\x81V[4\x80\x15a\x12+W__\xFD[Pa\x04\xE9a\x12:6`\x04af\xB3V[a.\x18V[4\x80\x15a\x12JW__\xFD[Pa\x12^a\x12Y6`\x04an\xACV[a.DV[`@\x80Q\x93\x84R` \x84\x01\x92\x90\x92R\x90\x82\x01R``\x01a\x05%V[a\x12\x81a15V[`\x01\x81\x12\x15a\x12\xA3W`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x10T\x81\x13\x15a\x12\xC6W`@Qc\x9D\x8C}\x99`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x04Ta\x12\xDD\x90`\x01`\x01`\xA0\x1B\x03\x163\x83a1OV[a\x12\xF0a\x12\xE9\x82aohV[`\x02a1sV[PV[a\x12\xFBa15V[_\x82\x81R`\x14` R`@\x90 \x80T`\xFF\x19\x16\x82\x15\x15\x17\x90Ua\x13\x1E\x82\x82a1\xA2V[PPV[a\x13*a15V[b\x0FB@\x81\x11\x15a\x13NW`@QcJU\x94k`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x0C\x80Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x83\x16\x17\x90Ua\x12\xF0\x81a24V[a\x13ta2\x9EV[\x80_\x03a\x13\x94W`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[3_\x90\x81R`\x11` R`@\x90 T\x80\x82\x11\x15a\x13\xC4W`@Qc\xD4p\x8C\xA5`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x13\xCCa\x17\x0EV[\x82\x11\x15a\x13\xECW`@Qc\xB5\\\x1B\xAD`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x13\xF6\x82\x82ao\x82V[3_\x81\x81R`\x11` R`@\x90 \x91\x90\x91U`\x04Ta\x14!\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x84a1OV[a\x13\x1E3\x83a2\xC1V[`\x07` R\x81_R`@_ \x81\x81T\x81\x10a\x14DW_\x80\xFD[_\x91\x82R` \x91\x82\x90 `\n\x90\x91\x02\x01\x80T`\x01\x82\x01T`\x02\x83\x01T`\x03\x84\x01T`\x04\x85\x01T`\x05\x86\x01T`\x06\x87\x01T`@\x80Q``\x81\x01\x82R`\x07\x8A\x01T\x81R`\x08\x8A\x01T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x9B\x82\x01\x9B\x90\x9BR`\t\x90\x99\x01T\x8A\x16\x90\x89\x01R\x95\x99P\x93\x87\x16\x97P\x95\x82\x16\x95`\x01`\x01`@\x1B\x03`\x01`\xA0\x1B\x90\x93\x04\x83\x16\x95\x82\x84\x16\x95c\xFF\xFF\xFF\xFF`\x01`@\x1B\x85\x04\x16\x95`\x01``\x1B\x90\x94\x04\x90\x94\x16\x93\x91\x92\x91\x90\x8BV[a\x14\xF4a2\x9EV[_a\x14\xFE\x85a3KV[`\x02\x81\x01T\x90\x91P`\x01`\x01`\xA0\x1B\x03\x163\x14a\x15.W`@Qc8\x9Bzy`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x1573a3\xBBV[_\x84\x81R`\x14` R`@\x90 T`\xFF\x16\x15a\x15fW`@Qc\xD9%\x9C\xA9`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x15p\x84\x84a4\xD0V[`@\x80Q``\x81\x01\x82R\x85\x81R`\x01`\x01`\xA0\x1B\x03\x80\x86\x16` \x83\x01\x81\x90R\x90\x85\x16\x91\x90\x92\x01\x81\x90R`\x07\x83\x01\x86\x90U`\x08\x83\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x16\x90\x93\x17\x90U`\t\x83\x01\x80T\x90\x92\x16\x17\x90Ua\x15\xCF\x85\x85\x85\x85a5\xC2V[PPPPPV[a\x15\xE2\x84\x84\x84\x84a6dV[PPPPV[a\x15\xF0a15V[a\x15\xF8a8\xA3V[V[_a\x16\x050\x83a*QV[\x92\x91PPV[a\x16\x13a15V[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\r` R`@\x90 \x80Tc\xFF\xFF\xFF\xFF`\xA0\x1B\x19\x16`\x01`\xA0\x1Bc\xFF\xFF\xFF\xFF\x84\x16\x02\x17\x90Ua\x13\x1E\x82\x82a8\xF4V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\r` R`@\x81 \x80Tc\xFF\xFF\xFF\xFF`\x01` \x1B\x82\x04\x81\x16\x92`\x01`@\x1B\x90\x92\x04\x16\x90\x82\x15\x80\x15\x90a\x16\x90WP\x81\x15\x15[\x93PP\x91\x93\x90\x92PV[\x80_\x03a\x16\xBAW`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x04T`\x01`\x01`\xA0\x1B\x03\x16a\x16\xE3W`@Qc\x85b\xEBE`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x04Ta\x16\xFB\x90`\x01`\x01`\xA0\x1B\x03\x1630\x84a9\x87V[a\x12\xF0a\x17\x07\x82a9\xA2V[`\x05a1sV[`\x04T_\x90`\x01`\x01`\xA0\x1B\x03\x16\x80a\x17(W_\x91PP\x90V[a\x172\x810a9\xCFV[\x91PP\x90V[a\x17@a2\x9EV[`\x18T`\x17T_[\x81\x83\x10\x80\x15a\x17VWP\x83\x81\x10[\x15a\x1C(W_`\x17\x84\x81T\x81\x10a\x17oWa\x17oao\x95V[_\x91\x82R` \x90\x91 `\x03\x90\x91\x02\x01\x80T\x90\x91P\x7F\xFC\xB4O\xFE\xBD8\xE2\xFE\x82\xABb>\xA3x\x88T!<E\x8C\xF9\x85U%\xB5\x86[p}_\x01>\x81\x01a\x18~W___\x84`\x01\x01\x80Ta\x17\xBC\x90ao\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x17\xE8\x90ao\xA9V[\x80\x15a\x183W\x80`\x1F\x10a\x18\nWa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x183V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x18\x16W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x80` \x01\x90Q\x81\x01\x90a\x18K\x91\x90ao\xE1V[\x94PPP\x92P\x92Pa\x18v\x83\x83\x83\x88`\x02\x01`\x08\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16a6dV[PPPa\x1BfV[\x7F\xA4O)=\xFA\x92(\x91cE\xA6\x01b \xF3\x04\xFDN\x10\xC2\xF2^\xF6,\x89kIF\x92jp\xF4\x81\x03a\x19pW_\x82`\x01\x01\x80Ta\x18\xB5\x90ao\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x18\xE1\x90ao\xA9V[\x80\x15a\x19,W\x80`\x1F\x10a\x19\x03Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x19,V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x19\x0FW\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x80` \x01\x90Q\x81\x01\x90a\x19D\x91\x90ap'V[`\x05\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x83\x16\x17\x90U\x90Pa\x19j\x81a:^V[Pa\x1BfV[\x7F\xC1-\xAF\xB0\xC4\x07\xB0\xB3Bb6\x05\xE9P\xEF9\xBC.<\x97\xA3\xE5\xEEWEU\xB3Pgv\x01\xB1\x81\x03a\x1A\x7FW__\x83`\x01\x01\x80Ta\x19\xA8\x90ao\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x19\xD4\x90ao\xA9V[\x80\x15a\x1A\x1FW\x80`\x1F\x10a\x19\xF6Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x1A\x1FV[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1A\x02W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x80` \x01\x90Q\x81\x01\x90a\x1A7\x91\x90apBV[P\x91P\x91P_\x82\x82\x10\x15a\x1AeWa\x1AWa\x1AR\x83\x85ao\x82V[a9\xA2V[a\x1A`\x90aohV[a\x1ArV[a\x1Ara\x1AR\x84\x84ao\x82V[\x90Pa\x18v\x81`\x01a1sV[\x7FG\xC6u\x1EZ\xBE\x12,\x1C\xA5\x82\x8C\x0F\xD6\x0C2\x8B6\x9EWR'\xDF\xCC\x17\xE7b>\x89^\xC0E\x81\x03a\x1BfW_\x82`\x01\x01\x80Ta\x1A\xB6\x90ao\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x1A\xE2\x90ao\xA9V[\x80\x15a\x1B-W\x80`\x1F\x10a\x1B\x04Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x1B-V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1B\x10W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x80` \x01\x90Q\x81\x01\x90a\x1BE\x91\x90apnV[\x91PPa\x1Bda\x1BT\x82a9\xA2V[a\x1B]\x90aohV[`\x04a1sV[P[`\x02\x82\x01T`\x01\x83\x01\x80Ta\x1C\x1A\x92\x88\x92`\x01`\x01`@\x1B\x03\x80\x83\x16\x93`\x01`@\x1B\x90\x93\x04\x16\x91\x86\x91\x90a\x1B\x99\x90ao\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta\x1B\xC5\x90ao\xA9V[\x80\x15a\x1C\x10W\x80`\x1F\x10a\x1B\xE7Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a\x1C\x10V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a\x1B\xF3W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPPa:\xD0V[PP`\x01\x92\x83\x01\x92\x01a\x17HV[PP`\x18UPV[a\x1C8a15V[`\x0C\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x1B\x19\x16`\x01``\x1B`\x01`\x01`@\x1B\x03\x84\x16\x02\x17\x90Ua\x12\xF0\x81a;IV[a\x1Cna15V[`\x04T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x90\x83\x16\x03a\x1C\x9DW`@Qc\x1CN\x1B\xFF`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x1C\xA8\x823\x83a1OV[a\x13\x1E\x82\x82a;\xC4V[a\x1C\xBAa15V[`\x04\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x83\x16\x17\x90Ua\x12\xF0\x81a<MV[_a\x1C\xE7a2\x9EV[`\x03T`@Qc\t9\xB3\xF3`\xE3\x1B\x81R_\x91`\x01`\x01`\xA0\x1B\x03\x16\x90cI\xCD\x9F\x98\x90a\x1D!\x90\x8D\x90\x8D\x90\x8D\x90\x8D\x90\x8D\x90\x8D\x90`\x04\x01aq\x03V[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x1D;W=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x1Db\x91\x90\x81\x01\x90aq\xC7V[\x90P_a\x1D\x8E\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a<\xBFV[\x90P\x80`\x01`\x01`X\x1B\x03\x19\x16\x82`\x80\x01Q`\x01`\x01`X\x1B\x03\x19\x16\x14a\x1D\xC8W`@Qc6[>S`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x1D\xD5\x82`\xA0\x01Qa<\xD4V[`\x15T\x90\x93P\x80\x84\x03a\x1D\xFBW`@Qc5\xB0Q\x9F`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x16T_\x80a\x1E\x0C\x84\x84\x8B\x8Ba=\x80V[\x91P\x91P\x86\x82\x14a\x1E0W`@Qc\x0ER\x1CC`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x15\x87\x90U`\x16\x81\x90Ua\x1ED\x89\x89a?\x02V[PPPPPP\x98\x97PPPPPPPPV[a\x1E^a15V[b\x0FB@\x81\x11\x15a\x1E\x82W`@QcJU\x94k`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\r` R`@\x90 \x80Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x83\x16\x17\x90Ua\x13\x1E\x82\x82a@EV[a\x1E\xBEa15V[c\xFF\xFF\xFF\xFF\x82\x11\x80a\x1E\xD3WPc\xFF\xFF\xFF\xFF\x81\x11[\x15a\x1E\xF1W`@Qc\xA1~\xEAw`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x15\x81\x15\x14a\x1F\x13W`@Qc\xA1~\xEAw`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x0C\x80Tc\xFF\xFF\xFF\xFF\x83\x81\x16`\x01`@\x1B\x02c\xFF\xFF\xFF\xFF`@\x1B\x19\x91\x86\x16`\x01` \x1B\x02\x91\x90\x91\x16k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\x19\x90\x92\x16\x91\x90\x91\x17\x17\x90Ua\x13\x1E\x82\x82a@\xCFV[a\x1Fea15V[`\x01`\x01`\xA0\x1B\x03\x83\x16a\x1F\x8CW`@Qc\x85b\xEBE`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x1F\xB3W`@Qc\xB3|y\xED`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x83\x81\x16_\x90\x81R`\x13` \x90\x81R`@\x80\x83 \x86\x84R\x90\x91R\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x91\x83\x16\x91\x90\x91\x17\x90Ua\x1F\xF6\x83\x83\x83aAHV[PPPV[a \x03a15V[a\x15\xF8_aA\xDBV[`\x19` R\x81_R`@_ \x81\x81T\x81\x10a %W_\x80\xFD[_\x91\x82R` \x90\x91 `\x05\x90\x91\x02\x01\x80T`\x01\x82\x01T`\x02\x83\x01T`\x03\x84\x01T`\x04\x90\x94\x01T\x92\x95P\x90\x93P\x91\x90`\x01`\x01`\xA0\x1B\x03\x16\x85V[_``___`\x17\x86\x81T\x81\x10a xWa xao\x95V[_\x91\x82R` \x90\x91 `\x03\x90\x91\x02\x01\x80T`\x02\x82\x01T`\x01\x83\x01\x80T\x93\x94P\x91\x92`\x01`\x01`@\x1B\x03\x80\x83\x16\x92`\x01`@\x1B\x90\x04\x16\x90\x83\x90a \xB9\x90ao\xA9V[\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x92\x91\x90\x81\x81R` \x01\x82\x80Ta \xE5\x90ao\xA9V[\x80\x15a!0W\x80`\x1F\x10a!\x07Wa\x01\0\x80\x83T\x04\x02\x83R\x91` \x01\x91a!0V[\x82\x01\x91\x90_R` _ \x90[\x81T\x81R\x90`\x01\x01\x90` \x01\x80\x83\x11a!\x13W\x82\x90\x03`\x1F\x16\x82\x01\x91[PPPPP\x92P\x94P\x94P\x94P\x94PP\x91\x93P\x91\x93V[__a!Qa2\x9EV[a!_3\x8B\x8A\x8A\x8A\x8AaB\x01V[a!i\x85\x85a4\xD0V[`\x06_\x81Ta!w\x90ar\xB8V[\x91\x82\x90UP\x91PBa!\x92\x83\x8C3\x8D\x85\x8E\x8E\x8E\x8E\x8E\x8EaC\xF6V[\x91Pa!\xA5\x83\x8C\x843\x8E\x86\x8F\x8F\x8FaG\x0CV[a!\xB1\x83\x87\x87\x87a5\xC2V[P\x98P\x98\x96PPPPPPPV[a!\xC7a15V[a\x15\xF8aH\x0CV[`\x0F`\xF8\x1B``\x80_\x80\x80\x83a\"\x16`@\x80Q\x80\x82\x01\x82R`\x06\x81Re*\xB7:97\xB7`\xD1\x1B` \x80\x83\x01\x91\x90\x91R\x82Q\x80\x84\x01\x90\x93R`\x01\x83R`1`\xF8\x1B\x90\x83\x01R\x91V[\x97\x98\x90\x97\x96PF\x95P0\x94P\x91\x92P\x90V[a\"0a15V[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\x0B` R`@\x90 \x80T`\xFF\x19\x16\x82\x15\x15\x17\x90Ua\x13\x1E\x82\x82aHHV[a\"ea15V[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\n` R`@\x90 \x80T`\xFF\x19\x16\x82\x15\x15\x17\x90Ua\x13\x1E\x82\x82aH\xD8V[_a\x16\x05\x82aIhV[__________a\"\xD9`@Q\x80``\x01`@R\x80_\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01_`\x01`\x01`\xA0\x1B\x03\x16\x81RP\x90V[_\x8C\x81R`\x08` R`@\x81 `\x01\x81\x01T\x90\x91\x81\x90\x03a\"\xFBWPPa$^V[\x81T_\x90\x81R`\x07` R`@\x81 a#\x15`\x01\x84ao\x82V[\x81T\x81\x10a#%Wa#%ao\x95V[\x90_R` _ \x90`\n\x02\x01\x90P\x80_\x01T\x9DP\x80`\x01\x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x9CP\x80`\x02\x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x9BP\x80`\x02\x01`\x14\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16\x9AP\x80`\x03\x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16\x99P\x80`\x03\x01`\x08\x90T\x90a\x01\0\n\x90\x04c\xFF\xFF\xFF\xFF\x16\x98P\x80`\x03\x01`\x0C\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16\x97P\x80`\x04\x01T\x96P\x80`\x05\x01T\x95P\x80`\x06\x01T\x94P\x80`\x07\x01`@Q\x80``\x01`@R\x90\x81_\x82\x01T\x81R` \x01`\x01\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01`\x02\x82\x01_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16`\x01`\x01`\xA0\x1B\x03\x16\x81RPP\x93PPPP[\x91\x93\x95\x97\x99\x9B\x90\x92\x94\x96\x98\x9APV[_a\x16\x05\x82a<\xD4V[0h\x92\x9E\xEE\x14\x9BK\xD2\x12hT\x03a$\x95Wc\xAB\x14<\x06_R`\x04`\x1C\xFD[0h\x92\x9E\xEE\x14\x9BK\xD2\x12hUa$\xA9a2\x9EV[`\x01`\x01`\xA0\x1B\x03\x84\x16a$\xD0W`@Qc\x85b\xEBE`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82\x15a%\xC0W`\x01`\x01`\xA0\x1B\x03\x80\x85\x16_\x81\x81R`\x19` \x90\x81R`@\x80\x83 `\x1A\x90\x92R\x82 T`\x04T\x91\x94\x90\x93\x91\x16\x14a%AWP`\x01`\x01`\xA0\x1B\x03\x86\x16_\x90\x81R`\x12` R`@\x81 T\x90\x81\x90\x03a%AW`@Qc\x04~?\xE7`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[___a%Q\x8A\x87\x87\x8C\x88aI\xCEV[`\x04T\x92\x95P\x90\x93P\x91P_\x90`\x01`\x01`\xA0\x1B\x03\x8C\x81\x16\x91\x16\x14a%\x80Wa%}\x8B\x84\x84\x8C\x8CaJ\xF5V[\x90P[a%\x8D\x8B\x86\x89\x89\x88aK\xE5V[`\x01`\x01`\xA0\x1B\x03\x8B\x16_\x90\x81R`\x1A` R`@\x90 \x84\x90U\x80\x15a%\xB8Wa%\xB8\x8B3\x83a1OV[PPPPPPP[8h\x92\x9E\xEE\x14\x9BK\xD2\x12hUPPPPV[`@\x80Qs=`-\x80`\n=9\x81\xF36==7===6=s``\x1B` \x82\x01Rk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0``\x1B\x16`4\x82\x01RnZ\xF4=\x82\x80>\x90=\x91`+W\xFD[\xF3`\x88\x1B`H\x82\x01R\x81Q`7\x81\x83\x03\x01\x81R`W\x90\x91\x01\x90\x91R\x90V[a&`a2\x9EV[\x82B\x11\x15a&\x81W`@Qc\x08\x19\xBD\xCD`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a&\x8B\x86a3KV[`\x02\x81\x01T\x90\x91Pa&\xA5\x90`\x01`\x01`\xA0\x1B\x03\x16a3\xBBV[_\x86\x81R` \x80\x80R`@\x80\x83 T\x92\x885\x92\x90\x91a&\xC9\x91\x90\x8A\x01\x90\x8A\x01af\xB3V[\x90P_a&\xDC``\x8A\x01`@\x8B\x01af\xB3V[\x90Pa&\xE8\x83\x83a4\xD0V[_a&\xF7\x8B\x85\x85\x85\x89\x8EaN\x19V[`\x02\x87\x01T\x90\x91Pa'\x14\x90`\x01`\x01`\xA0\x1B\x03\x16\x82\x8A\x8AaN\x8DV[a'\x1E\x8B\x86aN\xF9V[a'(\x86\x8BaO#V[a'V\x8B\x8B5a'>`@\x8E\x01` \x8F\x01af\xB3V[\x8D`@\x01` \x81\x01\x90a'Q\x91\x90af\xB3V[a5\xC2V[PPPPPPPPPPPV[__a'ma2\x9EV[_\x85\x81R`\x1D` R`@\x90 T`\xFF\x16\x15a'\x9CW`@Qc\x1B\xEBq\x05`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x85\x81R`\x1E` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16\x15a'\xD1W`@Qc\xCC\x0B\xB0\xC1`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x82_\x03a'\xF1W`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a'\xFB\x85a3KV[\x90Pa(\x07\x81\x85aO\xB9V[\x91P\x81_\x03a()W`@Qc?A\xAE\x01`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x07\x81\x01\x80T`\x08\x83\x01Ta(G\x91\x90`\x01`\x01`\xA0\x1B\x03\x16a4\xD0V[3_\x90\x81R`\x11` R`@\x90 T\x83\x81\x10\x15a(wW`@Qc\xAC\xF2\xDA\x93`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a(\x81\x84\x82ao\x82V[3_\x90\x81R`\x11` R`@\x81 \x91\x90\x91U`\x01\x83\x01T\x83T`\x02\x85\x01Ta(\xB9\x92`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x89\x92\x8D\x92\x16aP'V[\x80\x92P\x81\x97PPP`@Q\x80`\xA0\x01`@R\x803`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x89\x81R` \x01\x88\x81R` \x01\x87\x81R` \x01\x82\x81RP`\x1E_\x8B\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01_a\x01\0\n\x81T\x81`\x01`\x01`\xA0\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`\xA0\x1B\x03\x16\x02\x17\x90UP` \x82\x01Q\x81`\x01\x01U`@\x82\x01Q\x81`\x02\x01U``\x82\x01Q\x81`\x03\x01U`\x80\x82\x01Q\x81`\x04\x01U\x90PPa)g\x88\x82\x85\x89\x89\x8E3\x8EaQBV[PPPP\x93P\x93\x91PPV[`\x17`@Q\x80`\x80\x01`@R\x80\x87\x81R` \x01\x86\x86\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x82\x90RP\x93\x85RPPP`\x01`\x01`@\x1B\x03\x80\x87\x16` \x80\x85\x01\x91\x90\x91R\x90\x86\x16`@\x90\x93\x01\x92\x90\x92R\x83T`\x01\x81\x81\x01\x86U\x94\x82R\x90\x82\x90 \x83Q`\x03\x90\x92\x02\x01\x90\x81U\x90\x82\x01Q\x91\x92\x90\x91\x90\x82\x01\x90a*\x0E\x90\x82as\x14V[P`@\x82\x01Q`\x02\x90\x91\x01\x80T``\x90\x93\x01Q`\x01`\x01`@\x1B\x03\x90\x81\x16`\x01`@\x1B\x02`\x01`\x01`\x80\x1B\x03\x19\x90\x94\x16\x92\x16\x91\x90\x91\x17\x91\x90\x91\x17\x90UPPPPPV[_\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83\x83a*}a%\xD2V[\x80Q` \x91\x82\x01 `@Qa*\xC9\x95\x94\x93\x92\x01`\x01`\x01`\xF8\x1B\x03\x19\x94\x90\x94\x16\x84R``\x92\x90\x92\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01\x84\x01R`\x15\x83\x01R`5\x82\x01R`U\x01\x90V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x93\x92PPPV[a*\xF0a2\x9EV[3_\x90\x81R`\x0B` R`@\x90 T`\xFF\x16a+\x1FW`@Qc\x03kc\x8D`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80_\x03a+?W`@Qc\x1F* \x05`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x04Ta+W\x90`\x01`\x01`\xA0\x1B\x03\x1630\x84a9\x87V[3_\x90\x81R`\x11` R`@\x81 \x80T\x83\x92\x90a+u\x90\x84\x90as\xCEV[\x90\x91UPa\x12\xF0\x90P3\x82aQ\xD3V[_a+\x93\x86\x86\x86\x86\x86aP'V[P\x96\x95PPPPPPV[a+\xA6a15V[`\x01`\x01`\xA0\x1B\x03\x82\x16a+\xCDW`@Qc\x85b\xEBE`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80_\x03a+\xEDW`@Qc\x04~?\xE7`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\x12` R`@\x90 \x81\x90Ua\x13\x1E\x82\x82aR]V[_\x81\x81R`\t` \x90\x81R`@\x91\x82\x90 \x80T\x83Q\x81\x84\x02\x81\x01\x84\x01\x90\x94R\x80\x84R``\x93\x92\x83\x01\x82\x82\x80\x15a,dW` \x02\x82\x01\x91\x90_R` _ \x90[\x81T\x81R` \x01\x90`\x01\x01\x90\x80\x83\x11a,PW[PPPPP\x90P\x91\x90PV[_a\x16\x05\x82a<\xBFV[a,\x82a15V[`\x0C\x80Tc\xFF\xFF\xFF\xFF`\xA0\x1B\x19\x16`\x01`\xA0\x1Bc\xFF\xFF\xFF\xFF\x84\x16\x02\x17\x90Ua\x12\xF0\x81aR\xE7V[_\x81\x81R`\x08` R`@\x81 `\x01\x81\x01T\x82\x91\x90\x80\x83\x03a,\xD1WP_\x94\x85\x94P\x92PPPV[\x81Ta,\xDE`\x01\x83ao\x82V[\x93P\x93PPP\x91P\x91V[a,\xF1a15V[c\xFF\xFF\xFF\xFF\x82\x11\x80a-\x06WPc\xFF\xFF\xFF\xFF\x81\x11[\x15a-$W`@Qc!2\xC1\x19`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x15\x81\x15\x14a-FW`@Qc!2\xC1\x19`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\r` R`@\x90 \x80Tc\xFF\xFF\xFF\xFF\x83\x81\x16`\x01`@\x1B\x02c\xFF\xFF\xFF\xFF`@\x1B\x19\x91\x86\x16`\x01` \x1B\x02\x91\x90\x91\x16k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\x19\x90\x92\x16\x91\x90\x91\x17\x17\x81Ua\x15\xE2\x84\x84\x84aS\\V[a-\xAEa15V[`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\r` R`@\x90 \x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF``\x1B\x19\x16`\x01``\x1B`\x01`\x01`@\x1B\x03\x84\x16\x02\x17\x90Ua\x13\x1E\x82\x82aS\xEEV[a-\xFAa15V[\x80``\x1Ba.\x0FWctH\xFB\xAE_R`\x04`\x1C\xFD[a\x12\xF0\x81aA\xDBV[a. a15V[`\x03\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x83\x16\x17\x90Ua\x12\xF0\x81aT\x87V[___a.Oa2\x9EV[`\x03T`@Qc\t9\xB3\xF3`\xE3\x1B\x81R_\x91`\x01`\x01`\xA0\x1B\x03\x16\x90cI\xCD\x9F\x98\x90a.\x89\x90\x8D\x90\x8D\x90\x8D\x90\x8D\x90\x8D\x90\x8D\x90`\x04\x01aq\x03V[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a.\xA3W=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra.\xCA\x91\x90\x81\x01\x90aq\xC7V[\x80Q_\x81\x81R`\x1D` R`@\x90 T\x91\x92P\x90`\xFF\x16\x15a.\xFFW`@Qc\x1B\xEBq\x05`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x1D_\x83\x81R` \x01\x90\x81R` \x01_ _a\x01\0\n\x81T\x81`\xFF\x02\x19\x16\x90\x83\x15\x15\x02\x17\x90UP_`\x05_\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xA0\x1B\x03\x16\x90P_a/Z\x8E\x85`\x80\x01Q\x86``\x01Q\x87`\xA0\x01Q\x86aT\xF9V[\x90Pa/k\x8E\x83\x86`@\x01QaU\xB1V[a/\x7F\x8E\x85`@\x01Qc\xFF\xFF\xFF\xFF\x16aV\x18V[\x95P\x85_\x03a/\xA1W`@Qc%\x03\xBB3`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a/\xAB\x87a3KV[\x90P\x81\x81`\x04\x01_\x82\x82Ta/\xC0\x91\x90as\xCEV[\x92PP\x81\x90UP\x81\x81`\x06\x01_\x82\x82Ta/\xDA\x91\x90as\xCEV[\x90\x91UPa/\xEA\x90P\x81\x83aO\xB9V[\x95Pa/\xF6\x82\x87aV\xCCV[_\x84\x81R`\x1E` R`@\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x16\x15a0\xCDW\x80T`\x01\x82\x01T`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90_\x90\x8A\x14\x80\x15a09WP\x84\x83`\x02\x01T\x14[`\x03\x80\x85\x01T_\x8A\x81R`\x1E` R`@\x81 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x81U`\x01\x81\x01\x82\x90U`\x02\x81\x01\x82\x90U\x92\x83\x01\x81\x90U`\x04\x90\x92\x01\x91\x90\x91U\x90\x91P\x81\x15a0\xB3W\x89\x15a0\xB3W`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x11` R`@\x81 \x80T\x8C\x92\x90a0\xAD\x90\x84\x90as\xCEV[\x90\x91UPP[\x81\x15a0\xC9W\x9APa1(\x97PPPPPPPPV[PPP[\x86\x15a1!W`\x08\x82\x01T`\x07\x83\x01\x80T`\t\x85\x01T\x91\x92_\x92a1\x02\x92`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x92\x8D\x92\x8F\x92\x91\x16aP'V[\x80\x92P\x81\x9CPPPa1\x1E\x8A\x82\x84\x8E\x8D\x8C\x8E`@\x01Q\x8CaV\xE2V[PP[PPPPPP[\x97P\x97P\x97\x94PPPPPV[c\x8Bx\xC6\xD8\x19T3\x14a\x15\xF8Wc\x82\xB4)\0_R`\x04`\x1C\xFD[`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a1iWa\x1F\xF6\x83\x83\x83aWgV[a\x1F\xF6\x82\x82aW\xB1V[\x81_\x03a1~WPPV[\x81`\x10_\x82\x82Ta1\x8F\x91\x90as\xE1V[\x90\x91UPP`\x10Ta\x13\x1E\x90\x83\x83aW\xCAV[\x81\x7F\xC8\xB7\xFE$\xDC.\x9Es\x11A\xFE\x1D\xD7Ml\xE4p\xBDkSq\xC1/B\xC9\xCEF\xBA\xC1T$\xC5\x82`@Qa1\xD6\x91\x15\x15\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2a\x13\x1E\x7F\xC8\xB7\xFE$\xDC.\x9Es\x11A\xFE\x1D\xD7Ml\xE4p\xBDkSq\xC1/B\xC9\xCEF\xBA\xC1T$\xC5\x83\x83`@Q` \x01a2 \x92\x91\x90\x91\x82R\x15\x15` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@RaX>V[`@Q\x81\x81R\x7F\xF7\xCF\xAE\x98p\xE10z\x07\x91\xD6A\x8D\x9Ex\xAB\xD1s\x1A\x1C\x03`h\x13\x90kGM0~\xADV\x90` \x01`@Q\x80\x91\x03\x90\xA1a\x12\xF0\x7F\xF7\xCF\xAE\x98p\xE10z\x07\x91\xD6A\x8D\x9Ex\xAB\xD1s\x1A\x1C\x03`h\x13\x90kGM0~\xADV\x82`@Q` \x01a2 \x91\x81R` \x01\x90V[_T`\xFF\x16\x15a\x15\xF8W`@Qc\xD9<\x06e`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81`\x01`\x01`\xA0\x1B\x03\x16\x7FD(.*K\xBB\x86\xB9\xF8\x08\x9D\x10\x86\xF4\xE0\xDF'0T\xEA\xB6,\xDB\xDA\x18\xF6G\xCF\xD2*\x1E\xFF\x82`@Qa2\xFC\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R\x90\x81\x01\x82\x90Ra\x13\x1E\x90\x7FD(.*K\xBB\x86\xB9\xF8\x08\x9D\x10\x86\xF4\xE0\xDF'0T\xEA\xB6,\xDB\xDA\x18\xF6G\xCF\xD2*\x1E\xFF\x90``\x01a2 V[_\x81\x81R`\x08` R`@\x81 `\x01\x81\x01T\x80\x83\x03a3|W`@Qb\x90\xED=`\xE6\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81T_\x90\x81R`\x07` R`@\x90 a3\x96`\x01\x83ao\x82V[\x81T\x81\x10a3\xA6Wa3\xA6ao\x95V[\x90_R` _ \x90`\n\x02\x01\x92PPP\x91\x90PV[`\x0C\x80Tc\xFF\xFF\xFF\xFF`\x01` \x1B\x82\x04\x81\x16\x91`\x01`@\x1B\x90\x04\x16\x81\x15\x80a3\xE1WP\x80\x15[\x15a3\xECWPPPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`\x0F` R`@\x90 \x80TB\x91\x90\x84\x81\x10a4\x88W_\x82a4\x1B\x87\x84ao\x82V[\x81T\x81\x10a4+Wa4+ao\x95V[_\x91\x82R` \x90\x91 `\x04\x82\x04\x01T`\x03\x90\x91\x16`\x08\x02a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16\x90Pa4]\x85\x82as\xCEV[\x84`\x01`\x01`@\x1B\x03\x16\x10\x15a4\x86W`@Qc\x02\xA0\xEC!`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[P[P\x80T`\x01\x81\x01\x82U_\x91\x82R` \x90\x91 `\x04\x82\x04\x01\x80T`\x03\x90\x92\x16`\x08\x02a\x01\0\n`\x01`\x01`@\x1B\x03\x81\x81\x02\x19\x90\x93\x16\x93\x90\x92\x16\x91\x90\x91\x02\x91\x90\x91\x17\x90UPPPPV[_\x82\x81R`\x14` R`@\x90 T`\xFF\x16\x15a4\xFFW`@Qc\xD9%\x9C\xA9`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16a5&W`@Qc\x85b\xEBE`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x04T`\x01`\x01`\xA0\x1B\x03\x82\x81\x16\x91\x16\x14\x80\x15\x90F\x84\x14\x15\x90a5zW`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x12` R`@\x81 T\x90\x03a5zW`@Qc\x04~?\xE7`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x80\x15a\x15\xE2W`\x01`\x01`\xA0\x1B\x03\x83\x81\x16_\x90\x81R`\x13` \x90\x81R`@\x80\x83 \x88\x84R\x90\x91R\x90 T\x16a\x15\xE2W`@Qc\xB3|y\xED`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@\x80Q\x84\x81R`\x01`\x01`\xA0\x1B\x03\x84\x81\x16` \x83\x01R\x83\x16\x81\x83\x01R\x90Q\x85\x91\x7F\xD7\xCFu\xDC\x192\x07\xF6HK{\xD6\xC4\xFCF\x9F;ks=,\xBC\xEE@9u({\x01]\xC4\x99\x91\x90\x81\x90\x03``\x01\x90\xA2`@\x80Q` \x81\x01\x86\x90R\x90\x81\x01\x84\x90R`\x01`\x01`\xA0\x1B\x03\x80\x84\x16``\x83\x01R\x82\x16`\x80\x82\x01Ra\x15\xE2\x90\x7F\xD7\xCFu\xDC\x192\x07\xF6HK{\xD6\xC4\xFCF\x9F;ks=,\xBC\xEE@9u({\x01]\xC4\x99\x90`\xA0\x01a2 V[_\x84\x81R`\x1F` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x87\x16\x84R\x90\x91R\x90 T`\x01`\x01`@\x1B\x03\x90\x81\x16\x90\x82\x16\x81\x10\x15a6\xD7W_\x85\x81R`\x1F` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x88\x16\x84R\x90\x91R\x90 \x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`@\x1B\x03\x84\x16\x17\x90U[\x82_\x03a6\xE4WPa\x15\xE2V[`\x05T\x83\x90`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x90\x86\x16\x03a7\xF7W_\x86\x81R`\t` R`@\x81 \x80T\x90\x91[\x81\x81\x10\x80\x15a7\x1CWP\x83\x15\x15[\x15a7\xF3W_\x89\x81R`\x07` R`@\x81 \x80T\x83\x90\x81\x10a7@Wa7@ao\x95V[\x90_R` _ \x90`\n\x02\x01\x90P\x86`\x01`\x01`@\x1B\x03\x16\x81`\x02\x01`\x14\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x16\x11\x15a7\x85WPa7\xF3V[`\x06\x81\x01T_\x81\x90\x03a7\x99WPPa7\xE3V[_\x81\x87\x10a7\xA7W\x81a7\xA9V[\x86[\x90P\x80\x83`\x05\x01_\x82\x82Ta7\xBE\x91\x90as\xCEV[\x90\x91UPa7\xCE\x90P\x81\x83ao\x82V[`\x06\x84\x01Ua7\xDD\x81\x88ao\x82V[\x96PPPP[a7\xEC\x81ar\xB8V[\x90Pa7\x0EV[PPP[\x80\x15a8\x9BW_a8\x08\x87\x85aV\x18V[\x90P\x80_\x03a8,Wa8$a8\x1D\x83a9\xA2V[`\x03a1sV[PPPa\x15\xE2V[_a86\x82a3KV[\x90P\x82\x81`\x04\x01_\x82\x82Ta8K\x91\x90as\xCEV[\x92PP\x81\x90UP\x82\x81`\x05\x01_\x82\x82Ta8e\x91\x90as\xCEV[\x90\x91UP_\x90Pa8v\x82\x85aO\xB9V[\x90Pa8\x82\x84\x82aV\xCCV[\x80\x15a8\x97Wa8\x97\x83\x83\x83\x8C\x8C\x8B\x8AaY\x0CV[PPP[PPPPPPV[a8\xABaY\xDBV[_\x80T`\xFF\x19\x16\x90U\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA3[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01`@Q\x80\x91\x03\x90\xA1V[`@Qc\xFF\xFF\xFF\xFF\x82\x16\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90\x7F\xB1\xD8\xEF\xF9HX\x16\xBB8\xCE\xEC\xF3\x17\xA3\xFD\xA0U\x97\xBC[8\xF2\xF2-\xF9l\x0E\xBD]\xC26\xEE\x90` \x01`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01Rc\xFF\xFF\xFF\xFF\x83\x16\x91\x81\x01\x91\x90\x91Ra\x13\x1E\x90\x7F\xB1\xD8\xEF\xF9HX\x16\xBB8\xCE\xEC\xF3\x17\xA3\xFD\xA0U\x97\xBC[8\xF2\xF2-\xF9l\x0E\xBD]\xC26\xEE\x90``\x01a2 V[`\x01`\x01`\xA0\x1B\x03\x84\x16\x15a\x15\xE2Wa\x15\xE2\x84\x84\x84\x84aY\xFDV[_`\x01`\x01`\xFF\x1B\x03\x82\x11\x15a9\xCBW`@Qc\x05\x99\xF7\x1D`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[P\x90V[_`\x01`\x01`\xA0\x1B\x03\x83\x16a9\xEFWP`\x01`\x01`\xA0\x1B\x03\x81\x161a\x16\x05V[`@Qcp\xA0\x821`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x81\x16`\x04\x83\x01R\x84\x16\x90cp\xA0\x821\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a:3W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a:W\x91\x90at\x08V[\x93\x92PPPV[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\x9F^\x1D\x13\x04]'/\xBEt\xCEM\x08\xE9\x19\x82\xA5\xC5w\x849\x1A\xE6\xA1\x99\xEE\xCD\xCFc\x94\x9F\xFE\x90_\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x83\x16` \x82\x01Ra\x12\xF0\x91\x7F\x9F^\x1D\x13\x04]'/\xBEt\xCEM\x08\xE9\x19\x82\xA5\xC5w\x849\x1A\xE6\xA1\x99\xEE\xCD\xCFc\x94\x9F\xFE\x91\x01a2 V[\x81\x84\x86\x7F\xDC\xA1k\n\xF6\xE1\x0F]\xFB}N\xA9\x10U\x95\x14\x19\xA0\xC8\xFF\xC5\x92Z\xCF\xFD\xC5*\x95\xFC\xC6q3\x86\x85`@Qa;\x04\x92\x91\x90at\x1FV[`@Q\x80\x91\x03\x90\xA4a\x15\xCF\x7F\xDC\xA1k\n\xF6\xE1\x0F]\xFB}N\xA9\x10U\x95\x14\x19\xA0\xC8\xFF\xC5\x92Z\xCF\xFD\xC5*\x95\xFC\xC6q3\x86\x86\x86\x86\x86`@Q` \x01a2 \x95\x94\x93\x92\x91\x90at7V[`@Q`\x01`\x01`@\x1B\x03\x82\x16\x81R\x7F(l\xD7\xC5x\x1Em\xF3v\xDA\xA5\x9A\xB2\x07\xE1\xA0\xB1\xEC\xE9_\xAF\xC2\x98\xF9\xABi\xA1\x88\xF4\x9F\xF2\xD5\x90` \x01`@Q\x80\x91\x03\x90\xA1`@\x80Q`\x01`\x01`@\x1B\x03\x83\x16` \x82\x01Ra\x12\xF0\x91\x7F(l\xD7\xC5x\x1Em\xF3v\xDA\xA5\x9A\xB2\x07\xE1\xA0\xB1\xEC\xE9_\xAF\xC2\x98\xF9\xABi\xA1\x88\xF4\x9F\xF2\xD5\x91\x01a2 V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16\x81R` \x81\x01\x83\x90R\x7Fh\xF6}\xE8\x9E\x96\xB1:>\xA0X\xAF_\xD4L\xC1%\xEF\xCE\xB5(H-S\x9C{C\xDB/\xAA\x06n\x91\x01`@Q\x80\x91\x03\x90\xA1`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R\x90\x81\x01\x82\x90Ra\x13\x1E\x90\x7Fh\xF6}\xE8\x9E\x96\xB1:>\xA0X\xAF_\xD4L\xC1%\xEF\xCE\xB5(H-S\x9C{C\xDB/\xAA\x06n\x90``\x01a2 V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F\xA4O)=\xFA\x92(\x91cE\xA6\x01b \xF3\x04\xFDN\x10\xC2\xF2^\xF6,\x89kIF\x92jp\xF4\x90_\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x83\x16` \x82\x01Ra\x12\xF0\x91\x7F\xA4O)=\xFA\x92(\x91cE\xA6\x01b \xF3\x04\xFDN\x10\xC2\xF2^\xF6,\x89kIF\x92jp\xF4\x91\x01a2 V[`\x01`\x01`\xA0\x1B\x03\x16`A`\xA0\x1B\x17`X\x1B\x90V[_`\x04\x82Q\x10\x15a<\xF8W`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a=\x02\x83atlV[\x90Pcf\xD8\xA5e`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x82\x16\x01a=%Wa:W\x83aZVV[c\nm5\xE5`\xE3\x1B`\x01`\x01`\xE0\x1B\x03\x19\x82\x16\x01a=gWa:W\x83\x7F\x99'Z\x9B\x9A=\x95\x0C\xFE\r1\xA1\xD4\x83\x1Af\xA9\xCE\xBA}\x83o\x9BhT\xF0\xF1\xA7\xEBN\xAC\x1CaZ\x84V[`@Qc6[>S`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x80\x82\x81[\x81\x81\x10\x15a>\xF6W6\x86\x86\x83\x81\x81\x10a=\xA0Wa=\xA0ao\x95V[\x90P` \x02\x81\x01\x90a=\xB2\x91\x90at\xAAV[\x90Pa>2\x89a=\xC8``\x84\x01`@\x85\x01ag\xB8V[`\x01`\x01`@\x1B\x03\x16a=\xE1`\x80\x85\x01``\x86\x01ag\xB8V[`\x01`\x01`@\x1B\x03\x16\x845a=\xF9` \x87\x01\x87at\xC8V[\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPa[\x91\x92PPPV[`\x01\x90\x97\x01\x96`\x02\x89\x89a>L``\x85\x01`@\x86\x01ag\xB8V[`\x01`\x01`@\x1B\x03\x16a>e`\x80\x86\x01``\x87\x01ag\xB8V[`\x01`\x01`@\x1B\x03\x16\x855a>}` \x88\x01\x88at\xC8V[`@Q` \x01a>\x93\x97\x96\x95\x94\x93\x92\x91\x90au\nV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra>\xAD\x91auVV[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a>\xC8W=__>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a>\xEB\x91\x90at\x08V[\x98PP`\x01\x01a=\x85V[P\x95\x96\x94\x95PPPPPV[\x80_[\x81\x81\x10\x15a\x15\xE2W6\x84\x84\x83\x81\x81\x10a? Wa? ao\x95V[\x90P` \x02\x81\x01\x90a?2\x91\x90at\xAAV[\x90P`\x17`@Q\x80`\x80\x01`@R\x80\x83_\x015\x81R` \x01\x83\x80` \x01\x90a?Z\x91\x90at\xC8V[\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPPP\x90\x82RP` \x01a?\xA3``\x85\x01`@\x86\x01ag\xB8V[`\x01`\x01`@\x1B\x03\x16\x81R` \x01a?\xC1`\x80\x85\x01``\x86\x01ag\xB8V[`\x01`\x01`@\x1B\x03\x16\x90R\x81T`\x01\x81\x81\x01\x84U_\x93\x84R` \x93\x84\x90 \x83Q`\x03\x90\x93\x02\x01\x91\x82U\x92\x82\x01Q\x91\x92\x90\x91\x90\x82\x01\x90a@\0\x90\x82as\x14V[P`@\x82\x01Q`\x02\x90\x91\x01\x80T``\x90\x93\x01Q`\x01`\x01`@\x1B\x03\x90\x81\x16`\x01`@\x1B\x02`\x01`\x01`\x80\x1B\x03\x19\x90\x94\x16\x92\x16\x91\x90\x91\x17\x91\x90\x91\x17\x90UP`\x01\x01a?\x05V[\x81`\x01`\x01`\xA0\x1B\x03\x16\x7F\n\xA8&&\xF1\x9B\xB5\xD4\x19b\x02\xB0\x1F/\xEEC\x1B\x95\xE8\x8C\xB0THK\x98}e\r\x91\x92\x8A\xDA\x82`@Qa@\x80\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R\x90\x81\x01\x82\x90Ra\x13\x1E\x90\x7F\n\xA8&&\xF1\x9B\xB5\xD4\x19b\x02\xB0\x1F/\xEEC\x1B\x95\xE8\x8C\xB0THK\x98}e\r\x91\x92\x8A\xDA\x90``\x01a2 V[`@\x80Q\x83\x81R` \x81\x01\x83\x90R\x7F\xABc\xC2Z\xA0zM\x10\xA1\x84-a\x02j\x08\xD9Q\x15\xC4\xE6\x89R\x88h0\x15\xCADd\xC7\xF5\x0F\x91\x01`@Q\x80\x91\x03\x90\xA1a\x13\x1E\x7F\xABc\xC2Z\xA0zM\x10\xA1\x84-a\x02j\x08\xD9Q\x15\xC4\xE6\x89R\x88h0\x15\xCADd\xC7\xF5\x0F\x83\x83`@Q` \x01a2 \x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x81\x16\x82R\x83\x91\x90\x85\x16\x90\x7FB}\xB4\x8F\x8C\xD0\xCF\x7F\xDA\xBC\xDB\xC12|}\xB2l\xE3\xA5D)+\xA3\x80\xEF\x07\xD5\x17Z\xF7)\xCD\x90` \x01`@Q\x80\x91\x03\x90\xA3`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x86\x16` \x83\x01R\x91\x81\x01\x84\x90R\x90\x82\x16``\x82\x01Ra\x1F\xF6\x90\x7FB}\xB4\x8F\x8C\xD0\xCF\x7F\xDA\xBC\xDB\xC12|}\xB2l\xE3\xA5D)+\xA3\x80\xEF\x07\xD5\x17Z\xF7)\xCD\x90`\x80\x01a2 V[c\x8Bx\xC6\xD8\x19T`\x01`\x01`\xA0\x1B\x03\x90\x91\x16c\x8Bx\xC6\xD8\x19\x81\x90U\x90a\x13\x1E\x81\x83a\\\x0BV[`\x01`\x01`\xA0\x1B\x03\x86\x16_\x90\x81R`\n` R`@\x90 T`\xFF\x16aB9W`@QcE\x14!\xBD`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aBB\x86a\\\x97V[_aBL\x87a]wV[\x90P\x80\x84c\xFF\xFF\xFF\xFF\x16\x10\x80aBjWPb\x0FB@\x84c\xFF\xFF\xFF\xFF\x16\x11[\x15aB\x88W`@QcJU\x94k`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_aB\x92\x88a]\xB1V[\x90P\x80\x84`\x01`\x01`@\x1B\x03\x16\x10\x15aB\xBEW`@Qc&%\xB7\x81`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x83\x81R`\x14` R`@\x90 T`\xFF\x16\x15aB\xEDW`@Qc\xD9%\x9C\xA9`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[B`\x01`\x01`@\x1B\x03\x80\x82\x16\x90\x88\x16\x10\x15aC\x1BW`@QcP\x1D\x13\xED`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_aC%\x8AaIhV[\x90P\x80\x15aCiW_aCD`\x01`\x01`@\x1B\x03\x80\x85\x16\x90\x8B\x16ao\x82V[\x90P\x81\x81\x11\x15aCgW`@Qc*\xB8LG`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[P[_\x89\x81R`\t` R`@\x90 \x80T\x15a'VW_\x8A\x81R`\x07` R`@\x81 \x82TaC\x98\x90`\x01\x90ao\x82V[\x81T\x81\x10aC\xA8WaC\xA8ao\x95V[_\x91\x82R` \x90\x91 `\n\x90\x91\x02\x01`\x03\x81\x01T\x90\x91P`\x01`\x01`@\x1B\x03\x16B\x10\x15aC\xE8W`@Qc\xB4\xED\x1C5`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPPPPPPPPPPPV[_\x8A\x81R`\x07` \x90\x81R`@\x91\x82\x90 T\x82Q\x80\x84\x01\x90\x93R\x8C\x83R\x91\x90\x81\x01aD\"\x83`\x01as\xCEV[\x81RP`\x08_\x8E\x81R` \x01\x90\x81R` \x01_ _\x82\x01Q\x81_\x01U` \x82\x01Q\x81`\x01\x01U\x90PP`\x07_\x8C\x81R` \x01\x90\x81R` \x01_ `@Q\x80a\x01`\x01`@R\x80\x8D\x81R` \x01\x8C`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x8B`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x8A`\x01`\x01`@\x1B\x03\x16\x81R` \x01\x89`\x01`\x01`@\x1B\x03\x16\x81R` \x01\x88c\xFF\xFF\xFF\xFF\x16\x81R` \x01\x87`\x01`\x01`@\x1B\x03\x16\x81R` \x01_\x81R` \x01_\x81R` \x01_\x81R` \x01`@Q\x80``\x01`@R\x80\x88\x81R` \x01\x87`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x86`\x01`\x01`\xA0\x1B\x03\x16\x81RP\x81RP\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x90`\n\x02\x01_\x90\x91\x90\x91\x90\x91P_\x82\x01Q\x81_\x01U` \x82\x01Q\x81`\x01\x01_a\x01\0\n\x81T\x81`\x01`\x01`\xA0\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`\xA0\x1B\x03\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x02\x01_a\x01\0\n\x81T\x81`\x01`\x01`\xA0\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`\xA0\x1B\x03\x16\x02\x17\x90UP``\x82\x01Q\x81`\x02\x01`\x14a\x01\0\n\x81T\x81`\x01`\x01`@\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`@\x1B\x03\x16\x02\x17\x90UP`\x80\x82\x01Q\x81`\x03\x01_a\x01\0\n\x81T\x81`\x01`\x01`@\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`@\x1B\x03\x16\x02\x17\x90UP`\xA0\x82\x01Q\x81`\x03\x01`\x08a\x01\0\n\x81T\x81c\xFF\xFF\xFF\xFF\x02\x19\x16\x90\x83c\xFF\xFF\xFF\xFF\x16\x02\x17\x90UP`\xC0\x82\x01Q\x81`\x03\x01`\x0Ca\x01\0\n\x81T\x81`\x01`\x01`@\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`@\x1B\x03\x16\x02\x17\x90UP`\xE0\x82\x01Q\x81`\x04\x01Ua\x01\0\x82\x01Q\x81`\x05\x01Ua\x01 \x82\x01Q\x81`\x06\x01Ua\x01@\x82\x01Q\x81`\x07\x01_\x82\x01Q\x81_\x01U` \x82\x01Q\x81`\x01\x01_a\x01\0\n\x81T\x81`\x01`\x01`\xA0\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`\xA0\x1B\x03\x16\x02\x17\x90UP`@\x82\x01Q\x81`\x02\x01_a\x01\0\n\x81T\x81`\x01`\x01`\xA0\x1B\x03\x02\x19\x16\x90\x83`\x01`\x01`\xA0\x1B\x03\x16\x02\x17\x90UPPPPP`\t_\x8C\x81R` \x01\x90\x81R` \x01_ \x8C\x90\x80`\x01\x81T\x01\x80\x82U\x80\x91PP`\x01\x90\x03\x90_R` _ \x01_\x90\x91\x90\x91\x90\x91PU\x9B\x9APPPPPPPPPPPV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x88\x81\x16\x82R\x87\x16` \x82\x01R`\x01`\x01`@\x1B\x03\x86\x81\x16\x82\x84\x01R\x85\x81\x16``\x83\x01Rc\xFF\xFF\xFF\xFF\x85\x16`\x80\x83\x01R\x83\x16`\xA0\x82\x01R\x90Q\x88\x91\x8A\x91\x8C\x91\x7F\xE41P+\xD0\xDFX\x809~\xC1<\n&\x0F\x0Ct\x9C\x8F:0\xC6\xCA\xF3\xFF\xE0\xF0\x8A.\xD19B\x91\x90\x81\x90\x03`\xC0\x01\x90\xA4`@\x80Q` \x81\x01\x8B\x90R\x90\x81\x01\x89\x90R``\x81\x01\x88\x90R`\x01`\x01`\xA0\x1B\x03\x80\x88\x16`\x80\x83\x01R\x86\x16`\xA0\x82\x01R`\x01`\x01`@\x1B\x03\x80\x86\x16`\xC0\x83\x01R\x80\x85\x16`\xE0\x83\x01Rc\xFF\xFF\xFF\xFF\x84\x16a\x01\0\x83\x01R\x82\x16a\x01 \x82\x01Ra8\x97\x90\x7F\xE41P+\xD0\xDFX\x809~\xC1<\n&\x0F\x0Ct\x9C\x8F:0\xC6\xCA\xF3\xFF\xE0\xF0\x8A.\xD19B\x90a\x01@\x01a2 V[aH\x14a2\x9EV[_\x80T`\xFF\x19\x16`\x01\x17\x90U\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2Xa8\xD73\x90V[\x81`\x01`\x01`\xA0\x1B\x03\x16\x7FD/z\xB7\xD2k\xF7\xBAt\xF2>#}\x12\x87bQ\xF9\x1Da\xAE\xB2\x89\x9A\xD9_3O\xA5\xE7\xC63\x82`@QaH\x85\x91\x15\x15\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R\x82\x15\x15\x91\x81\x01\x91\x90\x91Ra\x13\x1E\x90\x7FD/z\xB7\xD2k\xF7\xBAt\xF2>#}\x12\x87bQ\xF9\x1Da\xAE\xB2\x89\x9A\xD9_3O\xA5\xE7\xC63\x90``\x01a2 V[\x81`\x01`\x01`\xA0\x1B\x03\x16\x7F \x80\xA7VDM*\xF0\xF9\xFBO\x87\xDBz\xF6<\xD6\xE2;z\x12\x03\xCB\xE9\xAB\tr\xEE\x05\xD1\xEA\xFD\x82`@QaI\x15\x91\x15\x15\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R\x82\x15\x15\x91\x81\x01\x91\x90\x91Ra\x13\x1E\x90\x7F \x80\xA7VDM*\xF0\xF9\xFBO\x87\xDBz\xF6<\xD6\xE2;z\x12\x03\xCB\xE9\xAB\tr\xEE\x05\xD1\xEA\xFD\x90``\x01a2 V[`\x0CT`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\r` R`@\x81 T\x90\x91c\xFF\xFF\xFF\xFF`\x01`\xA0\x1B\x91\x82\x90\x04\x81\x16\x92\x91\x90\x91\x04\x16\x81\x83\x03aI\xA9W\x93\x92PPPV[\x80_\x03aI\xB7WP\x92\x91PPV[\x81\x81\x10aI\xC4W\x81aI\xC6V[\x80[\x94\x93PPPPV[____aI\xDAa\x17\x0EV[\x90P\x86\x93P[\x87T\x84\x10\x80\x15aI\xF8WP\x85aI\xF6\x88\x86ao\x82V[\x10[\x15aJ\xE9W_\x88\x85\x81T\x81\x10aJ\x10WaJ\x10ao\x95V[\x90_R` _ \x90`\x05\x02\x01`\x01\x01T\x90P\x80\x82\x10\x15aJ0WPaJ\xE9V[aJ:\x81\x85as\xCEV[`\x04T\x90\x94P`\x01`\x01`\xA0\x1B\x03\x8B\x81\x16\x91\x16\x14aJ\xDCW_\x89\x86\x81T\x81\x10aJeWaJeao\x95V[\x90_R` _ \x90`\x05\x02\x01`\x03\x01T\x90PF\x81\x14aJ\xC0W`\x01`\x01`\xA0\x1B\x03\x8B\x81\x16_\x90\x81R`\x13` \x90\x81R`@\x80\x83 \x85\x84R\x90\x91R\x90 T\x16aJ\xC0W`@Qc\xB3|y\xED`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aJ\xCE\x82\x88b\x0FB@a]\xF6V[aJ\xD8\x90\x85as\xCEV[\x93PP[`\x01\x90\x94\x01\x93\x90\x03aI\xE0V[P\x95P\x95P\x95\x92PPPV[`\x04T_\x90aK.\x90`\x01`\x01`\xA0\x1B\x03\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x87a1OV[`@Qc\x8B\xCC\xC1\x87`\xE0\x1B\x81R_\x90`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\x8B\xCC\xC1\x87\x90aK\x84\x90\x87\x90\x87\x90\x8C\x90\x8B\x900\x90`\x04\x01auaV[` `@Q\x80\x83\x03\x81_\x87Z\xF1\x15\x80\x15aK\xA0W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aK\xC4\x91\x90at\x08V[\x90P\x84\x81\x11\x15aK\xDBWaK\xD8\x85\x82ao\x82V[\x91P[P\x95\x94PPPPPV[\x81[\x81\x81\x10\x15a8\x9BW_\x84\x82\x81T\x81\x10aL\x02WaL\x02ao\x95V[_\x91\x82R` \x91\x82\x90 `@\x80Q`\xA0\x81\x01\x82R`\x05\x90\x93\x02\x90\x91\x01\x80T\x83R`\x01\x81\x01T\x93\x83\x01\x84\x90R`\x02\x81\x01T\x91\x83\x01\x91\x90\x91R`\x03\x81\x01T``\x83\x01R`\x04\x01T`\x01`\x01`\xA0\x1B\x03\x16`\x80\x82\x01R\x86T\x90\x92P\x86\x90\x84\x90\x81\x10aLlWaLlao\x95V[_\x91\x82R` \x80\x83 `\x05\x90\x92\x02\x90\x91\x01\x82\x81U`\x01\x80\x82\x01\x84\x90U`\x02\x82\x01\x84\x90U`\x03\x82\x01\x84\x90U`\x04\x91\x82\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x16\x90\x91U`@\x80\x88\x01Q\x86R`\x1C\x85R\x80\x86 \x88Q\x87R\x90\x94R\x92\x84 \x80T\x90\x93\x16\x83U\x91\x90\x91\x01\x82\x90UT`\x01`\x01`\xA0\x1B\x03\x8A\x81\x16\x91\x16\x14aL\xF9WaL\xF4\x82\x89b\x0FB@a]\xF6V[aL\xFBV[\x81[\x90P\x80\x15aM\xEDWF\x83``\x01Q\x14aM\xDEW`\x01`\x01`\xA0\x1B\x03\x80\x8A\x16_\x90\x81R`\x13` \x90\x81R`@\x80\x83 ``\x88\x01Q\x84R\x90\x91R\x90 T\x16\x80aMUW`@Qc\xB3|y\xED`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[aM`\x8A\x82\x84a1OV[``\x84\x01Q`\x80\x85\x01Q`@Qc/,\x1D-`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x8D\x81\x16`\x04\x83\x01R`$\x82\x01\x86\x90R`D\x82\x01\x93\x90\x93R\x90\x82\x16`d\x82\x01R\x90\x82\x16\x90c^X:Z\x90`\x84\x01_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15aM\xC2W__\xFD[PZ\xF1\x15\x80\x15aM\xD4W=__>=_\xFD[PPPPPaM\xEDV[aM\xED\x89\x84`\x80\x01Q\x83a1OV[aN\x0B\x83`@\x01Q\x84_\x01Q\x8B\x87\x86\x88``\x01Q\x89`\x80\x01Qa^\x02V[PPP\x80`\x01\x01\x90PaK\xE7V[__\x7F\x10J\xC0\xAD\x95\xE4C\x03\xBC\xFB\r\x0EV\x8A\xC4\x9A\xB6f\xCA\x92\xAFe\r\x9F\xA3V\xAD\x9C\x0FI\xDB\xA2\x90P_`@Q\x82\x81R\x89` \x82\x01R\x88`@\x82\x01R\x87``\x82\x01R\x86`\x80\x82\x01R\x85`\xA0\x82\x01R\x84`\xC0\x82\x01R`\xE0\x81 \x91P`\xE0\x81\x01`@RPaN\x80\x81a^\xD3V[\x99\x98PPPPPPPPPV[_aN\xD9\x84\x84\x84\x80\x80`\x1F\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847_\x92\x01\x91\x90\x91RPP`\x01`\x01`\xA0\x1B\x03\x8A\x16\x93\x92\x91PPa_\xE9V[\x90P\x80a\x15\xCFW`@Qc\x8B\xAAW\x9F`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x82\x81R` \x80R`@\x90 `\x01\x80\x83\x01\x90\x91Ua\x13\x1E\x90\x83\x90aO\x1E\x90\x84\x90as\xCEV[a`\xC6V[`@Q\x80``\x01`@R\x80\x82_\x015\x81R` \x01\x82` \x01` \x81\x01\x90aOJ\x91\x90af\xB3V[`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01aOh``\x84\x01`@\x85\x01af\xB3V[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x90\x91R\x81Q`\x07\x85\x01U` \x82\x01Q`\x08\x85\x01\x80T\x91\x83\x16`\x01`\x01`\xA0\x1B\x03\x19\x92\x83\x16\x17\x90U`@\x90\x92\x01Q`\t\x90\x94\x01\x80T\x94\x90\x91\x16\x93\x90\x91\x16\x92\x90\x92\x17\x90\x91UPV[`\x03\x82\x01T_\x90`\x01`@\x1B\x90\x04c\xFF\xFF\xFF\xFF\x16\x81b\x0FB@aO\xDC\x83\x82ao\x82V[aO\xE6\x90\x86av>V[aO\xF0\x91\x90aviV[`\x03\x86\x01T\x90\x91P`\x01``\x1B\x90\x04`\x01`\x01`@\x1B\x03\x16\x80\x82\x11\x15aP\x1AW\x80\x82\x03\x93PaP\x1EV[_\x93P[PPP\x92\x91PPV[_\x83\x81R`\x1B` R`@\x81 \x80T\x82\x91\x82aPB\x83ar\xB8V[\x90\x91UP`\x01`\x01`\xA0\x1B\x03\x88\x81\x16_\x90\x81R`\x19` \x90\x81R`@\x80\x83 \x81Q`\xA0\x81\x01\x83R\x86\x81R\x80\x84\x01\x8D\x81R\x92\x81\x01\x8C\x81R``\x82\x01\x8C\x81R\x8B\x88\x16`\x80\x84\x01\x90\x81R\x84T`\x01\x80\x82\x01\x87U\x86\x8AR\x97\x90\x98 \x93Q`\x05\x90\x98\x02\x90\x93\x01\x96\x87U\x93Q\x86\x86\x01UQ`\x02\x86\x01U\x91Q`\x03\x85\x01U\x90Q`\x04\x90\x93\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x93\x90\x94\x16\x92\x90\x92\x17\x90\x92U\x80T\x92\x93P\x91aP\xE7\x91\x90ao\x82V[`@\x80Q\x80\x82\x01\x82R`\x01`\x01`\xA0\x1B\x03\x8B\x81\x16\x82R` \x80\x83\x01\x85\x81R_\x8C\x81R`\x1C\x83R\x85\x81 \x89\x82R\x90\x92R\x93\x90 \x91Q\x82T`\x01`\x01`\xA0\x1B\x03\x19\x16\x91\x16\x17\x81U\x90Q`\x01\x90\x91\x01U\x92PP[\x95P\x95\x93PPPPV[`@\x80Qa\x01\xA0\x81\x01\x82R\x89\x81R` \x81\x01\x89\x90R`\x01\x88\x01T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x82\x01\x92\x90\x92R``\x81\x01\x87\x90R`\x80\x81\x01\x86\x90R\x87T`\xA0\x82\x01R`\x02\x88\x01T\x90\x91\x16`\xC0\x82\x01RaQ\xC9\x90`\xE0\x81\x01_\x81R` \x81\x01\x86\x90R`\x01`\x01`\xA0\x1B\x03\x85\x16`@\x82\x01R_``\x82\x01\x81\x90R`\x80\x82\x01R`\xA0\x01\x83\x90Raa@V[PPPPPPPPV[\x81`\x01`\x01`\xA0\x1B\x03\x16\x7F\xDA\xE4A|%\xA9<\xFB\x86\xCE_\xBB\xB8\xFC\x160\x94[a\xAF\xAE\xABO)\xCF0\x1B\x9A\x05\x8B\xA9\x14\x82`@QaR\x0E\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R\x90\x81\x01\x82\x90Ra\x13\x1E\x90\x7F\xDA\xE4A|%\xA9<\xFB\x86\xCE_\xBB\xB8\xFC\x160\x94[a\xAF\xAE\xABO)\xCF0\x1B\x9A\x05\x8B\xA9\x14\x90``\x01a2 V[\x81`\x01`\x01`\xA0\x1B\x03\x16\x7F\xA8\xD3\xB3!;\x7F\x82D\xE5\xB0EQ\xDB\x9A\xAA\xBC\xCC!\xD6!,C\xC3\xB3\x14;\xCD\xE9|\xA8S\xCE\x82`@QaR\x98\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R\x90\x81\x01\x82\x90Ra\x13\x1E\x90\x7F\xA8\xD3\xB3!;\x7F\x82D\xE5\xB0EQ\xDB\x9A\xAA\xBC\xCC!\xD6!,C\xC3\xB3\x14;\xCD\xE9|\xA8S\xCE\x90``\x01a2 V[`@Qc\xFF\xFF\xFF\xFF\x82\x16\x81R\x7F\x1F\xB3\xB3\x8E@ \t\xF1\xBB\xD2M\np\0Zz\x9A\x05[?[Tl\x8B!\xF8\x15G\n\x9C.\xC4\x90` \x01`@Q\x80\x91\x03\x90\xA1`@\x80Qc\xFF\xFF\xFF\xFF\x83\x16` \x82\x01Ra\x12\xF0\x91\x7F\x1F\xB3\xB3\x8E@ \t\xF1\xBB\xD2M\np\0Zz\x9A\x05[?[Tl\x8B!\xF8\x15G\n\x9C.\xC4\x91\x01a2 V[`@\x80Q\x83\x81R` \x81\x01\x83\x90R`\x01`\x01`\xA0\x1B\x03\x85\x16\x91\x7Fa\xC4\x9A\xB6\xBB\x1E\xF5\x91\x91\xA7F\xAF\xCE}'1\xD4\xD9\xB0\xFA\xFD\xAB\x8Dc\xF0/\xE4AiS-\xC5\x91\x01`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x85\x16` \x82\x01R\x90\x81\x01\x83\x90R``\x81\x01\x82\x90Ra\x1F\xF6\x90\x7Fa\xC4\x9A\xB6\xBB\x1E\xF5\x91\x91\xA7F\xAF\xCE}'1\xD4\xD9\xB0\xFA\xFD\xAB\x8Dc\xF0/\xE4AiS-\xC5\x90`\x80\x01a2 V[`@Q`\x01`\x01`@\x1B\x03\x82\x16\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90\x7F/H\x171\x82B\xD1\xB8g\0\xA4&\xF7\xCE\xD0I\xC6\x80Y%<\nr\x1E\x01\xB9q\x8FE'\xBE\xF6\x90` \x01`@Q\x80\x91\x03\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x84\x16` \x82\x01R`\x01`\x01`@\x1B\x03\x83\x16\x91\x81\x01\x91\x90\x91Ra\x13\x1E\x90\x7F/H\x171\x82B\xD1\xB8g\0\xA4&\xF7\xCE\xD0I\xC6\x80Y%<\nr\x1E\x01\xB9q\x8FE'\xBE\xF6\x90``\x01a2 V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x90\x7F])i>c\xB3\xA0\x84\xE5h\x93\xCE\x8C\x7F^\xF5\xDC\x82\x13\xDAA\x07\0\x84\xE6\xB1\xC47\n\xBDd\xC4\x90_\x90\xA2`@\x80Q`\x01`\x01`\xA0\x1B\x03\x83\x16` \x82\x01Ra\x12\xF0\x91\x7F])i>c\xB3\xA0\x84\xE5h\x93\xCE\x8C\x7F^\xF5\xDC\x82\x13\xDAA\x07\0\x84\xE6\xB1\xC47\n\xBDd\xC4\x91\x01a2 V[_aU\x03\x82a<\xBFV[j\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x86\x81\x16\x91\x16\x14aU3W`@Qc3\x95v[`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_aU^\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x88a*QV[\x90P_aUj\x82a<\xBFV[\x90P__aUx\x87\x89aa\xF8V[\x92P\x92PP\x82`\x01`\x01`X\x1B\x03\x19\x16\x82`\x01`\x01`X\x1B\x03\x19\x16\x14aN\x80W`@Qc@e\x0E\xA9`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x83\x81R`\x1F` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 T`\x01`\x01`@\x1B\x03\x16\x80\x15\x80\x15\x90aU\xFAWP`\x01`\x01`@\x1B\x03\x81\x16c\xFF\xFF\xFF\xFF\x83\x16\x11\x15[\x15a\x15\xE2W`@Qc>l\x07\x11`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x82\x81R`\t` R`@\x81 \x80T\x80\x83\x03aV8W_\x92PPPa\x16\x05V[\x80[\x80\x15aP\x1EW_\x86\x81R`\x07` R`@\x81 \x80T_\x19\x90\x93\x01\x92\x83\x90\x81\x10aVeWaVeao\x95V[\x90_R` _ \x90`\n\x02\x01\x90P\x85`\x01`\x01`@\x1B\x03\x16\x81`\x02\x01`\x14\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x16\x11aV\xC6W\x83\x82\x81T\x81\x10aV\xB5WaV\xB5ao\x95V[\x90_R` _ \x01T\x94PPaP\x1EV[PaV:V[a\x13\x1EaV\xDCa\x1AR\x83\x85ao\x82V[_a1sV[`@\x80Qa\x01\xA0\x81\x01\x82R\x89\x81R` \x81\x01\x89\x90R`\x01\x80\x89\x01T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x93\x83\x01\x93\x90\x93R``\x82\x01\x88\x90R`\x80\x82\x01\x87\x90R\x88T`\xA0\x83\x01R`\x02\x89\x01T\x90\x92\x16`\xC0\x82\x01RaQ\xC9\x91`\xE0\x82\x01\x90\x81R` \x81\x01\x86\x90R_`@\x82\x01\x81\x90R``\x82\x01Rc\xFF\xFF\xFF\xFF\x85\x16`\x80\x82\x01R`\xA0\x01\x83\x90Raa@V[\x81`\x14R\x80`4Rc\xA9\x05\x9C\xBB``\x1B_R` _`D`\x10_\x87Z\xF1\x80`\x01_Q\x14\x16aW\xA7W\x80=\x85;\x15\x17\x10aW\xA7Wc\x90\xB8\xEC\x18_R`\x04`\x1C\xFD[P_`4RPPPV[_8_8\x84\x86Z\xF1a\x13\x1EWc\xB1-\x13\xEB_R`\x04`\x1C\xFD[\x7FC\x99\x1E\x1E\x1C\xFB.\xEDl\x9D\xC3zz\x84\x86\"\xF8\xE3\xF7[\xC3\x8DS*\0\xEA\xF0&\xCD\x87\xA0\x14\x83\x83\x83`@QaW\xFD\x93\x92\x91\x90av\x9CV[`@Q\x80\x91\x03\x90\xA1a\x1F\xF6\x7FC\x99\x1E\x1E\x1C\xFB.\xEDl\x9D\xC3zz\x84\x86\"\xF8\xE3\xF7[\xC3\x8DS*\0\xEA\xF0&\xCD\x87\xA0\x14\x84\x84\x84`@Q` \x01a2 \x93\x92\x91\x90av\x9CV[`\x02\x80T`\x01\x90\x81\x01\x80\x83U\x90T`@Q\x90\x92\x91aXi\x91\x84\x91\x90C\x90B\x90\x89\x90\x89\x90` \x01av\xC8V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90RaX\x83\x91auVV[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15aX\x9EW=__>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aX\xC1\x91\x90at\x08V[`\x01\x81\x90UP`\x01T\x81`\x02T\x7Fx\x16\x0F\x0B\x1B+2\xB5*\0v\xD8\xF0\xF7\x08\x88h{\xA7\x02\xA4\xD9\x93\xD5Z\xC8\xD92}W\xA1'\x86\x86`@QaX\xFF\x92\x91\x90at\x1FV[`@Q\x80\x91\x03\x90\xA4PPPV[`\x08\x86\x01T`\x07\x87\x01\x80T`\t\x89\x01T\x91\x92_\x92\x83\x92aY>\x92`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x8C\x92\x8F\x92\x90\x91\x16aP'V[`@\x80Qa\x01\xA0\x81\x01\x82R\x8D\x81R` \x81\x01\x83\x90R`\x01\x87\x01T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x92\x82\x01\x92\x90\x92R``\x81\x01\x84\x90R`\x80\x81\x01\x8C\x90R\x86T`\xA0\x82\x01R`\x02\x80\x88\x01T\x83\x16`\xC0\x83\x01R`\xE0\x82\x01Ra\x01\0\x81\x01\x8B\x90R_a\x01 \x82\x01R\x90\x89\x16a\x01@\x82\x01R`\x01`\x01`@\x1B\x03\x88\x16a\x01`\x82\x01Ra\x01\x80\x81\x01\x87\x90R\x91\x93P\x91PaY\xCF\x90aa@V[PPPPPPPPPPV[_T`\xFF\x16a\x15\xF8W`@Qc\x8D\xFC +`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@Q\x81``R\x82`@R\x83``\x1B`,Rc#\xB8r\xDD``\x1B`\x0CR` _`d`\x1C_\x89Z\xF1\x80`\x01_Q\x14\x16aZHW\x80=\x87;\x15\x17\x10aZHWcy9\xF4$_R`\x04`\x1C\xFD[P_``R`@RPPPPV[\x80Q_\x90`$\x81\x14aZ{W`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP`$\x01Q\x90V[\x81Q_\x90`$\x81\x10\x15aZ\xAAW`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`$\x84\x01Q_\x90aZ\xBC\x90`\x04as\xCEV[\x90P\x81aZ\xCA\x82` as\xCEV[\x11\x15aZ\xE9W`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_aZ\xF7\x86\x83\x01` \x01Q\x90V[\x90P_a[\x05\x83` as\xCEV[\x90P\x83a[\x13\x83` av>V[a[\x1D\x90\x83as\xCEV[\x11\x15a[<W`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_[\x82\x81\x10\x15a[wW__a[U\x8A\x85\x89\x86\x8Dab\xA6V[\x91P\x91P\x81\x15a[mW\x96Pa\x16\x05\x95PPPPPPV[PP`\x01\x01a[>V[P`@Qc\"\x86\xAC\xB9`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x81\x84\x7F\x9Da\x1B[4\xCBv\x13\x1CO\xB4\x13\xEBt\x11\x9B,\x0C:j\xA6\xFC\xD8\xE7@\xCFp\xAC0\x85\xD8{\x87\x86\x85`@Qa[\xC6\x93\x92\x91\x90av\xFDV[`@Q\x80\x91\x03\x90\xA3a\x15\xCF\x7F\x9Da\x1B[4\xCBv\x13\x1CO\xB4\x13\xEBt\x11\x9B,\x0C:j\xA6\xFC\xD8\xE7@\xCFp\xAC0\x85\xD8{\x86\x86\x86\x86\x86`@Q` \x01a2 \x95\x94\x93\x92\x91\x90at7V[\x80`\x01`\x01`\xA0\x1B\x03\x16\x82`\x01`\x01`\xA0\x1B\x03\x16\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0`@Q`@Q\x80\x91\x03\x90\xA3a\x13\x1E\x7F\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0\x83\x83`@Q` \x01a2 \x92\x91\x90`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x81R\x91\x16` \x82\x01R`@\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\r` R`@\x90 \x80Tc\xFF\xFF\xFF\xFF`\x01` \x1B\x82\x04\x81\x16\x91`\x01`@\x1B\x90\x04\x16\x81\x15\x80a\\\xD2WP\x80\x15[\x15a\\\xDDWPPPPV[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`\x0E` R`@\x90 \x80TB\x91\x90\x84\x81\x10a4\x88W_\x82a]\x0C\x87\x84ao\x82V[\x81T\x81\x10a]\x1CWa]\x1Cao\x95V[_\x91\x82R` \x90\x91 `\x04\x82\x04\x01T`\x03\x90\x91\x16`\x08\x02a\x01\0\n\x90\x04`\x01`\x01`@\x1B\x03\x16\x90Pa]N\x85\x82as\xCEV[\x84`\x01`\x01`@\x1B\x03\x16\x10\x15a4\x86W`@Qc\x13\x15\n\xB9`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x0CT`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\r` R`@\x81 T\x90\x91c\xFF\xFF\xFF\xFF\x90\x81\x16\x91\x16\x81\x81\x11\x15a]\xAAW\x80\x91P[P\x92\x91PPV[`\x0CT`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\r` R`@\x81 T\x90\x91`\x01`\x01`@\x1B\x03`\x01``\x1B\x91\x82\x90\x04\x81\x16\x92\x91\x90\x91\x04\x16\x81\x81\x11\x15a]\xAAW\x93\x92PPPV[_aI\xC6\x84\x84\x84ac\xDAV[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x87\x81\x16\x82R` \x82\x01\x87\x90R\x81\x83\x01\x86\x90R``\x82\x01\x85\x90R\x83\x16`\x80\x82\x01R\x90Q\x87\x91\x89\x91\x7F\xB6+No\x1E\xC5\x97\n)'Ntx5\xF4D\xA5\xCC\xD4\x80Ii\x8E\xFF\x9C\x9C\xFD\xCA.\x1A^\xAF\x91\x81\x90\x03`\xA0\x01\x90\xA3`@\x80Q` \x81\x01\x89\x90R\x90\x81\x01\x87\x90R`\x01`\x01`\xA0\x1B\x03\x80\x87\x16``\x83\x01R`\x80\x82\x01\x86\x90R`\xA0\x82\x01\x85\x90R`\xC0\x82\x01\x84\x90R\x82\x16`\xE0\x82\x01Ra^\xCA\x90\x7F\xB6+No\x1E\xC5\x97\n)'Ntx5\xF4D\xA5\xCC\xD4\x80Ii\x8E\xFF\x9C\x9C\xFD\xCA.\x1A^\xAF\x90a\x01\0\x01a2 V[PPPPPPPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x000\x14\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0F\x14\x16a_\xC6WP`@\x80Q\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x81R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x81\x01\x91\x90\x91RF``\x82\x01R0`\x80\x82\x01R`\xA0\x90 [g\x19\x01\0\0\0\0\0\0_R\x80`\x1AR\x81`:R`B`\x18 \x90P_`:R\x91\x90PV[_`\x01`\x01`\xA0\x1B\x03\x84\x16\x15a:WW`@Q\x84;a`~W\x82Q`@\x81\x14a`\x1AW`A\x81\x14a`;WPa`\xBEV[`@\x84\x01Q`\xFF\x81\x90\x1C`\x1B\x01` R`\x01`\x01`\xFF\x1B\x03\x16``Ra`NV[``\x84\x01Q_\x1A` R`@\x84\x01Q``R[P\x83_R` \x83\x01Q`@R` `\x01`\x80_`\x01Z\xFAQ\x80\x86\x18``\x1B=\x11\x92PP_``R\x80`@Ra`\xBEV[c\x16&\xBA~`\xE0\x1B\x80\x82R\x84`\x04\x83\x01R`$\x82\x01`@\x81R\x84Q` \x01\x80`D\x85\x01\x82\x88`\x04Z\xFA\x90P` \x82`D=\x01\x86\x8BZ\xFA\x91Q\x91\x16\x91\x14\x16\x91P[P\x93\x92PPPV[\x81\x7F\x8E\x98\xA0sD \xE5~\xF1\x02\xCA\xB0\xB1\xAF\x08\t\xA5\xBB\xAFO\xDE\x96o\xD1s\xC3\"I\x06D\xA5\xD0\x82`@Qa`\xF8\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA2a\x13\x1E\x7F\x8E\x98\xA0sD \xE5~\xF1\x02\xCA\xB0\xB1\xAF\x08\t\xA5\xBB\xAFO\xDE\x96o\xD1s\xC3\"I\x06D\xA5\xD0\x83\x83`@Q` \x01a2 \x92\x91\x90\x91\x82R` \x82\x01R`@\x01\x90V[` \x81\x01Q\x81Q`@\x80\x84\x01Q``\x85\x01Q`\x80\x86\x01Q`\xA0\x87\x01Q`\xC0\x88\x01Q`\xE0\x89\x01Qa\x01\0\x8A\x01Qa\x01 \x8B\x01Qa\x01@\x8C\x01Qa\x01`\x8D\x01Qa\x01\x80\x8E\x01Q\x9AQ\x7Fw$/\xBDW:\xF5\xA5\xF3Q\x8D\xA9&\0\xE9g\x95\xEB\xFF\xF9\x93`kO\xB5M\xEA-\xCD-\xFE\x85\x9Baa\xBB\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x92\x91aw8V[`@Q\x80\x91\x03\x90\xA3a\x12\xF0\x7Fw$/\xBDW:\xF5\xA5\xF3Q\x8D\xA9&\0\xE9g\x95\xEB\xFF\xF9\x93`kO\xB5M\xEA-\xCD-\xFE\x85\x82`@Q` \x01a2 \x91\x90aw\xB3V[___`\x04\x85Q\x10\x15ab\x1EW`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_ab(\x86atlV[\x90PcV\xFAcE`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x82\x16\x01abXWabK\x86ad\x8AV[\x86\x95P\x90\x93P\x91Pab\x9EV[c\xDCG\x8D#`\xE0\x1B`\x01`\x01`\xE0\x1B\x03\x19\x82\x16\x01ab\x85Waby\x86ad\xD2V[\x91\x95P\x93P\x91Pab\x9EV[`@Qc\t\x15\xB8{`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[P\x92P\x92P\x92V[_\x80\x80ab\xCA\x88ab\xB8\x87` av>V[ab\xC2\x90\x8Aas\xCEV[\x01` \x01Q\x90V[\x90P_ab\xD7\x82\x89as\xCEV[\x90P\x86ab\xE5\x82` as\xCEV[\x11\x15ac\x04W`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_ac\x12\x8A\x83\x01` \x01Q\x90V[\x90P`\x04\x81\x10\x15ac,WP_\x93P\x83\x92PaQ8\x91PPV[_ac8\x83` as\xCEV[\x90P_acE\x83\x83as\xCEV[\x90P\x89\x81\x11\x15achW`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[\x8B\x82\x01` \x01Q`\x01`\x01`\xE0\x1B\x03\x19\x80\x82\x16\x90\x8A\x16\x14ac\x95WP_\x96P\x86\x95PaQ8\x94PPPPPV[\x83`$\x14ac\xB6W`@Qc\x12y\x95\x03`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[ac\xC5\x8Dab\xC2\x85`\x04as\xCEV[`\x01\x9E\x90\x9DP\x9BPPPPPPPPPPPPV[___ac\xE7\x86\x86ae1V[\x91P\x91P\x81_\x03ad\x0BW\x83\x81\x81ad\x01Wad\x01avUV[\x04\x92PPPa:WV[\x81\x84\x11ad\"Wad\"`\x03\x85\x15\x02`\x11\x18aeMV[_\x84\x86\x88\t_\x86\x81\x03\x87\x16\x96\x87\x90\x04\x96`\x02`\x03\x89\x02\x81\x18\x80\x8A\x02\x82\x03\x02\x80\x8A\x02\x82\x03\x02\x80\x8A\x02\x82\x03\x02\x80\x8A\x02\x82\x03\x02\x80\x8A\x02\x82\x03\x02\x80\x8A\x02\x90\x91\x03\x02\x91\x81\x90\x03\x81\x90\x04`\x01\x01\x85\x84\x11\x90\x96\x03\x95\x90\x95\x02\x91\x90\x93\x03\x93\x90\x93\x04\x92\x90\x92\x17\x02\x91PP\x93\x92PPPV[\x80Q_\x90\x81\x90`D\x81\x14ad\xB1W`@Qc\x9A\xC6\x0C-`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`$\x84\x01Q`D\x85\x01Q\x81ad\xC5\x81a<\xBFV[\x97\x91\x96P\x90\x94PPPPPV[____\x84Q\x90P\x80`d\x14ad\xFBW`@Qc\x9A\xC6\x0C-`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`$\x85\x01Q`D\x86\x01Q`d\x87\x01Q\x82\x82ae\x15\x82a<\xBFV[\x98Pae \x81a<\xBFV[\x98\x9A\x98\x99P\x91\x97\x96PPPPPPPV[_\x80_\x19\x83\x85\t\x93\x90\x92\x02\x80\x84\x10\x93\x81\x90\x03\x93\x90\x93\x03\x93\x91PPV[cNH{q_R\x80` R`$`\x1C\xFD[_` \x82\x84\x03\x12\x15aenW__\xFD[P5\x91\x90PV[\x805\x80\x15\x15\x81\x14ae\x84W__\xFD[\x91\x90PV[__`@\x83\x85\x03\x12\x15ae\x9AW__\xFD[\x825\x91Pae\xAA` \x84\x01aeuV[\x90P\x92P\x92\x90PV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x12\xF0W__\xFD[__`@\x83\x85\x03\x12\x15ae\xD8W__\xFD[\x825ae\xE3\x81ae\xB3V[\x94` \x93\x90\x93\x015\x93PPPV[__`@\x83\x85\x03\x12\x15af\x02W__\xFD[PP\x805\x92` \x90\x91\x015\x91PV[\x8B\x81R`\x01`\x01`\xA0\x1B\x03\x8B\x81\x16` \x83\x01R\x8A\x16`@\x82\x01R`\x01`\x01`@\x1B\x03\x89\x81\x16``\x83\x01R\x88\x81\x16`\x80\x83\x01Rc\xFF\xFF\xFF\xFF\x88\x16`\xA0\x83\x01R\x86\x16`\xC0\x82\x01R`\xE0\x81\x01\x85\x90Ra\x01\0\x81\x01\x84\x90Ra\x01 \x81\x01\x83\x90Ra\x01\xA0\x81\x01af\xA3a\x01@\x83\x01\x84\x80Q\x82R` \x80\x82\x01Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x91\x84\x01\x91\x90\x91R`@\x91\x82\x01Q\x16\x91\x01RV[\x9C\x9BPPPPPPPPPPPPV[_` \x82\x84\x03\x12\x15af\xC3W__\xFD[\x815a:W\x81ae\xB3V[____`\x80\x85\x87\x03\x12\x15af\xE1W__\xFD[\x845\x93P` \x85\x015\x92P`@\x85\x015af\xFA\x81ae\xB3V[\x91P``\x85\x015ag\n\x81ae\xB3V[\x93\x96\x92\x95P\x90\x93PPV[\x805`\x01`\x01`@\x1B\x03\x81\x16\x81\x14ae\x84W__\xFD[____`\x80\x85\x87\x03\x12\x15ag>W__\xFD[\x845\x93P` \x85\x015agP\x81ae\xB3V[\x92P`@\x85\x015\x91Page``\x86\x01ag\x15V[\x90P\x92\x95\x91\x94P\x92PV[c\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x12\xF0W__\xFD[__`@\x83\x85\x03\x12\x15ag\x92W__\xFD[\x825ag\x9D\x81ae\xB3V[\x91P` \x83\x015ag\xAD\x81agpV[\x80\x91PP\x92P\x92\x90PV[_` \x82\x84\x03\x12\x15ag\xC8W__\xFD[a:W\x82ag\x15V[\x80a\x02\x80\x81\x01\x83\x10\x15a\x16\x05W__\xFD[__\x83`\x1F\x84\x01\x12ag\xF2W__\xFD[P\x815`\x01`\x01`@\x1B\x03\x81\x11\x15ah\x08W__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15ah\x1FW__\xFD[\x92P\x92\x90PV[__\x83`\x1F\x84\x01\x12ah6W__\xFD[P\x815`\x01`\x01`@\x1B\x03\x81\x11\x15ahLW__\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15ah\x1FW__\xFD[________`\xA0\x89\x8B\x03\x12\x15ah}W__\xFD[\x885`\x01`\x01`@\x1B\x03\x81\x11\x15ah\x92W__\xFD[ah\x9E\x8B\x82\x8C\x01ag\xD1V[\x98PP` \x89\x015`\x01`\x01`@\x1B\x03\x81\x11\x15ah\xB9W__\xFD[ah\xC5\x8B\x82\x8C\x01ag\xE2V[\x90\x98P\x96PP`@\x89\x015`\x01`\x01`@\x1B\x03\x81\x11\x15ah\xE3W__\xFD[ah\xEF\x8B\x82\x8C\x01ah&V[\x90\x96P\x94PP``\x89\x015\x92P`\x80\x89\x015`\x01`\x01`@\x1B\x03\x81\x11\x15ai\x14W__\xFD[ai \x8B\x82\x8C\x01ah&V[\x99\x9C\x98\x9BP\x96\x99P\x94\x97\x93\x96\x92\x95\x94PPPV[___``\x84\x86\x03\x12\x15aiFW__\xFD[\x835aiQ\x81ae\xB3V[\x92P` \x84\x015\x91P`@\x84\x015aih\x81ae\xB3V[\x80\x91PP\x92P\x92P\x92V[_\x81Q\x80\x84R\x80` \x84\x01` \x86\x01^_` \x82\x86\x01\x01R` `\x1F\x19`\x1F\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[\x84\x81R`\x80` \x82\x01R_ai\xB9`\x80\x83\x01\x86aisV[`\x01`\x01`@\x1B\x03\x94\x85\x16`@\x84\x01R\x92\x90\x93\x16``\x90\x91\x01R\x93\x92PPPV[________a\x01\0\x89\x8B\x03\x12\x15ai\xF2W__\xFD[\x885\x97P` \x89\x015aj\x04\x81ae\xB3V[\x96Paj\x12`@\x8A\x01ag\x15V[\x95P``\x89\x015aj\"\x81agpV[\x94Paj0`\x80\x8A\x01ag\x15V[\x93P`\xA0\x89\x015\x92P`\xC0\x89\x015ajG\x81ae\xB3V[\x91P`\xE0\x89\x015ajW\x81ae\xB3V[\x80\x91PP\x92\x95\x98P\x92\x95\x98\x90\x93\x96PV[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15aj\x98W\x81Q\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01ajzV[P\x93\x94\x93PPPPV[`\xFF`\xF8\x1B\x88\x16\x81R`\xE0` \x82\x01R_aj\xC0`\xE0\x83\x01\x89aisV[\x82\x81\x03`@\x84\x01Raj\xD2\x81\x89aisV[``\x84\x01\x88\x90R`\x01`\x01`\xA0\x1B\x03\x87\x16`\x80\x85\x01R`\xA0\x84\x01\x86\x90R\x83\x81\x03`\xC0\x85\x01R\x90Pak\x03\x81\x85ajhV[\x9A\x99PPPPPPPPPPV[__`@\x83\x85\x03\x12\x15ak\"W__\xFD[\x825ak-\x81ae\xB3V[\x91Pae\xAA` \x84\x01aeuV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q`\xC0\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15akqWakqak;V[`@R\x90V[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15ak\x9FWak\x9Fak;V[`@R\x91\x90PV[_`\x01`\x01`@\x1B\x03\x82\x11\x15ak\xBFWak\xBFak;V[P`\x1F\x01`\x1F\x19\x16` \x01\x90V[_` \x82\x84\x03\x12\x15ak\xDDW__\xFD[\x815`\x01`\x01`@\x1B\x03\x81\x11\x15ak\xF2W__\xFD[\x82\x01`\x1F\x81\x01\x84\x13al\x02W__\xFD[\x805al\x15al\x10\x82ak\xA7V[akwV[\x81\x81R\x85` \x83\x85\x01\x01\x11\x15al)W__\xFD[\x81` \x84\x01` \x83\x017_\x91\x81\x01` \x01\x91\x90\x91R\x94\x93PPPPV[____``\x85\x87\x03\x12\x15alYW__\xFD[\x845ald\x81ae\xB3V[\x93P` \x85\x015\x92P`@\x85\x015`\x01`\x01`@\x1B\x03\x81\x11\x15al\x85W__\xFD[al\x91\x87\x82\x88\x01ah&V[\x95\x98\x94\x97P\x95PPPPV[` \x81R_a:W` \x83\x01\x84aisV[_____\x85\x87\x03`\xC0\x81\x12\x15al\xC4W__\xFD[\x865\x95P```\x1F\x19\x82\x01\x12\x15al\xD9W__\xFD[P` \x86\x01\x93P`\x80\x86\x015\x92P`\xA0\x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15al\xFFW__\xFD[am\x0B\x88\x82\x89\x01ag\xE2V[\x96\x99\x95\x98P\x93\x96P\x92\x94\x93\x92PPPV[___``\x84\x86\x03\x12\x15am.W__\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[_____`\x80\x86\x88\x03\x12\x15amYW__\xFD[\x855\x94P` \x86\x015`\x01`\x01`@\x1B\x03\x81\x11\x15amuW__\xFD[am\x81\x88\x82\x89\x01ag\xE2V[\x90\x95P\x93Pam\x94\x90P`@\x87\x01ag\x15V[\x91Pam\xA2``\x87\x01ag\x15V[\x90P\x92\x95P\x92\x95\x90\x93PV[_____`\xA0\x86\x88\x03\x12\x15am\xC2W__\xFD[\x855am\xCD\x81ae\xB3V[\x94P` \x86\x015\x93P`@\x86\x015\x92P``\x86\x015\x91P`\x80\x86\x015am\xF2\x81ae\xB3V[\x80\x91PP\x92\x95P\x92\x95\x90\x93PV[__`@\x83\x85\x03\x12\x15an\x11W__\xFD[\x825\x91P` \x83\x015ag\xAD\x81ae\xB3V[` \x81R_a:W` \x83\x01\x84ajhV[_` \x82\x84\x03\x12\x15anEW__\xFD[\x815a:W\x81agpV[___``\x84\x86\x03\x12\x15anbW__\xFD[\x835anm\x81ae\xB3V[\x95` \x85\x015\x95P`@\x90\x94\x015\x93\x92PPPV[__`@\x83\x85\x03\x12\x15an\x93W__\xFD[\x825an\x9E\x81ae\xB3V[\x91Pae\xAA` \x84\x01ag\x15V[_______`\xA0\x88\x8A\x03\x12\x15an\xC2W__\xFD[\x875\x96P` \x88\x015`\x01`\x01`@\x1B\x03\x81\x11\x15an\xDEW__\xFD[an\xEA\x8A\x82\x8B\x01ag\xD1V[\x96PP`@\x88\x015`\x01`\x01`@\x1B\x03\x81\x11\x15ao\x05W__\xFD[ao\x11\x8A\x82\x8B\x01ag\xE2V[\x90\x96P\x94PP``\x88\x015`\x01`\x01`@\x1B\x03\x81\x11\x15ao/W__\xFD[ao;\x8A\x82\x8B\x01ah&V[\x98\x9B\x97\x9AP\x95\x98\x94\x97\x95\x96`\x80\x90\x95\x015\x94\x93PPPPV[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[_`\x01`\xFF\x1B\x82\x01ao|Wao|aoTV[P_\x03\x90V[\x81\x81\x03\x81\x81\x11\x15a\x16\x05Wa\x16\x05aoTV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[`\x01\x81\x81\x1C\x90\x82\x16\x80ao\xBDW`\x7F\x82\x16\x91P[` \x82\x10\x81\x03ao\xDBWcNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[P\x91\x90PV[_____`\xA0\x86\x88\x03\x12\x15ao\xF5W__\xFD[\x85Q` \x87\x01Q\x90\x95Pap\x08\x81ae\xB3V[`@\x87\x01Q``\x88\x01Q`\x80\x90\x98\x01Q\x96\x99\x91\x98P\x96\x95\x94P\x92PPPV[_` \x82\x84\x03\x12\x15ap7W__\xFD[\x81Qa:W\x81ae\xB3V[___``\x84\x86\x03\x12\x15apTW__\xFD[\x83Q` \x85\x01Q`@\x86\x01Q\x91\x94P\x92Paih\x81ae\xB3V[__`@\x83\x85\x03\x12\x15ap\x7FW__\xFD[\x82Qap\x8A\x81ae\xB3V[` \x93\x90\x93\x01Q\x92\x94\x92\x93PPPV[\x81\x83R\x81\x81` \x85\x017P_\x82\x82\x01` \x90\x81\x01\x91\x90\x91R`\x1F\x90\x91\x01`\x1F\x19\x16\x90\x91\x01\x01\x90V[__\x835`\x1E\x19\x846\x03\x01\x81\x12ap\xD7W__\xFD[\x83\x01` \x81\x01\x92P5\x90P`\x01`\x01`@\x1B\x03\x81\x11\x15ap\xF5W__\xFD[\x806\x03\x82\x13\x15ah\x1FW__\xFD[`\x80\x80\x82R_\x90a\x03\0\x83\x01\x90\x83\x01\x89\x83[`\x14\x81\x10\x15aqSW\x85\x84\x03`\x7F\x19\x01\x83Raq1\x82\x8Dap\xC2V[aq<\x86\x82\x84ap\x9AV[\x95PPP` \x92\x83\x01\x92\x91\x90\x91\x01\x90`\x01\x01aq\x15V[PPP\x82\x81\x03` \x84\x01Raqi\x81\x88\x8Aap\x9AV[\x83\x81\x03`@\x85\x01R\x85\x81R\x90P`\x01`\x01`\xFB\x1B\x03\x85\x11\x15aq\x89W__\xFD[\x84`\x05\x1B\x80\x87` \x84\x017``\x93\x90\x93\x01\x93\x90\x93RP\x01` \x01\x95\x94PPPPPV[\x80Qj\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x81\x16\x81\x14ae\x84W__\xFD[_` \x82\x84\x03\x12\x15aq\xD7W__\xFD[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15aq\xECW__\xFD[\x82\x01`\xC0\x81\x85\x03\x12\x15aq\xFDW__\xFD[ar\x05akOV[\x81Q\x81R` \x80\x83\x01Q\x90\x82\x01R`@\x82\x01Qar!\x81agpV[`@\x82\x01Rar2``\x83\x01aq\xACV[``\x82\x01RarC`\x80\x83\x01aq\xACV[`\x80\x82\x01R`\xA0\x82\x01Q`\x01`\x01`@\x1B\x03\x81\x11\x15ar`W__\xFD[\x80\x83\x01\x92PP\x84`\x1F\x83\x01\x12artW__\xFD[\x81Qar\x82al\x10\x82ak\xA7V[\x81\x81R\x86` \x83\x86\x01\x01\x11\x15ar\x96W__\xFD[\x81` \x85\x01` \x83\x01^_\x91\x81\x01` \x01\x91\x90\x91R`\xA0\x82\x01R\x94\x93PPPPV[_`\x01\x82\x01ar\xC9War\xC9aoTV[P`\x01\x01\x90V[`\x1F\x82\x11\x15a\x1F\xF6W\x80_R` _ `\x1F\x84\x01`\x05\x1C\x81\x01` \x85\x10\x15ar\xF5WP\x80[`\x1F\x84\x01`\x05\x1C\x82\x01\x91P[\x81\x81\x10\x15a\x15\xCFW_\x81U`\x01\x01as\x01V[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15as-Was-ak;V[asA\x81as;\x84Tao\xA9V[\x84ar\xD0V[` `\x1F\x82\x11`\x01\x81\x14assW_\x83\x15as\\WP\x84\x82\x01Q[_\x19`\x03\x85\x90\x1B\x1C\x19\x16`\x01\x84\x90\x1B\x17\x84Ua\x15\xCFV[_\x84\x81R` \x81 `\x1F\x19\x85\x16\x91[\x82\x81\x10\x15as\xA2W\x87\x85\x01Q\x82U` \x94\x85\x01\x94`\x01\x90\x92\x01\x91\x01as\x82V[P\x84\x82\x10\x15as\xBFW\x86\x84\x01Q_\x19`\x03\x87\x90\x1B`\xF8\x16\x1C\x19\x16\x81U[PPPP`\x01\x90\x81\x1B\x01\x90UPV[\x80\x82\x01\x80\x82\x11\x15a\x16\x05Wa\x16\x05aoTV[\x80\x82\x01\x82\x81\x12_\x83\x12\x80\x15\x82\x16\x82\x15\x82\x16\x17\x15at\0Wat\0aoTV[PP\x92\x91PPV[_` \x82\x84\x03\x12\x15at\x18W__\xFD[PQ\x91\x90PV[\x82\x81R`@` \x82\x01R_aI\xC6`@\x83\x01\x84aisV[\x85\x81R\x84` \x82\x01R\x83`@\x82\x01R\x82``\x82\x01R`\xA0`\x80\x82\x01R_ata`\xA0\x83\x01\x84aisV[\x97\x96PPPPPPPV[\x80Q` \x82\x01Q`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x91\x90`\x04\x82\x10\x15at\xA3W`\x01`\x01`\xE0\x1B\x03\x19`\x04\x83\x90\x03`\x03\x1B\x81\x90\x1B\x82\x16\x16\x92P[PP\x91\x90PV[_\x825`~\x19\x836\x03\x01\x81\x12at\xBEW__\xFD[\x91\x90\x91\x01\x92\x91PPV[__\x835`\x1E\x19\x846\x03\x01\x81\x12at\xDDW__\xFD[\x83\x01\x805\x91P`\x01`\x01`@\x1B\x03\x82\x11\x15at\xF6W__\xFD[` \x01\x91P6\x81\x90\x03\x82\x13\x15ah\x1FW__\xFD[\x87\x81R\x86` \x82\x01R\x85`@\x82\x01R\x84``\x82\x01R\x83`\x80\x82\x01R\x81\x83`\xA0\x83\x017_\x91\x01`\xA0\x01\x90\x81R\x96\x95PPPPPPV[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[_a:W\x82\x84au?V[`\x80\x80\x82R\x81\x01\x85\x90R_`\xA0`\x05\x87\x90\x1B\x83\x01\x81\x01\x90\x83\x01\x88\x83`^\x196\x83\x90\x03\x01[\x8A\x82\x10\x15av\x04W\x86\x85\x03`\x9F\x19\x01\x84R\x825\x81\x81\x12au\xA3W__\xFD[\x8C\x01\x805au\xB0\x81ae\xB3V[`\x01`\x01`\xA0\x1B\x03\x16\x86R` \x81\x81\x015\x90\x87\x01Rau\xD2`@\x82\x01\x82ap\xC2V[\x91P```@\x88\x01Rau\xE9``\x88\x01\x83\x83ap\x9AV[\x96PPP` \x83\x01\x92P` \x84\x01\x93P`\x01\x82\x01\x91Pau\x85V[PPP`\x01`\x01`\xA0\x1B\x03\x87\x16` \x85\x01RP\x90P\x83`@\x83\x01Rav4``\x83\x01\x84`\x01`\x01`\xA0\x1B\x03\x16\x90RV[\x96\x95PPPPPPV[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x16\x05Wa\x16\x05aoTV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_\x82av\x83WcNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[P\x04\x90V[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x83\x81R` \x81\x01\x83\x90R``\x81\x01`\x06\x83\x10av\xBAWav\xBAav\x88V[\x82`@\x83\x01R\x94\x93PPPPV[\x86\x81R\x85` \x82\x01R\x84`@\x82\x01R\x83``\x82\x01R\x82`\x80\x82\x01R_av\xF1`\xA0\x83\x01\x84au?V[\x98\x97PPPPPPPPV[\x83\x81R\x82` \x82\x01R```@\x82\x01R_aw\x1B``\x83\x01\x84aisV[\x95\x94PPPPPV[`\x03\x81\x10aw4Waw4av\x88V[\x90RV[`\x01`\x01`\xA0\x1B\x03\x8C\x81\x16\x82R` \x82\x01\x8C\x90R`@\x82\x01\x8B\x90R``\x82\x01\x8A\x90R\x88\x16`\x80\x82\x01Ra\x01`\x81\x01aws`\xA0\x83\x01\x89aw$V[`\xC0\x82\x01\x96\x90\x96R`\x01`\x01`\xA0\x1B\x03\x94\x85\x16`\xE0\x82\x01R\x92\x90\x93\x16a\x01\0\x83\x01R`\x01`\x01`@\x1B\x03\x16a\x01 \x82\x01Ra\x01@\x01R\x96\x95PPPPPPV[_a\x01\xA0\x82\x01\x90P\x82Q\x82R` \x83\x01Q` \x83\x01R`@\x83\x01Qaw\xE3`@\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P``\x83\x01Q``\x83\x01R`\x80\x83\x01Q`\x80\x83\x01R`\xA0\x83\x01Q`\xA0\x83\x01R`\xC0\x83\x01Qax\x1C`\xC0\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[P`\xE0\x83\x01Qax/`\xE0\x84\x01\x82aw$V[Pa\x01\0\x83\x01Qa\x01\0\x83\x01Ra\x01 \x83\x01QaxXa\x01 \x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[Pa\x01@\x83\x01Qaxua\x01@\x84\x01\x82`\x01`\x01`\xA0\x1B\x03\x16\x90RV[Pa\x01`\x83\x01Qax\x92a\x01`\x84\x01\x82`\x01`\x01`@\x1B\x03\x16\x90RV[Pa\x01\x80\x92\x83\x01Q\x91\x90\x92\x01R\x90V\xFE\xA1dsolcC\0\x08\x1B\0\n",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct Call { address to; uint256 value; bytes data; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Call {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Call> for UnderlyingRustTuple<'_> {
            fn from(value: Call) -> Self {
                (value.to, value.value, value.data)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Call {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    to: tuple.0,
                    value: tuple.1,
                    data: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Call {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Call {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Call {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Call {
            const NAME: &'static str = "Call";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Call(address to,uint256 value,bytes data)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.to,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.value)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.data,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Call {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.to,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.value)
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.data,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.to,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.value,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.data,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AlreadyInitialized()` and selector `0x0dc149f0`.
```solidity
error AlreadyInitialized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadyInitialized;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyInitialized> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyInitialized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyInitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyInitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyInitialized()";
            const SELECTOR: [u8; 4] = [13u8, 193u8, 73u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AmountTooLargeForInt()` and selector `0x1667dc74`.
```solidity
error AmountTooLargeForInt();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AmountTooLargeForInt;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AmountTooLargeForInt> for UnderlyingRustTuple<'_> {
            fn from(value: AmountTooLargeForInt) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AmountTooLargeForInt {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AmountTooLargeForInt {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AmountTooLargeForInt()";
            const SELECTOR: [u8; 4] = [22u8, 103u8, 220u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CannotRescueUSDT()` and selector `0x1c4e1bff`.
```solidity
error CannotRescueUSDT();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CannotRescueUSDT;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CannotRescueUSDT> for UnderlyingRustTuple<'_> {
            fn from(value: CannotRescueUSDT) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CannotRescueUSDT {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CannotRescueUSDT {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CannotRescueUSDT()";
            const SELECTOR: [u8; 4] = [28u8, 78u8, 27u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ChainDeprecated()` and selector `0xd9259ca9`.
```solidity
error ChainDeprecated();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ChainDeprecated;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ChainDeprecated> for UnderlyingRustTuple<'_> {
            fn from(value: ChainDeprecated) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ChainDeprecated {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ChainDeprecated {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ChainDeprecated()";
            const SELECTOR: [u8; 4] = [217u8, 37u8, 156u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `DepositAlreadyProcessed()` and selector `0x37d6e20a`.
```solidity
error DepositAlreadyProcessed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DepositAlreadyProcessed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DepositAlreadyProcessed> for UnderlyingRustTuple<'_> {
            fn from(value: DepositAlreadyProcessed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DepositAlreadyProcessed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DepositAlreadyProcessed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DepositAlreadyProcessed()";
            const SELECTOR: [u8; 4] = [55u8, 214u8, 226u8, 10u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `DepositNotAfterLastReceiverPull()` and selector `0xf9b01c44`.
```solidity
error DepositNotAfterLastReceiverPull();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DepositNotAfterLastReceiverPull;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DepositNotAfterLastReceiverPull>
        for UnderlyingRustTuple<'_> {
            fn from(value: DepositNotAfterLastReceiverPull) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for DepositNotAfterLastReceiverPull {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DepositNotAfterLastReceiverPull {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DepositNotAfterLastReceiverPull()";
            const SELECTOR: [u8; 4] = [249u8, 176u8, 28u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EnforcedPause()` and selector `0xd93c0665`.
```solidity
error EnforcedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EnforcedPause;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EnforcedPause> for UnderlyingRustTuple<'_> {
            fn from(value: EnforcedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EnforcedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EnforcedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EnforcedPause()";
            const SELECTOR: [u8; 4] = [217u8, 60u8, 6u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EventRelayNoProgress()` and selector `0xd6c1467c`.
```solidity
error EventRelayNoProgress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EventRelayNoProgress;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EventRelayNoProgress> for UnderlyingRustTuple<'_> {
            fn from(value: EventRelayNoProgress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EventRelayNoProgress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EventRelayNoProgress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EventRelayNoProgress()";
            const SELECTOR: [u8; 4] = [214u8, 193u8, 70u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EventTipMismatch()` and selector `0x0e521c43`.
```solidity
error EventTipMismatch();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EventTipMismatch;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EventTipMismatch> for UnderlyingRustTuple<'_> {
            fn from(value: EventTipMismatch) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EventTipMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EventTipMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EventTipMismatch()";
            const SELECTOR: [u8; 4] = [14u8, 82u8, 28u8, 67u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ExpectedPause()` and selector `0x8dfc202b`.
```solidity
error ExpectedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExpectedPause;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExpectedPause> for UnderlyingRustTuple<'_> {
            fn from(value: ExpectedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExpectedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExpectedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExpectedPause()";
            const SELECTOR: [u8; 4] = [141u8, 252u8, 32u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientLpPrincipal()` and selector `0xacf2da93`.
```solidity
error InsufficientLpPrincipal();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientLpPrincipal;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientLpPrincipal> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientLpPrincipal) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientLpPrincipal {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientLpPrincipal {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientLpPrincipal()";
            const SELECTOR: [u8; 4] = [172u8, 242u8, 218u8, 147u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientProtocolProfit()` and selector `0x9d8c7d99`.
```solidity
error InsufficientProtocolProfit();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientProtocolProfit;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientProtocolProfit>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientProtocolProfit) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientProtocolProfit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientProtocolProfit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientProtocolProfit()";
            const SELECTOR: [u8; 4] = [157u8, 140u8, 125u8, 153u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientUsdtBalance()` and selector `0xb55c1bad`.
```solidity
error InsufficientUsdtBalance();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientUsdtBalance;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientUsdtBalance> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientUsdtBalance) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientUsdtBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientUsdtBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientUsdtBalance()";
            const SELECTOR: [u8; 4] = [181u8, 92u8, 27u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidLeaseId()` and selector `0x243b4f40`.
```solidity
error InvalidLeaseId();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidLeaseId;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidLeaseId> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidLeaseId) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidLeaseId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidLeaseId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidLeaseId()";
            const SELECTOR: [u8; 4] = [36u8, 59u8, 79u8, 64u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidLeaseTimeframe()` and selector `0x501d13ed`.
```solidity
error InvalidLeaseTimeframe();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidLeaseTimeframe;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidLeaseTimeframe> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidLeaseTimeframe) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidLeaseTimeframe {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidLeaseTimeframe {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidLeaseTimeframe()";
            const SELECTOR: [u8; 4] = [80u8, 29u8, 19u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidReceiverForSalt()` and selector `0x80ca1d52`.
```solidity
error InvalidReceiverForSalt();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidReceiverForSalt;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidReceiverForSalt> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidReceiverForSalt) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidReceiverForSalt {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidReceiverForSalt {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidReceiverForSalt()";
            const SELECTOR: [u8; 4] = [128u8, 202u8, 29u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidSignature()` and selector `0x8baa579f`.
```solidity
error InvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidSignature;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidSignature()";
            const SELECTOR: [u8; 4] = [139u8, 170u8, 87u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidTargetToken()` and selector `0x8562eb45`.
```solidity
error InvalidTargetToken();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidTargetToken;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidTargetToken> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidTargetToken) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidTargetToken {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidTargetToken {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidTargetToken()";
            const SELECTOR: [u8; 4] = [133u8, 98u8, 235u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `LeaseDurationTooLong()` and selector `0xaae1311c`.
```solidity
error LeaseDurationTooLong();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LeaseDurationTooLong;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<LeaseDurationTooLong> for UnderlyingRustTuple<'_> {
            fn from(value: LeaseDurationTooLong) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for LeaseDurationTooLong {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for LeaseDurationTooLong {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LeaseDurationTooLong()";
            const SELECTOR: [u8; 4] = [170u8, 225u8, 49u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `LeaseFeeTooLow()` and selector `0x94ab28d6`.
```solidity
error LeaseFeeTooLow();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LeaseFeeTooLow;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<LeaseFeeTooLow> for UnderlyingRustTuple<'_> {
            fn from(value: LeaseFeeTooLow) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for LeaseFeeTooLow {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for LeaseFeeTooLow {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LeaseFeeTooLow()";
            const SELECTOR: [u8; 4] = [148u8, 171u8, 40u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `LeaseFlatFeeTooLow()` and selector `0x4c4b6f02`.
```solidity
error LeaseFlatFeeTooLow();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LeaseFlatFeeTooLow;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<LeaseFlatFeeTooLow> for UnderlyingRustTuple<'_> {
            fn from(value: LeaseFlatFeeTooLow) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for LeaseFlatFeeTooLow {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for LeaseFlatFeeTooLow {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LeaseFlatFeeTooLow()";
            const SELECTOR: [u8; 4] = [76u8, 75u8, 111u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `LeaseNotNukeableYet()` and selector `0xb4ed1c35`.
```solidity
error LeaseNotNukeableYet();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LeaseNotNukeableYet;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<LeaseNotNukeableYet> for UnderlyingRustTuple<'_> {
            fn from(value: LeaseNotNukeableYet) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for LeaseNotNukeableYet {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for LeaseNotNukeableYet {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LeaseNotNukeableYet()";
            const SELECTOR: [u8; 4] = [180u8, 237u8, 28u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `LeaseRateLimitConfigInvalid()` and selector `0x42658232`.
```solidity
error LeaseRateLimitConfigInvalid();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LeaseRateLimitConfigInvalid;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<LeaseRateLimitConfigInvalid>
        for UnderlyingRustTuple<'_> {
            fn from(value: LeaseRateLimitConfigInvalid) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for LeaseRateLimitConfigInvalid {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for LeaseRateLimitConfigInvalid {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LeaseRateLimitConfigInvalid()";
            const SELECTOR: [u8; 4] = [66u8, 101u8, 130u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `LeaseRateLimitExceeded()` and selector `0x4c542ae4`.
```solidity
error LeaseRateLimitExceeded();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LeaseRateLimitExceeded;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<LeaseRateLimitExceeded> for UnderlyingRustTuple<'_> {
            fn from(value: LeaseRateLimitExceeded) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for LeaseRateLimitExceeded {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for LeaseRateLimitExceeded {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LeaseRateLimitExceeded()";
            const SELECTOR: [u8; 4] = [76u8, 84u8, 42u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `LpNotAllowlisted()` and selector `0x0dad8e34`.
```solidity
error LpNotAllowlisted();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LpNotAllowlisted;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<LpNotAllowlisted> for UnderlyingRustTuple<'_> {
            fn from(value: LpNotAllowlisted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for LpNotAllowlisted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for LpNotAllowlisted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LpNotAllowlisted()";
            const SELECTOR: [u8; 4] = [13u8, 173u8, 142u8, 52u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NewOwnerIsZeroAddress()` and selector `0x7448fbae`.
```solidity
error NewOwnerIsZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NewOwnerIsZeroAddress;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NewOwnerIsZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: NewOwnerIsZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NewOwnerIsZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NewOwnerIsZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NewOwnerIsZeroAddress()";
            const SELECTOR: [u8; 4] = [116u8, 72u8, 251u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NoActiveLease()` and selector `0x4a077666`.
```solidity
error NoActiveLease();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoActiveLease;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoActiveLease> for UnderlyingRustTuple<'_> {
            fn from(value: NoActiveLease) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoActiveLease {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoActiveLease {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoActiveLease()";
            const SELECTOR: [u8; 4] = [74u8, 7u8, 118u8, 102u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NoBridger()` and selector `0xb37c79ed`.
```solidity
error NoBridger();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoBridger;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoBridger> for UnderlyingRustTuple<'_> {
            fn from(value: NoBridger) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoBridger {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoBridger {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoBridger()";
            const SELECTOR: [u8; 4] = [179u8, 124u8, 121u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NoEventChainTipInMulticall()` and selector `0x450d5972`.
```solidity
error NoEventChainTipInMulticall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoEventChainTipInMulticall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoEventChainTipInMulticall>
        for UnderlyingRustTuple<'_> {
            fn from(value: NoEventChainTipInMulticall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for NoEventChainTipInMulticall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoEventChainTipInMulticall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoEventChainTipInMulticall()";
            const SELECTOR: [u8; 4] = [69u8, 13u8, 89u8, 114u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotATrc20Transfer()` and selector `0x2456e1ec`.
```solidity
error NotATrc20Transfer();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotATrc20Transfer;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotATrc20Transfer> for UnderlyingRustTuple<'_> {
            fn from(value: NotATrc20Transfer) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotATrc20Transfer {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotATrc20Transfer {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotATrc20Transfer()";
            const SELECTOR: [u8; 4] = [36u8, 86u8, 225u8, 236u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotEventChainTip()` and selector `0x6cb67ca6`.
```solidity
error NotEventChainTip();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotEventChainTip;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotEventChainTip> for UnderlyingRustTuple<'_> {
            fn from(value: NotEventChainTip) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotEventChainTip {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotEventChainTip {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotEventChainTip()";
            const SELECTOR: [u8; 4] = [108u8, 182u8, 124u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotLessee()` and selector `0x7136f4f2`.
```solidity
error NotLessee();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotLessee;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotLessee> for UnderlyingRustTuple<'_> {
            fn from(value: NotLessee) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotLessee {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotLessee {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotLessee()";
            const SELECTOR: [u8; 4] = [113u8, 54u8, 244u8, 242u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotRealtor()` and selector `0x8a28437a`.
```solidity
error NotRealtor();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotRealtor;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotRealtor> for UnderlyingRustTuple<'_> {
            fn from(value: NotRealtor) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotRealtor {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotRealtor {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotRealtor()";
            const SELECTOR: [u8; 4] = [138u8, 40u8, 67u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotTronUsdt()` and selector `0x3395765b`.
```solidity
error NotTronUsdt();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotTronUsdt;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotTronUsdt> for UnderlyingRustTuple<'_> {
            fn from(value: NotTronUsdt) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotTronUsdt {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotTronUsdt {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotTronUsdt()";
            const SELECTOR: [u8; 4] = [51u8, 149u8, 118u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `PayoutConfigRateLimitConfigInvalid()` and selector `0xa17eea77`.
```solidity
error PayoutConfigRateLimitConfigInvalid();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PayoutConfigRateLimitConfigInvalid;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PayoutConfigRateLimitConfigInvalid>
        for UnderlyingRustTuple<'_> {
            fn from(value: PayoutConfigRateLimitConfigInvalid) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for PayoutConfigRateLimitConfigInvalid {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for PayoutConfigRateLimitConfigInvalid {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PayoutConfigRateLimitConfigInvalid()";
            const SELECTOR: [u8; 4] = [161u8, 126u8, 234u8, 119u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `PayoutConfigRateLimitExceeded()` and selector `0x0a83b084`.
```solidity
error PayoutConfigRateLimitExceeded();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PayoutConfigRateLimitExceeded;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PayoutConfigRateLimitExceeded>
        for UnderlyingRustTuple<'_> {
            fn from(value: PayoutConfigRateLimitExceeded) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for PayoutConfigRateLimitExceeded {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for PayoutConfigRateLimitExceeded {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PayoutConfigRateLimitExceeded()";
            const SELECTOR: [u8; 4] = [10u8, 131u8, 176u8, 132u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `RateNotSet()` and selector `0x08fc7fce`.
```solidity
error RateNotSet();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RateNotSet;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RateNotSet> for UnderlyingRustTuple<'_> {
            fn from(value: RateNotSet) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for RateNotSet {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for RateNotSet {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RateNotSet()";
            const SELECTOR: [u8; 4] = [8u8, 252u8, 127u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `Reentrancy()` and selector `0xab143c06`.
```solidity
error Reentrancy();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Reentrancy;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Reentrancy> for UnderlyingRustTuple<'_> {
            fn from(value: Reentrancy) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Reentrancy {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Reentrancy {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Reentrancy()";
            const SELECTOR: [u8; 4] = [171u8, 20u8, 60u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SignatureExpired()` and selector `0x0819bdcd`.
```solidity
error SignatureExpired();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SignatureExpired;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SignatureExpired> for UnderlyingRustTuple<'_> {
            fn from(value: SignatureExpired) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SignatureExpired {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SignatureExpired {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SignatureExpired()";
            const SELECTOR: [u8; 4] = [8u8, 25u8, 189u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SubjectiveNetOutZero()` and selector `0x3f41ae01`.
```solidity
error SubjectiveNetOutZero();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SubjectiveNetOutZero;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SubjectiveNetOutZero> for UnderlyingRustTuple<'_> {
            fn from(value: SubjectiveNetOutZero) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SubjectiveNetOutZero {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SubjectiveNetOutZero {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SubjectiveNetOutZero()";
            const SELECTOR: [u8; 4] = [63u8, 65u8, 174u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SubjectivePreEntitlementAlreadyExists()` and selector `0xcc0bb0c1`.
```solidity
error SubjectivePreEntitlementAlreadyExists();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SubjectivePreEntitlementAlreadyExists;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SubjectivePreEntitlementAlreadyExists>
        for UnderlyingRustTuple<'_> {
            fn from(value: SubjectivePreEntitlementAlreadyExists) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SubjectivePreEntitlementAlreadyExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SubjectivePreEntitlementAlreadyExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SubjectivePreEntitlementAlreadyExists()";
            const SELECTOR: [u8; 4] = [204u8, 11u8, 176u8, 193u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `TronInvalidCalldataLength()` and selector `0x12799503`.
```solidity
error TronInvalidCalldataLength();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TronInvalidCalldataLength;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TronInvalidCalldataLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: TronInvalidCalldataLength) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for TronInvalidCalldataLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TronInvalidCalldataLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TronInvalidCalldataLength()";
            const SELECTOR: [u8; 4] = [18u8, 121u8, 149u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `TronInvalidTrc20DataLength()` and selector `0x9ac60c2d`.
```solidity
error TronInvalidTrc20DataLength();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TronInvalidTrc20DataLength;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TronInvalidTrc20DataLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: TronInvalidTrc20DataLength) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for TronInvalidTrc20DataLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TronInvalidTrc20DataLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TronInvalidTrc20DataLength()";
            const SELECTOR: [u8; 4] = [154u8, 198u8, 12u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `Unauthorized()` and selector `0x82b42900`.
```solidity
error Unauthorized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Unauthorized;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Unauthorized> for UnderlyingRustTuple<'_> {
            fn from(value: Unauthorized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Unauthorized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Unauthorized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Unauthorized()";
            const SELECTOR: [u8; 4] = [130u8, 180u8, 41u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `WithdrawExceedsPrincipal()` and selector `0xd4708ca5`.
```solidity
error WithdrawExceedsPrincipal();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct WithdrawExceedsPrincipal;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<WithdrawExceedsPrincipal>
        for UnderlyingRustTuple<'_> {
            fn from(value: WithdrawExceedsPrincipal) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for WithdrawExceedsPrincipal {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for WithdrawExceedsPrincipal {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "WithdrawExceedsPrincipal()";
            const SELECTOR: [u8; 4] = [212u8, 112u8, 140u8, 165u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ZeroAmount()` and selector `0x1f2a2005`.
```solidity
error ZeroAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAmount;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAmount> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAmount()";
            const SELECTOR: [u8; 4] = [31u8, 42u8, 32u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `BridgerSet(address,uint256,address)` and selector `0x427db48f8cd0cf7fdabcdbc1327c7db26ce3a544292ba380ef07d5175af729cd`.
```solidity
event BridgerSet(address indexed targetToken, uint256 indexed targetChainId, address bridger);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgerSet {
        #[allow(missing_docs)]
        pub targetToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub targetChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub bridger: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgerSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "BridgerSet(address,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                66u8, 125u8, 180u8, 143u8, 140u8, 208u8, 207u8, 127u8, 218u8, 188u8,
                219u8, 193u8, 50u8, 124u8, 125u8, 178u8, 108u8, 227u8, 165u8, 68u8, 41u8,
                43u8, 163u8, 128u8, 239u8, 7u8, 213u8, 23u8, 90u8, 247u8, 41u8, 205u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    targetToken: topics.1,
                    targetChainId: topics.2,
                    bridger: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridger,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.targetToken.clone(),
                    self.targetChainId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.targetToken,
                );
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.targetChainId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgerSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgerSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgerSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ChainDeprecatedSet(uint256,bool)` and selector `0xc8b7fe24dc2e9e731141fe1dd74d6ce470bd6b5371c12f42c9ce46bac15424c5`.
```solidity
event ChainDeprecatedSet(uint256 indexed targetChainId, bool deprecated);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ChainDeprecatedSet {
        #[allow(missing_docs)]
        pub targetChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub deprecated: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChainDeprecatedSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "ChainDeprecatedSet(uint256,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                200u8, 183u8, 254u8, 36u8, 220u8, 46u8, 158u8, 115u8, 17u8, 65u8, 254u8,
                29u8, 215u8, 77u8, 108u8, 228u8, 112u8, 189u8, 107u8, 83u8, 113u8, 193u8,
                47u8, 66u8, 201u8, 206u8, 70u8, 186u8, 193u8, 84u8, 36u8, 197u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    targetChainId: topics.1,
                    deprecated: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.deprecated,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.targetChainId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.targetChainId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChainDeprecatedSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChainDeprecatedSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ChainDeprecatedSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ClaimCreated(uint256,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,address,address,uint64,uint256)` and selector `0x77242fbd573af5a5f3518da92600e96795ebfff993606b4fb54dea2dcd2dfe85`.
```solidity
event ClaimCreated(uint256 indexed leaseId, uint256 indexed claimId, address targetToken, uint256 queueIndex, uint256 amountUsdt, uint256 targetChainId, address beneficiary, UntronV3Index.ClaimOrigin origin, bytes32 originId, address originActor, address originToken, uint64 originTimestamp, uint256 originRawAmount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ClaimCreated {
        #[allow(missing_docs)]
        pub leaseId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub claimId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub targetToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub queueIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amountUsdt: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub targetChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub beneficiary: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub origin: <UntronV3Index::ClaimOrigin as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub originId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub originActor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub originToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub originTimestamp: u64,
        #[allow(missing_docs)]
        pub originRawAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ClaimCreated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                UntronV3Index::ClaimOrigin,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "ClaimCreated(uint256,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,address,address,uint64,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                119u8, 36u8, 47u8, 189u8, 87u8, 58u8, 245u8, 165u8, 243u8, 81u8, 141u8,
                169u8, 38u8, 0u8, 233u8, 103u8, 149u8, 235u8, 255u8, 249u8, 147u8, 96u8,
                107u8, 79u8, 181u8, 77u8, 234u8, 45u8, 205u8, 45u8, 254u8, 133u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    leaseId: topics.1,
                    claimId: topics.2,
                    targetToken: data.0,
                    queueIndex: data.1,
                    amountUsdt: data.2,
                    targetChainId: data.3,
                    beneficiary: data.4,
                    origin: data.5,
                    originId: data.6,
                    originActor: data.7,
                    originToken: data.8,
                    originTimestamp: data.9,
                    originRawAmount: data.10,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.targetToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.queueIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountUsdt),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.targetChainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.beneficiary,
                    ),
                    <UntronV3Index::ClaimOrigin as alloy_sol_types::SolType>::tokenize(
                        &self.origin,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.originId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.originActor,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.originToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.originTimestamp),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.originRawAmount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.leaseId.clone(), self.claimId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.leaseId);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.claimId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ClaimCreated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ClaimCreated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ClaimCreated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ClaimFilled(uint256,uint256,address,uint256,uint256,uint256,address)` and selector `0xb62b4e6f1ec5970a29274e747835f444a5ccd48049698eff9c9cfdca2e1a5eaf`.
```solidity
event ClaimFilled(uint256 indexed leaseId, uint256 indexed claimId, address targetToken, uint256 queueIndex, uint256 amountUsdt, uint256 targetChainId, address beneficiary);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ClaimFilled {
        #[allow(missing_docs)]
        pub leaseId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub claimId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub targetToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub queueIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amountUsdt: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub targetChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub beneficiary: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ClaimFilled {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "ClaimFilled(uint256,uint256,address,uint256,uint256,uint256,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                182u8, 43u8, 78u8, 111u8, 30u8, 197u8, 151u8, 10u8, 41u8, 39u8, 78u8,
                116u8, 120u8, 53u8, 244u8, 68u8, 165u8, 204u8, 212u8, 128u8, 73u8, 105u8,
                142u8, 255u8, 156u8, 156u8, 253u8, 202u8, 46u8, 26u8, 94u8, 175u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    leaseId: topics.1,
                    claimId: topics.2,
                    targetToken: data.0,
                    queueIndex: data.1,
                    amountUsdt: data.2,
                    targetChainId: data.3,
                    beneficiary: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.targetToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.queueIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountUsdt),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.targetChainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.beneficiary,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.leaseId.clone(), self.claimId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.leaseId);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.claimId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ClaimFilled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ClaimFilled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ClaimFilled) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ControllerEventChainTipUpdated(bytes32,uint256,uint256,bytes32,bytes)` and selector `0x9d611b5b34cb76131c4fb413eb74119b2c0c3a6aa6fcd8e740cf70ac3085d87b`.
```solidity
event ControllerEventChainTipUpdated(bytes32 previousTip, uint256 indexed blockNumber, uint256 blockTimestamp, bytes32 indexed eventSignature, bytes abiEncodedEventData);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ControllerEventChainTipUpdated {
        #[allow(missing_docs)]
        pub previousTip: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub blockTimestamp: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub eventSignature: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub abiEncodedEventData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ControllerEventChainTipUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "ControllerEventChainTipUpdated(bytes32,uint256,uint256,bytes32,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                157u8, 97u8, 27u8, 91u8, 52u8, 203u8, 118u8, 19u8, 28u8, 79u8, 180u8,
                19u8, 235u8, 116u8, 17u8, 155u8, 44u8, 12u8, 58u8, 106u8, 166u8, 252u8,
                216u8, 231u8, 64u8, 207u8, 112u8, 172u8, 48u8, 133u8, 216u8, 123u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousTip: data.0,
                    blockNumber: topics.1,
                    blockTimestamp: data.1,
                    eventSignature: topics.2,
                    abiEncodedEventData: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.previousTip),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockTimestamp),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.abiEncodedEventData,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.blockNumber.clone(),
                    self.eventSignature.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blockNumber);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.eventSignature);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ControllerEventChainTipUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ControllerEventChainTipUpdated>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &ControllerEventChainTipUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ControllerEventProcessed(uint256,uint256,uint256,bytes32,bytes)` and selector `0xdca16b0af6e10f5dfb7d4ea91055951419a0c8ffc5925acffdc52a95fcc67133`.
```solidity
event ControllerEventProcessed(uint256 indexed eventIndex, uint256 indexed blockNumber, uint256 blockTimestamp, bytes32 indexed eventSignature, bytes abiEncodedEventData);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ControllerEventProcessed {
        #[allow(missing_docs)]
        pub eventIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub blockTimestamp: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub eventSignature: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub abiEncodedEventData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ControllerEventProcessed {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "ControllerEventProcessed(uint256,uint256,uint256,bytes32,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                220u8, 161u8, 107u8, 10u8, 246u8, 225u8, 15u8, 93u8, 251u8, 125u8, 78u8,
                169u8, 16u8, 85u8, 149u8, 20u8, 25u8, 160u8, 200u8, 255u8, 197u8, 146u8,
                90u8, 207u8, 253u8, 197u8, 42u8, 149u8, 252u8, 198u8, 113u8, 51u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    eventIndex: topics.1,
                    blockNumber: topics.2,
                    blockTimestamp: data.0,
                    eventSignature: topics.3,
                    abiEncodedEventData: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockTimestamp),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.abiEncodedEventData,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.eventIndex.clone(),
                    self.blockNumber.clone(),
                    self.eventSignature.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.eventIndex);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blockNumber);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.eventSignature);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ControllerEventProcessed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ControllerEventProcessed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &ControllerEventProcessed,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `EventAppended(uint256,bytes32,bytes32,bytes32,bytes)` and selector `0x78160f0b1b2b32b52a0076d8f0f70888687ba702a4d993d55ac8d9327d57a127`.
```solidity
event EventAppended(uint256 indexed eventSeq, bytes32 indexed prevTip, bytes32 indexed newTip, bytes32 eventSignature, bytes abiEncodedEventData);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EventAppended {
        #[allow(missing_docs)]
        pub eventSeq: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub prevTip: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newTip: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub eventSignature: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub abiEncodedEventData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EventAppended {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "EventAppended(uint256,bytes32,bytes32,bytes32,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                120u8, 22u8, 15u8, 11u8, 27u8, 43u8, 50u8, 181u8, 42u8, 0u8, 118u8,
                216u8, 240u8, 247u8, 8u8, 136u8, 104u8, 123u8, 167u8, 2u8, 164u8, 217u8,
                147u8, 213u8, 90u8, 200u8, 217u8, 50u8, 125u8, 87u8, 161u8, 39u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    eventSeq: topics.1,
                    prevTip: topics.2,
                    newTip: topics.3,
                    eventSignature: data.0,
                    abiEncodedEventData: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.eventSignature),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.abiEncodedEventData,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.eventSeq.clone(),
                    self.prevTip.clone(),
                    self.newTip.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.eventSeq);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.prevTip);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newTip);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EventAppended {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EventAppended> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EventAppended) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `LeaseCreated(uint256,bytes32,uint256,address,address,uint64,uint64,uint32,uint64)` and selector `0xe431502bd0df5880397ec13c0a260f0c749c8f3a30c6caf3ffe0f08a2ed13942`.
```solidity
event LeaseCreated(uint256 indexed leaseId, bytes32 indexed receiverSalt, uint256 indexed leaseNumber, address realtor, address lessee, uint64 startTime, uint64 nukeableAfter, uint32 leaseFeePpm, uint64 flatFee);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct LeaseCreated {
        #[allow(missing_docs)]
        pub leaseId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub receiverSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub leaseNumber: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lessee: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub startTime: u64,
        #[allow(missing_docs)]
        pub nukeableAfter: u64,
        #[allow(missing_docs)]
        pub leaseFeePpm: u32,
        #[allow(missing_docs)]
        pub flatFee: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for LeaseCreated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "LeaseCreated(uint256,bytes32,uint256,address,address,uint64,uint64,uint32,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                228u8, 49u8, 80u8, 43u8, 208u8, 223u8, 88u8, 128u8, 57u8, 126u8, 193u8,
                60u8, 10u8, 38u8, 15u8, 12u8, 116u8, 156u8, 143u8, 58u8, 48u8, 198u8,
                202u8, 243u8, 255u8, 224u8, 240u8, 138u8, 46u8, 209u8, 57u8, 66u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    leaseId: topics.1,
                    receiverSalt: topics.2,
                    leaseNumber: topics.3,
                    realtor: data.0,
                    lessee: data.1,
                    startTime: data.2,
                    nukeableAfter: data.3,
                    leaseFeePpm: data.4,
                    flatFee: data.5,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.realtor,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.lessee,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.startTime),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.nukeableAfter),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseFeePpm),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.flatFee),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.leaseId.clone(),
                    self.receiverSalt.clone(),
                    self.leaseNumber.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.leaseId);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.receiverSalt);
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.leaseNumber);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for LeaseCreated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&LeaseCreated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &LeaseCreated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `LeaseNonceUpdated(uint256,uint256)` and selector `0x8e98a0734420e57ef102cab0b1af0809a5bbaf4fde966fd173c322490644a5d0`.
```solidity
event LeaseNonceUpdated(uint256 indexed leaseId, uint256 nonce);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct LeaseNonceUpdated {
        #[allow(missing_docs)]
        pub leaseId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nonce: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for LeaseNonceUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "LeaseNonceUpdated(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                142u8, 152u8, 160u8, 115u8, 68u8, 32u8, 229u8, 126u8, 241u8, 2u8, 202u8,
                176u8, 177u8, 175u8, 8u8, 9u8, 165u8, 187u8, 175u8, 79u8, 222u8, 150u8,
                111u8, 209u8, 115u8, 195u8, 34u8, 73u8, 6u8, 68u8, 165u8, 208u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    leaseId: topics.1,
                    nonce: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonce),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.leaseId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.leaseId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for LeaseNonceUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&LeaseNonceUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &LeaseNonceUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `LesseePayoutConfigRateLimitSet(uint256,uint256)` and selector `0xab63c25aa07a4d10a1842d61026a08d95115c4e6895288683015ca4464c7f50f`.
```solidity
event LesseePayoutConfigRateLimitSet(uint256 maxUpdates, uint256 windowSeconds);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct LesseePayoutConfigRateLimitSet {
        #[allow(missing_docs)]
        pub maxUpdates: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub windowSeconds: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for LesseePayoutConfigRateLimitSet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "LesseePayoutConfigRateLimitSet(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                171u8, 99u8, 194u8, 90u8, 160u8, 122u8, 77u8, 16u8, 161u8, 132u8, 45u8,
                97u8, 2u8, 106u8, 8u8, 217u8, 81u8, 21u8, 196u8, 230u8, 137u8, 82u8,
                136u8, 104u8, 48u8, 21u8, 202u8, 68u8, 100u8, 199u8, 245u8, 15u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    maxUpdates: data.0,
                    windowSeconds: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxUpdates),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.windowSeconds),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for LesseePayoutConfigRateLimitSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&LesseePayoutConfigRateLimitSet>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &LesseePayoutConfigRateLimitSet,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `LpDeposited(address,uint256)` and selector `0xdae4417c25a93cfb86ce5fbbb8fc1630945b61afaeab4f29cf301b9a058ba914`.
```solidity
event LpDeposited(address indexed lp, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct LpDeposited {
        #[allow(missing_docs)]
        pub lp: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for LpDeposited {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "LpDeposited(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                218u8, 228u8, 65u8, 124u8, 37u8, 169u8, 60u8, 251u8, 134u8, 206u8, 95u8,
                187u8, 184u8, 252u8, 22u8, 48u8, 148u8, 91u8, 97u8, 175u8, 174u8, 171u8,
                79u8, 41u8, 207u8, 48u8, 27u8, 154u8, 5u8, 139u8, 169u8, 20u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    lp: topics.1,
                    amount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.lp.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.lp,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for LpDeposited {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&LpDeposited> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &LpDeposited) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `LpSet(address,bool)` and selector `0x442f7ab7d26bf7ba74f23e237d12876251f91d61aeb2899ad95f334fa5e7c633`.
```solidity
event LpSet(address indexed lp, bool allowed);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct LpSet {
        #[allow(missing_docs)]
        pub lp: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub allowed: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for LpSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "LpSet(address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                68u8, 47u8, 122u8, 183u8, 210u8, 107u8, 247u8, 186u8, 116u8, 242u8, 62u8,
                35u8, 125u8, 18u8, 135u8, 98u8, 81u8, 249u8, 29u8, 97u8, 174u8, 178u8,
                137u8, 154u8, 217u8, 95u8, 51u8, 79u8, 165u8, 231u8, 198u8, 51u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    lp: topics.1,
                    allowed: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.allowed,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.lp.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.lp,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for LpSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&LpSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &LpSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `LpWithdrawn(address,uint256)` and selector `0x44282e2a4bbb86b9f8089d1086f4e0df273054eab62cdbda18f647cfd22a1eff`.
```solidity
event LpWithdrawn(address indexed lp, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct LpWithdrawn {
        #[allow(missing_docs)]
        pub lp: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for LpWithdrawn {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "LpWithdrawn(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                68u8, 40u8, 46u8, 42u8, 75u8, 187u8, 134u8, 185u8, 248u8, 8u8, 157u8,
                16u8, 134u8, 244u8, 224u8, 223u8, 39u8, 48u8, 84u8, 234u8, 182u8, 44u8,
                219u8, 218u8, 24u8, 246u8, 71u8, 207u8, 210u8, 42u8, 30u8, 255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    lp: topics.1,
                    amount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.lp.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.lp,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for LpWithdrawn {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&LpWithdrawn> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &LpWithdrawn) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub oldOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.oldOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oldOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `PayoutConfigUpdated(uint256,uint256,address,address)` and selector `0xd7cf75dc193207f6484b7bd6c4fc469f3b6b733d2cbcee403975287b015dc499`.
```solidity
event PayoutConfigUpdated(uint256 indexed leaseId, uint256 targetChainId, address targetToken, address beneficiary);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct PayoutConfigUpdated {
        #[allow(missing_docs)]
        pub leaseId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub targetChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub targetToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub beneficiary: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for PayoutConfigUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "PayoutConfigUpdated(uint256,uint256,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                215u8, 207u8, 117u8, 220u8, 25u8, 50u8, 7u8, 246u8, 72u8, 75u8, 123u8,
                214u8, 196u8, 252u8, 70u8, 159u8, 59u8, 107u8, 115u8, 61u8, 44u8, 188u8,
                238u8, 64u8, 57u8, 117u8, 40u8, 123u8, 1u8, 93u8, 196u8, 153u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    leaseId: topics.1,
                    targetChainId: data.0,
                    targetToken: data.1,
                    beneficiary: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.targetChainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.targetToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.beneficiary,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.leaseId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.leaseId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for PayoutConfigUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&PayoutConfigUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &PayoutConfigUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ProtocolFlatFeeFloorSet(uint64)` and selector `0x286cd7c5781e6df376daa59ab207e1a0b1ece95fafc298f9ab69a188f49ff2d5`.
```solidity
event ProtocolFlatFeeFloorSet(uint64 floorFlatFee);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ProtocolFlatFeeFloorSet {
        #[allow(missing_docs)]
        pub floorFlatFee: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ProtocolFlatFeeFloorSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ProtocolFlatFeeFloorSet(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                40u8, 108u8, 215u8, 197u8, 120u8, 30u8, 109u8, 243u8, 118u8, 218u8,
                165u8, 154u8, 178u8, 7u8, 225u8, 160u8, 177u8, 236u8, 233u8, 95u8, 175u8,
                194u8, 152u8, 249u8, 171u8, 105u8, 161u8, 136u8, 244u8, 159u8, 242u8,
                213u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { floorFlatFee: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.floorFlatFee),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ProtocolFlatFeeFloorSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ProtocolFlatFeeFloorSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &ProtocolFlatFeeFloorSet,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ProtocolFloorSet(uint256)` and selector `0xf7cfae9870e1307a0791d6418d9e78abd1731a1c03606813906b474d307ead56`.
```solidity
event ProtocolFloorSet(uint256 floorPpm);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ProtocolFloorSet {
        #[allow(missing_docs)]
        pub floorPpm: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ProtocolFloorSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ProtocolFloorSet(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                247u8, 207u8, 174u8, 152u8, 112u8, 225u8, 48u8, 122u8, 7u8, 145u8, 214u8,
                65u8, 141u8, 158u8, 120u8, 171u8, 209u8, 115u8, 26u8, 28u8, 3u8, 96u8,
                104u8, 19u8, 144u8, 107u8, 71u8, 77u8, 48u8, 126u8, 173u8, 86u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { floorPpm: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.floorPpm),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ProtocolFloorSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ProtocolFloorSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ProtocolFloorSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ProtocolMaxLeaseDurationSet(uint32)` and selector `0x1fb3b38e402009f1bbd24d0a70005a7a9a055b3f5b546c8b21f815470a9c2ec4`.
```solidity
event ProtocolMaxLeaseDurationSet(uint32 maxLeaseDurationSeconds);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ProtocolMaxLeaseDurationSet {
        #[allow(missing_docs)]
        pub maxLeaseDurationSeconds: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ProtocolMaxLeaseDurationSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ProtocolMaxLeaseDurationSet(uint32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                31u8, 179u8, 179u8, 142u8, 64u8, 32u8, 9u8, 241u8, 187u8, 210u8, 77u8,
                10u8, 112u8, 0u8, 90u8, 122u8, 154u8, 5u8, 91u8, 63u8, 91u8, 84u8, 108u8,
                139u8, 33u8, 248u8, 21u8, 71u8, 10u8, 156u8, 46u8, 196u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    maxLeaseDurationSeconds: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.maxLeaseDurationSeconds,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ProtocolMaxLeaseDurationSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ProtocolMaxLeaseDurationSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &ProtocolMaxLeaseDurationSet,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ProtocolPnlUpdated(int256,int256,uint8)` and selector `0x43991e1e1cfb2eed6c9dc37a7a848622f8e3f75bc38d532a00eaf026cd87a014`.
```solidity
event ProtocolPnlUpdated(int256 pnl, int256 delta, UntronV3Index.PnlReason reason);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ProtocolPnlUpdated {
        #[allow(missing_docs)]
        pub pnl: alloy::sol_types::private::primitives::aliases::I256,
        #[allow(missing_docs)]
        pub delta: alloy::sol_types::private::primitives::aliases::I256,
        #[allow(missing_docs)]
        pub reason: <UntronV3Index::PnlReason as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ProtocolPnlUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Int<256>,
                alloy::sol_types::sol_data::Int<256>,
                UntronV3Index::PnlReason,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ProtocolPnlUpdated(int256,int256,uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                67u8, 153u8, 30u8, 30u8, 28u8, 251u8, 46u8, 237u8, 108u8, 157u8, 195u8,
                122u8, 122u8, 132u8, 134u8, 34u8, 248u8, 227u8, 247u8, 91u8, 195u8,
                141u8, 83u8, 42u8, 0u8, 234u8, 240u8, 38u8, 205u8, 135u8, 160u8, 20u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    pnl: data.0,
                    delta: data.1,
                    reason: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.pnl),
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.delta),
                    <UntronV3Index::PnlReason as alloy_sol_types::SolType>::tokenize(
                        &self.reason,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ProtocolPnlUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ProtocolPnlUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ProtocolPnlUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RealtorLeaseRateLimitSet(address,uint256,uint256)` and selector `0x61c49ab6bb1ef59191a746afce7d2731d4d9b0fafdab8d63f02fe44169532dc5`.
```solidity
event RealtorLeaseRateLimitSet(address indexed realtor, uint256 maxLeases, uint256 windowSeconds);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RealtorLeaseRateLimitSet {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub maxLeases: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub windowSeconds: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RealtorLeaseRateLimitSet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RealtorLeaseRateLimitSet(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                97u8, 196u8, 154u8, 182u8, 187u8, 30u8, 245u8, 145u8, 145u8, 167u8, 70u8,
                175u8, 206u8, 125u8, 39u8, 49u8, 212u8, 217u8, 176u8, 250u8, 253u8,
                171u8, 141u8, 99u8, 240u8, 47u8, 228u8, 65u8, 105u8, 83u8, 45u8, 197u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    realtor: topics.1,
                    maxLeases: data.0,
                    windowSeconds: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxLeases),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.windowSeconds),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.realtor.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.realtor,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RealtorLeaseRateLimitSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RealtorLeaseRateLimitSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &RealtorLeaseRateLimitSet,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RealtorMaxLeaseDurationSet(address,uint32)` and selector `0xb1d8eff9485816bb38ceecf317a3fda05597bc5b38f2f22df96c0ebd5dc236ee`.
```solidity
event RealtorMaxLeaseDurationSet(address indexed realtor, uint32 maxLeaseDurationSeconds);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RealtorMaxLeaseDurationSet {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub maxLeaseDurationSeconds: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RealtorMaxLeaseDurationSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RealtorMaxLeaseDurationSet(address,uint32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                177u8, 216u8, 239u8, 249u8, 72u8, 88u8, 22u8, 187u8, 56u8, 206u8, 236u8,
                243u8, 23u8, 163u8, 253u8, 160u8, 85u8, 151u8, 188u8, 91u8, 56u8, 242u8,
                242u8, 45u8, 249u8, 108u8, 14u8, 189u8, 93u8, 194u8, 54u8, 238u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    realtor: topics.1,
                    maxLeaseDurationSeconds: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.maxLeaseDurationSeconds,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.realtor.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.realtor,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RealtorMaxLeaseDurationSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RealtorMaxLeaseDurationSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &RealtorMaxLeaseDurationSet,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RealtorMinFeeSet(address,uint256)` and selector `0x0aa82626f19bb5d4196202b01f2fee431b95e88cb054484b987d650d91928ada`.
```solidity
event RealtorMinFeeSet(address indexed realtor, uint256 minFeePpm);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RealtorMinFeeSet {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub minFeePpm: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RealtorMinFeeSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RealtorMinFeeSet(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                10u8, 168u8, 38u8, 38u8, 241u8, 155u8, 181u8, 212u8, 25u8, 98u8, 2u8,
                176u8, 31u8, 47u8, 238u8, 67u8, 27u8, 149u8, 232u8, 140u8, 176u8, 84u8,
                72u8, 75u8, 152u8, 125u8, 101u8, 13u8, 145u8, 146u8, 138u8, 218u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    realtor: topics.1,
                    minFeePpm: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.minFeePpm),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.realtor.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.realtor,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RealtorMinFeeSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RealtorMinFeeSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RealtorMinFeeSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RealtorMinFlatFeeSet(address,uint64)` and selector `0x2f4817318242d1b86700a426f7ced049c68059253c0a721e01b9718f4527bef6`.
```solidity
event RealtorMinFlatFeeSet(address indexed realtor, uint64 minFlatFee);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RealtorMinFlatFeeSet {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub minFlatFee: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RealtorMinFlatFeeSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RealtorMinFlatFeeSet(address,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8, 72u8, 23u8, 49u8, 130u8, 66u8, 209u8, 184u8, 103u8, 0u8, 164u8,
                38u8, 247u8, 206u8, 208u8, 73u8, 198u8, 128u8, 89u8, 37u8, 60u8, 10u8,
                114u8, 30u8, 1u8, 185u8, 113u8, 143u8, 69u8, 39u8, 190u8, 246u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    realtor: topics.1,
                    minFlatFee: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.minFlatFee),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.realtor.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.realtor,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RealtorMinFlatFeeSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RealtorMinFlatFeeSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RealtorMinFlatFeeSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RealtorSet(address,bool)` and selector `0x2080a756444d2af0f9fb4f87db7af63cd6e23b7a1203cbe9ab0972ee05d1eafd`.
```solidity
event RealtorSet(address indexed realtor, bool allowed);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RealtorSet {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub allowed: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RealtorSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RealtorSet(address,bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                32u8, 128u8, 167u8, 86u8, 68u8, 77u8, 42u8, 240u8, 249u8, 251u8, 79u8,
                135u8, 219u8, 122u8, 246u8, 60u8, 214u8, 226u8, 59u8, 122u8, 18u8, 3u8,
                203u8, 233u8, 171u8, 9u8, 114u8, 238u8, 5u8, 209u8, 234u8, 253u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    realtor: topics.1,
                    allowed: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.allowed,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.realtor.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.realtor,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RealtorSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RealtorSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RealtorSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SwapRateSet(address,uint256)` and selector `0xa8d3b3213b7f8244e5b04551db9aaabccc21d6212c43c3b3143bcde97ca853ce`.
```solidity
event SwapRateSet(address indexed targetToken, uint256 ratePpm);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SwapRateSet {
        #[allow(missing_docs)]
        pub targetToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ratePpm: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SwapRateSet {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "SwapRateSet(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                168u8, 211u8, 179u8, 33u8, 59u8, 127u8, 130u8, 68u8, 229u8, 176u8, 69u8,
                81u8, 219u8, 154u8, 170u8, 188u8, 204u8, 33u8, 214u8, 33u8, 44u8, 67u8,
                195u8, 179u8, 20u8, 59u8, 205u8, 233u8, 124u8, 168u8, 83u8, 206u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    targetToken: topics.1,
                    ratePpm: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.ratePpm),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.targetToken.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.targetToken,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SwapRateSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SwapRateSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SwapRateSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `TokensRescued(address,uint256)` and selector `0x68f67de89e96b13a3ea058af5fd44cc125efceb528482d539c7b43db2faa066e`.
```solidity
event TokensRescued(address token, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TokensRescued {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TokensRescued {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TokensRescued(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                104u8, 246u8, 125u8, 232u8, 158u8, 150u8, 177u8, 58u8, 62u8, 160u8, 88u8,
                175u8, 95u8, 212u8, 76u8, 193u8, 37u8, 239u8, 206u8, 181u8, 40u8, 72u8,
                45u8, 83u8, 156u8, 123u8, 67u8, 219u8, 47u8, 170u8, 6u8, 110u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    token: data.0,
                    amount: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TokensRescued {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TokensRescued> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TokensRescued) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `TronReaderSet(address)` and selector `0x5d29693e63b3a084e56893ce8c7f5ef5dc8213da41070084e6b1c4370abd64c4`.
```solidity
event TronReaderSet(address indexed reader);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TronReaderSet {
        #[allow(missing_docs)]
        pub reader: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TronReaderSet {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "TronReaderSet(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8, 41u8, 105u8, 62u8, 99u8, 179u8, 160u8, 132u8, 229u8, 104u8, 147u8,
                206u8, 140u8, 127u8, 94u8, 245u8, 220u8, 130u8, 19u8, 218u8, 65u8, 7u8,
                0u8, 132u8, 230u8, 177u8, 196u8, 55u8, 10u8, 189u8, 100u8, 196u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { reader: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.reader.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.reader,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TronReaderSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TronReaderSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TronReaderSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `TronUsdtSet(address)` and selector `0x9f5e1d13045d272fbe74ce4d08e91982a5c57784391ae6a199eecdcf63949ffe`.
```solidity
event TronUsdtSet(address indexed tronUsdt);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TronUsdtSet {
        #[allow(missing_docs)]
        pub tronUsdt: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TronUsdtSet {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "TronUsdtSet(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                159u8, 94u8, 29u8, 19u8, 4u8, 93u8, 39u8, 47u8, 190u8, 116u8, 206u8,
                77u8, 8u8, 233u8, 25u8, 130u8, 165u8, 197u8, 119u8, 132u8, 57u8, 26u8,
                230u8, 161u8, 153u8, 238u8, 205u8, 207u8, 99u8, 148u8, 159u8, 254u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { tronUsdt: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.tronUsdt.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.tronUsdt,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TronUsdtSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TronUsdtSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TronUsdtSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `UsdtSet(address)` and selector `0xa44f293dfa9228916345a6016220f304fd4e10c2f25ef62c896b4946926a70f4`.
```solidity
event UsdtSet(address indexed usdt);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct UsdtSet {
        #[allow(missing_docs)]
        pub usdt: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UsdtSet {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "UsdtSet(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                164u8, 79u8, 41u8, 61u8, 250u8, 146u8, 40u8, 145u8, 99u8, 69u8, 166u8,
                1u8, 98u8, 32u8, 243u8, 4u8, 253u8, 78u8, 16u8, 194u8, 242u8, 94u8,
                246u8, 44u8, 137u8, 107u8, 73u8, 70u8, 146u8, 106u8, 112u8, 244u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { usdt: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.usdt.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.usdt,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for UsdtSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UsdtSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &UsdtSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address controllerAddress, bytes1 create2Prefix, address receiverImplOverride);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub controllerAddress: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub create2Prefix: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub receiverImplOverride: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.controllerAddress,
                        value.create2Prefix,
                        value.receiverImplOverride,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        controllerAddress: tuple.0,
                        create2Prefix: tuple.1,
                        receiverImplOverride: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.controllerAddress,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.create2Prefix),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiverImplOverride,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `CONTROLLER_ADDRESS()` and selector `0xb98e631d`.
```solidity
function CONTROLLER_ADDRESS() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CONTROLLER_ADDRESSCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`CONTROLLER_ADDRESS()`](CONTROLLER_ADDRESSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CONTROLLER_ADDRESSReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CONTROLLER_ADDRESSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: CONTROLLER_ADDRESSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for CONTROLLER_ADDRESSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<CONTROLLER_ADDRESSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: CONTROLLER_ADDRESSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for CONTROLLER_ADDRESSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for CONTROLLER_ADDRESSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CONTROLLER_ADDRESS()";
            const SELECTOR: [u8; 4] = [185u8, 142u8, 99u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: CONTROLLER_ADDRESSReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: CONTROLLER_ADDRESSReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `RECEIVER_IMPL()` and selector `0xde40d89f`.
```solidity
function RECEIVER_IMPL() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RECEIVER_IMPLCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`RECEIVER_IMPL()`](RECEIVER_IMPLCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RECEIVER_IMPLReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<RECEIVER_IMPLCall> for UnderlyingRustTuple<'_> {
                fn from(value: RECEIVER_IMPLCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for RECEIVER_IMPLCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<RECEIVER_IMPLReturn> for UnderlyingRustTuple<'_> {
                fn from(value: RECEIVER_IMPLReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for RECEIVER_IMPLReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for RECEIVER_IMPLCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RECEIVER_IMPL()";
            const SELECTOR: [u8; 4] = [222u8, 64u8, 216u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: RECEIVER_IMPLReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: RECEIVER_IMPLReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `SWAP_EXECUTOR()` and selector `0x0b345879`.
```solidity
function SWAP_EXECUTOR() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SWAP_EXECUTORCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`SWAP_EXECUTOR()`](SWAP_EXECUTORCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SWAP_EXECUTORReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SWAP_EXECUTORCall> for UnderlyingRustTuple<'_> {
                fn from(value: SWAP_EXECUTORCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SWAP_EXECUTORCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SWAP_EXECUTORReturn> for UnderlyingRustTuple<'_> {
                fn from(value: SWAP_EXECUTORReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SWAP_EXECUTORReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SWAP_EXECUTORCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SWAP_EXECUTOR()";
            const SELECTOR: [u8; 4] = [11u8, 52u8, 88u8, 121u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: SWAP_EXECUTORReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: SWAP_EXECUTORReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `bridgers(address,uint256)` and selector `0x1dbf4c61`.
```solidity
function bridgers(address, uint256) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgersCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`bridgers(address,uint256)`](bridgersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct bridgersReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgersCall> for UnderlyingRustTuple<'_> {
                fn from(value: bridgersCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<bridgersReturn> for UnderlyingRustTuple<'_> {
                fn from(value: bridgersReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for bridgersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for bridgersCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "bridgers(address,uint256)";
            const SELECTOR: [u8; 4] = [29u8, 191u8, 76u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: bridgersReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: bridgersReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `claimLocatorByLease(uint256,uint256)` and selector `0x718fbc25`.
```solidity
function claimLocatorByLease(uint256, uint256) external view returns (address targetToken, uint256 queueIndex);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimLocatorByLeaseCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`claimLocatorByLease(uint256,uint256)`](claimLocatorByLeaseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimLocatorByLeaseReturn {
        #[allow(missing_docs)]
        pub targetToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub queueIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimLocatorByLeaseCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimLocatorByLeaseCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimLocatorByLeaseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimLocatorByLeaseReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimLocatorByLeaseReturn) -> Self {
                    (value.targetToken, value.queueIndex)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimLocatorByLeaseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        targetToken: tuple.0,
                        queueIndex: tuple.1,
                    }
                }
            }
        }
        impl claimLocatorByLeaseReturn {
            fn _tokenize(
                &self,
            ) -> <claimLocatorByLeaseCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.targetToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.queueIndex),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimLocatorByLeaseCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimLocatorByLeaseReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimLocatorByLease(uint256,uint256)";
            const SELECTOR: [u8; 4] = [113u8, 143u8, 188u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                claimLocatorByLeaseReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `claimQueueLength(address)` and selector `0x3627720d`.
```solidity
function claimQueueLength(address targetToken) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimQueueLengthCall {
        #[allow(missing_docs)]
        pub targetToken: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`claimQueueLength(address)`](claimQueueLengthCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimQueueLengthReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimQueueLengthCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimQueueLengthCall) -> Self {
                    (value.targetToken,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimQueueLengthCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { targetToken: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimQueueLengthReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimQueueLengthReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimQueueLengthReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimQueueLengthCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimQueueLength(address)";
            const SELECTOR: [u8; 4] = [54u8, 39u8, 114u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.targetToken,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: claimQueueLengthReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: claimQueueLengthReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `claimsByTargetToken(address,uint256)` and selector `0x78aaf25e`.
```solidity
function claimsByTargetToken(address, uint256) external view returns (uint256 claimId, uint256 amountUsdt, uint256 leaseId, uint256 targetChainId, address beneficiary);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimsByTargetTokenCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`claimsByTargetToken(address,uint256)`](claimsByTargetTokenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimsByTargetTokenReturn {
        #[allow(missing_docs)]
        pub claimId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amountUsdt: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub leaseId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub targetChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub beneficiary: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimsByTargetTokenCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimsByTargetTokenCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimsByTargetTokenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimsByTargetTokenReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimsByTargetTokenReturn) -> Self {
                    (
                        value.claimId,
                        value.amountUsdt,
                        value.leaseId,
                        value.targetChainId,
                        value.beneficiary,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimsByTargetTokenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        claimId: tuple.0,
                        amountUsdt: tuple.1,
                        leaseId: tuple.2,
                        targetChainId: tuple.3,
                        beneficiary: tuple.4,
                    }
                }
            }
        }
        impl claimsByTargetTokenReturn {
            fn _tokenize(
                &self,
            ) -> <claimsByTargetTokenCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountUsdt),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.targetChainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.beneficiary,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimsByTargetTokenCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimsByTargetTokenReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimsByTargetToken(address,uint256)";
            const SELECTOR: [u8; 4] = [120u8, 170u8, 242u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                claimsByTargetTokenReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `controllerEventAt(uint256)` and selector `0x7c4c4feb`.
```solidity
function controllerEventAt(uint256 idx) external view returns (bytes32 sig, bytes memory data, uint64 blockNumber, uint64 blockTimestamp);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct controllerEventAtCall {
        #[allow(missing_docs)]
        pub idx: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`controllerEventAt(uint256)`](controllerEventAtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct controllerEventAtReturn {
        #[allow(missing_docs)]
        pub sig: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub blockNumber: u64,
        #[allow(missing_docs)]
        pub blockTimestamp: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<controllerEventAtCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: controllerEventAtCall) -> Self {
                    (value.idx,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for controllerEventAtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { idx: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
                u64,
                u64,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<controllerEventAtReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: controllerEventAtReturn) -> Self {
                    (value.sig, value.data, value.blockNumber, value.blockTimestamp)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for controllerEventAtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sig: tuple.0,
                        data: tuple.1,
                        blockNumber: tuple.2,
                        blockTimestamp: tuple.3,
                    }
                }
            }
        }
        impl controllerEventAtReturn {
            fn _tokenize(
                &self,
            ) -> <controllerEventAtCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sig),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockTimestamp),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for controllerEventAtCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = controllerEventAtReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "controllerEventAt(uint256)";
            const SELECTOR: [u8; 4] = [124u8, 76u8, 79u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.idx),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                controllerEventAtReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `controllerEventsLength()` and selector `0xa6e92f3c`.
```solidity
function controllerEventsLength() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct controllerEventsLengthCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`controllerEventsLength()`](controllerEventsLengthCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct controllerEventsLengthReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<controllerEventsLengthCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: controllerEventsLengthCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for controllerEventsLengthCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<controllerEventsLengthReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: controllerEventsLengthReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for controllerEventsLengthReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for controllerEventsLengthCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "controllerEventsLength()";
            const SELECTOR: [u8; 4] = [166u8, 233u8, 47u8, 60u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: controllerEventsLengthReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: controllerEventsLengthReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `createLease(bytes32,address,uint64,uint32,uint64,uint256,address,address)` and selector `0x7e49447f`.
```solidity
function createLease(bytes32 receiverSalt, address lessee, uint64 nukeableAfter, uint32 leaseFeePpm, uint64 flatFee, uint256 targetChainId, address targetToken, address beneficiary) external returns (uint256 leaseId, uint256 leaseNumber);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createLeaseCall {
        #[allow(missing_docs)]
        pub receiverSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub lessee: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nukeableAfter: u64,
        #[allow(missing_docs)]
        pub leaseFeePpm: u32,
        #[allow(missing_docs)]
        pub flatFee: u64,
        #[allow(missing_docs)]
        pub targetChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub targetToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub beneficiary: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`createLease(bytes32,address,uint64,uint32,uint64,uint256,address,address)`](createLeaseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createLeaseReturn {
        #[allow(missing_docs)]
        pub leaseId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub leaseNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                u64,
                u32,
                u64,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createLeaseCall> for UnderlyingRustTuple<'_> {
                fn from(value: createLeaseCall) -> Self {
                    (
                        value.receiverSalt,
                        value.lessee,
                        value.nukeableAfter,
                        value.leaseFeePpm,
                        value.flatFee,
                        value.targetChainId,
                        value.targetToken,
                        value.beneficiary,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createLeaseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        receiverSalt: tuple.0,
                        lessee: tuple.1,
                        nukeableAfter: tuple.2,
                        leaseFeePpm: tuple.3,
                        flatFee: tuple.4,
                        targetChainId: tuple.5,
                        targetToken: tuple.6,
                        beneficiary: tuple.7,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createLeaseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: createLeaseReturn) -> Self {
                    (value.leaseId, value.leaseNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createLeaseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        leaseId: tuple.0,
                        leaseNumber: tuple.1,
                    }
                }
            }
        }
        impl createLeaseReturn {
            fn _tokenize(
                &self,
            ) -> <createLeaseCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseNumber),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createLeaseCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createLeaseReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createLease(bytes32,address,uint64,uint32,uint64,uint256,address,address)";
            const SELECTOR: [u8; 4] = [126u8, 73u8, 68u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.receiverSalt),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.lessee,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.nukeableAfter),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseFeePpm),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.flatFee),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.targetChainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.targetToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.beneficiary,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                createLeaseReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `deposit(uint256)` and selector `0xb6b55f25`.
```solidity
function deposit(uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositCall {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`deposit(uint256)`](depositCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositCall> for UnderlyingRustTuple<'_> {
                fn from(value: depositCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositReturn> for UnderlyingRustTuple<'_> {
                fn from(value: depositReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl depositReturn {
            fn _tokenize(
                &self,
            ) -> <depositCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deposit(uint256)";
            const SELECTOR: [u8; 4] = [182u8, 181u8, 95u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                depositReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `depositProcessed(bytes32)` and selector `0x88927296`.
```solidity
function depositProcessed(bytes32) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositProcessedCall(pub alloy::sol_types::private::FixedBytes<32>);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`depositProcessed(bytes32)`](depositProcessedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositProcessedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositProcessedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositProcessedCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositProcessedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositProcessedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositProcessedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositProcessedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositProcessedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "depositProcessed(bytes32)";
            const SELECTOR: [u8; 4] = [136u8, 146u8, 114u8, 150u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: depositProcessedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: depositProcessedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `depositToPnl(uint256)` and selector `0x46de406f`.
```solidity
function depositToPnl(uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositToPnlCall {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`depositToPnl(uint256)`](depositToPnlCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositToPnlReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositToPnlCall> for UnderlyingRustTuple<'_> {
                fn from(value: depositToPnlCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositToPnlCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositToPnlReturn> for UnderlyingRustTuple<'_> {
                fn from(value: depositToPnlReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositToPnlReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl depositToPnlReturn {
            fn _tokenize(
                &self,
            ) -> <depositToPnlCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositToPnlCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositToPnlReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "depositToPnl(uint256)";
            const SELECTOR: [u8; 4] = [70u8, 222u8, 64u8, 111u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                depositToPnlReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `effectiveLeaseRateLimit(address)` and selector `0x4341fc86`.
```solidity
function effectiveLeaseRateLimit(address realtor) external view returns (bool enabled, uint256 maxLeases, uint256 windowSeconds);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct effectiveLeaseRateLimitCall {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`effectiveLeaseRateLimit(address)`](effectiveLeaseRateLimitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct effectiveLeaseRateLimitReturn {
        #[allow(missing_docs)]
        pub enabled: bool,
        #[allow(missing_docs)]
        pub maxLeases: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub windowSeconds: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<effectiveLeaseRateLimitCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: effectiveLeaseRateLimitCall) -> Self {
                    (value.realtor,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for effectiveLeaseRateLimitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { realtor: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                bool,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<effectiveLeaseRateLimitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: effectiveLeaseRateLimitReturn) -> Self {
                    (value.enabled, value.maxLeases, value.windowSeconds)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for effectiveLeaseRateLimitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        enabled: tuple.0,
                        maxLeases: tuple.1,
                        windowSeconds: tuple.2,
                    }
                }
            }
        }
        impl effectiveLeaseRateLimitReturn {
            fn _tokenize(
                &self,
            ) -> <effectiveLeaseRateLimitCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.enabled,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxLeases),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.windowSeconds),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for effectiveLeaseRateLimitCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = effectiveLeaseRateLimitReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "effectiveLeaseRateLimit(address)";
            const SELECTOR: [u8; 4] = [67u8, 65u8, 252u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.realtor,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                effectiveLeaseRateLimitReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `effectiveMaxLeaseDurationSeconds(address)` and selector `0x8842c573`.
```solidity
function effectiveMaxLeaseDurationSeconds(address realtor) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct effectiveMaxLeaseDurationSecondsCall {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`effectiveMaxLeaseDurationSeconds(address)`](effectiveMaxLeaseDurationSecondsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct effectiveMaxLeaseDurationSecondsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<effectiveMaxLeaseDurationSecondsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: effectiveMaxLeaseDurationSecondsCall) -> Self {
                    (value.realtor,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for effectiveMaxLeaseDurationSecondsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { realtor: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<effectiveMaxLeaseDurationSecondsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: effectiveMaxLeaseDurationSecondsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for effectiveMaxLeaseDurationSecondsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for effectiveMaxLeaseDurationSecondsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "effectiveMaxLeaseDurationSeconds(address)";
            const SELECTOR: [u8; 4] = [136u8, 66u8, 197u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.realtor,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: effectiveMaxLeaseDurationSecondsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: effectiveMaxLeaseDurationSecondsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `eip712Domain()` and selector `0x84b0196e`.
```solidity
function eip712Domain() external view returns (bytes1 fields, string memory name, string memory version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] memory extensions);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`eip712Domain()`](eip712DomainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eip712DomainReturn {
        #[allow(missing_docs)]
        pub fields: alloy::sol_types::private::FixedBytes<1>,
        #[allow(missing_docs)]
        pub name: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub version: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub chainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub verifyingContract: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub extensions: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainCall> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<1>,
                alloy::sol_types::private::String,
                alloy::sol_types::private::String,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eip712DomainReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eip712DomainReturn) -> Self {
                    (
                        value.fields,
                        value.name,
                        value.version,
                        value.chainId,
                        value.verifyingContract,
                        value.salt,
                        value.extensions,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eip712DomainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fields: tuple.0,
                        name: tuple.1,
                        version: tuple.2,
                        chainId: tuple.3,
                        verifyingContract: tuple.4,
                        salt: tuple.5,
                        extensions: tuple.6,
                    }
                }
            }
        }
        impl eip712DomainReturn {
            fn _tokenize(
                &self,
            ) -> <eip712DomainCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        1,
                    > as alloy_sol_types::SolType>::tokenize(&self.fields),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.name,
                    ),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.version,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.chainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.verifyingContract,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.salt),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(&self.extensions),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eip712DomainCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = eip712DomainReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<1>,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eip712Domain()";
            const SELECTOR: [u8; 4] = [132u8, 176u8, 25u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                eip712DomainReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `enqueueClaim(address,uint256,uint256,uint256,address)` and selector `0xc0283e62`.
```solidity
function enqueueClaim(address targetToken, uint256 amountUsdt, uint256 leaseId, uint256 targetChainId, address beneficiary) external returns (uint256 claimIndex);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enqueueClaimCall {
        #[allow(missing_docs)]
        pub targetToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amountUsdt: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub leaseId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub targetChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub beneficiary: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`enqueueClaim(address,uint256,uint256,uint256,address)`](enqueueClaimCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enqueueClaimReturn {
        #[allow(missing_docs)]
        pub claimIndex: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enqueueClaimCall> for UnderlyingRustTuple<'_> {
                fn from(value: enqueueClaimCall) -> Self {
                    (
                        value.targetToken,
                        value.amountUsdt,
                        value.leaseId,
                        value.targetChainId,
                        value.beneficiary,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for enqueueClaimCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        targetToken: tuple.0,
                        amountUsdt: tuple.1,
                        leaseId: tuple.2,
                        targetChainId: tuple.3,
                        beneficiary: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enqueueClaimReturn> for UnderlyingRustTuple<'_> {
                fn from(value: enqueueClaimReturn) -> Self {
                    (value.claimIndex,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for enqueueClaimReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { claimIndex: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for enqueueClaimCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "enqueueClaim(address,uint256,uint256,uint256,address)";
            const SELECTOR: [u8; 4] = [192u8, 40u8, 62u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.targetToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountUsdt),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.targetChainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.beneficiary,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: enqueueClaimReturn = r.into();
                        r.claimIndex
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: enqueueClaimReturn = r.into();
                        r.claimIndex
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `eventChainTip()` and selector `0x4d53e931`.
```solidity
function eventChainTip() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventChainTipCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`eventChainTip()`](eventChainTipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventChainTipReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventChainTipCall> for UnderlyingRustTuple<'_> {
                fn from(value: eventChainTipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventChainTipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventChainTipReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eventChainTipReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventChainTipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eventChainTipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eventChainTip()";
            const SELECTOR: [u8; 4] = [77u8, 83u8, 233u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: eventChainTipReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: eventChainTipReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `eventSeq()` and selector `0xe24d5c35`.
```solidity
function eventSeq() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventSeqCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`eventSeq()`](eventSeqCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventSeqReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventSeqCall> for UnderlyingRustTuple<'_> {
                fn from(value: eventSeqCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventSeqCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventSeqReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eventSeqReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventSeqReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eventSeqCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eventSeq()";
            const SELECTOR: [u8; 4] = [226u8, 77u8, 92u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: eventSeqReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: eventSeqReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `evmToTron(address)` and selector `0xdb14fb41`.
```solidity
function evmToTron(address a) external pure returns (bytes21 tron);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct evmToTronCall {
        #[allow(missing_docs)]
        pub a: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`evmToTron(address)`](evmToTronCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct evmToTronReturn {
        #[allow(missing_docs)]
        pub tron: alloy::sol_types::private::FixedBytes<21>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<evmToTronCall> for UnderlyingRustTuple<'_> {
                fn from(value: evmToTronCall) -> Self {
                    (value.a,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for evmToTronCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { a: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<21>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<21>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<evmToTronReturn> for UnderlyingRustTuple<'_> {
                fn from(value: evmToTronReturn) -> Self {
                    (value.tron,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for evmToTronReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tron: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for evmToTronCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<21>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<21>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "evmToTron(address)";
            const SELECTOR: [u8; 4] = [219u8, 20u8, 251u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.a,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        21,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: evmToTronReturn = r.into();
                        r.tron
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: evmToTronReturn = r.into();
                        r.tron
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `exposedDecodeEventChainTip(bytes)` and selector `0x89f297bd`.
```solidity
function exposedDecodeEventChainTip(bytes memory data) external pure returns (bytes32 tip);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct exposedDecodeEventChainTipCall {
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`exposedDecodeEventChainTip(bytes)`](exposedDecodeEventChainTipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct exposedDecodeEventChainTipReturn {
        #[allow(missing_docs)]
        pub tip: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exposedDecodeEventChainTipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: exposedDecodeEventChainTipCall) -> Self {
                    (value.data,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for exposedDecodeEventChainTipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { data: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exposedDecodeEventChainTipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: exposedDecodeEventChainTipReturn) -> Self {
                    (value.tip,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for exposedDecodeEventChainTipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tip: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for exposedDecodeEventChainTipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "exposedDecodeEventChainTip(bytes)";
            const SELECTOR: [u8; 4] = [137u8, 242u8, 151u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: exposedDecodeEventChainTipReturn = r.into();
                        r.tip
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: exposedDecodeEventChainTipReturn = r.into();
                        r.tip
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `exposedProcessReceiverPulled(bytes32,address,uint256,uint64)` and selector `0x38ee72d0`.
```solidity
function exposedProcessReceiverPulled(bytes32 receiverSalt, address token, uint256 usdtAmount, uint64 dumpTimestamp) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct exposedProcessReceiverPulledCall {
        #[allow(missing_docs)]
        pub receiverSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub usdtAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub dumpTimestamp: u64,
    }
    ///Container type for the return parameters of the [`exposedProcessReceiverPulled(bytes32,address,uint256,uint64)`](exposedProcessReceiverPulledCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct exposedProcessReceiverPulledReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                u64,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exposedProcessReceiverPulledCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: exposedProcessReceiverPulledCall) -> Self {
                    (
                        value.receiverSalt,
                        value.token,
                        value.usdtAmount,
                        value.dumpTimestamp,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for exposedProcessReceiverPulledCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        receiverSalt: tuple.0,
                        token: tuple.1,
                        usdtAmount: tuple.2,
                        dumpTimestamp: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<exposedProcessReceiverPulledReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: exposedProcessReceiverPulledReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for exposedProcessReceiverPulledReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl exposedProcessReceiverPulledReturn {
            fn _tokenize(
                &self,
            ) -> <exposedProcessReceiverPulledCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for exposedProcessReceiverPulledCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = exposedProcessReceiverPulledReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "exposedProcessReceiverPulled(bytes32,address,uint256,uint64)";
            const SELECTOR: [u8; 4] = [56u8, 238u8, 114u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.receiverSalt),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.usdtAmount),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.dumpTimestamp),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                exposedProcessReceiverPulledReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fill(address,uint256,(address,uint256,bytes)[])` and selector `0x99b49925`.
```solidity
function fill(address targetToken, uint256 maxClaims, Call[] memory calls) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fillCall {
        #[allow(missing_docs)]
        pub targetToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub maxClaims: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub calls: alloy::sol_types::private::Vec<
            <Call as alloy::sol_types::SolType>::RustType,
        >,
    }
    ///Container type for the return parameters of the [`fill(address,uint256,(address,uint256,bytes)[])`](fillCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fillReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<Call>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    <Call as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fillCall> for UnderlyingRustTuple<'_> {
                fn from(value: fillCall) -> Self {
                    (value.targetToken, value.maxClaims, value.calls)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fillCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        targetToken: tuple.0,
                        maxClaims: tuple.1,
                        calls: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fillReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fillReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fillReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl fillReturn {
            fn _tokenize(
                &self,
            ) -> <fillCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fillCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<Call>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = fillReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fill(address,uint256,(address,uint256,bytes)[])";
            const SELECTOR: [u8; 4] = [153u8, 180u8, 153u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.targetToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxClaims),
                    <alloy::sol_types::sol_data::Array<
                        Call,
                    > as alloy_sol_types::SolType>::tokenize(&self.calls),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                fillReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isChainDeprecated(uint256)` and selector `0x04ec4294`.
```solidity
function isChainDeprecated(uint256) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isChainDeprecatedCall(
        pub alloy::sol_types::private::primitives::aliases::U256,
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isChainDeprecated(uint256)`](isChainDeprecatedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isChainDeprecatedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isChainDeprecatedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isChainDeprecatedCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isChainDeprecatedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isChainDeprecatedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isChainDeprecatedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isChainDeprecatedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isChainDeprecatedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isChainDeprecated(uint256)";
            const SELECTOR: [u8; 4] = [4u8, 236u8, 66u8, 148u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isChainDeprecatedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isChainDeprecatedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isLpAllowed(address)` and selector `0xbc5c5950`.
```solidity
function isLpAllowed(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isLpAllowedCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isLpAllowed(address)`](isLpAllowedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isLpAllowedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isLpAllowedCall> for UnderlyingRustTuple<'_> {
                fn from(value: isLpAllowedCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isLpAllowedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isLpAllowedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isLpAllowedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isLpAllowedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isLpAllowedCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isLpAllowed(address)";
            const SELECTOR: [u8; 4] = [188u8, 92u8, 89u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isLpAllowedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isLpAllowedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isRealtor(address)` and selector `0x60b6bfdd`.
```solidity
function isRealtor(address) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isRealtorCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isRealtor(address)`](isRealtorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isRealtorReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isRealtorCall> for UnderlyingRustTuple<'_> {
                fn from(value: isRealtorCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isRealtorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isRealtorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isRealtorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isRealtorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isRealtorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isRealtor(address)";
            const SELECTOR: [u8; 4] = [96u8, 182u8, 191u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isRealtorReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isRealtorReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `lastControllerEventSeq()` and selector `0xb371fa69`.
```solidity
function lastControllerEventSeq() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastControllerEventSeqCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`lastControllerEventSeq()`](lastControllerEventSeqCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastControllerEventSeqReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastControllerEventSeqCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastControllerEventSeqCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastControllerEventSeqCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastControllerEventSeqReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastControllerEventSeqReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastControllerEventSeqReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lastControllerEventSeqCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lastControllerEventSeq()";
            const SELECTOR: [u8; 4] = [179u8, 113u8, 250u8, 105u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: lastControllerEventSeqReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: lastControllerEventSeqReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `lastControllerEventTip()` and selector `0xa6302559`.
```solidity
function lastControllerEventTip() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastControllerEventTipCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`lastControllerEventTip()`](lastControllerEventTipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastControllerEventTipReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastControllerEventTipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastControllerEventTipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastControllerEventTipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastControllerEventTipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastControllerEventTipReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastControllerEventTipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lastControllerEventTipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lastControllerEventTip()";
            const SELECTOR: [u8; 4] = [166u8, 48u8, 37u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: lastControllerEventTipReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: lastControllerEventTipReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `lastReceiverPullTimestampByToken(bytes32,address)` and selector `0xc63bbf29`.
```solidity
function lastReceiverPullTimestampByToken(bytes32, address) external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastReceiverPullTimestampByTokenCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`lastReceiverPullTimestampByToken(bytes32,address)`](lastReceiverPullTimestampByTokenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastReceiverPullTimestampByTokenReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastReceiverPullTimestampByTokenCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastReceiverPullTimestampByTokenCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastReceiverPullTimestampByTokenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastReceiverPullTimestampByTokenReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastReceiverPullTimestampByTokenReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastReceiverPullTimestampByTokenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lastReceiverPullTimestampByTokenCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lastReceiverPullTimestampByToken(bytes32,address)";
            const SELECTOR: [u8; 4] = [198u8, 59u8, 191u8, 41u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._1,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: lastReceiverPullTimestampByTokenReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: lastReceiverPullTimestampByTokenReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `leaseIdsByReceiver(bytes32)` and selector `0xd38b018b`.
```solidity
function leaseIdsByReceiver(bytes32 receiverSalt) external view returns (uint256[] memory ids);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leaseIdsByReceiverCall {
        #[allow(missing_docs)]
        pub receiverSalt: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`leaseIdsByReceiver(bytes32)`](leaseIdsByReceiverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leaseIdsByReceiverReturn {
        #[allow(missing_docs)]
        pub ids: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leaseIdsByReceiverCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: leaseIdsByReceiverCall) -> Self {
                    (value.receiverSalt,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for leaseIdsByReceiverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { receiverSalt: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leaseIdsByReceiverReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: leaseIdsByReceiverReturn) -> Self {
                    (value.ids,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for leaseIdsByReceiverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { ids: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for leaseIdsByReceiverCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "leaseIdsByReceiver(bytes32)";
            const SELECTOR: [u8; 4] = [211u8, 139u8, 1u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.receiverSalt),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: leaseIdsByReceiverReturn = r.into();
                        r.ids
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: leaseIdsByReceiverReturn = r.into();
                        r.ids
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `leaseLocatorById(uint256)` and selector `0xe8be6504`.
```solidity
function leaseLocatorById(uint256 leaseId) external view returns (bytes32 receiverSalt, uint256 leaseNumber);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leaseLocatorByIdCall {
        #[allow(missing_docs)]
        pub leaseId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`leaseLocatorById(uint256)`](leaseLocatorByIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leaseLocatorByIdReturn {
        #[allow(missing_docs)]
        pub receiverSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub leaseNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leaseLocatorByIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: leaseLocatorByIdCall) -> Self {
                    (value.leaseId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for leaseLocatorByIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { leaseId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leaseLocatorByIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: leaseLocatorByIdReturn) -> Self {
                    (value.receiverSalt, value.leaseNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for leaseLocatorByIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        receiverSalt: tuple.0,
                        leaseNumber: tuple.1,
                    }
                }
            }
        }
        impl leaseLocatorByIdReturn {
            fn _tokenize(
                &self,
            ) -> <leaseLocatorByIdCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.receiverSalt),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseNumber),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for leaseLocatorByIdCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = leaseLocatorByIdReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "leaseLocatorById(uint256)";
            const SELECTOR: [u8; 4] = [232u8, 190u8, 101u8, 4u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                leaseLocatorByIdReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `leaseNonces(uint256)` and selector `0x6c835a82`.
```solidity
function leaseNonces(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leaseNoncesCall(pub alloy::sol_types::private::primitives::aliases::U256);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`leaseNonces(uint256)`](leaseNoncesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leaseNoncesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leaseNoncesCall> for UnderlyingRustTuple<'_> {
                fn from(value: leaseNoncesCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for leaseNoncesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leaseNoncesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: leaseNoncesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for leaseNoncesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for leaseNoncesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "leaseNonces(uint256)";
            const SELECTOR: [u8; 4] = [108u8, 131u8, 90u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: leaseNoncesReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: leaseNoncesReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `leases(uint256)` and selector `0x8927a106`.
```solidity
function leases(uint256 leaseId) external view returns (bytes32 receiverSalt, address realtor, address lessee, uint64 startTime, uint64 nukeableAfter, uint32 leaseFeePpm, uint64 flatFee, uint256 recognizedRaw, uint256 backedRaw, uint256 unbackedRaw, UntronV3.PayoutConfig memory payout);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leasesCall {
        #[allow(missing_docs)]
        pub leaseId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`leases(uint256)`](leasesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leasesReturn {
        #[allow(missing_docs)]
        pub receiverSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lessee: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub startTime: u64,
        #[allow(missing_docs)]
        pub nukeableAfter: u64,
        #[allow(missing_docs)]
        pub leaseFeePpm: u32,
        #[allow(missing_docs)]
        pub flatFee: u64,
        #[allow(missing_docs)]
        pub recognizedRaw: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub backedRaw: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub unbackedRaw: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub payout: <UntronV3::PayoutConfig as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leasesCall> for UnderlyingRustTuple<'_> {
                fn from(value: leasesCall) -> Self {
                    (value.leaseId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for leasesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { leaseId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                UntronV3::PayoutConfig,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                u64,
                u64,
                u32,
                u64,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                <UntronV3::PayoutConfig as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leasesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: leasesReturn) -> Self {
                    (
                        value.receiverSalt,
                        value.realtor,
                        value.lessee,
                        value.startTime,
                        value.nukeableAfter,
                        value.leaseFeePpm,
                        value.flatFee,
                        value.recognizedRaw,
                        value.backedRaw,
                        value.unbackedRaw,
                        value.payout,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for leasesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        receiverSalt: tuple.0,
                        realtor: tuple.1,
                        lessee: tuple.2,
                        startTime: tuple.3,
                        nukeableAfter: tuple.4,
                        leaseFeePpm: tuple.5,
                        flatFee: tuple.6,
                        recognizedRaw: tuple.7,
                        backedRaw: tuple.8,
                        unbackedRaw: tuple.9,
                        payout: tuple.10,
                    }
                }
            }
        }
        impl leasesReturn {
            fn _tokenize(
                &self,
            ) -> <leasesCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.receiverSalt),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.realtor,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.lessee,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.startTime),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.nukeableAfter),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseFeePpm),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.flatFee),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.recognizedRaw),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.backedRaw),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.unbackedRaw),
                    <UntronV3::PayoutConfig as alloy_sol_types::SolType>::tokenize(
                        &self.payout,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for leasesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = leasesReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                UntronV3::PayoutConfig,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "leases(uint256)";
            const SELECTOR: [u8; 4] = [137u8, 39u8, 161u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                leasesReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `leasesByReceiver(bytes32,uint256)` and selector `0x2f83d9af`.
```solidity
function leasesByReceiver(bytes32, uint256) external view returns (bytes32 receiverSalt, address realtor, address lessee, uint64 startTime, uint64 nukeableAfter, uint32 leaseFeePpm, uint64 flatFee, uint256 recognizedRaw, uint256 backedRaw, uint256 unbackedRaw, UntronV3.PayoutConfig memory payout);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leasesByReceiverCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`leasesByReceiver(bytes32,uint256)`](leasesByReceiverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leasesByReceiverReturn {
        #[allow(missing_docs)]
        pub receiverSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub lessee: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub startTime: u64,
        #[allow(missing_docs)]
        pub nukeableAfter: u64,
        #[allow(missing_docs)]
        pub leaseFeePpm: u32,
        #[allow(missing_docs)]
        pub flatFee: u64,
        #[allow(missing_docs)]
        pub recognizedRaw: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub backedRaw: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub unbackedRaw: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub payout: <UntronV3::PayoutConfig as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leasesByReceiverCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: leasesByReceiverCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for leasesByReceiverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                UntronV3::PayoutConfig,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                u64,
                u64,
                u32,
                u64,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                <UntronV3::PayoutConfig as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leasesByReceiverReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: leasesByReceiverReturn) -> Self {
                    (
                        value.receiverSalt,
                        value.realtor,
                        value.lessee,
                        value.startTime,
                        value.nukeableAfter,
                        value.leaseFeePpm,
                        value.flatFee,
                        value.recognizedRaw,
                        value.backedRaw,
                        value.unbackedRaw,
                        value.payout,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for leasesByReceiverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        receiverSalt: tuple.0,
                        realtor: tuple.1,
                        lessee: tuple.2,
                        startTime: tuple.3,
                        nukeableAfter: tuple.4,
                        leaseFeePpm: tuple.5,
                        flatFee: tuple.6,
                        recognizedRaw: tuple.7,
                        backedRaw: tuple.8,
                        unbackedRaw: tuple.9,
                        payout: tuple.10,
                    }
                }
            }
        }
        impl leasesByReceiverReturn {
            fn _tokenize(
                &self,
            ) -> <leasesByReceiverCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.receiverSalt),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.realtor,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.lessee,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.startTime),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.nukeableAfter),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseFeePpm),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.flatFee),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.recognizedRaw),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.backedRaw),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.unbackedRaw),
                    <UntronV3::PayoutConfig as alloy_sol_types::SolType>::tokenize(
                        &self.payout,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for leasesByReceiverCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = leasesByReceiverReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                UntronV3::PayoutConfig,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "leasesByReceiver(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [47u8, 131u8, 217u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                leasesByReceiverReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `lesseePayoutConfigRateLimit()` and selector `0x481f9376`.
```solidity
function lesseePayoutConfigRateLimit() external view returns (uint256 maxUpdates, uint256 windowSeconds);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lesseePayoutConfigRateLimitCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`lesseePayoutConfigRateLimit()`](lesseePayoutConfigRateLimitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lesseePayoutConfigRateLimitReturn {
        #[allow(missing_docs)]
        pub maxUpdates: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub windowSeconds: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lesseePayoutConfigRateLimitCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: lesseePayoutConfigRateLimitCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lesseePayoutConfigRateLimitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lesseePayoutConfigRateLimitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: lesseePayoutConfigRateLimitReturn) -> Self {
                    (value.maxUpdates, value.windowSeconds)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lesseePayoutConfigRateLimitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        maxUpdates: tuple.0,
                        windowSeconds: tuple.1,
                    }
                }
            }
        }
        impl lesseePayoutConfigRateLimitReturn {
            fn _tokenize(
                &self,
            ) -> <lesseePayoutConfigRateLimitCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxUpdates),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.windowSeconds),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lesseePayoutConfigRateLimitCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = lesseePayoutConfigRateLimitReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lesseePayoutConfigRateLimit()";
            const SELECTOR: [u8; 4] = [72u8, 31u8, 147u8, 118u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                lesseePayoutConfigRateLimitReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `lpPrincipal(address)` and selector `0x4da2f899`.
```solidity
function lpPrincipal(address) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lpPrincipalCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`lpPrincipal(address)`](lpPrincipalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lpPrincipalReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lpPrincipalCall> for UnderlyingRustTuple<'_> {
                fn from(value: lpPrincipalCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for lpPrincipalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lpPrincipalReturn> for UnderlyingRustTuple<'_> {
                fn from(value: lpPrincipalReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for lpPrincipalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lpPrincipalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lpPrincipal(address)";
            const SELECTOR: [u8; 4] = [77u8, 162u8, 248u8, 153u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: lpPrincipalReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: lpPrincipalReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `nextClaimIdByLease(uint256)` and selector `0xf516a5b4`.
```solidity
function nextClaimIdByLease(uint256) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextClaimIdByLeaseCall(
        pub alloy::sol_types::private::primitives::aliases::U256,
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`nextClaimIdByLease(uint256)`](nextClaimIdByLeaseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextClaimIdByLeaseReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextClaimIdByLeaseCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: nextClaimIdByLeaseCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nextClaimIdByLeaseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextClaimIdByLeaseReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: nextClaimIdByLeaseReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nextClaimIdByLeaseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nextClaimIdByLeaseCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nextClaimIdByLease(uint256)";
            const SELECTOR: [u8; 4] = [245u8, 22u8, 165u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: nextClaimIdByLeaseReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: nextClaimIdByLeaseReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `nextControllerEventIndex()` and selector `0xf127a9b3`.
```solidity
function nextControllerEventIndex() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextControllerEventIndexCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`nextControllerEventIndex()`](nextControllerEventIndexCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextControllerEventIndexReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextControllerEventIndexCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: nextControllerEventIndexCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nextControllerEventIndexCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextControllerEventIndexReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: nextControllerEventIndexReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nextControllerEventIndexReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nextControllerEventIndexCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nextControllerEventIndex()";
            const SELECTOR: [u8; 4] = [241u8, 39u8, 169u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: nextControllerEventIndexReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: nextControllerEventIndexReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `nextIndexByTargetToken(address)` and selector `0xeeb90259`.
```solidity
function nextIndexByTargetToken(address) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextIndexByTargetTokenCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`nextIndexByTargetToken(address)`](nextIndexByTargetTokenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextIndexByTargetTokenReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextIndexByTargetTokenCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: nextIndexByTargetTokenCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nextIndexByTargetTokenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextIndexByTargetTokenReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: nextIndexByTargetTokenReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nextIndexByTargetTokenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nextIndexByTargetTokenCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nextIndexByTargetToken(address)";
            const SELECTOR: [u8; 4] = [238u8, 185u8, 2u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: nextIndexByTargetTokenReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: nextIndexByTargetTokenReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `nextLeaseId()` and selector `0x902238e1`.
```solidity
function nextLeaseId() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextLeaseIdCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`nextLeaseId()`](nextLeaseIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextLeaseIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextLeaseIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: nextLeaseIdCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nextLeaseIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextLeaseIdReturn> for UnderlyingRustTuple<'_> {
                fn from(value: nextLeaseIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nextLeaseIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nextLeaseIdCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nextLeaseId()";
            const SELECTOR: [u8; 4] = [144u8, 34u8, 56u8, 225u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: nextLeaseIdReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: nextLeaseIdReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `nextLeaseNumberAtReceiver(bytes32)` and selector `0xca02a81e`.
```solidity
function nextLeaseNumberAtReceiver(bytes32 receiverSalt) external view returns (uint256 nextLeaseNumber);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextLeaseNumberAtReceiverCall {
        #[allow(missing_docs)]
        pub receiverSalt: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`nextLeaseNumberAtReceiver(bytes32)`](nextLeaseNumberAtReceiverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextLeaseNumberAtReceiverReturn {
        #[allow(missing_docs)]
        pub nextLeaseNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextLeaseNumberAtReceiverCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: nextLeaseNumberAtReceiverCall) -> Self {
                    (value.receiverSalt,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nextLeaseNumberAtReceiverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { receiverSalt: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextLeaseNumberAtReceiverReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: nextLeaseNumberAtReceiverReturn) -> Self {
                    (value.nextLeaseNumber,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for nextLeaseNumberAtReceiverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { nextLeaseNumber: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nextLeaseNumberAtReceiverCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nextLeaseNumberAtReceiver(bytes32)";
            const SELECTOR: [u8; 4] = [202u8, 2u8, 168u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.receiverSalt),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: nextLeaseNumberAtReceiverReturn = r.into();
                        r.nextLeaseNumber
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: nextLeaseNumberAtReceiverReturn = r.into();
                        r.nextLeaseNumber
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall;
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl pauseReturn {
            fn _tokenize(
                &self,
            ) -> <pauseCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                pauseReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: pausedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: pausedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `preEntitle(bytes32,bytes[20],bytes,bytes32[],uint256)` and selector `0xf9fdcae6`.
```solidity
function preEntitle(bytes32 receiverSalt, bytes[20] memory blocks, bytes memory encodedTx, bytes32[] memory proof, uint256 index) external returns (uint256 queueIndex, uint256 leaseId, uint256 netOut);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct preEntitleCall {
        #[allow(missing_docs)]
        pub receiverSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub blocks: [alloy::sol_types::private::Bytes; 20usize],
        #[allow(missing_docs)]
        pub encodedTx: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub proof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`preEntitle(bytes32,bytes[20],bytes,bytes32[],uint256)`](preEntitleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct preEntitleReturn {
        #[allow(missing_docs)]
        pub queueIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub leaseId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub netOut: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Bytes,
                    20usize,
                >,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                [alloy::sol_types::private::Bytes; 20usize],
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<preEntitleCall> for UnderlyingRustTuple<'_> {
                fn from(value: preEntitleCall) -> Self {
                    (
                        value.receiverSalt,
                        value.blocks,
                        value.encodedTx,
                        value.proof,
                        value.index,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for preEntitleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        receiverSalt: tuple.0,
                        blocks: tuple.1,
                        encodedTx: tuple.2,
                        proof: tuple.3,
                        index: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<preEntitleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: preEntitleReturn) -> Self {
                    (value.queueIndex, value.leaseId, value.netOut)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for preEntitleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        queueIndex: tuple.0,
                        leaseId: tuple.1,
                        netOut: tuple.2,
                    }
                }
            }
        }
        impl preEntitleReturn {
            fn _tokenize(
                &self,
            ) -> <preEntitleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.queueIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.netOut),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for preEntitleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Bytes,
                    20usize,
                >,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = preEntitleReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "preEntitle(bytes32,bytes[20],bytes,bytes32[],uint256)";
            const SELECTOR: [u8; 4] = [249u8, 253u8, 202u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.receiverSalt),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Bytes,
                        20usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.blocks),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.encodedTx,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.proof),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                preEntitleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `predictReceiverAddress(bytes32)` and selector `0x3fea3488`.
```solidity
function predictReceiverAddress(bytes32 salt) external view returns (address predicted);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct predictReceiverAddress_0Call {
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`predictReceiverAddress(bytes32)`](predictReceiverAddress_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct predictReceiverAddress_0Return {
        #[allow(missing_docs)]
        pub predicted: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<predictReceiverAddress_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: predictReceiverAddress_0Call) -> Self {
                    (value.salt,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for predictReceiverAddress_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { salt: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<predictReceiverAddress_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: predictReceiverAddress_0Return) -> Self {
                    (value.predicted,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for predictReceiverAddress_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { predicted: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for predictReceiverAddress_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "predictReceiverAddress(bytes32)";
            const SELECTOR: [u8; 4] = [63u8, 234u8, 52u8, 136u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.salt),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: predictReceiverAddress_0Return = r.into();
                        r.predicted
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: predictReceiverAddress_0Return = r.into();
                        r.predicted
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `predictReceiverAddress(address,bytes32)` and selector `0xaa94360c`.
```solidity
function predictReceiverAddress(address controller, bytes32 salt) external view returns (address predicted);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct predictReceiverAddress_1Call {
        #[allow(missing_docs)]
        pub controller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`predictReceiverAddress(address,bytes32)`](predictReceiverAddress_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct predictReceiverAddress_1Return {
        #[allow(missing_docs)]
        pub predicted: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<predictReceiverAddress_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: predictReceiverAddress_1Call) -> Self {
                    (value.controller, value.salt)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for predictReceiverAddress_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        controller: tuple.0,
                        salt: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<predictReceiverAddress_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: predictReceiverAddress_1Return) -> Self {
                    (value.predicted,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for predictReceiverAddress_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { predicted: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for predictReceiverAddress_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "predictReceiverAddress(address,bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 148u8, 54u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.controller,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.salt),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: predictReceiverAddress_1Return = r.into();
                        r.predicted
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: predictReceiverAddress_1Return = r.into();
                        r.predicted
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `processControllerEvents(uint256)` and selector `0x5016c47b`.
```solidity
function processControllerEvents(uint256 maxEvents) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct processControllerEventsCall {
        #[allow(missing_docs)]
        pub maxEvents: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`processControllerEvents(uint256)`](processControllerEventsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct processControllerEventsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<processControllerEventsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: processControllerEventsCall) -> Self {
                    (value.maxEvents,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for processControllerEventsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { maxEvents: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<processControllerEventsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: processControllerEventsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for processControllerEventsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl processControllerEventsReturn {
            fn _tokenize(
                &self,
            ) -> <processControllerEventsCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for processControllerEventsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = processControllerEventsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "processControllerEvents(uint256)";
            const SELECTOR: [u8; 4] = [80u8, 22u8, 196u8, 123u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxEvents),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                processControllerEventsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `protocolFloorFlatFee()` and selector `0x67de8b7e`.
```solidity
function protocolFloorFlatFee() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct protocolFloorFlatFeeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`protocolFloorFlatFee()`](protocolFloorFlatFeeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct protocolFloorFlatFeeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolFloorFlatFeeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: protocolFloorFlatFeeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for protocolFloorFlatFeeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolFloorFlatFeeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: protocolFloorFlatFeeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for protocolFloorFlatFeeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for protocolFloorFlatFeeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "protocolFloorFlatFee()";
            const SELECTOR: [u8; 4] = [103u8, 222u8, 139u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: protocolFloorFlatFeeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: protocolFloorFlatFeeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `protocolFloorPpm()` and selector `0x93a9ee46`.
```solidity
function protocolFloorPpm() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct protocolFloorPpmCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`protocolFloorPpm()`](protocolFloorPpmCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct protocolFloorPpmReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolFloorPpmCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: protocolFloorPpmCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for protocolFloorPpmCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolFloorPpmReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: protocolFloorPpmReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for protocolFloorPpmReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for protocolFloorPpmCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "protocolFloorPpm()";
            const SELECTOR: [u8; 4] = [147u8, 169u8, 238u8, 70u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: protocolFloorPpmReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: protocolFloorPpmReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `protocolMaxLeaseDurationSeconds()` and selector `0xb133be7d`.
```solidity
function protocolMaxLeaseDurationSeconds() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct protocolMaxLeaseDurationSecondsCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`protocolMaxLeaseDurationSeconds()`](protocolMaxLeaseDurationSecondsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct protocolMaxLeaseDurationSecondsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolMaxLeaseDurationSecondsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: protocolMaxLeaseDurationSecondsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for protocolMaxLeaseDurationSecondsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolMaxLeaseDurationSecondsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: protocolMaxLeaseDurationSecondsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for protocolMaxLeaseDurationSecondsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for protocolMaxLeaseDurationSecondsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "protocolMaxLeaseDurationSeconds()";
            const SELECTOR: [u8; 4] = [177u8, 51u8, 190u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: protocolMaxLeaseDurationSecondsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: protocolMaxLeaseDurationSecondsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `protocolPnl()` and selector `0xb7ed020e`.
```solidity
function protocolPnl() external view returns (int256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct protocolPnlCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`protocolPnl()`](protocolPnlCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct protocolPnlReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::I256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolPnlCall> for UnderlyingRustTuple<'_> {
                fn from(value: protocolPnlCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for protocolPnlCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<protocolPnlReturn> for UnderlyingRustTuple<'_> {
                fn from(value: protocolPnlReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for protocolPnlReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for protocolPnlCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::I256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "protocolPnl()";
            const SELECTOR: [u8; 4] = [183u8, 237u8, 2u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: protocolPnlReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: protocolPnlReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pushControllerEvent(bytes32,bytes,uint64,uint64)` and selector `0xaa63e545`.
```solidity
function pushControllerEvent(bytes32 sig, bytes memory data, uint64 blockNumber, uint64 blockTimestamp) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pushControllerEventCall {
        #[allow(missing_docs)]
        pub sig: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub blockNumber: u64,
        #[allow(missing_docs)]
        pub blockTimestamp: u64,
    }
    ///Container type for the return parameters of the [`pushControllerEvent(bytes32,bytes,uint64,uint64)`](pushControllerEventCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pushControllerEventReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
                u64,
                u64,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pushControllerEventCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: pushControllerEventCall) -> Self {
                    (value.sig, value.data, value.blockNumber, value.blockTimestamp)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pushControllerEventCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sig: tuple.0,
                        data: tuple.1,
                        blockNumber: tuple.2,
                        blockTimestamp: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pushControllerEventReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: pushControllerEventReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pushControllerEventReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl pushControllerEventReturn {
            fn _tokenize(
                &self,
            ) -> <pushControllerEventCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pushControllerEventCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pushControllerEventReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pushControllerEvent(bytes32,bytes,uint64,uint64)";
            const SELECTOR: [u8; 4] = [170u8, 99u8, 229u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.sig),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockTimestamp),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                pushControllerEventReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `realtorLeaseRateLimit(address)` and selector `0x3660fb92`.
```solidity
function realtorLeaseRateLimit(address realtor) external view returns (uint256 maxLeases, uint256 windowSeconds);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct realtorLeaseRateLimitCall {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`realtorLeaseRateLimit(address)`](realtorLeaseRateLimitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct realtorLeaseRateLimitReturn {
        #[allow(missing_docs)]
        pub maxLeases: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub windowSeconds: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<realtorLeaseRateLimitCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: realtorLeaseRateLimitCall) -> Self {
                    (value.realtor,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for realtorLeaseRateLimitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { realtor: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<realtorLeaseRateLimitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: realtorLeaseRateLimitReturn) -> Self {
                    (value.maxLeases, value.windowSeconds)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for realtorLeaseRateLimitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        maxLeases: tuple.0,
                        windowSeconds: tuple.1,
                    }
                }
            }
        }
        impl realtorLeaseRateLimitReturn {
            fn _tokenize(
                &self,
            ) -> <realtorLeaseRateLimitCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxLeases),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.windowSeconds),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for realtorLeaseRateLimitCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = realtorLeaseRateLimitReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "realtorLeaseRateLimit(address)";
            const SELECTOR: [u8; 4] = [54u8, 96u8, 251u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.realtor,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                realtorLeaseRateLimitReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `realtorMaxLeaseDurationSeconds(address)` and selector `0x9d61dd07`.
```solidity
function realtorMaxLeaseDurationSeconds(address realtor) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct realtorMaxLeaseDurationSecondsCall {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`realtorMaxLeaseDurationSeconds(address)`](realtorMaxLeaseDurationSecondsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct realtorMaxLeaseDurationSecondsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<realtorMaxLeaseDurationSecondsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: realtorMaxLeaseDurationSecondsCall) -> Self {
                    (value.realtor,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for realtorMaxLeaseDurationSecondsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { realtor: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<realtorMaxLeaseDurationSecondsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: realtorMaxLeaseDurationSecondsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for realtorMaxLeaseDurationSecondsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for realtorMaxLeaseDurationSecondsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "realtorMaxLeaseDurationSeconds(address)";
            const SELECTOR: [u8; 4] = [157u8, 97u8, 221u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.realtor,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: realtorMaxLeaseDurationSecondsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: realtorMaxLeaseDurationSecondsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `realtorMinFeePpm(address)` and selector `0x33680d58`.
```solidity
function realtorMinFeePpm(address realtor) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct realtorMinFeePpmCall {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`realtorMinFeePpm(address)`](realtorMinFeePpmCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct realtorMinFeePpmReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<realtorMinFeePpmCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: realtorMinFeePpmCall) -> Self {
                    (value.realtor,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for realtorMinFeePpmCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { realtor: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<realtorMinFeePpmReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: realtorMinFeePpmReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for realtorMinFeePpmReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for realtorMinFeePpmCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "realtorMinFeePpm(address)";
            const SELECTOR: [u8; 4] = [51u8, 104u8, 13u8, 88u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.realtor,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: realtorMinFeePpmReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: realtorMinFeePpmReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `realtorMinFlatFee(address)` and selector `0x7de89f30`.
```solidity
function realtorMinFlatFee(address realtor) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct realtorMinFlatFeeCall {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`realtorMinFlatFee(address)`](realtorMinFlatFeeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct realtorMinFlatFeeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<realtorMinFlatFeeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: realtorMinFlatFeeCall) -> Self {
                    (value.realtor,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for realtorMinFlatFeeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { realtor: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<realtorMinFlatFeeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: realtorMinFlatFeeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for realtorMinFlatFeeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for realtorMinFlatFeeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "realtorMinFlatFee(address)";
            const SELECTOR: [u8; 4] = [125u8, 232u8, 159u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.realtor,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: realtorMinFlatFeeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: realtorMinFlatFeeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `receiverBytecode()` and selector `0x9efaca79`.
```solidity
function receiverBytecode() external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct receiverBytecodeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`receiverBytecode()`](receiverBytecodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct receiverBytecodeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<receiverBytecodeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: receiverBytecodeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for receiverBytecodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<receiverBytecodeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: receiverBytecodeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for receiverBytecodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for receiverBytecodeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "receiverBytecode()";
            const SELECTOR: [u8; 4] = [158u8, 250u8, 202u8, 121u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: receiverBytecodeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: receiverBytecodeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `relayControllerEventChain(bytes[20],bytes,bytes32[],uint256,(bytes32,bytes,uint64,uint64)[])` and selector `0x5cf88012`.
```solidity
function relayControllerEventChain(bytes[20] memory blocks, bytes memory encodedTx, bytes32[] memory proof, uint256 index, UntronV3.ControllerEvent[] memory events) external returns (bytes32 tipNew);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct relayControllerEventChainCall {
        #[allow(missing_docs)]
        pub blocks: [alloy::sol_types::private::Bytes; 20usize],
        #[allow(missing_docs)]
        pub encodedTx: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub proof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub events: alloy::sol_types::private::Vec<
            <UntronV3::ControllerEvent as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`relayControllerEventChain(bytes[20],bytes,bytes32[],uint256,(bytes32,bytes,uint64,uint64)[])`](relayControllerEventChainCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct relayControllerEventChainReturn {
        #[allow(missing_docs)]
        pub tipNew: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Bytes,
                    20usize,
                >,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<UntronV3::ControllerEvent>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                [alloy::sol_types::private::Bytes; 20usize],
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    <UntronV3::ControllerEvent as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<relayControllerEventChainCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: relayControllerEventChainCall) -> Self {
                    (
                        value.blocks,
                        value.encodedTx,
                        value.proof,
                        value.index,
                        value.events,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for relayControllerEventChainCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blocks: tuple.0,
                        encodedTx: tuple.1,
                        proof: tuple.2,
                        index: tuple.3,
                        events: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<relayControllerEventChainReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: relayControllerEventChainReturn) -> Self {
                    (value.tipNew,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for relayControllerEventChainReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { tipNew: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for relayControllerEventChainCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Bytes,
                    20usize,
                >,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<UntronV3::ControllerEvent>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "relayControllerEventChain(bytes[20],bytes,bytes32[],uint256,(bytes32,bytes,uint64,uint64)[])";
            const SELECTOR: [u8; 4] = [92u8, 248u8, 128u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Bytes,
                        20usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.blocks),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.encodedTx,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.proof),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                    <alloy::sol_types::sol_data::Array<
                        UntronV3::ControllerEvent,
                    > as alloy_sol_types::SolType>::tokenize(&self.events),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: relayControllerEventChainReturn = r.into();
                        r.tipNew
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: relayControllerEventChainReturn = r.into();
                        r.tipNew
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall;
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <renounceOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `rescueTokens(address,uint256)` and selector `0x57376198`.
```solidity
function rescueTokens(address token, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rescueTokensCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`rescueTokens(address,uint256)`](rescueTokensCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rescueTokensReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rescueTokensCall> for UnderlyingRustTuple<'_> {
                fn from(value: rescueTokensCall) -> Self {
                    (value.token, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rescueTokensCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rescueTokensReturn> for UnderlyingRustTuple<'_> {
                fn from(value: rescueTokensReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rescueTokensReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl rescueTokensReturn {
            fn _tokenize(
                &self,
            ) -> <rescueTokensCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rescueTokensCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = rescueTokensReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rescueTokens(address,uint256)";
            const SELECTOR: [u8; 4] = [87u8, 55u8, 97u8, 152u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                rescueTokensReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setBridger(address,uint256,address)` and selector `0x665e0eed`.
```solidity
function setBridger(address targetToken, uint256 targetChainId, address bridger) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgerCall {
        #[allow(missing_docs)]
        pub targetToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub targetChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub bridger: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setBridger(address,uint256,address)`](setBridgerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgerCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgerCall) -> Self {
                    (value.targetToken, value.targetChainId, value.bridger)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        targetToken: tuple.0,
                        targetChainId: tuple.1,
                        bridger: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setBridgerReturn {
            fn _tokenize(
                &self,
            ) -> <setBridgerCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridger(address,uint256,address)";
            const SELECTOR: [u8; 4] = [102u8, 94u8, 14u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.targetToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.targetChainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridger,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setBridgerReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setChainDeprecated(uint256,bool)` and selector `0x1376de52`.
```solidity
function setChainDeprecated(uint256 targetChainId, bool deprecated) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChainDeprecatedCall {
        #[allow(missing_docs)]
        pub targetChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub deprecated: bool,
    }
    ///Container type for the return parameters of the [`setChainDeprecated(uint256,bool)`](setChainDeprecatedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setChainDeprecatedReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChainDeprecatedCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setChainDeprecatedCall) -> Self {
                    (value.targetChainId, value.deprecated)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setChainDeprecatedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        targetChainId: tuple.0,
                        deprecated: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChainDeprecatedReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setChainDeprecatedReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setChainDeprecatedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setChainDeprecatedReturn {
            fn _tokenize(
                &self,
            ) -> <setChainDeprecatedCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setChainDeprecatedCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setChainDeprecatedReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setChainDeprecated(uint256,bool)";
            const SELECTOR: [u8; 4] = [19u8, 118u8, 222u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.targetChainId),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.deprecated,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setChainDeprecatedReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setLesseePayoutConfigRateLimit(uint256,uint256)` and selector `0x636ee624`.
```solidity
function setLesseePayoutConfigRateLimit(uint256 maxUpdates, uint256 windowSeconds) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLesseePayoutConfigRateLimitCall {
        #[allow(missing_docs)]
        pub maxUpdates: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub windowSeconds: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setLesseePayoutConfigRateLimit(uint256,uint256)`](setLesseePayoutConfigRateLimitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLesseePayoutConfigRateLimitReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLesseePayoutConfigRateLimitCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setLesseePayoutConfigRateLimitCall) -> Self {
                    (value.maxUpdates, value.windowSeconds)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setLesseePayoutConfigRateLimitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        maxUpdates: tuple.0,
                        windowSeconds: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLesseePayoutConfigRateLimitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setLesseePayoutConfigRateLimitReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setLesseePayoutConfigRateLimitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setLesseePayoutConfigRateLimitReturn {
            fn _tokenize(
                &self,
            ) -> <setLesseePayoutConfigRateLimitCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setLesseePayoutConfigRateLimitCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setLesseePayoutConfigRateLimitReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setLesseePayoutConfigRateLimit(uint256,uint256)";
            const SELECTOR: [u8; 4] = [99u8, 110u8, 230u8, 36u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxUpdates),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.windowSeconds),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setLesseePayoutConfigRateLimitReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setLp(address,bool)` and selector `0x8701d7b2`.
```solidity
function setLp(address lp, bool allowed) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLpCall {
        #[allow(missing_docs)]
        pub lp: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub allowed: bool,
    }
    ///Container type for the return parameters of the [`setLp(address,bool)`](setLpCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setLpReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLpCall> for UnderlyingRustTuple<'_> {
                fn from(value: setLpCall) -> Self {
                    (value.lp, value.allowed)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setLpCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lp: tuple.0,
                        allowed: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setLpReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setLpReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setLpReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setLpReturn {
            fn _tokenize(
                &self,
            ) -> <setLpCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setLpCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setLpReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setLp(address,bool)";
            const SELECTOR: [u8; 4] = [135u8, 1u8, 215u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.lp,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.allowed,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setLpReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setPayoutConfig(uint256,uint256,address,address)` and selector `0x33d908ad`.
```solidity
function setPayoutConfig(uint256 leaseId, uint256 targetChainId, address targetToken, address beneficiary) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setPayoutConfigCall {
        #[allow(missing_docs)]
        pub leaseId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub targetChainId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub targetToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub beneficiary: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setPayoutConfig(uint256,uint256,address,address)`](setPayoutConfigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setPayoutConfigReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setPayoutConfigCall> for UnderlyingRustTuple<'_> {
                fn from(value: setPayoutConfigCall) -> Self {
                    (
                        value.leaseId,
                        value.targetChainId,
                        value.targetToken,
                        value.beneficiary,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setPayoutConfigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        leaseId: tuple.0,
                        targetChainId: tuple.1,
                        targetToken: tuple.2,
                        beneficiary: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setPayoutConfigReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setPayoutConfigReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setPayoutConfigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setPayoutConfigReturn {
            fn _tokenize(
                &self,
            ) -> <setPayoutConfigCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setPayoutConfigCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setPayoutConfigReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setPayoutConfig(uint256,uint256,address,address)";
            const SELECTOR: [u8; 4] = [51u8, 217u8, 8u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.targetChainId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.targetToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.beneficiary,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setPayoutConfigReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setPayoutConfigWithSig(uint256,(uint256,address,address),uint256,bytes)` and selector `0xa34d28eb`.
```solidity
function setPayoutConfigWithSig(uint256 leaseId, UntronV3.PayoutConfig memory config, uint256 deadline, bytes memory signature) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setPayoutConfigWithSigCall {
        #[allow(missing_docs)]
        pub leaseId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub config: <UntronV3::PayoutConfig as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`setPayoutConfigWithSig(uint256,(uint256,address,address),uint256,bytes)`](setPayoutConfigWithSigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setPayoutConfigWithSigReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                UntronV3::PayoutConfig,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                <UntronV3::PayoutConfig as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setPayoutConfigWithSigCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setPayoutConfigWithSigCall) -> Self {
                    (value.leaseId, value.config, value.deadline, value.signature)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setPayoutConfigWithSigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        leaseId: tuple.0,
                        config: tuple.1,
                        deadline: tuple.2,
                        signature: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setPayoutConfigWithSigReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setPayoutConfigWithSigReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setPayoutConfigWithSigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setPayoutConfigWithSigReturn {
            fn _tokenize(
                &self,
            ) -> <setPayoutConfigWithSigCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setPayoutConfigWithSigCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                UntronV3::PayoutConfig,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setPayoutConfigWithSigReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setPayoutConfigWithSig(uint256,(uint256,address,address),uint256,bytes)";
            const SELECTOR: [u8; 4] = [163u8, 77u8, 40u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseId),
                    <UntronV3::PayoutConfig as alloy_sol_types::SolType>::tokenize(
                        &self.config,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setPayoutConfigWithSigReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setProtocolFloorFlatFee(uint64)` and selector `0x506294dc`.
```solidity
function setProtocolFloorFlatFee(uint64 floorFlatFee) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setProtocolFloorFlatFeeCall {
        #[allow(missing_docs)]
        pub floorFlatFee: u64,
    }
    ///Container type for the return parameters of the [`setProtocolFloorFlatFee(uint64)`](setProtocolFloorFlatFeeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setProtocolFloorFlatFeeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProtocolFloorFlatFeeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setProtocolFloorFlatFeeCall) -> Self {
                    (value.floorFlatFee,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setProtocolFloorFlatFeeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { floorFlatFee: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProtocolFloorFlatFeeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setProtocolFloorFlatFeeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setProtocolFloorFlatFeeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setProtocolFloorFlatFeeReturn {
            fn _tokenize(
                &self,
            ) -> <setProtocolFloorFlatFeeCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setProtocolFloorFlatFeeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setProtocolFloorFlatFeeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setProtocolFloorFlatFee(uint64)";
            const SELECTOR: [u8; 4] = [80u8, 98u8, 148u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.floorFlatFee),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setProtocolFloorFlatFeeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setProtocolFloorPpm(uint256)` and selector `0x1cf1bd3a`.
```solidity
function setProtocolFloorPpm(uint256 floorPpm) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setProtocolFloorPpmCall {
        #[allow(missing_docs)]
        pub floorPpm: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setProtocolFloorPpm(uint256)`](setProtocolFloorPpmCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setProtocolFloorPpmReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProtocolFloorPpmCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setProtocolFloorPpmCall) -> Self {
                    (value.floorPpm,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setProtocolFloorPpmCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { floorPpm: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProtocolFloorPpmReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setProtocolFloorPpmReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setProtocolFloorPpmReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setProtocolFloorPpmReturn {
            fn _tokenize(
                &self,
            ) -> <setProtocolFloorPpmCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setProtocolFloorPpmCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setProtocolFloorPpmReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setProtocolFloorPpm(uint256)";
            const SELECTOR: [u8; 4] = [28u8, 241u8, 189u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.floorPpm),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setProtocolFloorPpmReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setProtocolMaxLeaseDurationSeconds(uint32)` and selector `0xdc1f9adf`.
```solidity
function setProtocolMaxLeaseDurationSeconds(uint32 maxLeaseDurationSeconds) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setProtocolMaxLeaseDurationSecondsCall {
        #[allow(missing_docs)]
        pub maxLeaseDurationSeconds: u32,
    }
    ///Container type for the return parameters of the [`setProtocolMaxLeaseDurationSeconds(uint32)`](setProtocolMaxLeaseDurationSecondsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setProtocolMaxLeaseDurationSecondsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProtocolMaxLeaseDurationSecondsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setProtocolMaxLeaseDurationSecondsCall) -> Self {
                    (value.maxLeaseDurationSeconds,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setProtocolMaxLeaseDurationSecondsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        maxLeaseDurationSeconds: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setProtocolMaxLeaseDurationSecondsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setProtocolMaxLeaseDurationSecondsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setProtocolMaxLeaseDurationSecondsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setProtocolMaxLeaseDurationSecondsReturn {
            fn _tokenize(
                &self,
            ) -> <setProtocolMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setProtocolMaxLeaseDurationSecondsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setProtocolMaxLeaseDurationSecondsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setProtocolMaxLeaseDurationSeconds(uint32)";
            const SELECTOR: [u8; 4] = [220u8, 31u8, 154u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.maxLeaseDurationSeconds,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setProtocolMaxLeaseDurationSecondsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setRealtor(address,bool)` and selector `0x878ba156`.
```solidity
function setRealtor(address realtor, bool allowed) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRealtorCall {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub allowed: bool,
    }
    ///Container type for the return parameters of the [`setRealtor(address,bool)`](setRealtorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRealtorReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRealtorCall> for UnderlyingRustTuple<'_> {
                fn from(value: setRealtorCall) -> Self {
                    (value.realtor, value.allowed)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setRealtorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        realtor: tuple.0,
                        allowed: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRealtorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setRealtorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setRealtorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setRealtorReturn {
            fn _tokenize(
                &self,
            ) -> <setRealtorCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setRealtorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setRealtorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setRealtor(address,bool)";
            const SELECTOR: [u8; 4] = [135u8, 139u8, 161u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.realtor,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.allowed,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setRealtorReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setRealtorLeaseRateLimit(address,uint256,uint256)` and selector `0xecf88bb0`.
```solidity
function setRealtorLeaseRateLimit(address realtor, uint256 maxLeases, uint256 windowSeconds) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRealtorLeaseRateLimitCall {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub maxLeases: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub windowSeconds: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setRealtorLeaseRateLimit(address,uint256,uint256)`](setRealtorLeaseRateLimitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRealtorLeaseRateLimitReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRealtorLeaseRateLimitCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRealtorLeaseRateLimitCall) -> Self {
                    (value.realtor, value.maxLeases, value.windowSeconds)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRealtorLeaseRateLimitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        realtor: tuple.0,
                        maxLeases: tuple.1,
                        windowSeconds: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRealtorLeaseRateLimitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRealtorLeaseRateLimitReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRealtorLeaseRateLimitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setRealtorLeaseRateLimitReturn {
            fn _tokenize(
                &self,
            ) -> <setRealtorLeaseRateLimitCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setRealtorLeaseRateLimitCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setRealtorLeaseRateLimitReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setRealtorLeaseRateLimit(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [236u8, 248u8, 139u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.realtor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxLeases),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.windowSeconds),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setRealtorLeaseRateLimitReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setRealtorMaxLeaseDurationSeconds(address,uint32)` and selector `0x42005c6c`.
```solidity
function setRealtorMaxLeaseDurationSeconds(address realtor, uint32 maxLeaseDurationSeconds) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRealtorMaxLeaseDurationSecondsCall {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub maxLeaseDurationSeconds: u32,
    }
    ///Container type for the return parameters of the [`setRealtorMaxLeaseDurationSeconds(address,uint32)`](setRealtorMaxLeaseDurationSecondsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRealtorMaxLeaseDurationSecondsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRealtorMaxLeaseDurationSecondsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRealtorMaxLeaseDurationSecondsCall) -> Self {
                    (value.realtor, value.maxLeaseDurationSeconds)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRealtorMaxLeaseDurationSecondsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        realtor: tuple.0,
                        maxLeaseDurationSeconds: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRealtorMaxLeaseDurationSecondsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRealtorMaxLeaseDurationSecondsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRealtorMaxLeaseDurationSecondsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setRealtorMaxLeaseDurationSecondsReturn {
            fn _tokenize(
                &self,
            ) -> <setRealtorMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setRealtorMaxLeaseDurationSecondsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setRealtorMaxLeaseDurationSecondsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setRealtorMaxLeaseDurationSeconds(address,uint32)";
            const SELECTOR: [u8; 4] = [66u8, 0u8, 92u8, 108u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.realtor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.maxLeaseDurationSeconds,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setRealtorMaxLeaseDurationSecondsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setRealtorMinFeePpm(address,uint256)` and selector `0x5ea63c6c`.
```solidity
function setRealtorMinFeePpm(address realtor, uint256 minFeePpm) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRealtorMinFeePpmCall {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub minFeePpm: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setRealtorMinFeePpm(address,uint256)`](setRealtorMinFeePpmCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRealtorMinFeePpmReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRealtorMinFeePpmCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRealtorMinFeePpmCall) -> Self {
                    (value.realtor, value.minFeePpm)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRealtorMinFeePpmCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        realtor: tuple.0,
                        minFeePpm: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRealtorMinFeePpmReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRealtorMinFeePpmReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRealtorMinFeePpmReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setRealtorMinFeePpmReturn {
            fn _tokenize(
                &self,
            ) -> <setRealtorMinFeePpmCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setRealtorMinFeePpmCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setRealtorMinFeePpmReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setRealtorMinFeePpm(address,uint256)";
            const SELECTOR: [u8; 4] = [94u8, 166u8, 60u8, 108u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.realtor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.minFeePpm),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setRealtorMinFeePpmReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setRealtorMinFlatFee(address,uint64)` and selector `0xf03eb61a`.
```solidity
function setRealtorMinFlatFee(address realtor, uint64 minFlatFee) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRealtorMinFlatFeeCall {
        #[allow(missing_docs)]
        pub realtor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub minFlatFee: u64,
    }
    ///Container type for the return parameters of the [`setRealtorMinFlatFee(address,uint64)`](setRealtorMinFlatFeeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRealtorMinFlatFeeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRealtorMinFlatFeeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRealtorMinFlatFeeCall) -> Self {
                    (value.realtor, value.minFlatFee)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRealtorMinFlatFeeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        realtor: tuple.0,
                        minFlatFee: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRealtorMinFlatFeeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRealtorMinFlatFeeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRealtorMinFlatFeeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setRealtorMinFlatFeeReturn {
            fn _tokenize(
                &self,
            ) -> <setRealtorMinFlatFeeCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setRealtorMinFlatFeeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setRealtorMinFlatFeeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setRealtorMinFlatFee(address,uint64)";
            const SELECTOR: [u8; 4] = [240u8, 62u8, 182u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.realtor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.minFlatFee),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setRealtorMinFlatFeeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setSwapRate(address,uint256)` and selector `0xcef5f482`.
```solidity
function setSwapRate(address targetToken, uint256 ratePpm) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSwapRateCall {
        #[allow(missing_docs)]
        pub targetToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ratePpm: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setSwapRate(address,uint256)`](setSwapRateCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSwapRateReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSwapRateCall> for UnderlyingRustTuple<'_> {
                fn from(value: setSwapRateCall) -> Self {
                    (value.targetToken, value.ratePpm)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setSwapRateCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        targetToken: tuple.0,
                        ratePpm: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSwapRateReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setSwapRateReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setSwapRateReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setSwapRateReturn {
            fn _tokenize(
                &self,
            ) -> <setSwapRateCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setSwapRateCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setSwapRateReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setSwapRate(address,uint256)";
            const SELECTOR: [u8; 4] = [206u8, 245u8, 244u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.targetToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.ratePpm),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setSwapRateReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setTronReader(address)` and selector `0xf654b7d0`.
```solidity
function setTronReader(address reader) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setTronReaderCall {
        #[allow(missing_docs)]
        pub reader: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setTronReader(address)`](setTronReaderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setTronReaderReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setTronReaderCall> for UnderlyingRustTuple<'_> {
                fn from(value: setTronReaderCall) -> Self {
                    (value.reader,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setTronReaderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { reader: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setTronReaderReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setTronReaderReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setTronReaderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setTronReaderReturn {
            fn _tokenize(
                &self,
            ) -> <setTronReaderCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setTronReaderCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setTronReaderReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setTronReader(address)";
            const SELECTOR: [u8; 4] = [246u8, 84u8, 183u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.reader,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setTronReaderReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setUsdt(address)` and selector `0x58979bfe`.
```solidity
function setUsdt(address usdt_) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setUsdtCall {
        #[allow(missing_docs)]
        pub usdt_: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setUsdt(address)`](setUsdtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setUsdtReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setUsdtCall> for UnderlyingRustTuple<'_> {
                fn from(value: setUsdtCall) -> Self {
                    (value.usdt_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setUsdtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { usdt_: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setUsdtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setUsdtReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setUsdtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setUsdtReturn {
            fn _tokenize(
                &self,
            ) -> <setUsdtCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setUsdtCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setUsdtReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setUsdt(address)";
            const SELECTOR: [u8; 4] = [88u8, 151u8, 155u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.usdt_,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setUsdtReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `subjectivePreEntitle(bytes32,uint256,uint256)` and selector `0xa7ec9df9`.
```solidity
function subjectivePreEntitle(bytes32 txId, uint256 leaseId, uint256 rawAmount) external returns (uint256 queueIndex, uint256 netOut);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct subjectivePreEntitleCall {
        #[allow(missing_docs)]
        pub txId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub leaseId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub rawAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`subjectivePreEntitle(bytes32,uint256,uint256)`](subjectivePreEntitleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct subjectivePreEntitleReturn {
        #[allow(missing_docs)]
        pub queueIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub netOut: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<subjectivePreEntitleCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: subjectivePreEntitleCall) -> Self {
                    (value.txId, value.leaseId, value.rawAmount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for subjectivePreEntitleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        txId: tuple.0,
                        leaseId: tuple.1,
                        rawAmount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<subjectivePreEntitleReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: subjectivePreEntitleReturn) -> Self {
                    (value.queueIndex, value.netOut)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for subjectivePreEntitleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        queueIndex: tuple.0,
                        netOut: tuple.1,
                    }
                }
            }
        }
        impl subjectivePreEntitleReturn {
            fn _tokenize(
                &self,
            ) -> <subjectivePreEntitleCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.queueIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.netOut),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for subjectivePreEntitleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = subjectivePreEntitleReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "subjectivePreEntitle(bytes32,uint256,uint256)";
            const SELECTOR: [u8; 4] = [167u8, 236u8, 157u8, 249u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.txId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.rawAmount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                subjectivePreEntitleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `subjectivePreEntitlementByTxId(bytes32)` and selector `0x3d92af84`.
```solidity
function subjectivePreEntitlementByTxId(bytes32) external view returns (address sponsor, uint256 leaseId, uint256 rawAmount, uint256 queueIndex, uint256 claimId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct subjectivePreEntitlementByTxIdCall(
        pub alloy::sol_types::private::FixedBytes<32>,
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`subjectivePreEntitlementByTxId(bytes32)`](subjectivePreEntitlementByTxIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct subjectivePreEntitlementByTxIdReturn {
        #[allow(missing_docs)]
        pub sponsor: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub leaseId: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub rawAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub queueIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub claimId: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<subjectivePreEntitlementByTxIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: subjectivePreEntitlementByTxIdCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for subjectivePreEntitlementByTxIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<subjectivePreEntitlementByTxIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: subjectivePreEntitlementByTxIdReturn) -> Self {
                    (
                        value.sponsor,
                        value.leaseId,
                        value.rawAmount,
                        value.queueIndex,
                        value.claimId,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for subjectivePreEntitlementByTxIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        sponsor: tuple.0,
                        leaseId: tuple.1,
                        rawAmount: tuple.2,
                        queueIndex: tuple.3,
                        claimId: tuple.4,
                    }
                }
            }
        }
        impl subjectivePreEntitlementByTxIdReturn {
            fn _tokenize(
                &self,
            ) -> <subjectivePreEntitlementByTxIdCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sponsor,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.leaseId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.rawAmount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.queueIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.claimId),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for subjectivePreEntitlementByTxIdCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = subjectivePreEntitlementByTxIdReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "subjectivePreEntitlementByTxId(bytes32)";
            const SELECTOR: [u8; 4] = [61u8, 146u8, 175u8, 132u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                subjectivePreEntitlementByTxIdReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `swapRatePpm(address)` and selector `0xf04e02c0`.
```solidity
function swapRatePpm(address) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct swapRatePpmCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`swapRatePpm(address)`](swapRatePpmCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct swapRatePpmReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<swapRatePpmCall> for UnderlyingRustTuple<'_> {
                fn from(value: swapRatePpmCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for swapRatePpmCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<swapRatePpmReturn> for UnderlyingRustTuple<'_> {
                fn from(value: swapRatePpmReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for swapRatePpmReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for swapRatePpmCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "swapRatePpm(address)";
            const SELECTOR: [u8; 4] = [240u8, 78u8, 2u8, 192u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: swapRatePpmReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: swapRatePpmReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl transferOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <transferOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                transferOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `tronReader()` and selector `0x80a72c8b`.
```solidity
function tronReader() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tronReaderCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`tronReader()`](tronReaderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tronReaderReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tronReaderCall> for UnderlyingRustTuple<'_> {
                fn from(value: tronReaderCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tronReaderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tronReaderReturn> for UnderlyingRustTuple<'_> {
                fn from(value: tronReaderReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tronReaderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for tronReaderCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "tronReader()";
            const SELECTOR: [u8; 4] = [128u8, 167u8, 44u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: tronReaderReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: tronReaderReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `tronUsdt()` and selector `0xdc8f8633`.
```solidity
function tronUsdt() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tronUsdtCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`tronUsdt()`](tronUsdtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct tronUsdtReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tronUsdtCall> for UnderlyingRustTuple<'_> {
                fn from(value: tronUsdtCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tronUsdtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<tronUsdtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: tronUsdtReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for tronUsdtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for tronUsdtCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "tronUsdt()";
            const SELECTOR: [u8; 4] = [220u8, 143u8, 134u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: tronUsdtReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: tronUsdtReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall;
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl unpauseReturn {
            fn _tokenize(
                &self,
            ) -> <unpauseCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                unpauseReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `usdt()` and selector `0x2f48ab7d`.
```solidity
function usdt() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct usdtCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`usdt()`](usdtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct usdtReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<usdtCall> for UnderlyingRustTuple<'_> {
                fn from(value: usdtCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for usdtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<usdtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: usdtReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for usdtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for usdtCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "usdt()";
            const SELECTOR: [u8; 4] = [47u8, 72u8, 171u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: usdtReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: usdtReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `usdtBalance()` and selector `0x482edb07`.
```solidity
function usdtBalance() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct usdtBalanceCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`usdtBalance()`](usdtBalanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct usdtBalanceReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<usdtBalanceCall> for UnderlyingRustTuple<'_> {
                fn from(value: usdtBalanceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for usdtBalanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<usdtBalanceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: usdtBalanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for usdtBalanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for usdtBalanceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "usdtBalance()";
            const SELECTOR: [u8; 4] = [72u8, 46u8, 219u8, 7u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: usdtBalanceReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: usdtBalanceReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `withdraw(uint256)` and selector `0x2e1a7d4d`.
```solidity
function withdraw(uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawCall {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`withdraw(uint256)`](withdrawCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawCall> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawReturn> for UnderlyingRustTuple<'_> {
                fn from(value: withdrawReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for withdrawReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl withdrawReturn {
            fn _tokenize(
                &self,
            ) -> <withdrawCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for withdrawCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = withdrawReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "withdraw(uint256)";
            const SELECTOR: [u8; 4] = [46u8, 26u8, 125u8, 77u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                withdrawReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `withdrawProtocolProfit(int256)` and selector `0x0465eab0`.
```solidity
function withdrawProtocolProfit(int256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawProtocolProfitCall {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::I256,
    }
    ///Container type for the return parameters of the [`withdrawProtocolProfit(int256)`](withdrawProtocolProfitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct withdrawProtocolProfitReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Int<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::I256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawProtocolProfitCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: withdrawProtocolProfitCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for withdrawProtocolProfitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<withdrawProtocolProfitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: withdrawProtocolProfitReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for withdrawProtocolProfitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl withdrawProtocolProfitReturn {
            fn _tokenize(
                &self,
            ) -> <withdrawProtocolProfitCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for withdrawProtocolProfitCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Int<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = withdrawProtocolProfitReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "withdrawProtocolProfit(int256)";
            const SELECTOR: [u8; 4] = [4u8, 101u8, 234u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Int<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                withdrawProtocolProfitReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`UntronV3Harness`](self) function calls.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum UntronV3HarnessCalls {
        #[allow(missing_docs)]
        CONTROLLER_ADDRESS(CONTROLLER_ADDRESSCall),
        #[allow(missing_docs)]
        RECEIVER_IMPL(RECEIVER_IMPLCall),
        #[allow(missing_docs)]
        SWAP_EXECUTOR(SWAP_EXECUTORCall),
        #[allow(missing_docs)]
        bridgers(bridgersCall),
        #[allow(missing_docs)]
        claimLocatorByLease(claimLocatorByLeaseCall),
        #[allow(missing_docs)]
        claimQueueLength(claimQueueLengthCall),
        #[allow(missing_docs)]
        claimsByTargetToken(claimsByTargetTokenCall),
        #[allow(missing_docs)]
        controllerEventAt(controllerEventAtCall),
        #[allow(missing_docs)]
        controllerEventsLength(controllerEventsLengthCall),
        #[allow(missing_docs)]
        createLease(createLeaseCall),
        #[allow(missing_docs)]
        deposit(depositCall),
        #[allow(missing_docs)]
        depositProcessed(depositProcessedCall),
        #[allow(missing_docs)]
        depositToPnl(depositToPnlCall),
        #[allow(missing_docs)]
        effectiveLeaseRateLimit(effectiveLeaseRateLimitCall),
        #[allow(missing_docs)]
        effectiveMaxLeaseDurationSeconds(effectiveMaxLeaseDurationSecondsCall),
        #[allow(missing_docs)]
        eip712Domain(eip712DomainCall),
        #[allow(missing_docs)]
        enqueueClaim(enqueueClaimCall),
        #[allow(missing_docs)]
        eventChainTip(eventChainTipCall),
        #[allow(missing_docs)]
        eventSeq(eventSeqCall),
        #[allow(missing_docs)]
        evmToTron(evmToTronCall),
        #[allow(missing_docs)]
        exposedDecodeEventChainTip(exposedDecodeEventChainTipCall),
        #[allow(missing_docs)]
        exposedProcessReceiverPulled(exposedProcessReceiverPulledCall),
        #[allow(missing_docs)]
        fill(fillCall),
        #[allow(missing_docs)]
        isChainDeprecated(isChainDeprecatedCall),
        #[allow(missing_docs)]
        isLpAllowed(isLpAllowedCall),
        #[allow(missing_docs)]
        isRealtor(isRealtorCall),
        #[allow(missing_docs)]
        lastControllerEventSeq(lastControllerEventSeqCall),
        #[allow(missing_docs)]
        lastControllerEventTip(lastControllerEventTipCall),
        #[allow(missing_docs)]
        lastReceiverPullTimestampByToken(lastReceiverPullTimestampByTokenCall),
        #[allow(missing_docs)]
        leaseIdsByReceiver(leaseIdsByReceiverCall),
        #[allow(missing_docs)]
        leaseLocatorById(leaseLocatorByIdCall),
        #[allow(missing_docs)]
        leaseNonces(leaseNoncesCall),
        #[allow(missing_docs)]
        leases(leasesCall),
        #[allow(missing_docs)]
        leasesByReceiver(leasesByReceiverCall),
        #[allow(missing_docs)]
        lesseePayoutConfigRateLimit(lesseePayoutConfigRateLimitCall),
        #[allow(missing_docs)]
        lpPrincipal(lpPrincipalCall),
        #[allow(missing_docs)]
        nextClaimIdByLease(nextClaimIdByLeaseCall),
        #[allow(missing_docs)]
        nextControllerEventIndex(nextControllerEventIndexCall),
        #[allow(missing_docs)]
        nextIndexByTargetToken(nextIndexByTargetTokenCall),
        #[allow(missing_docs)]
        nextLeaseId(nextLeaseIdCall),
        #[allow(missing_docs)]
        nextLeaseNumberAtReceiver(nextLeaseNumberAtReceiverCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        preEntitle(preEntitleCall),
        #[allow(missing_docs)]
        predictReceiverAddress_0(predictReceiverAddress_0Call),
        #[allow(missing_docs)]
        predictReceiverAddress_1(predictReceiverAddress_1Call),
        #[allow(missing_docs)]
        processControllerEvents(processControllerEventsCall),
        #[allow(missing_docs)]
        protocolFloorFlatFee(protocolFloorFlatFeeCall),
        #[allow(missing_docs)]
        protocolFloorPpm(protocolFloorPpmCall),
        #[allow(missing_docs)]
        protocolMaxLeaseDurationSeconds(protocolMaxLeaseDurationSecondsCall),
        #[allow(missing_docs)]
        protocolPnl(protocolPnlCall),
        #[allow(missing_docs)]
        pushControllerEvent(pushControllerEventCall),
        #[allow(missing_docs)]
        realtorLeaseRateLimit(realtorLeaseRateLimitCall),
        #[allow(missing_docs)]
        realtorMaxLeaseDurationSeconds(realtorMaxLeaseDurationSecondsCall),
        #[allow(missing_docs)]
        realtorMinFeePpm(realtorMinFeePpmCall),
        #[allow(missing_docs)]
        realtorMinFlatFee(realtorMinFlatFeeCall),
        #[allow(missing_docs)]
        receiverBytecode(receiverBytecodeCall),
        #[allow(missing_docs)]
        relayControllerEventChain(relayControllerEventChainCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        rescueTokens(rescueTokensCall),
        #[allow(missing_docs)]
        setBridger(setBridgerCall),
        #[allow(missing_docs)]
        setChainDeprecated(setChainDeprecatedCall),
        #[allow(missing_docs)]
        setLesseePayoutConfigRateLimit(setLesseePayoutConfigRateLimitCall),
        #[allow(missing_docs)]
        setLp(setLpCall),
        #[allow(missing_docs)]
        setPayoutConfig(setPayoutConfigCall),
        #[allow(missing_docs)]
        setPayoutConfigWithSig(setPayoutConfigWithSigCall),
        #[allow(missing_docs)]
        setProtocolFloorFlatFee(setProtocolFloorFlatFeeCall),
        #[allow(missing_docs)]
        setProtocolFloorPpm(setProtocolFloorPpmCall),
        #[allow(missing_docs)]
        setProtocolMaxLeaseDurationSeconds(setProtocolMaxLeaseDurationSecondsCall),
        #[allow(missing_docs)]
        setRealtor(setRealtorCall),
        #[allow(missing_docs)]
        setRealtorLeaseRateLimit(setRealtorLeaseRateLimitCall),
        #[allow(missing_docs)]
        setRealtorMaxLeaseDurationSeconds(setRealtorMaxLeaseDurationSecondsCall),
        #[allow(missing_docs)]
        setRealtorMinFeePpm(setRealtorMinFeePpmCall),
        #[allow(missing_docs)]
        setRealtorMinFlatFee(setRealtorMinFlatFeeCall),
        #[allow(missing_docs)]
        setSwapRate(setSwapRateCall),
        #[allow(missing_docs)]
        setTronReader(setTronReaderCall),
        #[allow(missing_docs)]
        setUsdt(setUsdtCall),
        #[allow(missing_docs)]
        subjectivePreEntitle(subjectivePreEntitleCall),
        #[allow(missing_docs)]
        subjectivePreEntitlementByTxId(subjectivePreEntitlementByTxIdCall),
        #[allow(missing_docs)]
        swapRatePpm(swapRatePpmCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        tronReader(tronReaderCall),
        #[allow(missing_docs)]
        tronUsdt(tronUsdtCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
        #[allow(missing_docs)]
        usdt(usdtCall),
        #[allow(missing_docs)]
        usdtBalance(usdtBalanceCall),
        #[allow(missing_docs)]
        withdraw(withdrawCall),
        #[allow(missing_docs)]
        withdrawProtocolProfit(withdrawProtocolProfitCall),
    }
    impl UntronV3HarnessCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [4u8, 101u8, 234u8, 176u8],
            [4u8, 236u8, 66u8, 148u8],
            [11u8, 52u8, 88u8, 121u8],
            [19u8, 118u8, 222u8, 82u8],
            [28u8, 241u8, 189u8, 58u8],
            [29u8, 191u8, 76u8, 97u8],
            [46u8, 26u8, 125u8, 77u8],
            [47u8, 72u8, 171u8, 125u8],
            [47u8, 131u8, 217u8, 175u8],
            [51u8, 104u8, 13u8, 88u8],
            [51u8, 217u8, 8u8, 173u8],
            [54u8, 39u8, 114u8, 13u8],
            [54u8, 96u8, 251u8, 146u8],
            [56u8, 238u8, 114u8, 208u8],
            [61u8, 146u8, 175u8, 132u8],
            [63u8, 75u8, 168u8, 58u8],
            [63u8, 234u8, 52u8, 136u8],
            [66u8, 0u8, 92u8, 108u8],
            [67u8, 65u8, 252u8, 134u8],
            [70u8, 222u8, 64u8, 111u8],
            [72u8, 31u8, 147u8, 118u8],
            [72u8, 46u8, 219u8, 7u8],
            [77u8, 83u8, 233u8, 49u8],
            [77u8, 162u8, 248u8, 153u8],
            [80u8, 22u8, 196u8, 123u8],
            [80u8, 98u8, 148u8, 220u8],
            [87u8, 55u8, 97u8, 152u8],
            [88u8, 151u8, 155u8, 254u8],
            [92u8, 151u8, 90u8, 187u8],
            [92u8, 248u8, 128u8, 18u8],
            [94u8, 166u8, 60u8, 108u8],
            [96u8, 182u8, 191u8, 221u8],
            [99u8, 110u8, 230u8, 36u8],
            [102u8, 94u8, 14u8, 237u8],
            [103u8, 222u8, 139u8, 126u8],
            [108u8, 131u8, 90u8, 130u8],
            [113u8, 80u8, 24u8, 166u8],
            [113u8, 143u8, 188u8, 37u8],
            [120u8, 170u8, 242u8, 94u8],
            [124u8, 76u8, 79u8, 235u8],
            [125u8, 232u8, 159u8, 48u8],
            [126u8, 73u8, 68u8, 127u8],
            [128u8, 167u8, 44u8, 139u8],
            [132u8, 86u8, 203u8, 89u8],
            [132u8, 176u8, 25u8, 110u8],
            [135u8, 1u8, 215u8, 178u8],
            [135u8, 139u8, 161u8, 86u8],
            [136u8, 66u8, 197u8, 115u8],
            [136u8, 146u8, 114u8, 150u8],
            [137u8, 39u8, 161u8, 6u8],
            [137u8, 242u8, 151u8, 189u8],
            [141u8, 165u8, 203u8, 91u8],
            [144u8, 34u8, 56u8, 225u8],
            [147u8, 169u8, 238u8, 70u8],
            [153u8, 180u8, 153u8, 37u8],
            [157u8, 97u8, 221u8, 7u8],
            [158u8, 250u8, 202u8, 121u8],
            [163u8, 77u8, 40u8, 235u8],
            [166u8, 48u8, 37u8, 89u8],
            [166u8, 233u8, 47u8, 60u8],
            [167u8, 236u8, 157u8, 249u8],
            [170u8, 99u8, 229u8, 69u8],
            [170u8, 148u8, 54u8, 12u8],
            [177u8, 51u8, 190u8, 125u8],
            [179u8, 113u8, 250u8, 105u8],
            [182u8, 181u8, 95u8, 37u8],
            [183u8, 237u8, 2u8, 14u8],
            [185u8, 142u8, 99u8, 29u8],
            [188u8, 92u8, 89u8, 80u8],
            [192u8, 40u8, 62u8, 98u8],
            [198u8, 59u8, 191u8, 41u8],
            [202u8, 2u8, 168u8, 30u8],
            [206u8, 245u8, 244u8, 130u8],
            [211u8, 139u8, 1u8, 139u8],
            [219u8, 20u8, 251u8, 65u8],
            [220u8, 31u8, 154u8, 223u8],
            [220u8, 143u8, 134u8, 51u8],
            [222u8, 64u8, 216u8, 159u8],
            [226u8, 77u8, 92u8, 53u8],
            [232u8, 190u8, 101u8, 4u8],
            [236u8, 248u8, 139u8, 176u8],
            [238u8, 185u8, 2u8, 89u8],
            [240u8, 62u8, 182u8, 26u8],
            [240u8, 78u8, 2u8, 192u8],
            [241u8, 39u8, 169u8, 179u8],
            [242u8, 253u8, 227u8, 139u8],
            [245u8, 22u8, 165u8, 180u8],
            [246u8, 84u8, 183u8, 208u8],
            [249u8, 253u8, 202u8, 230u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(withdrawProtocolProfit),
            ::core::stringify!(isChainDeprecated),
            ::core::stringify!(SWAP_EXECUTOR),
            ::core::stringify!(setChainDeprecated),
            ::core::stringify!(setProtocolFloorPpm),
            ::core::stringify!(bridgers),
            ::core::stringify!(withdraw),
            ::core::stringify!(usdt),
            ::core::stringify!(leasesByReceiver),
            ::core::stringify!(realtorMinFeePpm),
            ::core::stringify!(setPayoutConfig),
            ::core::stringify!(claimQueueLength),
            ::core::stringify!(realtorLeaseRateLimit),
            ::core::stringify!(exposedProcessReceiverPulled),
            ::core::stringify!(subjectivePreEntitlementByTxId),
            ::core::stringify!(unpause),
            ::core::stringify!(predictReceiverAddress_0),
            ::core::stringify!(setRealtorMaxLeaseDurationSeconds),
            ::core::stringify!(effectiveLeaseRateLimit),
            ::core::stringify!(depositToPnl),
            ::core::stringify!(lesseePayoutConfigRateLimit),
            ::core::stringify!(usdtBalance),
            ::core::stringify!(eventChainTip),
            ::core::stringify!(lpPrincipal),
            ::core::stringify!(processControllerEvents),
            ::core::stringify!(setProtocolFloorFlatFee),
            ::core::stringify!(rescueTokens),
            ::core::stringify!(setUsdt),
            ::core::stringify!(paused),
            ::core::stringify!(relayControllerEventChain),
            ::core::stringify!(setRealtorMinFeePpm),
            ::core::stringify!(isRealtor),
            ::core::stringify!(setLesseePayoutConfigRateLimit),
            ::core::stringify!(setBridger),
            ::core::stringify!(protocolFloorFlatFee),
            ::core::stringify!(leaseNonces),
            ::core::stringify!(renounceOwnership),
            ::core::stringify!(claimLocatorByLease),
            ::core::stringify!(claimsByTargetToken),
            ::core::stringify!(controllerEventAt),
            ::core::stringify!(realtorMinFlatFee),
            ::core::stringify!(createLease),
            ::core::stringify!(tronReader),
            ::core::stringify!(pause),
            ::core::stringify!(eip712Domain),
            ::core::stringify!(setLp),
            ::core::stringify!(setRealtor),
            ::core::stringify!(effectiveMaxLeaseDurationSeconds),
            ::core::stringify!(depositProcessed),
            ::core::stringify!(leases),
            ::core::stringify!(exposedDecodeEventChainTip),
            ::core::stringify!(owner),
            ::core::stringify!(nextLeaseId),
            ::core::stringify!(protocolFloorPpm),
            ::core::stringify!(fill),
            ::core::stringify!(realtorMaxLeaseDurationSeconds),
            ::core::stringify!(receiverBytecode),
            ::core::stringify!(setPayoutConfigWithSig),
            ::core::stringify!(lastControllerEventTip),
            ::core::stringify!(controllerEventsLength),
            ::core::stringify!(subjectivePreEntitle),
            ::core::stringify!(pushControllerEvent),
            ::core::stringify!(predictReceiverAddress_1),
            ::core::stringify!(protocolMaxLeaseDurationSeconds),
            ::core::stringify!(lastControllerEventSeq),
            ::core::stringify!(deposit),
            ::core::stringify!(protocolPnl),
            ::core::stringify!(CONTROLLER_ADDRESS),
            ::core::stringify!(isLpAllowed),
            ::core::stringify!(enqueueClaim),
            ::core::stringify!(lastReceiverPullTimestampByToken),
            ::core::stringify!(nextLeaseNumberAtReceiver),
            ::core::stringify!(setSwapRate),
            ::core::stringify!(leaseIdsByReceiver),
            ::core::stringify!(evmToTron),
            ::core::stringify!(setProtocolMaxLeaseDurationSeconds),
            ::core::stringify!(tronUsdt),
            ::core::stringify!(RECEIVER_IMPL),
            ::core::stringify!(eventSeq),
            ::core::stringify!(leaseLocatorById),
            ::core::stringify!(setRealtorLeaseRateLimit),
            ::core::stringify!(nextIndexByTargetToken),
            ::core::stringify!(setRealtorMinFlatFee),
            ::core::stringify!(swapRatePpm),
            ::core::stringify!(nextControllerEventIndex),
            ::core::stringify!(transferOwnership),
            ::core::stringify!(nextClaimIdByLease),
            ::core::stringify!(setTronReader),
            ::core::stringify!(preEntitle),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <withdrawProtocolProfitCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isChainDeprecatedCall as alloy_sol_types::SolCall>::SIGNATURE,
            <SWAP_EXECUTORCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setChainDeprecatedCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setProtocolFloorPpmCall as alloy_sol_types::SolCall>::SIGNATURE,
            <bridgersCall as alloy_sol_types::SolCall>::SIGNATURE,
            <withdrawCall as alloy_sol_types::SolCall>::SIGNATURE,
            <usdtCall as alloy_sol_types::SolCall>::SIGNATURE,
            <leasesByReceiverCall as alloy_sol_types::SolCall>::SIGNATURE,
            <realtorMinFeePpmCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setPayoutConfigCall as alloy_sol_types::SolCall>::SIGNATURE,
            <claimQueueLengthCall as alloy_sol_types::SolCall>::SIGNATURE,
            <realtorLeaseRateLimitCall as alloy_sol_types::SolCall>::SIGNATURE,
            <exposedProcessReceiverPulledCall as alloy_sol_types::SolCall>::SIGNATURE,
            <subjectivePreEntitlementByTxIdCall as alloy_sol_types::SolCall>::SIGNATURE,
            <unpauseCall as alloy_sol_types::SolCall>::SIGNATURE,
            <predictReceiverAddress_0Call as alloy_sol_types::SolCall>::SIGNATURE,
            <setRealtorMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <effectiveLeaseRateLimitCall as alloy_sol_types::SolCall>::SIGNATURE,
            <depositToPnlCall as alloy_sol_types::SolCall>::SIGNATURE,
            <lesseePayoutConfigRateLimitCall as alloy_sol_types::SolCall>::SIGNATURE,
            <usdtBalanceCall as alloy_sol_types::SolCall>::SIGNATURE,
            <eventChainTipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <lpPrincipalCall as alloy_sol_types::SolCall>::SIGNATURE,
            <processControllerEventsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setProtocolFloorFlatFeeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <rescueTokensCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setUsdtCall as alloy_sol_types::SolCall>::SIGNATURE,
            <pausedCall as alloy_sol_types::SolCall>::SIGNATURE,
            <relayControllerEventChainCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setRealtorMinFeePpmCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isRealtorCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setLesseePayoutConfigRateLimitCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setBridgerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <protocolFloorFlatFeeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <leaseNoncesCall as alloy_sol_types::SolCall>::SIGNATURE,
            <renounceOwnershipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <claimLocatorByLeaseCall as alloy_sol_types::SolCall>::SIGNATURE,
            <claimsByTargetTokenCall as alloy_sol_types::SolCall>::SIGNATURE,
            <controllerEventAtCall as alloy_sol_types::SolCall>::SIGNATURE,
            <realtorMinFlatFeeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <createLeaseCall as alloy_sol_types::SolCall>::SIGNATURE,
            <tronReaderCall as alloy_sol_types::SolCall>::SIGNATURE,
            <pauseCall as alloy_sol_types::SolCall>::SIGNATURE,
            <eip712DomainCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setLpCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setRealtorCall as alloy_sol_types::SolCall>::SIGNATURE,
            <effectiveMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <depositProcessedCall as alloy_sol_types::SolCall>::SIGNATURE,
            <leasesCall as alloy_sol_types::SolCall>::SIGNATURE,
            <exposedDecodeEventChainTipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <ownerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <nextLeaseIdCall as alloy_sol_types::SolCall>::SIGNATURE,
            <protocolFloorPpmCall as alloy_sol_types::SolCall>::SIGNATURE,
            <fillCall as alloy_sol_types::SolCall>::SIGNATURE,
            <realtorMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <receiverBytecodeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setPayoutConfigWithSigCall as alloy_sol_types::SolCall>::SIGNATURE,
            <lastControllerEventTipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <controllerEventsLengthCall as alloy_sol_types::SolCall>::SIGNATURE,
            <subjectivePreEntitleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <pushControllerEventCall as alloy_sol_types::SolCall>::SIGNATURE,
            <predictReceiverAddress_1Call as alloy_sol_types::SolCall>::SIGNATURE,
            <protocolMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <lastControllerEventSeqCall as alloy_sol_types::SolCall>::SIGNATURE,
            <depositCall as alloy_sol_types::SolCall>::SIGNATURE,
            <protocolPnlCall as alloy_sol_types::SolCall>::SIGNATURE,
            <CONTROLLER_ADDRESSCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isLpAllowedCall as alloy_sol_types::SolCall>::SIGNATURE,
            <enqueueClaimCall as alloy_sol_types::SolCall>::SIGNATURE,
            <lastReceiverPullTimestampByTokenCall as alloy_sol_types::SolCall>::SIGNATURE,
            <nextLeaseNumberAtReceiverCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setSwapRateCall as alloy_sol_types::SolCall>::SIGNATURE,
            <leaseIdsByReceiverCall as alloy_sol_types::SolCall>::SIGNATURE,
            <evmToTronCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setProtocolMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <tronUsdtCall as alloy_sol_types::SolCall>::SIGNATURE,
            <RECEIVER_IMPLCall as alloy_sol_types::SolCall>::SIGNATURE,
            <eventSeqCall as alloy_sol_types::SolCall>::SIGNATURE,
            <leaseLocatorByIdCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setRealtorLeaseRateLimitCall as alloy_sol_types::SolCall>::SIGNATURE,
            <nextIndexByTargetTokenCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setRealtorMinFlatFeeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <swapRatePpmCall as alloy_sol_types::SolCall>::SIGNATURE,
            <nextControllerEventIndexCall as alloy_sol_types::SolCall>::SIGNATURE,
            <transferOwnershipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <nextClaimIdByLeaseCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setTronReaderCall as alloy_sol_types::SolCall>::SIGNATURE,
            <preEntitleCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for UntronV3HarnessCalls {
        const NAME: &'static str = "UntronV3HarnessCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 89usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::CONTROLLER_ADDRESS(_) => {
                    <CONTROLLER_ADDRESSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::RECEIVER_IMPL(_) => {
                    <RECEIVER_IMPLCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SWAP_EXECUTOR(_) => {
                    <SWAP_EXECUTORCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::bridgers(_) => <bridgersCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::claimLocatorByLease(_) => {
                    <claimLocatorByLeaseCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimQueueLength(_) => {
                    <claimQueueLengthCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimsByTargetToken(_) => {
                    <claimsByTargetTokenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::controllerEventAt(_) => {
                    <controllerEventAtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::controllerEventsLength(_) => {
                    <controllerEventsLengthCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createLease(_) => {
                    <createLeaseCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::deposit(_) => <depositCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::depositProcessed(_) => {
                    <depositProcessedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::depositToPnl(_) => {
                    <depositToPnlCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::effectiveLeaseRateLimit(_) => {
                    <effectiveLeaseRateLimitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::effectiveMaxLeaseDurationSeconds(_) => {
                    <effectiveMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eip712Domain(_) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::enqueueClaim(_) => {
                    <enqueueClaimCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eventChainTip(_) => {
                    <eventChainTipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eventSeq(_) => <eventSeqCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::evmToTron(_) => {
                    <evmToTronCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::exposedDecodeEventChainTip(_) => {
                    <exposedDecodeEventChainTipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::exposedProcessReceiverPulled(_) => {
                    <exposedProcessReceiverPulledCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fill(_) => <fillCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isChainDeprecated(_) => {
                    <isChainDeprecatedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isLpAllowed(_) => {
                    <isLpAllowedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isRealtor(_) => {
                    <isRealtorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::lastControllerEventSeq(_) => {
                    <lastControllerEventSeqCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::lastControllerEventTip(_) => {
                    <lastControllerEventTipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::lastReceiverPullTimestampByToken(_) => {
                    <lastReceiverPullTimestampByTokenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::leaseIdsByReceiver(_) => {
                    <leaseIdsByReceiverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::leaseLocatorById(_) => {
                    <leaseLocatorByIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::leaseNonces(_) => {
                    <leaseNoncesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::leases(_) => <leasesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::leasesByReceiver(_) => {
                    <leasesByReceiverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::lesseePayoutConfigRateLimit(_) => {
                    <lesseePayoutConfigRateLimitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::lpPrincipal(_) => {
                    <lpPrincipalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::nextClaimIdByLease(_) => {
                    <nextClaimIdByLeaseCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::nextControllerEventIndex(_) => {
                    <nextControllerEventIndexCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::nextIndexByTargetToken(_) => {
                    <nextIndexByTargetTokenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::nextLeaseId(_) => {
                    <nextLeaseIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::nextLeaseNumberAtReceiver(_) => {
                    <nextLeaseNumberAtReceiverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::preEntitle(_) => {
                    <preEntitleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::predictReceiverAddress_0(_) => {
                    <predictReceiverAddress_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::predictReceiverAddress_1(_) => {
                    <predictReceiverAddress_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::processControllerEvents(_) => {
                    <processControllerEventsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::protocolFloorFlatFee(_) => {
                    <protocolFloorFlatFeeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::protocolFloorPpm(_) => {
                    <protocolFloorPpmCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::protocolMaxLeaseDurationSeconds(_) => {
                    <protocolMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::protocolPnl(_) => {
                    <protocolPnlCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pushControllerEvent(_) => {
                    <pushControllerEventCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::realtorLeaseRateLimit(_) => {
                    <realtorLeaseRateLimitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::realtorMaxLeaseDurationSeconds(_) => {
                    <realtorMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::realtorMinFeePpm(_) => {
                    <realtorMinFeePpmCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::realtorMinFlatFee(_) => {
                    <realtorMinFlatFeeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::receiverBytecode(_) => {
                    <receiverBytecodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::relayControllerEventChain(_) => {
                    <relayControllerEventChainCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::rescueTokens(_) => {
                    <rescueTokensCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridger(_) => {
                    <setBridgerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setChainDeprecated(_) => {
                    <setChainDeprecatedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setLesseePayoutConfigRateLimit(_) => {
                    <setLesseePayoutConfigRateLimitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setLp(_) => <setLpCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::setPayoutConfig(_) => {
                    <setPayoutConfigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setPayoutConfigWithSig(_) => {
                    <setPayoutConfigWithSigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setProtocolFloorFlatFee(_) => {
                    <setProtocolFloorFlatFeeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setProtocolFloorPpm(_) => {
                    <setProtocolFloorPpmCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setProtocolMaxLeaseDurationSeconds(_) => {
                    <setProtocolMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setRealtor(_) => {
                    <setRealtorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setRealtorLeaseRateLimit(_) => {
                    <setRealtorLeaseRateLimitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setRealtorMaxLeaseDurationSeconds(_) => {
                    <setRealtorMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setRealtorMinFeePpm(_) => {
                    <setRealtorMinFeePpmCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setRealtorMinFlatFee(_) => {
                    <setRealtorMinFlatFeeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setSwapRate(_) => {
                    <setSwapRateCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setTronReader(_) => {
                    <setTronReaderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setUsdt(_) => <setUsdtCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::subjectivePreEntitle(_) => {
                    <subjectivePreEntitleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::subjectivePreEntitlementByTxId(_) => {
                    <subjectivePreEntitlementByTxIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::swapRatePpm(_) => {
                    <swapRatePpmCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::tronReader(_) => {
                    <tronReaderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::tronUsdt(_) => <tronUsdtCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::usdt(_) => <usdtCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::usdtBalance(_) => {
                    <usdtBalanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::withdraw(_) => <withdrawCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::withdrawProtocolProfit(_) => {
                    <withdrawProtocolProfitCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<UntronV3HarnessCalls>] = &[
                {
                    fn withdrawProtocolProfit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <withdrawProtocolProfitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::withdrawProtocolProfit)
                    }
                    withdrawProtocolProfit
                },
                {
                    fn isChainDeprecated(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <isChainDeprecatedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::isChainDeprecated)
                    }
                    isChainDeprecated
                },
                {
                    fn SWAP_EXECUTOR(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <SWAP_EXECUTORCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::SWAP_EXECUTOR)
                    }
                    SWAP_EXECUTOR
                },
                {
                    fn setChainDeprecated(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setChainDeprecatedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setChainDeprecated)
                    }
                    setChainDeprecated
                },
                {
                    fn setProtocolFloorPpm(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setProtocolFloorPpmCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setProtocolFloorPpm)
                    }
                    setProtocolFloorPpm
                },
                {
                    fn bridgers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <bridgersCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::bridgers)
                    }
                    bridgers
                },
                {
                    fn withdraw(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <withdrawCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::withdraw)
                    }
                    withdraw
                },
                {
                    fn usdt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <usdtCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::usdt)
                    }
                    usdt
                },
                {
                    fn leasesByReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <leasesByReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::leasesByReceiver)
                    }
                    leasesByReceiver
                },
                {
                    fn realtorMinFeePpm(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <realtorMinFeePpmCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::realtorMinFeePpm)
                    }
                    realtorMinFeePpm
                },
                {
                    fn setPayoutConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setPayoutConfigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setPayoutConfig)
                    }
                    setPayoutConfig
                },
                {
                    fn claimQueueLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <claimQueueLengthCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::claimQueueLength)
                    }
                    claimQueueLength
                },
                {
                    fn realtorLeaseRateLimit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <realtorLeaseRateLimitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::realtorLeaseRateLimit)
                    }
                    realtorLeaseRateLimit
                },
                {
                    fn exposedProcessReceiverPulled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <exposedProcessReceiverPulledCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::exposedProcessReceiverPulled)
                    }
                    exposedProcessReceiverPulled
                },
                {
                    fn subjectivePreEntitlementByTxId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <subjectivePreEntitlementByTxIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::subjectivePreEntitlementByTxId)
                    }
                    subjectivePreEntitlementByTxId
                },
                {
                    fn unpause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::unpause)
                    }
                    unpause
                },
                {
                    fn predictReceiverAddress_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <predictReceiverAddress_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::predictReceiverAddress_0)
                    }
                    predictReceiverAddress_0
                },
                {
                    fn setRealtorMaxLeaseDurationSeconds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setRealtorMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setRealtorMaxLeaseDurationSeconds)
                    }
                    setRealtorMaxLeaseDurationSeconds
                },
                {
                    fn effectiveLeaseRateLimit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <effectiveLeaseRateLimitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::effectiveLeaseRateLimit)
                    }
                    effectiveLeaseRateLimit
                },
                {
                    fn depositToPnl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <depositToPnlCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::depositToPnl)
                    }
                    depositToPnl
                },
                {
                    fn lesseePayoutConfigRateLimit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <lesseePayoutConfigRateLimitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::lesseePayoutConfigRateLimit)
                    }
                    lesseePayoutConfigRateLimit
                },
                {
                    fn usdtBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <usdtBalanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::usdtBalance)
                    }
                    usdtBalance
                },
                {
                    fn eventChainTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <eventChainTipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::eventChainTip)
                    }
                    eventChainTip
                },
                {
                    fn lpPrincipal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <lpPrincipalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::lpPrincipal)
                    }
                    lpPrincipal
                },
                {
                    fn processControllerEvents(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <processControllerEventsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::processControllerEvents)
                    }
                    processControllerEvents
                },
                {
                    fn setProtocolFloorFlatFee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setProtocolFloorFlatFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setProtocolFloorFlatFee)
                    }
                    setProtocolFloorFlatFee
                },
                {
                    fn rescueTokens(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <rescueTokensCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::rescueTokens)
                    }
                    rescueTokens
                },
                {
                    fn setUsdt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setUsdtCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::setUsdt)
                    }
                    setUsdt
                },
                {
                    fn paused(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::paused)
                    }
                    paused
                },
                {
                    fn relayControllerEventChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <relayControllerEventChainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::relayControllerEventChain)
                    }
                    relayControllerEventChain
                },
                {
                    fn setRealtorMinFeePpm(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setRealtorMinFeePpmCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setRealtorMinFeePpm)
                    }
                    setRealtorMinFeePpm
                },
                {
                    fn isRealtor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <isRealtorCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::isRealtor)
                    }
                    isRealtor
                },
                {
                    fn setLesseePayoutConfigRateLimit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setLesseePayoutConfigRateLimitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setLesseePayoutConfigRateLimit)
                    }
                    setLesseePayoutConfigRateLimit
                },
                {
                    fn setBridger(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setBridgerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setBridger)
                    }
                    setBridger
                },
                {
                    fn protocolFloorFlatFee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <protocolFloorFlatFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::protocolFloorFlatFee)
                    }
                    protocolFloorFlatFee
                },
                {
                    fn leaseNonces(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <leaseNoncesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::leaseNonces)
                    }
                    leaseNonces
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn claimLocatorByLease(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <claimLocatorByLeaseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::claimLocatorByLease)
                    }
                    claimLocatorByLease
                },
                {
                    fn claimsByTargetToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <claimsByTargetTokenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::claimsByTargetToken)
                    }
                    claimsByTargetToken
                },
                {
                    fn controllerEventAt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <controllerEventAtCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::controllerEventAt)
                    }
                    controllerEventAt
                },
                {
                    fn realtorMinFlatFee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <realtorMinFlatFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::realtorMinFlatFee)
                    }
                    realtorMinFlatFee
                },
                {
                    fn createLease(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <createLeaseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::createLease)
                    }
                    createLease
                },
                {
                    fn tronReader(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <tronReaderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::tronReader)
                    }
                    tronReader
                },
                {
                    fn pause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::pause)
                    }
                    pause
                },
                {
                    fn eip712Domain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <eip712DomainCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::eip712Domain)
                    }
                    eip712Domain
                },
                {
                    fn setLp(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setLpCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::setLp)
                    }
                    setLp
                },
                {
                    fn setRealtor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setRealtorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setRealtor)
                    }
                    setRealtor
                },
                {
                    fn effectiveMaxLeaseDurationSeconds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <effectiveMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::effectiveMaxLeaseDurationSeconds)
                    }
                    effectiveMaxLeaseDurationSeconds
                },
                {
                    fn depositProcessed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <depositProcessedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::depositProcessed)
                    }
                    depositProcessed
                },
                {
                    fn leases(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <leasesCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::leases)
                    }
                    leases
                },
                {
                    fn exposedDecodeEventChainTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <exposedDecodeEventChainTipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::exposedDecodeEventChainTip)
                    }
                    exposedDecodeEventChainTip
                },
                {
                    fn owner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::owner)
                    }
                    owner
                },
                {
                    fn nextLeaseId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <nextLeaseIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::nextLeaseId)
                    }
                    nextLeaseId
                },
                {
                    fn protocolFloorPpm(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <protocolFloorPpmCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::protocolFloorPpm)
                    }
                    protocolFloorPpm
                },
                {
                    fn fill(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <fillCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::fill)
                    }
                    fill
                },
                {
                    fn realtorMaxLeaseDurationSeconds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <realtorMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::realtorMaxLeaseDurationSeconds)
                    }
                    realtorMaxLeaseDurationSeconds
                },
                {
                    fn receiverBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <receiverBytecodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::receiverBytecode)
                    }
                    receiverBytecode
                },
                {
                    fn setPayoutConfigWithSig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setPayoutConfigWithSigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setPayoutConfigWithSig)
                    }
                    setPayoutConfigWithSig
                },
                {
                    fn lastControllerEventTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <lastControllerEventTipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::lastControllerEventTip)
                    }
                    lastControllerEventTip
                },
                {
                    fn controllerEventsLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <controllerEventsLengthCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::controllerEventsLength)
                    }
                    controllerEventsLength
                },
                {
                    fn subjectivePreEntitle(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <subjectivePreEntitleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::subjectivePreEntitle)
                    }
                    subjectivePreEntitle
                },
                {
                    fn pushControllerEvent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <pushControllerEventCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::pushControllerEvent)
                    }
                    pushControllerEvent
                },
                {
                    fn predictReceiverAddress_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <predictReceiverAddress_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::predictReceiverAddress_1)
                    }
                    predictReceiverAddress_1
                },
                {
                    fn protocolMaxLeaseDurationSeconds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <protocolMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::protocolMaxLeaseDurationSeconds)
                    }
                    protocolMaxLeaseDurationSeconds
                },
                {
                    fn lastControllerEventSeq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <lastControllerEventSeqCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::lastControllerEventSeq)
                    }
                    lastControllerEventSeq
                },
                {
                    fn deposit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <depositCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::deposit)
                    }
                    deposit
                },
                {
                    fn protocolPnl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <protocolPnlCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::protocolPnl)
                    }
                    protocolPnl
                },
                {
                    fn CONTROLLER_ADDRESS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <CONTROLLER_ADDRESSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::CONTROLLER_ADDRESS)
                    }
                    CONTROLLER_ADDRESS
                },
                {
                    fn isLpAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <isLpAllowedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::isLpAllowed)
                    }
                    isLpAllowed
                },
                {
                    fn enqueueClaim(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <enqueueClaimCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::enqueueClaim)
                    }
                    enqueueClaim
                },
                {
                    fn lastReceiverPullTimestampByToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <lastReceiverPullTimestampByTokenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::lastReceiverPullTimestampByToken)
                    }
                    lastReceiverPullTimestampByToken
                },
                {
                    fn nextLeaseNumberAtReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <nextLeaseNumberAtReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::nextLeaseNumberAtReceiver)
                    }
                    nextLeaseNumberAtReceiver
                },
                {
                    fn setSwapRate(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setSwapRateCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setSwapRate)
                    }
                    setSwapRate
                },
                {
                    fn leaseIdsByReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <leaseIdsByReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::leaseIdsByReceiver)
                    }
                    leaseIdsByReceiver
                },
                {
                    fn evmToTron(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <evmToTronCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::evmToTron)
                    }
                    evmToTron
                },
                {
                    fn setProtocolMaxLeaseDurationSeconds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setProtocolMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                UntronV3HarnessCalls::setProtocolMaxLeaseDurationSeconds,
                            )
                    }
                    setProtocolMaxLeaseDurationSeconds
                },
                {
                    fn tronUsdt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <tronUsdtCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::tronUsdt)
                    }
                    tronUsdt
                },
                {
                    fn RECEIVER_IMPL(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <RECEIVER_IMPLCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::RECEIVER_IMPL)
                    }
                    RECEIVER_IMPL
                },
                {
                    fn eventSeq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <eventSeqCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronV3HarnessCalls::eventSeq)
                    }
                    eventSeq
                },
                {
                    fn leaseLocatorById(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <leaseLocatorByIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::leaseLocatorById)
                    }
                    leaseLocatorById
                },
                {
                    fn setRealtorLeaseRateLimit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setRealtorLeaseRateLimitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setRealtorLeaseRateLimit)
                    }
                    setRealtorLeaseRateLimit
                },
                {
                    fn nextIndexByTargetToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <nextIndexByTargetTokenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::nextIndexByTargetToken)
                    }
                    nextIndexByTargetToken
                },
                {
                    fn setRealtorMinFlatFee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setRealtorMinFlatFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setRealtorMinFlatFee)
                    }
                    setRealtorMinFlatFee
                },
                {
                    fn swapRatePpm(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <swapRatePpmCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::swapRatePpm)
                    }
                    swapRatePpm
                },
                {
                    fn nextControllerEventIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <nextControllerEventIndexCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::nextControllerEventIndex)
                    }
                    nextControllerEventIndex
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn nextClaimIdByLease(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <nextClaimIdByLeaseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::nextClaimIdByLease)
                    }
                    nextClaimIdByLease
                },
                {
                    fn setTronReader(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setTronReaderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setTronReader)
                    }
                    setTronReader
                },
                {
                    fn preEntitle(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <preEntitleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessCalls::preEntitle)
                    }
                    preEntitle
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<UntronV3HarnessCalls>] = &[
                {
                    fn withdrawProtocolProfit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <withdrawProtocolProfitCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::withdrawProtocolProfit)
                    }
                    withdrawProtocolProfit
                },
                {
                    fn isChainDeprecated(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <isChainDeprecatedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::isChainDeprecated)
                    }
                    isChainDeprecated
                },
                {
                    fn SWAP_EXECUTOR(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <SWAP_EXECUTORCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::SWAP_EXECUTOR)
                    }
                    SWAP_EXECUTOR
                },
                {
                    fn setChainDeprecated(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setChainDeprecatedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setChainDeprecated)
                    }
                    setChainDeprecated
                },
                {
                    fn setProtocolFloorPpm(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setProtocolFloorPpmCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setProtocolFloorPpm)
                    }
                    setProtocolFloorPpm
                },
                {
                    fn bridgers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <bridgersCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::bridgers)
                    }
                    bridgers
                },
                {
                    fn withdraw(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <withdrawCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::withdraw)
                    }
                    withdraw
                },
                {
                    fn usdt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <usdtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::usdt)
                    }
                    usdt
                },
                {
                    fn leasesByReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <leasesByReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::leasesByReceiver)
                    }
                    leasesByReceiver
                },
                {
                    fn realtorMinFeePpm(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <realtorMinFeePpmCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::realtorMinFeePpm)
                    }
                    realtorMinFeePpm
                },
                {
                    fn setPayoutConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setPayoutConfigCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setPayoutConfig)
                    }
                    setPayoutConfig
                },
                {
                    fn claimQueueLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <claimQueueLengthCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::claimQueueLength)
                    }
                    claimQueueLength
                },
                {
                    fn realtorLeaseRateLimit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <realtorLeaseRateLimitCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::realtorLeaseRateLimit)
                    }
                    realtorLeaseRateLimit
                },
                {
                    fn exposedProcessReceiverPulled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <exposedProcessReceiverPulledCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::exposedProcessReceiverPulled)
                    }
                    exposedProcessReceiverPulled
                },
                {
                    fn subjectivePreEntitlementByTxId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <subjectivePreEntitlementByTxIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::subjectivePreEntitlementByTxId)
                    }
                    subjectivePreEntitlementByTxId
                },
                {
                    fn unpause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::unpause)
                    }
                    unpause
                },
                {
                    fn predictReceiverAddress_0(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <predictReceiverAddress_0Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::predictReceiverAddress_0)
                    }
                    predictReceiverAddress_0
                },
                {
                    fn setRealtorMaxLeaseDurationSeconds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setRealtorMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setRealtorMaxLeaseDurationSeconds)
                    }
                    setRealtorMaxLeaseDurationSeconds
                },
                {
                    fn effectiveLeaseRateLimit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <effectiveLeaseRateLimitCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::effectiveLeaseRateLimit)
                    }
                    effectiveLeaseRateLimit
                },
                {
                    fn depositToPnl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <depositToPnlCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::depositToPnl)
                    }
                    depositToPnl
                },
                {
                    fn lesseePayoutConfigRateLimit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <lesseePayoutConfigRateLimitCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::lesseePayoutConfigRateLimit)
                    }
                    lesseePayoutConfigRateLimit
                },
                {
                    fn usdtBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <usdtBalanceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::usdtBalance)
                    }
                    usdtBalance
                },
                {
                    fn eventChainTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <eventChainTipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::eventChainTip)
                    }
                    eventChainTip
                },
                {
                    fn lpPrincipal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <lpPrincipalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::lpPrincipal)
                    }
                    lpPrincipal
                },
                {
                    fn processControllerEvents(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <processControllerEventsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::processControllerEvents)
                    }
                    processControllerEvents
                },
                {
                    fn setProtocolFloorFlatFee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setProtocolFloorFlatFeeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setProtocolFloorFlatFee)
                    }
                    setProtocolFloorFlatFee
                },
                {
                    fn rescueTokens(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <rescueTokensCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::rescueTokens)
                    }
                    rescueTokens
                },
                {
                    fn setUsdt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setUsdtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setUsdt)
                    }
                    setUsdt
                },
                {
                    fn paused(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::paused)
                    }
                    paused
                },
                {
                    fn relayControllerEventChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <relayControllerEventChainCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::relayControllerEventChain)
                    }
                    relayControllerEventChain
                },
                {
                    fn setRealtorMinFeePpm(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setRealtorMinFeePpmCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setRealtorMinFeePpm)
                    }
                    setRealtorMinFeePpm
                },
                {
                    fn isRealtor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <isRealtorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::isRealtor)
                    }
                    isRealtor
                },
                {
                    fn setLesseePayoutConfigRateLimit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setLesseePayoutConfigRateLimitCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setLesseePayoutConfigRateLimit)
                    }
                    setLesseePayoutConfigRateLimit
                },
                {
                    fn setBridger(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setBridgerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setBridger)
                    }
                    setBridger
                },
                {
                    fn protocolFloorFlatFee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <protocolFloorFlatFeeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::protocolFloorFlatFee)
                    }
                    protocolFloorFlatFee
                },
                {
                    fn leaseNonces(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <leaseNoncesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::leaseNonces)
                    }
                    leaseNonces
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn claimLocatorByLease(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <claimLocatorByLeaseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::claimLocatorByLease)
                    }
                    claimLocatorByLease
                },
                {
                    fn claimsByTargetToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <claimsByTargetTokenCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::claimsByTargetToken)
                    }
                    claimsByTargetToken
                },
                {
                    fn controllerEventAt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <controllerEventAtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::controllerEventAt)
                    }
                    controllerEventAt
                },
                {
                    fn realtorMinFlatFee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <realtorMinFlatFeeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::realtorMinFlatFee)
                    }
                    realtorMinFlatFee
                },
                {
                    fn createLease(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <createLeaseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::createLease)
                    }
                    createLease
                },
                {
                    fn tronReader(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <tronReaderCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::tronReader)
                    }
                    tronReader
                },
                {
                    fn pause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::pause)
                    }
                    pause
                },
                {
                    fn eip712Domain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <eip712DomainCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::eip712Domain)
                    }
                    eip712Domain
                },
                {
                    fn setLp(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setLpCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setLp)
                    }
                    setLp
                },
                {
                    fn setRealtor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setRealtorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setRealtor)
                    }
                    setRealtor
                },
                {
                    fn effectiveMaxLeaseDurationSeconds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <effectiveMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::effectiveMaxLeaseDurationSeconds)
                    }
                    effectiveMaxLeaseDurationSeconds
                },
                {
                    fn depositProcessed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <depositProcessedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::depositProcessed)
                    }
                    depositProcessed
                },
                {
                    fn leases(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <leasesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::leases)
                    }
                    leases
                },
                {
                    fn exposedDecodeEventChainTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <exposedDecodeEventChainTipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::exposedDecodeEventChainTip)
                    }
                    exposedDecodeEventChainTip
                },
                {
                    fn owner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::owner)
                    }
                    owner
                },
                {
                    fn nextLeaseId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <nextLeaseIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::nextLeaseId)
                    }
                    nextLeaseId
                },
                {
                    fn protocolFloorPpm(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <protocolFloorPpmCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::protocolFloorPpm)
                    }
                    protocolFloorPpm
                },
                {
                    fn fill(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <fillCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::fill)
                    }
                    fill
                },
                {
                    fn realtorMaxLeaseDurationSeconds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <realtorMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::realtorMaxLeaseDurationSeconds)
                    }
                    realtorMaxLeaseDurationSeconds
                },
                {
                    fn receiverBytecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <receiverBytecodeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::receiverBytecode)
                    }
                    receiverBytecode
                },
                {
                    fn setPayoutConfigWithSig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setPayoutConfigWithSigCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setPayoutConfigWithSig)
                    }
                    setPayoutConfigWithSig
                },
                {
                    fn lastControllerEventTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <lastControllerEventTipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::lastControllerEventTip)
                    }
                    lastControllerEventTip
                },
                {
                    fn controllerEventsLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <controllerEventsLengthCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::controllerEventsLength)
                    }
                    controllerEventsLength
                },
                {
                    fn subjectivePreEntitle(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <subjectivePreEntitleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::subjectivePreEntitle)
                    }
                    subjectivePreEntitle
                },
                {
                    fn pushControllerEvent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <pushControllerEventCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::pushControllerEvent)
                    }
                    pushControllerEvent
                },
                {
                    fn predictReceiverAddress_1(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <predictReceiverAddress_1Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::predictReceiverAddress_1)
                    }
                    predictReceiverAddress_1
                },
                {
                    fn protocolMaxLeaseDurationSeconds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <protocolMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::protocolMaxLeaseDurationSeconds)
                    }
                    protocolMaxLeaseDurationSeconds
                },
                {
                    fn lastControllerEventSeq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <lastControllerEventSeqCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::lastControllerEventSeq)
                    }
                    lastControllerEventSeq
                },
                {
                    fn deposit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <depositCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::deposit)
                    }
                    deposit
                },
                {
                    fn protocolPnl(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <protocolPnlCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::protocolPnl)
                    }
                    protocolPnl
                },
                {
                    fn CONTROLLER_ADDRESS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <CONTROLLER_ADDRESSCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::CONTROLLER_ADDRESS)
                    }
                    CONTROLLER_ADDRESS
                },
                {
                    fn isLpAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <isLpAllowedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::isLpAllowed)
                    }
                    isLpAllowed
                },
                {
                    fn enqueueClaim(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <enqueueClaimCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::enqueueClaim)
                    }
                    enqueueClaim
                },
                {
                    fn lastReceiverPullTimestampByToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <lastReceiverPullTimestampByTokenCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::lastReceiverPullTimestampByToken)
                    }
                    lastReceiverPullTimestampByToken
                },
                {
                    fn nextLeaseNumberAtReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <nextLeaseNumberAtReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::nextLeaseNumberAtReceiver)
                    }
                    nextLeaseNumberAtReceiver
                },
                {
                    fn setSwapRate(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setSwapRateCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setSwapRate)
                    }
                    setSwapRate
                },
                {
                    fn leaseIdsByReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <leaseIdsByReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::leaseIdsByReceiver)
                    }
                    leaseIdsByReceiver
                },
                {
                    fn evmToTron(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <evmToTronCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::evmToTron)
                    }
                    evmToTron
                },
                {
                    fn setProtocolMaxLeaseDurationSeconds(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setProtocolMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                UntronV3HarnessCalls::setProtocolMaxLeaseDurationSeconds,
                            )
                    }
                    setProtocolMaxLeaseDurationSeconds
                },
                {
                    fn tronUsdt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <tronUsdtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::tronUsdt)
                    }
                    tronUsdt
                },
                {
                    fn RECEIVER_IMPL(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <RECEIVER_IMPLCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::RECEIVER_IMPL)
                    }
                    RECEIVER_IMPL
                },
                {
                    fn eventSeq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <eventSeqCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::eventSeq)
                    }
                    eventSeq
                },
                {
                    fn leaseLocatorById(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <leaseLocatorByIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::leaseLocatorById)
                    }
                    leaseLocatorById
                },
                {
                    fn setRealtorLeaseRateLimit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setRealtorLeaseRateLimitCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setRealtorLeaseRateLimit)
                    }
                    setRealtorLeaseRateLimit
                },
                {
                    fn nextIndexByTargetToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <nextIndexByTargetTokenCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::nextIndexByTargetToken)
                    }
                    nextIndexByTargetToken
                },
                {
                    fn setRealtorMinFlatFee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setRealtorMinFlatFeeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setRealtorMinFlatFee)
                    }
                    setRealtorMinFlatFee
                },
                {
                    fn swapRatePpm(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <swapRatePpmCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::swapRatePpm)
                    }
                    swapRatePpm
                },
                {
                    fn nextControllerEventIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <nextControllerEventIndexCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::nextControllerEventIndex)
                    }
                    nextControllerEventIndex
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn nextClaimIdByLease(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <nextClaimIdByLeaseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::nextClaimIdByLease)
                    }
                    nextClaimIdByLease
                },
                {
                    fn setTronReader(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <setTronReaderCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::setTronReader)
                    }
                    setTronReader
                },
                {
                    fn preEntitle(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessCalls> {
                        <preEntitleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessCalls::preEntitle)
                    }
                    preEntitle
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::CONTROLLER_ADDRESS(inner) => {
                    <CONTROLLER_ADDRESSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RECEIVER_IMPL(inner) => {
                    <RECEIVER_IMPLCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SWAP_EXECUTOR(inner) => {
                    <SWAP_EXECUTORCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::bridgers(inner) => {
                    <bridgersCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claimLocatorByLease(inner) => {
                    <claimLocatorByLeaseCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimQueueLength(inner) => {
                    <claimQueueLengthCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimsByTargetToken(inner) => {
                    <claimsByTargetTokenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::controllerEventAt(inner) => {
                    <controllerEventAtCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::controllerEventsLength(inner) => {
                    <controllerEventsLengthCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createLease(inner) => {
                    <createLeaseCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::deposit(inner) => {
                    <depositCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::depositProcessed(inner) => {
                    <depositProcessedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::depositToPnl(inner) => {
                    <depositToPnlCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::effectiveLeaseRateLimit(inner) => {
                    <effectiveLeaseRateLimitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::effectiveMaxLeaseDurationSeconds(inner) => {
                    <effectiveMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::enqueueClaim(inner) => {
                    <enqueueClaimCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::eventChainTip(inner) => {
                    <eventChainTipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::eventSeq(inner) => {
                    <eventSeqCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::evmToTron(inner) => {
                    <evmToTronCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::exposedDecodeEventChainTip(inner) => {
                    <exposedDecodeEventChainTipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::exposedProcessReceiverPulled(inner) => {
                    <exposedProcessReceiverPulledCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::fill(inner) => {
                    <fillCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isChainDeprecated(inner) => {
                    <isChainDeprecatedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isLpAllowed(inner) => {
                    <isLpAllowedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isRealtor(inner) => {
                    <isRealtorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::lastControllerEventSeq(inner) => {
                    <lastControllerEventSeqCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::lastControllerEventTip(inner) => {
                    <lastControllerEventTipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::lastReceiverPullTimestampByToken(inner) => {
                    <lastReceiverPullTimestampByTokenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::leaseIdsByReceiver(inner) => {
                    <leaseIdsByReceiverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::leaseLocatorById(inner) => {
                    <leaseLocatorByIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::leaseNonces(inner) => {
                    <leaseNoncesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::leases(inner) => {
                    <leasesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::leasesByReceiver(inner) => {
                    <leasesByReceiverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::lesseePayoutConfigRateLimit(inner) => {
                    <lesseePayoutConfigRateLimitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::lpPrincipal(inner) => {
                    <lpPrincipalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::nextClaimIdByLease(inner) => {
                    <nextClaimIdByLeaseCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::nextControllerEventIndex(inner) => {
                    <nextControllerEventIndexCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::nextIndexByTargetToken(inner) => {
                    <nextIndexByTargetTokenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::nextLeaseId(inner) => {
                    <nextLeaseIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::nextLeaseNumberAtReceiver(inner) => {
                    <nextLeaseNumberAtReceiverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::preEntitle(inner) => {
                    <preEntitleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::predictReceiverAddress_0(inner) => {
                    <predictReceiverAddress_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::predictReceiverAddress_1(inner) => {
                    <predictReceiverAddress_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::processControllerEvents(inner) => {
                    <processControllerEventsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::protocolFloorFlatFee(inner) => {
                    <protocolFloorFlatFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::protocolFloorPpm(inner) => {
                    <protocolFloorPpmCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::protocolMaxLeaseDurationSeconds(inner) => {
                    <protocolMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::protocolPnl(inner) => {
                    <protocolPnlCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pushControllerEvent(inner) => {
                    <pushControllerEventCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::realtorLeaseRateLimit(inner) => {
                    <realtorLeaseRateLimitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::realtorMaxLeaseDurationSeconds(inner) => {
                    <realtorMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::realtorMinFeePpm(inner) => {
                    <realtorMinFeePpmCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::realtorMinFlatFee(inner) => {
                    <realtorMinFlatFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::receiverBytecode(inner) => {
                    <receiverBytecodeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::relayControllerEventChain(inner) => {
                    <relayControllerEventChainCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::rescueTokens(inner) => {
                    <rescueTokensCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBridger(inner) => {
                    <setBridgerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setChainDeprecated(inner) => {
                    <setChainDeprecatedCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setLesseePayoutConfigRateLimit(inner) => {
                    <setLesseePayoutConfigRateLimitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setLp(inner) => {
                    <setLpCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setPayoutConfig(inner) => {
                    <setPayoutConfigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setPayoutConfigWithSig(inner) => {
                    <setPayoutConfigWithSigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setProtocolFloorFlatFee(inner) => {
                    <setProtocolFloorFlatFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setProtocolFloorPpm(inner) => {
                    <setProtocolFloorPpmCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setProtocolMaxLeaseDurationSeconds(inner) => {
                    <setProtocolMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setRealtor(inner) => {
                    <setRealtorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setRealtorLeaseRateLimit(inner) => {
                    <setRealtorLeaseRateLimitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setRealtorMaxLeaseDurationSeconds(inner) => {
                    <setRealtorMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setRealtorMinFeePpm(inner) => {
                    <setRealtorMinFeePpmCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setRealtorMinFlatFee(inner) => {
                    <setRealtorMinFlatFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setSwapRate(inner) => {
                    <setSwapRateCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setTronReader(inner) => {
                    <setTronReaderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setUsdt(inner) => {
                    <setUsdtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::subjectivePreEntitle(inner) => {
                    <subjectivePreEntitleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::subjectivePreEntitlementByTxId(inner) => {
                    <subjectivePreEntitlementByTxIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::swapRatePpm(inner) => {
                    <swapRatePpmCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::tronReader(inner) => {
                    <tronReaderCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::tronUsdt(inner) => {
                    <tronUsdtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::usdt(inner) => {
                    <usdtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::usdtBalance(inner) => {
                    <usdtBalanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::withdraw(inner) => {
                    <withdrawCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::withdrawProtocolProfit(inner) => {
                    <withdrawProtocolProfitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::CONTROLLER_ADDRESS(inner) => {
                    <CONTROLLER_ADDRESSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RECEIVER_IMPL(inner) => {
                    <RECEIVER_IMPLCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SWAP_EXECUTOR(inner) => {
                    <SWAP_EXECUTORCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::bridgers(inner) => {
                    <bridgersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimLocatorByLease(inner) => {
                    <claimLocatorByLeaseCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimQueueLength(inner) => {
                    <claimQueueLengthCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimsByTargetToken(inner) => {
                    <claimsByTargetTokenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::controllerEventAt(inner) => {
                    <controllerEventAtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::controllerEventsLength(inner) => {
                    <controllerEventsLengthCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createLease(inner) => {
                    <createLeaseCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deposit(inner) => {
                    <depositCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::depositProcessed(inner) => {
                    <depositProcessedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::depositToPnl(inner) => {
                    <depositToPnlCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::effectiveLeaseRateLimit(inner) => {
                    <effectiveLeaseRateLimitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::effectiveMaxLeaseDurationSeconds(inner) => {
                    <effectiveMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eip712Domain(inner) => {
                    <eip712DomainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::enqueueClaim(inner) => {
                    <enqueueClaimCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eventChainTip(inner) => {
                    <eventChainTipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eventSeq(inner) => {
                    <eventSeqCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::evmToTron(inner) => {
                    <evmToTronCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::exposedDecodeEventChainTip(inner) => {
                    <exposedDecodeEventChainTipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::exposedProcessReceiverPulled(inner) => {
                    <exposedProcessReceiverPulledCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fill(inner) => {
                    <fillCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::isChainDeprecated(inner) => {
                    <isChainDeprecatedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isLpAllowed(inner) => {
                    <isLpAllowedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isRealtor(inner) => {
                    <isRealtorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::lastControllerEventSeq(inner) => {
                    <lastControllerEventSeqCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::lastControllerEventTip(inner) => {
                    <lastControllerEventTipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::lastReceiverPullTimestampByToken(inner) => {
                    <lastReceiverPullTimestampByTokenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::leaseIdsByReceiver(inner) => {
                    <leaseIdsByReceiverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::leaseLocatorById(inner) => {
                    <leaseLocatorByIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::leaseNonces(inner) => {
                    <leaseNoncesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::leases(inner) => {
                    <leasesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::leasesByReceiver(inner) => {
                    <leasesByReceiverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::lesseePayoutConfigRateLimit(inner) => {
                    <lesseePayoutConfigRateLimitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::lpPrincipal(inner) => {
                    <lpPrincipalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::nextClaimIdByLease(inner) => {
                    <nextClaimIdByLeaseCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::nextControllerEventIndex(inner) => {
                    <nextControllerEventIndexCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::nextIndexByTargetToken(inner) => {
                    <nextIndexByTargetTokenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::nextLeaseId(inner) => {
                    <nextLeaseIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::nextLeaseNumberAtReceiver(inner) => {
                    <nextLeaseNumberAtReceiverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::preEntitle(inner) => {
                    <preEntitleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::predictReceiverAddress_0(inner) => {
                    <predictReceiverAddress_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::predictReceiverAddress_1(inner) => {
                    <predictReceiverAddress_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::processControllerEvents(inner) => {
                    <processControllerEventsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::protocolFloorFlatFee(inner) => {
                    <protocolFloorFlatFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::protocolFloorPpm(inner) => {
                    <protocolFloorPpmCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::protocolMaxLeaseDurationSeconds(inner) => {
                    <protocolMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::protocolPnl(inner) => {
                    <protocolPnlCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pushControllerEvent(inner) => {
                    <pushControllerEventCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::realtorLeaseRateLimit(inner) => {
                    <realtorLeaseRateLimitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::realtorMaxLeaseDurationSeconds(inner) => {
                    <realtorMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::realtorMinFeePpm(inner) => {
                    <realtorMinFeePpmCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::realtorMinFlatFee(inner) => {
                    <realtorMinFlatFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::receiverBytecode(inner) => {
                    <receiverBytecodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::relayControllerEventChain(inner) => {
                    <relayControllerEventChainCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::rescueTokens(inner) => {
                    <rescueTokensCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridger(inner) => {
                    <setBridgerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setChainDeprecated(inner) => {
                    <setChainDeprecatedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setLesseePayoutConfigRateLimit(inner) => {
                    <setLesseePayoutConfigRateLimitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setLp(inner) => {
                    <setLpCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::setPayoutConfig(inner) => {
                    <setPayoutConfigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setPayoutConfigWithSig(inner) => {
                    <setPayoutConfigWithSigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setProtocolFloorFlatFee(inner) => {
                    <setProtocolFloorFlatFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setProtocolFloorPpm(inner) => {
                    <setProtocolFloorPpmCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setProtocolMaxLeaseDurationSeconds(inner) => {
                    <setProtocolMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setRealtor(inner) => {
                    <setRealtorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setRealtorLeaseRateLimit(inner) => {
                    <setRealtorLeaseRateLimitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setRealtorMaxLeaseDurationSeconds(inner) => {
                    <setRealtorMaxLeaseDurationSecondsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setRealtorMinFeePpm(inner) => {
                    <setRealtorMinFeePpmCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setRealtorMinFlatFee(inner) => {
                    <setRealtorMinFlatFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setSwapRate(inner) => {
                    <setSwapRateCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setTronReader(inner) => {
                    <setTronReaderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setUsdt(inner) => {
                    <setUsdtCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::subjectivePreEntitle(inner) => {
                    <subjectivePreEntitleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::subjectivePreEntitlementByTxId(inner) => {
                    <subjectivePreEntitlementByTxIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::swapRatePpm(inner) => {
                    <swapRatePpmCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::tronReader(inner) => {
                    <tronReaderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::tronUsdt(inner) => {
                    <tronUsdtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::usdt(inner) => {
                    <usdtCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::usdtBalance(inner) => {
                    <usdtBalanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::withdraw(inner) => {
                    <withdrawCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::withdrawProtocolProfit(inner) => {
                    <withdrawProtocolProfitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`UntronV3Harness`](self) custom errors.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum UntronV3HarnessErrors {
        #[allow(missing_docs)]
        AlreadyInitialized(AlreadyInitialized),
        #[allow(missing_docs)]
        AmountTooLargeForInt(AmountTooLargeForInt),
        #[allow(missing_docs)]
        CannotRescueUSDT(CannotRescueUSDT),
        #[allow(missing_docs)]
        ChainDeprecated(ChainDeprecated),
        #[allow(missing_docs)]
        DepositAlreadyProcessed(DepositAlreadyProcessed),
        #[allow(missing_docs)]
        DepositNotAfterLastReceiverPull(DepositNotAfterLastReceiverPull),
        #[allow(missing_docs)]
        EnforcedPause(EnforcedPause),
        #[allow(missing_docs)]
        EventRelayNoProgress(EventRelayNoProgress),
        #[allow(missing_docs)]
        EventTipMismatch(EventTipMismatch),
        #[allow(missing_docs)]
        ExpectedPause(ExpectedPause),
        #[allow(missing_docs)]
        InsufficientLpPrincipal(InsufficientLpPrincipal),
        #[allow(missing_docs)]
        InsufficientProtocolProfit(InsufficientProtocolProfit),
        #[allow(missing_docs)]
        InsufficientUsdtBalance(InsufficientUsdtBalance),
        #[allow(missing_docs)]
        InvalidLeaseId(InvalidLeaseId),
        #[allow(missing_docs)]
        InvalidLeaseTimeframe(InvalidLeaseTimeframe),
        #[allow(missing_docs)]
        InvalidReceiverForSalt(InvalidReceiverForSalt),
        #[allow(missing_docs)]
        InvalidSignature(InvalidSignature),
        #[allow(missing_docs)]
        InvalidTargetToken(InvalidTargetToken),
        #[allow(missing_docs)]
        LeaseDurationTooLong(LeaseDurationTooLong),
        #[allow(missing_docs)]
        LeaseFeeTooLow(LeaseFeeTooLow),
        #[allow(missing_docs)]
        LeaseFlatFeeTooLow(LeaseFlatFeeTooLow),
        #[allow(missing_docs)]
        LeaseNotNukeableYet(LeaseNotNukeableYet),
        #[allow(missing_docs)]
        LeaseRateLimitConfigInvalid(LeaseRateLimitConfigInvalid),
        #[allow(missing_docs)]
        LeaseRateLimitExceeded(LeaseRateLimitExceeded),
        #[allow(missing_docs)]
        LpNotAllowlisted(LpNotAllowlisted),
        #[allow(missing_docs)]
        NewOwnerIsZeroAddress(NewOwnerIsZeroAddress),
        #[allow(missing_docs)]
        NoActiveLease(NoActiveLease),
        #[allow(missing_docs)]
        NoBridger(NoBridger),
        #[allow(missing_docs)]
        NoEventChainTipInMulticall(NoEventChainTipInMulticall),
        #[allow(missing_docs)]
        NotATrc20Transfer(NotATrc20Transfer),
        #[allow(missing_docs)]
        NotEventChainTip(NotEventChainTip),
        #[allow(missing_docs)]
        NotLessee(NotLessee),
        #[allow(missing_docs)]
        NotRealtor(NotRealtor),
        #[allow(missing_docs)]
        NotTronUsdt(NotTronUsdt),
        #[allow(missing_docs)]
        PayoutConfigRateLimitConfigInvalid(PayoutConfigRateLimitConfigInvalid),
        #[allow(missing_docs)]
        PayoutConfigRateLimitExceeded(PayoutConfigRateLimitExceeded),
        #[allow(missing_docs)]
        RateNotSet(RateNotSet),
        #[allow(missing_docs)]
        Reentrancy(Reentrancy),
        #[allow(missing_docs)]
        SignatureExpired(SignatureExpired),
        #[allow(missing_docs)]
        SubjectiveNetOutZero(SubjectiveNetOutZero),
        #[allow(missing_docs)]
        SubjectivePreEntitlementAlreadyExists(SubjectivePreEntitlementAlreadyExists),
        #[allow(missing_docs)]
        TronInvalidCalldataLength(TronInvalidCalldataLength),
        #[allow(missing_docs)]
        TronInvalidTrc20DataLength(TronInvalidTrc20DataLength),
        #[allow(missing_docs)]
        Unauthorized(Unauthorized),
        #[allow(missing_docs)]
        WithdrawExceedsPrincipal(WithdrawExceedsPrincipal),
        #[allow(missing_docs)]
        ZeroAmount(ZeroAmount),
    }
    impl UntronV3HarnessErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [8u8, 25u8, 189u8, 205u8],
            [8u8, 252u8, 127u8, 206u8],
            [10u8, 131u8, 176u8, 132u8],
            [13u8, 173u8, 142u8, 52u8],
            [13u8, 193u8, 73u8, 240u8],
            [14u8, 82u8, 28u8, 67u8],
            [18u8, 121u8, 149u8, 3u8],
            [22u8, 103u8, 220u8, 116u8],
            [28u8, 78u8, 27u8, 255u8],
            [31u8, 42u8, 32u8, 5u8],
            [36u8, 59u8, 79u8, 64u8],
            [36u8, 86u8, 225u8, 236u8],
            [51u8, 149u8, 118u8, 91u8],
            [55u8, 214u8, 226u8, 10u8],
            [63u8, 65u8, 174u8, 1u8],
            [66u8, 101u8, 130u8, 50u8],
            [69u8, 13u8, 89u8, 114u8],
            [74u8, 7u8, 118u8, 102u8],
            [76u8, 75u8, 111u8, 2u8],
            [76u8, 84u8, 42u8, 228u8],
            [80u8, 29u8, 19u8, 237u8],
            [108u8, 182u8, 124u8, 166u8],
            [113u8, 54u8, 244u8, 242u8],
            [116u8, 72u8, 251u8, 174u8],
            [128u8, 202u8, 29u8, 82u8],
            [130u8, 180u8, 41u8, 0u8],
            [133u8, 98u8, 235u8, 69u8],
            [138u8, 40u8, 67u8, 122u8],
            [139u8, 170u8, 87u8, 159u8],
            [141u8, 252u8, 32u8, 43u8],
            [148u8, 171u8, 40u8, 214u8],
            [154u8, 198u8, 12u8, 45u8],
            [157u8, 140u8, 125u8, 153u8],
            [161u8, 126u8, 234u8, 119u8],
            [170u8, 225u8, 49u8, 28u8],
            [171u8, 20u8, 60u8, 6u8],
            [172u8, 242u8, 218u8, 147u8],
            [179u8, 124u8, 121u8, 237u8],
            [180u8, 237u8, 28u8, 53u8],
            [181u8, 92u8, 27u8, 173u8],
            [204u8, 11u8, 176u8, 193u8],
            [212u8, 112u8, 140u8, 165u8],
            [214u8, 193u8, 70u8, 124u8],
            [217u8, 37u8, 156u8, 169u8],
            [217u8, 60u8, 6u8, 101u8],
            [249u8, 176u8, 28u8, 68u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(SignatureExpired),
            ::core::stringify!(RateNotSet),
            ::core::stringify!(PayoutConfigRateLimitExceeded),
            ::core::stringify!(LpNotAllowlisted),
            ::core::stringify!(AlreadyInitialized),
            ::core::stringify!(EventTipMismatch),
            ::core::stringify!(TronInvalidCalldataLength),
            ::core::stringify!(AmountTooLargeForInt),
            ::core::stringify!(CannotRescueUSDT),
            ::core::stringify!(ZeroAmount),
            ::core::stringify!(InvalidLeaseId),
            ::core::stringify!(NotATrc20Transfer),
            ::core::stringify!(NotTronUsdt),
            ::core::stringify!(DepositAlreadyProcessed),
            ::core::stringify!(SubjectiveNetOutZero),
            ::core::stringify!(LeaseRateLimitConfigInvalid),
            ::core::stringify!(NoEventChainTipInMulticall),
            ::core::stringify!(NoActiveLease),
            ::core::stringify!(LeaseFlatFeeTooLow),
            ::core::stringify!(LeaseRateLimitExceeded),
            ::core::stringify!(InvalidLeaseTimeframe),
            ::core::stringify!(NotEventChainTip),
            ::core::stringify!(NotLessee),
            ::core::stringify!(NewOwnerIsZeroAddress),
            ::core::stringify!(InvalidReceiverForSalt),
            ::core::stringify!(Unauthorized),
            ::core::stringify!(InvalidTargetToken),
            ::core::stringify!(NotRealtor),
            ::core::stringify!(InvalidSignature),
            ::core::stringify!(ExpectedPause),
            ::core::stringify!(LeaseFeeTooLow),
            ::core::stringify!(TronInvalidTrc20DataLength),
            ::core::stringify!(InsufficientProtocolProfit),
            ::core::stringify!(PayoutConfigRateLimitConfigInvalid),
            ::core::stringify!(LeaseDurationTooLong),
            ::core::stringify!(Reentrancy),
            ::core::stringify!(InsufficientLpPrincipal),
            ::core::stringify!(NoBridger),
            ::core::stringify!(LeaseNotNukeableYet),
            ::core::stringify!(InsufficientUsdtBalance),
            ::core::stringify!(SubjectivePreEntitlementAlreadyExists),
            ::core::stringify!(WithdrawExceedsPrincipal),
            ::core::stringify!(EventRelayNoProgress),
            ::core::stringify!(ChainDeprecated),
            ::core::stringify!(EnforcedPause),
            ::core::stringify!(DepositNotAfterLastReceiverPull),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <SignatureExpired as alloy_sol_types::SolError>::SIGNATURE,
            <RateNotSet as alloy_sol_types::SolError>::SIGNATURE,
            <PayoutConfigRateLimitExceeded as alloy_sol_types::SolError>::SIGNATURE,
            <LpNotAllowlisted as alloy_sol_types::SolError>::SIGNATURE,
            <AlreadyInitialized as alloy_sol_types::SolError>::SIGNATURE,
            <EventTipMismatch as alloy_sol_types::SolError>::SIGNATURE,
            <TronInvalidCalldataLength as alloy_sol_types::SolError>::SIGNATURE,
            <AmountTooLargeForInt as alloy_sol_types::SolError>::SIGNATURE,
            <CannotRescueUSDT as alloy_sol_types::SolError>::SIGNATURE,
            <ZeroAmount as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidLeaseId as alloy_sol_types::SolError>::SIGNATURE,
            <NotATrc20Transfer as alloy_sol_types::SolError>::SIGNATURE,
            <NotTronUsdt as alloy_sol_types::SolError>::SIGNATURE,
            <DepositAlreadyProcessed as alloy_sol_types::SolError>::SIGNATURE,
            <SubjectiveNetOutZero as alloy_sol_types::SolError>::SIGNATURE,
            <LeaseRateLimitConfigInvalid as alloy_sol_types::SolError>::SIGNATURE,
            <NoEventChainTipInMulticall as alloy_sol_types::SolError>::SIGNATURE,
            <NoActiveLease as alloy_sol_types::SolError>::SIGNATURE,
            <LeaseFlatFeeTooLow as alloy_sol_types::SolError>::SIGNATURE,
            <LeaseRateLimitExceeded as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidLeaseTimeframe as alloy_sol_types::SolError>::SIGNATURE,
            <NotEventChainTip as alloy_sol_types::SolError>::SIGNATURE,
            <NotLessee as alloy_sol_types::SolError>::SIGNATURE,
            <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidReceiverForSalt as alloy_sol_types::SolError>::SIGNATURE,
            <Unauthorized as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidTargetToken as alloy_sol_types::SolError>::SIGNATURE,
            <NotRealtor as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidSignature as alloy_sol_types::SolError>::SIGNATURE,
            <ExpectedPause as alloy_sol_types::SolError>::SIGNATURE,
            <LeaseFeeTooLow as alloy_sol_types::SolError>::SIGNATURE,
            <TronInvalidTrc20DataLength as alloy_sol_types::SolError>::SIGNATURE,
            <InsufficientProtocolProfit as alloy_sol_types::SolError>::SIGNATURE,
            <PayoutConfigRateLimitConfigInvalid as alloy_sol_types::SolError>::SIGNATURE,
            <LeaseDurationTooLong as alloy_sol_types::SolError>::SIGNATURE,
            <Reentrancy as alloy_sol_types::SolError>::SIGNATURE,
            <InsufficientLpPrincipal as alloy_sol_types::SolError>::SIGNATURE,
            <NoBridger as alloy_sol_types::SolError>::SIGNATURE,
            <LeaseNotNukeableYet as alloy_sol_types::SolError>::SIGNATURE,
            <InsufficientUsdtBalance as alloy_sol_types::SolError>::SIGNATURE,
            <SubjectivePreEntitlementAlreadyExists as alloy_sol_types::SolError>::SIGNATURE,
            <WithdrawExceedsPrincipal as alloy_sol_types::SolError>::SIGNATURE,
            <EventRelayNoProgress as alloy_sol_types::SolError>::SIGNATURE,
            <ChainDeprecated as alloy_sol_types::SolError>::SIGNATURE,
            <EnforcedPause as alloy_sol_types::SolError>::SIGNATURE,
            <DepositNotAfterLastReceiverPull as alloy_sol_types::SolError>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for UntronV3HarnessErrors {
        const NAME: &'static str = "UntronV3HarnessErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 46usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AlreadyInitialized(_) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AmountTooLargeForInt(_) => {
                    <AmountTooLargeForInt as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CannotRescueUSDT(_) => {
                    <CannotRescueUSDT as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ChainDeprecated(_) => {
                    <ChainDeprecated as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DepositAlreadyProcessed(_) => {
                    <DepositAlreadyProcessed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DepositNotAfterLastReceiverPull(_) => {
                    <DepositNotAfterLastReceiverPull as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EnforcedPause(_) => {
                    <EnforcedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EventRelayNoProgress(_) => {
                    <EventRelayNoProgress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EventTipMismatch(_) => {
                    <EventTipMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExpectedPause(_) => {
                    <ExpectedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientLpPrincipal(_) => {
                    <InsufficientLpPrincipal as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientProtocolProfit(_) => {
                    <InsufficientProtocolProfit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientUsdtBalance(_) => {
                    <InsufficientUsdtBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidLeaseId(_) => {
                    <InvalidLeaseId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidLeaseTimeframe(_) => {
                    <InvalidLeaseTimeframe as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidReceiverForSalt(_) => {
                    <InvalidReceiverForSalt as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidSignature(_) => {
                    <InvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidTargetToken(_) => {
                    <InvalidTargetToken as alloy_sol_types::SolError>::SELECTOR
                }
                Self::LeaseDurationTooLong(_) => {
                    <LeaseDurationTooLong as alloy_sol_types::SolError>::SELECTOR
                }
                Self::LeaseFeeTooLow(_) => {
                    <LeaseFeeTooLow as alloy_sol_types::SolError>::SELECTOR
                }
                Self::LeaseFlatFeeTooLow(_) => {
                    <LeaseFlatFeeTooLow as alloy_sol_types::SolError>::SELECTOR
                }
                Self::LeaseNotNukeableYet(_) => {
                    <LeaseNotNukeableYet as alloy_sol_types::SolError>::SELECTOR
                }
                Self::LeaseRateLimitConfigInvalid(_) => {
                    <LeaseRateLimitConfigInvalid as alloy_sol_types::SolError>::SELECTOR
                }
                Self::LeaseRateLimitExceeded(_) => {
                    <LeaseRateLimitExceeded as alloy_sol_types::SolError>::SELECTOR
                }
                Self::LpNotAllowlisted(_) => {
                    <LpNotAllowlisted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NewOwnerIsZeroAddress(_) => {
                    <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoActiveLease(_) => {
                    <NoActiveLease as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoBridger(_) => <NoBridger as alloy_sol_types::SolError>::SELECTOR,
                Self::NoEventChainTipInMulticall(_) => {
                    <NoEventChainTipInMulticall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotATrc20Transfer(_) => {
                    <NotATrc20Transfer as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotEventChainTip(_) => {
                    <NotEventChainTip as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotLessee(_) => <NotLessee as alloy_sol_types::SolError>::SELECTOR,
                Self::NotRealtor(_) => {
                    <NotRealtor as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotTronUsdt(_) => {
                    <NotTronUsdt as alloy_sol_types::SolError>::SELECTOR
                }
                Self::PayoutConfigRateLimitConfigInvalid(_) => {
                    <PayoutConfigRateLimitConfigInvalid as alloy_sol_types::SolError>::SELECTOR
                }
                Self::PayoutConfigRateLimitExceeded(_) => {
                    <PayoutConfigRateLimitExceeded as alloy_sol_types::SolError>::SELECTOR
                }
                Self::RateNotSet(_) => {
                    <RateNotSet as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Reentrancy(_) => {
                    <Reentrancy as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SignatureExpired(_) => {
                    <SignatureExpired as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SubjectiveNetOutZero(_) => {
                    <SubjectiveNetOutZero as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SubjectivePreEntitlementAlreadyExists(_) => {
                    <SubjectivePreEntitlementAlreadyExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TronInvalidCalldataLength(_) => {
                    <TronInvalidCalldataLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TronInvalidTrc20DataLength(_) => {
                    <TronInvalidTrc20DataLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Unauthorized(_) => {
                    <Unauthorized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::WithdrawExceedsPrincipal(_) => {
                    <WithdrawExceedsPrincipal as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAmount(_) => {
                    <ZeroAmount as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<UntronV3HarnessErrors>] = &[
                {
                    fn SignatureExpired(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <SignatureExpired as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::SignatureExpired)
                    }
                    SignatureExpired
                },
                {
                    fn RateNotSet(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <RateNotSet as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(UntronV3HarnessErrors::RateNotSet)
                    }
                    RateNotSet
                },
                {
                    fn PayoutConfigRateLimitExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <PayoutConfigRateLimitExceeded as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::PayoutConfigRateLimitExceeded)
                    }
                    PayoutConfigRateLimitExceeded
                },
                {
                    fn LpNotAllowlisted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <LpNotAllowlisted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::LpNotAllowlisted)
                    }
                    LpNotAllowlisted
                },
                {
                    fn AlreadyInitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <AlreadyInitialized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::AlreadyInitialized)
                    }
                    AlreadyInitialized
                },
                {
                    fn EventTipMismatch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <EventTipMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::EventTipMismatch)
                    }
                    EventTipMismatch
                },
                {
                    fn TronInvalidCalldataLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <TronInvalidCalldataLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::TronInvalidCalldataLength)
                    }
                    TronInvalidCalldataLength
                },
                {
                    fn AmountTooLargeForInt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <AmountTooLargeForInt as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::AmountTooLargeForInt)
                    }
                    AmountTooLargeForInt
                },
                {
                    fn CannotRescueUSDT(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <CannotRescueUSDT as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::CannotRescueUSDT)
                    }
                    CannotRescueUSDT
                },
                {
                    fn ZeroAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(UntronV3HarnessErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn InvalidLeaseId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InvalidLeaseId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InvalidLeaseId)
                    }
                    InvalidLeaseId
                },
                {
                    fn NotATrc20Transfer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NotATrc20Transfer as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::NotATrc20Transfer)
                    }
                    NotATrc20Transfer
                },
                {
                    fn NotTronUsdt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NotTronUsdt as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(UntronV3HarnessErrors::NotTronUsdt)
                    }
                    NotTronUsdt
                },
                {
                    fn DepositAlreadyProcessed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <DepositAlreadyProcessed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::DepositAlreadyProcessed)
                    }
                    DepositAlreadyProcessed
                },
                {
                    fn SubjectiveNetOutZero(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <SubjectiveNetOutZero as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::SubjectiveNetOutZero)
                    }
                    SubjectiveNetOutZero
                },
                {
                    fn LeaseRateLimitConfigInvalid(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <LeaseRateLimitConfigInvalid as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::LeaseRateLimitConfigInvalid)
                    }
                    LeaseRateLimitConfigInvalid
                },
                {
                    fn NoEventChainTipInMulticall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NoEventChainTipInMulticall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::NoEventChainTipInMulticall)
                    }
                    NoEventChainTipInMulticall
                },
                {
                    fn NoActiveLease(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NoActiveLease as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::NoActiveLease)
                    }
                    NoActiveLease
                },
                {
                    fn LeaseFlatFeeTooLow(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <LeaseFlatFeeTooLow as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::LeaseFlatFeeTooLow)
                    }
                    LeaseFlatFeeTooLow
                },
                {
                    fn LeaseRateLimitExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <LeaseRateLimitExceeded as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::LeaseRateLimitExceeded)
                    }
                    LeaseRateLimitExceeded
                },
                {
                    fn InvalidLeaseTimeframe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InvalidLeaseTimeframe as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InvalidLeaseTimeframe)
                    }
                    InvalidLeaseTimeframe
                },
                {
                    fn NotEventChainTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NotEventChainTip as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::NotEventChainTip)
                    }
                    NotEventChainTip
                },
                {
                    fn NotLessee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NotLessee as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(UntronV3HarnessErrors::NotLessee)
                    }
                    NotLessee
                },
                {
                    fn NewOwnerIsZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::NewOwnerIsZeroAddress)
                    }
                    NewOwnerIsZeroAddress
                },
                {
                    fn InvalidReceiverForSalt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InvalidReceiverForSalt as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InvalidReceiverForSalt)
                    }
                    InvalidReceiverForSalt
                },
                {
                    fn Unauthorized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <Unauthorized as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(UntronV3HarnessErrors::Unauthorized)
                    }
                    Unauthorized
                },
                {
                    fn InvalidTargetToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InvalidTargetToken as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InvalidTargetToken)
                    }
                    InvalidTargetToken
                },
                {
                    fn NotRealtor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NotRealtor as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(UntronV3HarnessErrors::NotRealtor)
                    }
                    NotRealtor
                },
                {
                    fn InvalidSignature(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InvalidSignature)
                    }
                    InvalidSignature
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn LeaseFeeTooLow(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <LeaseFeeTooLow as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::LeaseFeeTooLow)
                    }
                    LeaseFeeTooLow
                },
                {
                    fn TronInvalidTrc20DataLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <TronInvalidTrc20DataLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::TronInvalidTrc20DataLength)
                    }
                    TronInvalidTrc20DataLength
                },
                {
                    fn InsufficientProtocolProfit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InsufficientProtocolProfit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InsufficientProtocolProfit)
                    }
                    InsufficientProtocolProfit
                },
                {
                    fn PayoutConfigRateLimitConfigInvalid(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <PayoutConfigRateLimitConfigInvalid as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                UntronV3HarnessErrors::PayoutConfigRateLimitConfigInvalid,
                            )
                    }
                    PayoutConfigRateLimitConfigInvalid
                },
                {
                    fn LeaseDurationTooLong(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <LeaseDurationTooLong as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::LeaseDurationTooLong)
                    }
                    LeaseDurationTooLong
                },
                {
                    fn Reentrancy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <Reentrancy as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(UntronV3HarnessErrors::Reentrancy)
                    }
                    Reentrancy
                },
                {
                    fn InsufficientLpPrincipal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InsufficientLpPrincipal as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InsufficientLpPrincipal)
                    }
                    InsufficientLpPrincipal
                },
                {
                    fn NoBridger(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NoBridger as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(UntronV3HarnessErrors::NoBridger)
                    }
                    NoBridger
                },
                {
                    fn LeaseNotNukeableYet(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <LeaseNotNukeableYet as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::LeaseNotNukeableYet)
                    }
                    LeaseNotNukeableYet
                },
                {
                    fn InsufficientUsdtBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InsufficientUsdtBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InsufficientUsdtBalance)
                    }
                    InsufficientUsdtBalance
                },
                {
                    fn SubjectivePreEntitlementAlreadyExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <SubjectivePreEntitlementAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                UntronV3HarnessErrors::SubjectivePreEntitlementAlreadyExists,
                            )
                    }
                    SubjectivePreEntitlementAlreadyExists
                },
                {
                    fn WithdrawExceedsPrincipal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <WithdrawExceedsPrincipal as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::WithdrawExceedsPrincipal)
                    }
                    WithdrawExceedsPrincipal
                },
                {
                    fn EventRelayNoProgress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <EventRelayNoProgress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::EventRelayNoProgress)
                    }
                    EventRelayNoProgress
                },
                {
                    fn ChainDeprecated(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <ChainDeprecated as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::ChainDeprecated)
                    }
                    ChainDeprecated
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn DepositNotAfterLastReceiverPull(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <DepositNotAfterLastReceiverPull as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronV3HarnessErrors::DepositNotAfterLastReceiverPull)
                    }
                    DepositNotAfterLastReceiverPull
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<UntronV3HarnessErrors>] = &[
                {
                    fn SignatureExpired(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <SignatureExpired as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::SignatureExpired)
                    }
                    SignatureExpired
                },
                {
                    fn RateNotSet(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <RateNotSet as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::RateNotSet)
                    }
                    RateNotSet
                },
                {
                    fn PayoutConfigRateLimitExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <PayoutConfigRateLimitExceeded as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::PayoutConfigRateLimitExceeded)
                    }
                    PayoutConfigRateLimitExceeded
                },
                {
                    fn LpNotAllowlisted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <LpNotAllowlisted as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::LpNotAllowlisted)
                    }
                    LpNotAllowlisted
                },
                {
                    fn AlreadyInitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <AlreadyInitialized as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::AlreadyInitialized)
                    }
                    AlreadyInitialized
                },
                {
                    fn EventTipMismatch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <EventTipMismatch as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::EventTipMismatch)
                    }
                    EventTipMismatch
                },
                {
                    fn TronInvalidCalldataLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <TronInvalidCalldataLength as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::TronInvalidCalldataLength)
                    }
                    TronInvalidCalldataLength
                },
                {
                    fn AmountTooLargeForInt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <AmountTooLargeForInt as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::AmountTooLargeForInt)
                    }
                    AmountTooLargeForInt
                },
                {
                    fn CannotRescueUSDT(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <CannotRescueUSDT as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::CannotRescueUSDT)
                    }
                    CannotRescueUSDT
                },
                {
                    fn ZeroAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn InvalidLeaseId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InvalidLeaseId as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InvalidLeaseId)
                    }
                    InvalidLeaseId
                },
                {
                    fn NotATrc20Transfer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NotATrc20Transfer as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::NotATrc20Transfer)
                    }
                    NotATrc20Transfer
                },
                {
                    fn NotTronUsdt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NotTronUsdt as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::NotTronUsdt)
                    }
                    NotTronUsdt
                },
                {
                    fn DepositAlreadyProcessed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <DepositAlreadyProcessed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::DepositAlreadyProcessed)
                    }
                    DepositAlreadyProcessed
                },
                {
                    fn SubjectiveNetOutZero(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <SubjectiveNetOutZero as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::SubjectiveNetOutZero)
                    }
                    SubjectiveNetOutZero
                },
                {
                    fn LeaseRateLimitConfigInvalid(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <LeaseRateLimitConfigInvalid as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::LeaseRateLimitConfigInvalid)
                    }
                    LeaseRateLimitConfigInvalid
                },
                {
                    fn NoEventChainTipInMulticall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NoEventChainTipInMulticall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::NoEventChainTipInMulticall)
                    }
                    NoEventChainTipInMulticall
                },
                {
                    fn NoActiveLease(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NoActiveLease as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::NoActiveLease)
                    }
                    NoActiveLease
                },
                {
                    fn LeaseFlatFeeTooLow(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <LeaseFlatFeeTooLow as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::LeaseFlatFeeTooLow)
                    }
                    LeaseFlatFeeTooLow
                },
                {
                    fn LeaseRateLimitExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <LeaseRateLimitExceeded as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::LeaseRateLimitExceeded)
                    }
                    LeaseRateLimitExceeded
                },
                {
                    fn InvalidLeaseTimeframe(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InvalidLeaseTimeframe as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InvalidLeaseTimeframe)
                    }
                    InvalidLeaseTimeframe
                },
                {
                    fn NotEventChainTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NotEventChainTip as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::NotEventChainTip)
                    }
                    NotEventChainTip
                },
                {
                    fn NotLessee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NotLessee as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::NotLessee)
                    }
                    NotLessee
                },
                {
                    fn NewOwnerIsZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::NewOwnerIsZeroAddress)
                    }
                    NewOwnerIsZeroAddress
                },
                {
                    fn InvalidReceiverForSalt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InvalidReceiverForSalt as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InvalidReceiverForSalt)
                    }
                    InvalidReceiverForSalt
                },
                {
                    fn Unauthorized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <Unauthorized as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::Unauthorized)
                    }
                    Unauthorized
                },
                {
                    fn InvalidTargetToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InvalidTargetToken as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InvalidTargetToken)
                    }
                    InvalidTargetToken
                },
                {
                    fn NotRealtor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NotRealtor as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::NotRealtor)
                    }
                    NotRealtor
                },
                {
                    fn InvalidSignature(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InvalidSignature as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InvalidSignature)
                    }
                    InvalidSignature
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn LeaseFeeTooLow(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <LeaseFeeTooLow as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::LeaseFeeTooLow)
                    }
                    LeaseFeeTooLow
                },
                {
                    fn TronInvalidTrc20DataLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <TronInvalidTrc20DataLength as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::TronInvalidTrc20DataLength)
                    }
                    TronInvalidTrc20DataLength
                },
                {
                    fn InsufficientProtocolProfit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InsufficientProtocolProfit as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InsufficientProtocolProfit)
                    }
                    InsufficientProtocolProfit
                },
                {
                    fn PayoutConfigRateLimitConfigInvalid(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <PayoutConfigRateLimitConfigInvalid as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                UntronV3HarnessErrors::PayoutConfigRateLimitConfigInvalid,
                            )
                    }
                    PayoutConfigRateLimitConfigInvalid
                },
                {
                    fn LeaseDurationTooLong(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <LeaseDurationTooLong as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::LeaseDurationTooLong)
                    }
                    LeaseDurationTooLong
                },
                {
                    fn Reentrancy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <Reentrancy as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::Reentrancy)
                    }
                    Reentrancy
                },
                {
                    fn InsufficientLpPrincipal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InsufficientLpPrincipal as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InsufficientLpPrincipal)
                    }
                    InsufficientLpPrincipal
                },
                {
                    fn NoBridger(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <NoBridger as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::NoBridger)
                    }
                    NoBridger
                },
                {
                    fn LeaseNotNukeableYet(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <LeaseNotNukeableYet as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::LeaseNotNukeableYet)
                    }
                    LeaseNotNukeableYet
                },
                {
                    fn InsufficientUsdtBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <InsufficientUsdtBalance as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::InsufficientUsdtBalance)
                    }
                    InsufficientUsdtBalance
                },
                {
                    fn SubjectivePreEntitlementAlreadyExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <SubjectivePreEntitlementAlreadyExists as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                UntronV3HarnessErrors::SubjectivePreEntitlementAlreadyExists,
                            )
                    }
                    SubjectivePreEntitlementAlreadyExists
                },
                {
                    fn WithdrawExceedsPrincipal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <WithdrawExceedsPrincipal as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::WithdrawExceedsPrincipal)
                    }
                    WithdrawExceedsPrincipal
                },
                {
                    fn EventRelayNoProgress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <EventRelayNoProgress as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::EventRelayNoProgress)
                    }
                    EventRelayNoProgress
                },
                {
                    fn ChainDeprecated(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <ChainDeprecated as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::ChainDeprecated)
                    }
                    ChainDeprecated
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn DepositNotAfterLastReceiverPull(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronV3HarnessErrors> {
                        <DepositNotAfterLastReceiverPull as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronV3HarnessErrors::DepositNotAfterLastReceiverPull)
                    }
                    DepositNotAfterLastReceiverPull
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AmountTooLargeForInt(inner) => {
                    <AmountTooLargeForInt as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CannotRescueUSDT(inner) => {
                    <CannotRescueUSDT as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ChainDeprecated(inner) => {
                    <ChainDeprecated as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DepositAlreadyProcessed(inner) => {
                    <DepositAlreadyProcessed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DepositNotAfterLastReceiverPull(inner) => {
                    <DepositNotAfterLastReceiverPull as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::EventRelayNoProgress(inner) => {
                    <EventRelayNoProgress as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EventTipMismatch(inner) => {
                    <EventTipMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InsufficientLpPrincipal(inner) => {
                    <InsufficientLpPrincipal as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientProtocolProfit(inner) => {
                    <InsufficientProtocolProfit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientUsdtBalance(inner) => {
                    <InsufficientUsdtBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidLeaseId(inner) => {
                    <InvalidLeaseId as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidLeaseTimeframe(inner) => {
                    <InvalidLeaseTimeframe as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidReceiverForSalt(inner) => {
                    <InvalidReceiverForSalt as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidSignature(inner) => {
                    <InvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidTargetToken(inner) => {
                    <InvalidTargetToken as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LeaseDurationTooLong(inner) => {
                    <LeaseDurationTooLong as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LeaseFeeTooLow(inner) => {
                    <LeaseFeeTooLow as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LeaseFlatFeeTooLow(inner) => {
                    <LeaseFlatFeeTooLow as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LeaseNotNukeableYet(inner) => {
                    <LeaseNotNukeableYet as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LeaseRateLimitConfigInvalid(inner) => {
                    <LeaseRateLimitConfigInvalid as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LeaseRateLimitExceeded(inner) => {
                    <LeaseRateLimitExceeded as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LpNotAllowlisted(inner) => {
                    <LpNotAllowlisted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NewOwnerIsZeroAddress(inner) => {
                    <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NoActiveLease(inner) => {
                    <NoActiveLease as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NoBridger(inner) => {
                    <NoBridger as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NoEventChainTipInMulticall(inner) => {
                    <NoEventChainTipInMulticall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotATrc20Transfer(inner) => {
                    <NotATrc20Transfer as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotEventChainTip(inner) => {
                    <NotEventChainTip as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotLessee(inner) => {
                    <NotLessee as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotRealtor(inner) => {
                    <NotRealtor as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotTronUsdt(inner) => {
                    <NotTronUsdt as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::PayoutConfigRateLimitConfigInvalid(inner) => {
                    <PayoutConfigRateLimitConfigInvalid as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PayoutConfigRateLimitExceeded(inner) => {
                    <PayoutConfigRateLimitExceeded as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RateNotSet(inner) => {
                    <RateNotSet as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::Reentrancy(inner) => {
                    <Reentrancy as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::SignatureExpired(inner) => {
                    <SignatureExpired as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SubjectiveNetOutZero(inner) => {
                    <SubjectiveNetOutZero as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SubjectivePreEntitlementAlreadyExists(inner) => {
                    <SubjectivePreEntitlementAlreadyExists as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TronInvalidCalldataLength(inner) => {
                    <TronInvalidCalldataLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TronInvalidTrc20DataLength(inner) => {
                    <TronInvalidTrc20DataLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::WithdrawExceedsPrincipal(inner) => {
                    <WithdrawExceedsPrincipal as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AmountTooLargeForInt(inner) => {
                    <AmountTooLargeForInt as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CannotRescueUSDT(inner) => {
                    <CannotRescueUSDT as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ChainDeprecated(inner) => {
                    <ChainDeprecated as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DepositAlreadyProcessed(inner) => {
                    <DepositAlreadyProcessed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DepositNotAfterLastReceiverPull(inner) => {
                    <DepositNotAfterLastReceiverPull as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EventRelayNoProgress(inner) => {
                    <EventRelayNoProgress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EventTipMismatch(inner) => {
                    <EventTipMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientLpPrincipal(inner) => {
                    <InsufficientLpPrincipal as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientProtocolProfit(inner) => {
                    <InsufficientProtocolProfit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientUsdtBalance(inner) => {
                    <InsufficientUsdtBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidLeaseId(inner) => {
                    <InvalidLeaseId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidLeaseTimeframe(inner) => {
                    <InvalidLeaseTimeframe as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidReceiverForSalt(inner) => {
                    <InvalidReceiverForSalt as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidSignature(inner) => {
                    <InvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidTargetToken(inner) => {
                    <InvalidTargetToken as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LeaseDurationTooLong(inner) => {
                    <LeaseDurationTooLong as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LeaseFeeTooLow(inner) => {
                    <LeaseFeeTooLow as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LeaseFlatFeeTooLow(inner) => {
                    <LeaseFlatFeeTooLow as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LeaseNotNukeableYet(inner) => {
                    <LeaseNotNukeableYet as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LeaseRateLimitConfigInvalid(inner) => {
                    <LeaseRateLimitConfigInvalid as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LeaseRateLimitExceeded(inner) => {
                    <LeaseRateLimitExceeded as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LpNotAllowlisted(inner) => {
                    <LpNotAllowlisted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NewOwnerIsZeroAddress(inner) => {
                    <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoActiveLease(inner) => {
                    <NoActiveLease as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoBridger(inner) => {
                    <NoBridger as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::NoEventChainTipInMulticall(inner) => {
                    <NoEventChainTipInMulticall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotATrc20Transfer(inner) => {
                    <NotATrc20Transfer as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotEventChainTip(inner) => {
                    <NotEventChainTip as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotLessee(inner) => {
                    <NotLessee as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::NotRealtor(inner) => {
                    <NotRealtor as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::NotTronUsdt(inner) => {
                    <NotTronUsdt as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PayoutConfigRateLimitConfigInvalid(inner) => {
                    <PayoutConfigRateLimitConfigInvalid as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PayoutConfigRateLimitExceeded(inner) => {
                    <PayoutConfigRateLimitExceeded as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RateNotSet(inner) => {
                    <RateNotSet as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::Reentrancy(inner) => {
                    <Reentrancy as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::SignatureExpired(inner) => {
                    <SignatureExpired as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SubjectiveNetOutZero(inner) => {
                    <SubjectiveNetOutZero as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SubjectivePreEntitlementAlreadyExists(inner) => {
                    <SubjectivePreEntitlementAlreadyExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TronInvalidCalldataLength(inner) => {
                    <TronInvalidCalldataLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TronInvalidTrc20DataLength(inner) => {
                    <TronInvalidTrc20DataLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::WithdrawExceedsPrincipal(inner) => {
                    <WithdrawExceedsPrincipal as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`UntronV3Harness`](self) events.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum UntronV3HarnessEvents {
        #[allow(missing_docs)]
        BridgerSet(BridgerSet),
        #[allow(missing_docs)]
        ChainDeprecatedSet(ChainDeprecatedSet),
        #[allow(missing_docs)]
        ClaimCreated(ClaimCreated),
        #[allow(missing_docs)]
        ClaimFilled(ClaimFilled),
        #[allow(missing_docs)]
        ControllerEventChainTipUpdated(ControllerEventChainTipUpdated),
        #[allow(missing_docs)]
        ControllerEventProcessed(ControllerEventProcessed),
        #[allow(missing_docs)]
        EventAppended(EventAppended),
        #[allow(missing_docs)]
        LeaseCreated(LeaseCreated),
        #[allow(missing_docs)]
        LeaseNonceUpdated(LeaseNonceUpdated),
        #[allow(missing_docs)]
        LesseePayoutConfigRateLimitSet(LesseePayoutConfigRateLimitSet),
        #[allow(missing_docs)]
        LpDeposited(LpDeposited),
        #[allow(missing_docs)]
        LpSet(LpSet),
        #[allow(missing_docs)]
        LpWithdrawn(LpWithdrawn),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        PayoutConfigUpdated(PayoutConfigUpdated),
        #[allow(missing_docs)]
        ProtocolFlatFeeFloorSet(ProtocolFlatFeeFloorSet),
        #[allow(missing_docs)]
        ProtocolFloorSet(ProtocolFloorSet),
        #[allow(missing_docs)]
        ProtocolMaxLeaseDurationSet(ProtocolMaxLeaseDurationSet),
        #[allow(missing_docs)]
        ProtocolPnlUpdated(ProtocolPnlUpdated),
        #[allow(missing_docs)]
        RealtorLeaseRateLimitSet(RealtorLeaseRateLimitSet),
        #[allow(missing_docs)]
        RealtorMaxLeaseDurationSet(RealtorMaxLeaseDurationSet),
        #[allow(missing_docs)]
        RealtorMinFeeSet(RealtorMinFeeSet),
        #[allow(missing_docs)]
        RealtorMinFlatFeeSet(RealtorMinFlatFeeSet),
        #[allow(missing_docs)]
        RealtorSet(RealtorSet),
        #[allow(missing_docs)]
        SwapRateSet(SwapRateSet),
        #[allow(missing_docs)]
        TokensRescued(TokensRescued),
        #[allow(missing_docs)]
        TronReaderSet(TronReaderSet),
        #[allow(missing_docs)]
        TronUsdtSet(TronUsdtSet),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
        #[allow(missing_docs)]
        UsdtSet(UsdtSet),
    }
    impl UntronV3HarnessEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                10u8, 168u8, 38u8, 38u8, 241u8, 155u8, 181u8, 212u8, 25u8, 98u8, 2u8,
                176u8, 31u8, 47u8, 238u8, 67u8, 27u8, 149u8, 232u8, 140u8, 176u8, 84u8,
                72u8, 75u8, 152u8, 125u8, 101u8, 13u8, 145u8, 146u8, 138u8, 218u8,
            ],
            [
                31u8, 179u8, 179u8, 142u8, 64u8, 32u8, 9u8, 241u8, 187u8, 210u8, 77u8,
                10u8, 112u8, 0u8, 90u8, 122u8, 154u8, 5u8, 91u8, 63u8, 91u8, 84u8, 108u8,
                139u8, 33u8, 248u8, 21u8, 71u8, 10u8, 156u8, 46u8, 196u8,
            ],
            [
                32u8, 128u8, 167u8, 86u8, 68u8, 77u8, 42u8, 240u8, 249u8, 251u8, 79u8,
                135u8, 219u8, 122u8, 246u8, 60u8, 214u8, 226u8, 59u8, 122u8, 18u8, 3u8,
                203u8, 233u8, 171u8, 9u8, 114u8, 238u8, 5u8, 209u8, 234u8, 253u8,
            ],
            [
                40u8, 108u8, 215u8, 197u8, 120u8, 30u8, 109u8, 243u8, 118u8, 218u8,
                165u8, 154u8, 178u8, 7u8, 225u8, 160u8, 177u8, 236u8, 233u8, 95u8, 175u8,
                194u8, 152u8, 249u8, 171u8, 105u8, 161u8, 136u8, 244u8, 159u8, 242u8,
                213u8,
            ],
            [
                47u8, 72u8, 23u8, 49u8, 130u8, 66u8, 209u8, 184u8, 103u8, 0u8, 164u8,
                38u8, 247u8, 206u8, 208u8, 73u8, 198u8, 128u8, 89u8, 37u8, 60u8, 10u8,
                114u8, 30u8, 1u8, 185u8, 113u8, 143u8, 69u8, 39u8, 190u8, 246u8,
            ],
            [
                66u8, 125u8, 180u8, 143u8, 140u8, 208u8, 207u8, 127u8, 218u8, 188u8,
                219u8, 193u8, 50u8, 124u8, 125u8, 178u8, 108u8, 227u8, 165u8, 68u8, 41u8,
                43u8, 163u8, 128u8, 239u8, 7u8, 213u8, 23u8, 90u8, 247u8, 41u8, 205u8,
            ],
            [
                67u8, 153u8, 30u8, 30u8, 28u8, 251u8, 46u8, 237u8, 108u8, 157u8, 195u8,
                122u8, 122u8, 132u8, 134u8, 34u8, 248u8, 227u8, 247u8, 91u8, 195u8,
                141u8, 83u8, 42u8, 0u8, 234u8, 240u8, 38u8, 205u8, 135u8, 160u8, 20u8,
            ],
            [
                68u8, 40u8, 46u8, 42u8, 75u8, 187u8, 134u8, 185u8, 248u8, 8u8, 157u8,
                16u8, 134u8, 244u8, 224u8, 223u8, 39u8, 48u8, 84u8, 234u8, 182u8, 44u8,
                219u8, 218u8, 24u8, 246u8, 71u8, 207u8, 210u8, 42u8, 30u8, 255u8,
            ],
            [
                68u8, 47u8, 122u8, 183u8, 210u8, 107u8, 247u8, 186u8, 116u8, 242u8, 62u8,
                35u8, 125u8, 18u8, 135u8, 98u8, 81u8, 249u8, 29u8, 97u8, 174u8, 178u8,
                137u8, 154u8, 217u8, 95u8, 51u8, 79u8, 165u8, 231u8, 198u8, 51u8,
            ],
            [
                93u8, 41u8, 105u8, 62u8, 99u8, 179u8, 160u8, 132u8, 229u8, 104u8, 147u8,
                206u8, 140u8, 127u8, 94u8, 245u8, 220u8, 130u8, 19u8, 218u8, 65u8, 7u8,
                0u8, 132u8, 230u8, 177u8, 196u8, 55u8, 10u8, 189u8, 100u8, 196u8,
            ],
            [
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ],
            [
                97u8, 196u8, 154u8, 182u8, 187u8, 30u8, 245u8, 145u8, 145u8, 167u8, 70u8,
                175u8, 206u8, 125u8, 39u8, 49u8, 212u8, 217u8, 176u8, 250u8, 253u8,
                171u8, 141u8, 99u8, 240u8, 47u8, 228u8, 65u8, 105u8, 83u8, 45u8, 197u8,
            ],
            [
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ],
            [
                104u8, 246u8, 125u8, 232u8, 158u8, 150u8, 177u8, 58u8, 62u8, 160u8, 88u8,
                175u8, 95u8, 212u8, 76u8, 193u8, 37u8, 239u8, 206u8, 181u8, 40u8, 72u8,
                45u8, 83u8, 156u8, 123u8, 67u8, 219u8, 47u8, 170u8, 6u8, 110u8,
            ],
            [
                119u8, 36u8, 47u8, 189u8, 87u8, 58u8, 245u8, 165u8, 243u8, 81u8, 141u8,
                169u8, 38u8, 0u8, 233u8, 103u8, 149u8, 235u8, 255u8, 249u8, 147u8, 96u8,
                107u8, 79u8, 181u8, 77u8, 234u8, 45u8, 205u8, 45u8, 254u8, 133u8,
            ],
            [
                120u8, 22u8, 15u8, 11u8, 27u8, 43u8, 50u8, 181u8, 42u8, 0u8, 118u8,
                216u8, 240u8, 247u8, 8u8, 136u8, 104u8, 123u8, 167u8, 2u8, 164u8, 217u8,
                147u8, 213u8, 90u8, 200u8, 217u8, 50u8, 125u8, 87u8, 161u8, 39u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
            [
                142u8, 152u8, 160u8, 115u8, 68u8, 32u8, 229u8, 126u8, 241u8, 2u8, 202u8,
                176u8, 177u8, 175u8, 8u8, 9u8, 165u8, 187u8, 175u8, 79u8, 222u8, 150u8,
                111u8, 209u8, 115u8, 195u8, 34u8, 73u8, 6u8, 68u8, 165u8, 208u8,
            ],
            [
                157u8, 97u8, 27u8, 91u8, 52u8, 203u8, 118u8, 19u8, 28u8, 79u8, 180u8,
                19u8, 235u8, 116u8, 17u8, 155u8, 44u8, 12u8, 58u8, 106u8, 166u8, 252u8,
                216u8, 231u8, 64u8, 207u8, 112u8, 172u8, 48u8, 133u8, 216u8, 123u8,
            ],
            [
                159u8, 94u8, 29u8, 19u8, 4u8, 93u8, 39u8, 47u8, 190u8, 116u8, 206u8,
                77u8, 8u8, 233u8, 25u8, 130u8, 165u8, 197u8, 119u8, 132u8, 57u8, 26u8,
                230u8, 161u8, 153u8, 238u8, 205u8, 207u8, 99u8, 148u8, 159u8, 254u8,
            ],
            [
                164u8, 79u8, 41u8, 61u8, 250u8, 146u8, 40u8, 145u8, 99u8, 69u8, 166u8,
                1u8, 98u8, 32u8, 243u8, 4u8, 253u8, 78u8, 16u8, 194u8, 242u8, 94u8,
                246u8, 44u8, 137u8, 107u8, 73u8, 70u8, 146u8, 106u8, 112u8, 244u8,
            ],
            [
                168u8, 211u8, 179u8, 33u8, 59u8, 127u8, 130u8, 68u8, 229u8, 176u8, 69u8,
                81u8, 219u8, 154u8, 170u8, 188u8, 204u8, 33u8, 214u8, 33u8, 44u8, 67u8,
                195u8, 179u8, 20u8, 59u8, 205u8, 233u8, 124u8, 168u8, 83u8, 206u8,
            ],
            [
                171u8, 99u8, 194u8, 90u8, 160u8, 122u8, 77u8, 16u8, 161u8, 132u8, 45u8,
                97u8, 2u8, 106u8, 8u8, 217u8, 81u8, 21u8, 196u8, 230u8, 137u8, 82u8,
                136u8, 104u8, 48u8, 21u8, 202u8, 68u8, 100u8, 199u8, 245u8, 15u8,
            ],
            [
                177u8, 216u8, 239u8, 249u8, 72u8, 88u8, 22u8, 187u8, 56u8, 206u8, 236u8,
                243u8, 23u8, 163u8, 253u8, 160u8, 85u8, 151u8, 188u8, 91u8, 56u8, 242u8,
                242u8, 45u8, 249u8, 108u8, 14u8, 189u8, 93u8, 194u8, 54u8, 238u8,
            ],
            [
                182u8, 43u8, 78u8, 111u8, 30u8, 197u8, 151u8, 10u8, 41u8, 39u8, 78u8,
                116u8, 120u8, 53u8, 244u8, 68u8, 165u8, 204u8, 212u8, 128u8, 73u8, 105u8,
                142u8, 255u8, 156u8, 156u8, 253u8, 202u8, 46u8, 26u8, 94u8, 175u8,
            ],
            [
                200u8, 183u8, 254u8, 36u8, 220u8, 46u8, 158u8, 115u8, 17u8, 65u8, 254u8,
                29u8, 215u8, 77u8, 108u8, 228u8, 112u8, 189u8, 107u8, 83u8, 113u8, 193u8,
                47u8, 66u8, 201u8, 206u8, 70u8, 186u8, 193u8, 84u8, 36u8, 197u8,
            ],
            [
                215u8, 207u8, 117u8, 220u8, 25u8, 50u8, 7u8, 246u8, 72u8, 75u8, 123u8,
                214u8, 196u8, 252u8, 70u8, 159u8, 59u8, 107u8, 115u8, 61u8, 44u8, 188u8,
                238u8, 64u8, 57u8, 117u8, 40u8, 123u8, 1u8, 93u8, 196u8, 153u8,
            ],
            [
                218u8, 228u8, 65u8, 124u8, 37u8, 169u8, 60u8, 251u8, 134u8, 206u8, 95u8,
                187u8, 184u8, 252u8, 22u8, 48u8, 148u8, 91u8, 97u8, 175u8, 174u8, 171u8,
                79u8, 41u8, 207u8, 48u8, 27u8, 154u8, 5u8, 139u8, 169u8, 20u8,
            ],
            [
                220u8, 161u8, 107u8, 10u8, 246u8, 225u8, 15u8, 93u8, 251u8, 125u8, 78u8,
                169u8, 16u8, 85u8, 149u8, 20u8, 25u8, 160u8, 200u8, 255u8, 197u8, 146u8,
                90u8, 207u8, 253u8, 197u8, 42u8, 149u8, 252u8, 198u8, 113u8, 51u8,
            ],
            [
                228u8, 49u8, 80u8, 43u8, 208u8, 223u8, 88u8, 128u8, 57u8, 126u8, 193u8,
                60u8, 10u8, 38u8, 15u8, 12u8, 116u8, 156u8, 143u8, 58u8, 48u8, 198u8,
                202u8, 243u8, 255u8, 224u8, 240u8, 138u8, 46u8, 209u8, 57u8, 66u8,
            ],
            [
                247u8, 207u8, 174u8, 152u8, 112u8, 225u8, 48u8, 122u8, 7u8, 145u8, 214u8,
                65u8, 141u8, 158u8, 120u8, 171u8, 209u8, 115u8, 26u8, 28u8, 3u8, 96u8,
                104u8, 19u8, 144u8, 107u8, 71u8, 77u8, 48u8, 126u8, 173u8, 86u8,
            ],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(RealtorMinFeeSet),
            ::core::stringify!(ProtocolMaxLeaseDurationSet),
            ::core::stringify!(RealtorSet),
            ::core::stringify!(ProtocolFlatFeeFloorSet),
            ::core::stringify!(RealtorMinFlatFeeSet),
            ::core::stringify!(BridgerSet),
            ::core::stringify!(ProtocolPnlUpdated),
            ::core::stringify!(LpWithdrawn),
            ::core::stringify!(LpSet),
            ::core::stringify!(TronReaderSet),
            ::core::stringify!(Unpaused),
            ::core::stringify!(RealtorLeaseRateLimitSet),
            ::core::stringify!(Paused),
            ::core::stringify!(TokensRescued),
            ::core::stringify!(ClaimCreated),
            ::core::stringify!(EventAppended),
            ::core::stringify!(OwnershipTransferred),
            ::core::stringify!(LeaseNonceUpdated),
            ::core::stringify!(ControllerEventChainTipUpdated),
            ::core::stringify!(TronUsdtSet),
            ::core::stringify!(UsdtSet),
            ::core::stringify!(SwapRateSet),
            ::core::stringify!(LesseePayoutConfigRateLimitSet),
            ::core::stringify!(RealtorMaxLeaseDurationSet),
            ::core::stringify!(ClaimFilled),
            ::core::stringify!(ChainDeprecatedSet),
            ::core::stringify!(PayoutConfigUpdated),
            ::core::stringify!(LpDeposited),
            ::core::stringify!(ControllerEventProcessed),
            ::core::stringify!(LeaseCreated),
            ::core::stringify!(ProtocolFloorSet),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <RealtorMinFeeSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <ProtocolMaxLeaseDurationSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <RealtorSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <ProtocolFlatFeeFloorSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <RealtorMinFlatFeeSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <BridgerSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <ProtocolPnlUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
            <LpWithdrawn as alloy_sol_types::SolEvent>::SIGNATURE,
            <LpSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <TronReaderSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <Unpaused as alloy_sol_types::SolEvent>::SIGNATURE,
            <RealtorLeaseRateLimitSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <Paused as alloy_sol_types::SolEvent>::SIGNATURE,
            <TokensRescued as alloy_sol_types::SolEvent>::SIGNATURE,
            <ClaimCreated as alloy_sol_types::SolEvent>::SIGNATURE,
            <EventAppended as alloy_sol_types::SolEvent>::SIGNATURE,
            <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE,
            <LeaseNonceUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
            <ControllerEventChainTipUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
            <TronUsdtSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <UsdtSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <SwapRateSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <LesseePayoutConfigRateLimitSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <RealtorMaxLeaseDurationSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <ClaimFilled as alloy_sol_types::SolEvent>::SIGNATURE,
            <ChainDeprecatedSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <PayoutConfigUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
            <LpDeposited as alloy_sol_types::SolEvent>::SIGNATURE,
            <ControllerEventProcessed as alloy_sol_types::SolEvent>::SIGNATURE,
            <LeaseCreated as alloy_sol_types::SolEvent>::SIGNATURE,
            <ProtocolFloorSet as alloy_sol_types::SolEvent>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for UntronV3HarnessEvents {
        const NAME: &'static str = "UntronV3HarnessEvents";
        const COUNT: usize = 31usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<BridgerSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgerSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::BridgerSet)
                }
                Some(
                    <ChainDeprecatedSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ChainDeprecatedSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ChainDeprecatedSet)
                }
                Some(<ClaimCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ClaimCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ClaimCreated)
                }
                Some(<ClaimFilled as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ClaimFilled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ClaimFilled)
                }
                Some(
                    <ControllerEventChainTipUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ControllerEventChainTipUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ControllerEventChainTipUpdated)
                }
                Some(
                    <ControllerEventProcessed as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ControllerEventProcessed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ControllerEventProcessed)
                }
                Some(<EventAppended as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EventAppended as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::EventAppended)
                }
                Some(<LeaseCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <LeaseCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::LeaseCreated)
                }
                Some(
                    <LeaseNonceUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <LeaseNonceUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::LeaseNonceUpdated)
                }
                Some(
                    <LesseePayoutConfigRateLimitSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <LesseePayoutConfigRateLimitSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::LesseePayoutConfigRateLimitSet)
                }
                Some(<LpDeposited as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <LpDeposited as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::LpDeposited)
                }
                Some(<LpSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <LpSet as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::LpSet)
                }
                Some(<LpWithdrawn as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <LpWithdrawn as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::LpWithdrawn)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Paused)
                }
                Some(
                    <PayoutConfigUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <PayoutConfigUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::PayoutConfigUpdated)
                }
                Some(
                    <ProtocolFlatFeeFloorSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ProtocolFlatFeeFloorSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ProtocolFlatFeeFloorSet)
                }
                Some(<ProtocolFloorSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ProtocolFloorSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ProtocolFloorSet)
                }
                Some(
                    <ProtocolMaxLeaseDurationSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ProtocolMaxLeaseDurationSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ProtocolMaxLeaseDurationSet)
                }
                Some(
                    <ProtocolPnlUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ProtocolPnlUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ProtocolPnlUpdated)
                }
                Some(
                    <RealtorLeaseRateLimitSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RealtorLeaseRateLimitSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RealtorLeaseRateLimitSet)
                }
                Some(
                    <RealtorMaxLeaseDurationSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RealtorMaxLeaseDurationSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RealtorMaxLeaseDurationSet)
                }
                Some(<RealtorMinFeeSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RealtorMinFeeSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RealtorMinFeeSet)
                }
                Some(
                    <RealtorMinFlatFeeSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RealtorMinFlatFeeSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RealtorMinFlatFeeSet)
                }
                Some(<RealtorSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RealtorSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RealtorSet)
                }
                Some(<SwapRateSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <SwapRateSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::SwapRateSet)
                }
                Some(<TokensRescued as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TokensRescued as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::TokensRescued)
                }
                Some(<TronReaderSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TronReaderSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::TronReaderSet)
                }
                Some(<TronUsdtSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TronUsdtSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::TronUsdtSet)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Unpaused)
                }
                Some(<UsdtSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <UsdtSet as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::UsdtSet)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for UntronV3HarnessEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BridgerSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ChainDeprecatedSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ClaimCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ClaimFilled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ControllerEventChainTipUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ControllerEventProcessed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EventAppended(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::LeaseCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::LeaseNonceUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::LesseePayoutConfigRateLimitSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::LpDeposited(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::LpSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::LpWithdrawn(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::PayoutConfigUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ProtocolFlatFeeFloorSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ProtocolFloorSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ProtocolMaxLeaseDurationSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ProtocolPnlUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RealtorLeaseRateLimitSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RealtorMaxLeaseDurationSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RealtorMinFeeSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RealtorMinFlatFeeSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RealtorSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SwapRateSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TokensRescued(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TronReaderSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TronUsdtSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UsdtSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BridgerSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ChainDeprecatedSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ClaimCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ClaimFilled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ControllerEventChainTipUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ControllerEventProcessed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EventAppended(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::LeaseCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::LeaseNonceUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::LesseePayoutConfigRateLimitSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::LpDeposited(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::LpSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::LpWithdrawn(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::PayoutConfigUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ProtocolFlatFeeFloorSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ProtocolFloorSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ProtocolMaxLeaseDurationSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ProtocolPnlUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RealtorLeaseRateLimitSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RealtorMaxLeaseDurationSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RealtorMinFeeSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RealtorMinFlatFeeSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RealtorSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SwapRateSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TokensRescued(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TronReaderSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TronUsdtSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UsdtSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`UntronV3Harness`](self) contract instance.

See the [wrapper's documentation](`UntronV3HarnessInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> UntronV3HarnessInstance<P, N> {
        UntronV3HarnessInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        controllerAddress: alloy::sol_types::private::Address,
        create2Prefix: alloy::sol_types::private::FixedBytes<1>,
        receiverImplOverride: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<UntronV3HarnessInstance<P, N>>,
    > {
        UntronV3HarnessInstance::<
            P,
            N,
        >::deploy(__provider, controllerAddress, create2Prefix, receiverImplOverride)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        controllerAddress: alloy::sol_types::private::Address,
        create2Prefix: alloy::sol_types::private::FixedBytes<1>,
        receiverImplOverride: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        UntronV3HarnessInstance::<
            P,
            N,
        >::deploy_builder(
            __provider,
            controllerAddress,
            create2Prefix,
            receiverImplOverride,
        )
    }
    /**A [`UntronV3Harness`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`UntronV3Harness`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct UntronV3HarnessInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for UntronV3HarnessInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("UntronV3HarnessInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > UntronV3HarnessInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`UntronV3Harness`](self) contract instance.

See the [wrapper's documentation](`UntronV3HarnessInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
            controllerAddress: alloy::sol_types::private::Address,
            create2Prefix: alloy::sol_types::private::FixedBytes<1>,
            receiverImplOverride: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<UntronV3HarnessInstance<P, N>> {
            let call_builder = Self::deploy_builder(
                __provider,
                controllerAddress,
                create2Prefix,
                receiverImplOverride,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            __provider: P,
            controllerAddress: alloy::sol_types::private::Address,
            create2Prefix: alloy::sol_types::private::FixedBytes<1>,
            receiverImplOverride: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            controllerAddress,
                            create2Prefix,
                            receiverImplOverride,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> UntronV3HarnessInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> UntronV3HarnessInstance<P, N> {
            UntronV3HarnessInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > UntronV3HarnessInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`CONTROLLER_ADDRESS`] function.
        pub fn CONTROLLER_ADDRESS(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, CONTROLLER_ADDRESSCall, N> {
            self.call_builder(&CONTROLLER_ADDRESSCall)
        }
        ///Creates a new call builder for the [`RECEIVER_IMPL`] function.
        pub fn RECEIVER_IMPL(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, RECEIVER_IMPLCall, N> {
            self.call_builder(&RECEIVER_IMPLCall)
        }
        ///Creates a new call builder for the [`SWAP_EXECUTOR`] function.
        pub fn SWAP_EXECUTOR(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, SWAP_EXECUTORCall, N> {
            self.call_builder(&SWAP_EXECUTORCall)
        }
        ///Creates a new call builder for the [`bridgers`] function.
        pub fn bridgers(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, bridgersCall, N> {
            self.call_builder(&bridgersCall { _0, _1 })
        }
        ///Creates a new call builder for the [`claimLocatorByLease`] function.
        pub fn claimLocatorByLease(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, claimLocatorByLeaseCall, N> {
            self.call_builder(&claimLocatorByLeaseCall { _0, _1 })
        }
        ///Creates a new call builder for the [`claimQueueLength`] function.
        pub fn claimQueueLength(
            &self,
            targetToken: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, claimQueueLengthCall, N> {
            self.call_builder(
                &claimQueueLengthCall {
                    targetToken,
                },
            )
        }
        ///Creates a new call builder for the [`claimsByTargetToken`] function.
        pub fn claimsByTargetToken(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, claimsByTargetTokenCall, N> {
            self.call_builder(&claimsByTargetTokenCall { _0, _1 })
        }
        ///Creates a new call builder for the [`controllerEventAt`] function.
        pub fn controllerEventAt(
            &self,
            idx: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, controllerEventAtCall, N> {
            self.call_builder(&controllerEventAtCall { idx })
        }
        ///Creates a new call builder for the [`controllerEventsLength`] function.
        pub fn controllerEventsLength(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, controllerEventsLengthCall, N> {
            self.call_builder(&controllerEventsLengthCall)
        }
        ///Creates a new call builder for the [`createLease`] function.
        pub fn createLease(
            &self,
            receiverSalt: alloy::sol_types::private::FixedBytes<32>,
            lessee: alloy::sol_types::private::Address,
            nukeableAfter: u64,
            leaseFeePpm: u32,
            flatFee: u64,
            targetChainId: alloy::sol_types::private::primitives::aliases::U256,
            targetToken: alloy::sol_types::private::Address,
            beneficiary: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, createLeaseCall, N> {
            self.call_builder(
                &createLeaseCall {
                    receiverSalt,
                    lessee,
                    nukeableAfter,
                    leaseFeePpm,
                    flatFee,
                    targetChainId,
                    targetToken,
                    beneficiary,
                },
            )
        }
        ///Creates a new call builder for the [`deposit`] function.
        pub fn deposit(
            &self,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, depositCall, N> {
            self.call_builder(&depositCall { amount })
        }
        ///Creates a new call builder for the [`depositProcessed`] function.
        pub fn depositProcessed(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, depositProcessedCall, N> {
            self.call_builder(&depositProcessedCall(_0))
        }
        ///Creates a new call builder for the [`depositToPnl`] function.
        pub fn depositToPnl(
            &self,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, depositToPnlCall, N> {
            self.call_builder(&depositToPnlCall { amount })
        }
        ///Creates a new call builder for the [`effectiveLeaseRateLimit`] function.
        pub fn effectiveLeaseRateLimit(
            &self,
            realtor: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, effectiveLeaseRateLimitCall, N> {
            self.call_builder(
                &effectiveLeaseRateLimitCall {
                    realtor,
                },
            )
        }
        ///Creates a new call builder for the [`effectiveMaxLeaseDurationSeconds`] function.
        pub fn effectiveMaxLeaseDurationSeconds(
            &self,
            realtor: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            effectiveMaxLeaseDurationSecondsCall,
            N,
        > {
            self.call_builder(
                &effectiveMaxLeaseDurationSecondsCall {
                    realtor,
                },
            )
        }
        ///Creates a new call builder for the [`eip712Domain`] function.
        pub fn eip712Domain(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, eip712DomainCall, N> {
            self.call_builder(&eip712DomainCall)
        }
        ///Creates a new call builder for the [`enqueueClaim`] function.
        pub fn enqueueClaim(
            &self,
            targetToken: alloy::sol_types::private::Address,
            amountUsdt: alloy::sol_types::private::primitives::aliases::U256,
            leaseId: alloy::sol_types::private::primitives::aliases::U256,
            targetChainId: alloy::sol_types::private::primitives::aliases::U256,
            beneficiary: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, enqueueClaimCall, N> {
            self.call_builder(
                &enqueueClaimCall {
                    targetToken,
                    amountUsdt,
                    leaseId,
                    targetChainId,
                    beneficiary,
                },
            )
        }
        ///Creates a new call builder for the [`eventChainTip`] function.
        pub fn eventChainTip(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, eventChainTipCall, N> {
            self.call_builder(&eventChainTipCall)
        }
        ///Creates a new call builder for the [`eventSeq`] function.
        pub fn eventSeq(&self) -> alloy_contract::SolCallBuilder<&P, eventSeqCall, N> {
            self.call_builder(&eventSeqCall)
        }
        ///Creates a new call builder for the [`evmToTron`] function.
        pub fn evmToTron(
            &self,
            a: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, evmToTronCall, N> {
            self.call_builder(&evmToTronCall { a })
        }
        ///Creates a new call builder for the [`exposedDecodeEventChainTip`] function.
        pub fn exposedDecodeEventChainTip(
            &self,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, exposedDecodeEventChainTipCall, N> {
            self.call_builder(
                &exposedDecodeEventChainTipCall {
                    data,
                },
            )
        }
        ///Creates a new call builder for the [`exposedProcessReceiverPulled`] function.
        pub fn exposedProcessReceiverPulled(
            &self,
            receiverSalt: alloy::sol_types::private::FixedBytes<32>,
            token: alloy::sol_types::private::Address,
            usdtAmount: alloy::sol_types::private::primitives::aliases::U256,
            dumpTimestamp: u64,
        ) -> alloy_contract::SolCallBuilder<&P, exposedProcessReceiverPulledCall, N> {
            self.call_builder(
                &exposedProcessReceiverPulledCall {
                    receiverSalt,
                    token,
                    usdtAmount,
                    dumpTimestamp,
                },
            )
        }
        ///Creates a new call builder for the [`fill`] function.
        pub fn fill(
            &self,
            targetToken: alloy::sol_types::private::Address,
            maxClaims: alloy::sol_types::private::primitives::aliases::U256,
            calls: alloy::sol_types::private::Vec<
                <Call as alloy::sol_types::SolType>::RustType,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, fillCall, N> {
            self.call_builder(
                &fillCall {
                    targetToken,
                    maxClaims,
                    calls,
                },
            )
        }
        ///Creates a new call builder for the [`isChainDeprecated`] function.
        pub fn isChainDeprecated(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, isChainDeprecatedCall, N> {
            self.call_builder(&isChainDeprecatedCall(_0))
        }
        ///Creates a new call builder for the [`isLpAllowed`] function.
        pub fn isLpAllowed(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isLpAllowedCall, N> {
            self.call_builder(&isLpAllowedCall(_0))
        }
        ///Creates a new call builder for the [`isRealtor`] function.
        pub fn isRealtor(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isRealtorCall, N> {
            self.call_builder(&isRealtorCall(_0))
        }
        ///Creates a new call builder for the [`lastControllerEventSeq`] function.
        pub fn lastControllerEventSeq(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, lastControllerEventSeqCall, N> {
            self.call_builder(&lastControllerEventSeqCall)
        }
        ///Creates a new call builder for the [`lastControllerEventTip`] function.
        pub fn lastControllerEventTip(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, lastControllerEventTipCall, N> {
            self.call_builder(&lastControllerEventTipCall)
        }
        ///Creates a new call builder for the [`lastReceiverPullTimestampByToken`] function.
        pub fn lastReceiverPullTimestampByToken(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
            _1: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            lastReceiverPullTimestampByTokenCall,
            N,
        > {
            self.call_builder(
                &lastReceiverPullTimestampByTokenCall {
                    _0,
                    _1,
                },
            )
        }
        ///Creates a new call builder for the [`leaseIdsByReceiver`] function.
        pub fn leaseIdsByReceiver(
            &self,
            receiverSalt: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, leaseIdsByReceiverCall, N> {
            self.call_builder(
                &leaseIdsByReceiverCall {
                    receiverSalt,
                },
            )
        }
        ///Creates a new call builder for the [`leaseLocatorById`] function.
        pub fn leaseLocatorById(
            &self,
            leaseId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, leaseLocatorByIdCall, N> {
            self.call_builder(&leaseLocatorByIdCall { leaseId })
        }
        ///Creates a new call builder for the [`leaseNonces`] function.
        pub fn leaseNonces(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, leaseNoncesCall, N> {
            self.call_builder(&leaseNoncesCall(_0))
        }
        ///Creates a new call builder for the [`leases`] function.
        pub fn leases(
            &self,
            leaseId: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, leasesCall, N> {
            self.call_builder(&leasesCall { leaseId })
        }
        ///Creates a new call builder for the [`leasesByReceiver`] function.
        pub fn leasesByReceiver(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
            _1: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, leasesByReceiverCall, N> {
            self.call_builder(&leasesByReceiverCall { _0, _1 })
        }
        ///Creates a new call builder for the [`lesseePayoutConfigRateLimit`] function.
        pub fn lesseePayoutConfigRateLimit(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, lesseePayoutConfigRateLimitCall, N> {
            self.call_builder(&lesseePayoutConfigRateLimitCall)
        }
        ///Creates a new call builder for the [`lpPrincipal`] function.
        pub fn lpPrincipal(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, lpPrincipalCall, N> {
            self.call_builder(&lpPrincipalCall(_0))
        }
        ///Creates a new call builder for the [`nextClaimIdByLease`] function.
        pub fn nextClaimIdByLease(
            &self,
            _0: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, nextClaimIdByLeaseCall, N> {
            self.call_builder(&nextClaimIdByLeaseCall(_0))
        }
        ///Creates a new call builder for the [`nextControllerEventIndex`] function.
        pub fn nextControllerEventIndex(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, nextControllerEventIndexCall, N> {
            self.call_builder(&nextControllerEventIndexCall)
        }
        ///Creates a new call builder for the [`nextIndexByTargetToken`] function.
        pub fn nextIndexByTargetToken(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, nextIndexByTargetTokenCall, N> {
            self.call_builder(&nextIndexByTargetTokenCall(_0))
        }
        ///Creates a new call builder for the [`nextLeaseId`] function.
        pub fn nextLeaseId(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, nextLeaseIdCall, N> {
            self.call_builder(&nextLeaseIdCall)
        }
        ///Creates a new call builder for the [`nextLeaseNumberAtReceiver`] function.
        pub fn nextLeaseNumberAtReceiver(
            &self,
            receiverSalt: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, nextLeaseNumberAtReceiverCall, N> {
            self.call_builder(
                &nextLeaseNumberAtReceiverCall {
                    receiverSalt,
                },
            )
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<&P, ownerCall, N> {
            self.call_builder(&ownerCall)
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<&P, pauseCall, N> {
            self.call_builder(&pauseCall)
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<&P, pausedCall, N> {
            self.call_builder(&pausedCall)
        }
        ///Creates a new call builder for the [`preEntitle`] function.
        pub fn preEntitle(
            &self,
            receiverSalt: alloy::sol_types::private::FixedBytes<32>,
            blocks: [alloy::sol_types::private::Bytes; 20usize],
            encodedTx: alloy::sol_types::private::Bytes,
            proof: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, preEntitleCall, N> {
            self.call_builder(
                &preEntitleCall {
                    receiverSalt,
                    blocks,
                    encodedTx,
                    proof,
                    index,
                },
            )
        }
        ///Creates a new call builder for the [`predictReceiverAddress_0`] function.
        pub fn predictReceiverAddress_0(
            &self,
            salt: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, predictReceiverAddress_0Call, N> {
            self.call_builder(
                &predictReceiverAddress_0Call {
                    salt,
                },
            )
        }
        ///Creates a new call builder for the [`predictReceiverAddress_1`] function.
        pub fn predictReceiverAddress_1(
            &self,
            controller: alloy::sol_types::private::Address,
            salt: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, predictReceiverAddress_1Call, N> {
            self.call_builder(
                &predictReceiverAddress_1Call {
                    controller,
                    salt,
                },
            )
        }
        ///Creates a new call builder for the [`processControllerEvents`] function.
        pub fn processControllerEvents(
            &self,
            maxEvents: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, processControllerEventsCall, N> {
            self.call_builder(
                &processControllerEventsCall {
                    maxEvents,
                },
            )
        }
        ///Creates a new call builder for the [`protocolFloorFlatFee`] function.
        pub fn protocolFloorFlatFee(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, protocolFloorFlatFeeCall, N> {
            self.call_builder(&protocolFloorFlatFeeCall)
        }
        ///Creates a new call builder for the [`protocolFloorPpm`] function.
        pub fn protocolFloorPpm(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, protocolFloorPpmCall, N> {
            self.call_builder(&protocolFloorPpmCall)
        }
        ///Creates a new call builder for the [`protocolMaxLeaseDurationSeconds`] function.
        pub fn protocolMaxLeaseDurationSeconds(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, protocolMaxLeaseDurationSecondsCall, N> {
            self.call_builder(&protocolMaxLeaseDurationSecondsCall)
        }
        ///Creates a new call builder for the [`protocolPnl`] function.
        pub fn protocolPnl(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, protocolPnlCall, N> {
            self.call_builder(&protocolPnlCall)
        }
        ///Creates a new call builder for the [`pushControllerEvent`] function.
        pub fn pushControllerEvent(
            &self,
            sig: alloy::sol_types::private::FixedBytes<32>,
            data: alloy::sol_types::private::Bytes,
            blockNumber: u64,
            blockTimestamp: u64,
        ) -> alloy_contract::SolCallBuilder<&P, pushControllerEventCall, N> {
            self.call_builder(
                &pushControllerEventCall {
                    sig,
                    data,
                    blockNumber,
                    blockTimestamp,
                },
            )
        }
        ///Creates a new call builder for the [`realtorLeaseRateLimit`] function.
        pub fn realtorLeaseRateLimit(
            &self,
            realtor: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, realtorLeaseRateLimitCall, N> {
            self.call_builder(
                &realtorLeaseRateLimitCall {
                    realtor,
                },
            )
        }
        ///Creates a new call builder for the [`realtorMaxLeaseDurationSeconds`] function.
        pub fn realtorMaxLeaseDurationSeconds(
            &self,
            realtor: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, realtorMaxLeaseDurationSecondsCall, N> {
            self.call_builder(
                &realtorMaxLeaseDurationSecondsCall {
                    realtor,
                },
            )
        }
        ///Creates a new call builder for the [`realtorMinFeePpm`] function.
        pub fn realtorMinFeePpm(
            &self,
            realtor: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, realtorMinFeePpmCall, N> {
            self.call_builder(&realtorMinFeePpmCall { realtor })
        }
        ///Creates a new call builder for the [`realtorMinFlatFee`] function.
        pub fn realtorMinFlatFee(
            &self,
            realtor: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, realtorMinFlatFeeCall, N> {
            self.call_builder(&realtorMinFlatFeeCall { realtor })
        }
        ///Creates a new call builder for the [`receiverBytecode`] function.
        pub fn receiverBytecode(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, receiverBytecodeCall, N> {
            self.call_builder(&receiverBytecodeCall)
        }
        ///Creates a new call builder for the [`relayControllerEventChain`] function.
        pub fn relayControllerEventChain(
            &self,
            blocks: [alloy::sol_types::private::Bytes; 20usize],
            encodedTx: alloy::sol_types::private::Bytes,
            proof: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
            index: alloy::sol_types::private::primitives::aliases::U256,
            events: alloy::sol_types::private::Vec<
                <UntronV3::ControllerEvent as alloy::sol_types::SolType>::RustType,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, relayControllerEventChainCall, N> {
            self.call_builder(
                &relayControllerEventChainCall {
                    blocks,
                    encodedTx,
                    proof,
                    index,
                    events,
                },
            )
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall)
        }
        ///Creates a new call builder for the [`rescueTokens`] function.
        pub fn rescueTokens(
            &self,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, rescueTokensCall, N> {
            self.call_builder(&rescueTokensCall { token, amount })
        }
        ///Creates a new call builder for the [`setBridger`] function.
        pub fn setBridger(
            &self,
            targetToken: alloy::sol_types::private::Address,
            targetChainId: alloy::sol_types::private::primitives::aliases::U256,
            bridger: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setBridgerCall, N> {
            self.call_builder(
                &setBridgerCall {
                    targetToken,
                    targetChainId,
                    bridger,
                },
            )
        }
        ///Creates a new call builder for the [`setChainDeprecated`] function.
        pub fn setChainDeprecated(
            &self,
            targetChainId: alloy::sol_types::private::primitives::aliases::U256,
            deprecated: bool,
        ) -> alloy_contract::SolCallBuilder<&P, setChainDeprecatedCall, N> {
            self.call_builder(
                &setChainDeprecatedCall {
                    targetChainId,
                    deprecated,
                },
            )
        }
        ///Creates a new call builder for the [`setLesseePayoutConfigRateLimit`] function.
        pub fn setLesseePayoutConfigRateLimit(
            &self,
            maxUpdates: alloy::sol_types::private::primitives::aliases::U256,
            windowSeconds: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, setLesseePayoutConfigRateLimitCall, N> {
            self.call_builder(
                &setLesseePayoutConfigRateLimitCall {
                    maxUpdates,
                    windowSeconds,
                },
            )
        }
        ///Creates a new call builder for the [`setLp`] function.
        pub fn setLp(
            &self,
            lp: alloy::sol_types::private::Address,
            allowed: bool,
        ) -> alloy_contract::SolCallBuilder<&P, setLpCall, N> {
            self.call_builder(&setLpCall { lp, allowed })
        }
        ///Creates a new call builder for the [`setPayoutConfig`] function.
        pub fn setPayoutConfig(
            &self,
            leaseId: alloy::sol_types::private::primitives::aliases::U256,
            targetChainId: alloy::sol_types::private::primitives::aliases::U256,
            targetToken: alloy::sol_types::private::Address,
            beneficiary: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setPayoutConfigCall, N> {
            self.call_builder(
                &setPayoutConfigCall {
                    leaseId,
                    targetChainId,
                    targetToken,
                    beneficiary,
                },
            )
        }
        ///Creates a new call builder for the [`setPayoutConfigWithSig`] function.
        pub fn setPayoutConfigWithSig(
            &self,
            leaseId: alloy::sol_types::private::primitives::aliases::U256,
            config: <UntronV3::PayoutConfig as alloy::sol_types::SolType>::RustType,
            deadline: alloy::sol_types::private::primitives::aliases::U256,
            signature: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, setPayoutConfigWithSigCall, N> {
            self.call_builder(
                &setPayoutConfigWithSigCall {
                    leaseId,
                    config,
                    deadline,
                    signature,
                },
            )
        }
        ///Creates a new call builder for the [`setProtocolFloorFlatFee`] function.
        pub fn setProtocolFloorFlatFee(
            &self,
            floorFlatFee: u64,
        ) -> alloy_contract::SolCallBuilder<&P, setProtocolFloorFlatFeeCall, N> {
            self.call_builder(
                &setProtocolFloorFlatFeeCall {
                    floorFlatFee,
                },
            )
        }
        ///Creates a new call builder for the [`setProtocolFloorPpm`] function.
        pub fn setProtocolFloorPpm(
            &self,
            floorPpm: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, setProtocolFloorPpmCall, N> {
            self.call_builder(
                &setProtocolFloorPpmCall {
                    floorPpm,
                },
            )
        }
        ///Creates a new call builder for the [`setProtocolMaxLeaseDurationSeconds`] function.
        pub fn setProtocolMaxLeaseDurationSeconds(
            &self,
            maxLeaseDurationSeconds: u32,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            setProtocolMaxLeaseDurationSecondsCall,
            N,
        > {
            self.call_builder(
                &setProtocolMaxLeaseDurationSecondsCall {
                    maxLeaseDurationSeconds,
                },
            )
        }
        ///Creates a new call builder for the [`setRealtor`] function.
        pub fn setRealtor(
            &self,
            realtor: alloy::sol_types::private::Address,
            allowed: bool,
        ) -> alloy_contract::SolCallBuilder<&P, setRealtorCall, N> {
            self.call_builder(&setRealtorCall { realtor, allowed })
        }
        ///Creates a new call builder for the [`setRealtorLeaseRateLimit`] function.
        pub fn setRealtorLeaseRateLimit(
            &self,
            realtor: alloy::sol_types::private::Address,
            maxLeases: alloy::sol_types::private::primitives::aliases::U256,
            windowSeconds: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, setRealtorLeaseRateLimitCall, N> {
            self.call_builder(
                &setRealtorLeaseRateLimitCall {
                    realtor,
                    maxLeases,
                    windowSeconds,
                },
            )
        }
        ///Creates a new call builder for the [`setRealtorMaxLeaseDurationSeconds`] function.
        pub fn setRealtorMaxLeaseDurationSeconds(
            &self,
            realtor: alloy::sol_types::private::Address,
            maxLeaseDurationSeconds: u32,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            setRealtorMaxLeaseDurationSecondsCall,
            N,
        > {
            self.call_builder(
                &setRealtorMaxLeaseDurationSecondsCall {
                    realtor,
                    maxLeaseDurationSeconds,
                },
            )
        }
        ///Creates a new call builder for the [`setRealtorMinFeePpm`] function.
        pub fn setRealtorMinFeePpm(
            &self,
            realtor: alloy::sol_types::private::Address,
            minFeePpm: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, setRealtorMinFeePpmCall, N> {
            self.call_builder(
                &setRealtorMinFeePpmCall {
                    realtor,
                    minFeePpm,
                },
            )
        }
        ///Creates a new call builder for the [`setRealtorMinFlatFee`] function.
        pub fn setRealtorMinFlatFee(
            &self,
            realtor: alloy::sol_types::private::Address,
            minFlatFee: u64,
        ) -> alloy_contract::SolCallBuilder<&P, setRealtorMinFlatFeeCall, N> {
            self.call_builder(
                &setRealtorMinFlatFeeCall {
                    realtor,
                    minFlatFee,
                },
            )
        }
        ///Creates a new call builder for the [`setSwapRate`] function.
        pub fn setSwapRate(
            &self,
            targetToken: alloy::sol_types::private::Address,
            ratePpm: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, setSwapRateCall, N> {
            self.call_builder(
                &setSwapRateCall {
                    targetToken,
                    ratePpm,
                },
            )
        }
        ///Creates a new call builder for the [`setTronReader`] function.
        pub fn setTronReader(
            &self,
            reader: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setTronReaderCall, N> {
            self.call_builder(&setTronReaderCall { reader })
        }
        ///Creates a new call builder for the [`setUsdt`] function.
        pub fn setUsdt(
            &self,
            usdt_: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setUsdtCall, N> {
            self.call_builder(&setUsdtCall { usdt_ })
        }
        ///Creates a new call builder for the [`subjectivePreEntitle`] function.
        pub fn subjectivePreEntitle(
            &self,
            txId: alloy::sol_types::private::FixedBytes<32>,
            leaseId: alloy::sol_types::private::primitives::aliases::U256,
            rawAmount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, subjectivePreEntitleCall, N> {
            self.call_builder(
                &subjectivePreEntitleCall {
                    txId,
                    leaseId,
                    rawAmount,
                },
            )
        }
        ///Creates a new call builder for the [`subjectivePreEntitlementByTxId`] function.
        pub fn subjectivePreEntitlementByTxId(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, subjectivePreEntitlementByTxIdCall, N> {
            self.call_builder(&subjectivePreEntitlementByTxIdCall(_0))
        }
        ///Creates a new call builder for the [`swapRatePpm`] function.
        pub fn swapRatePpm(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, swapRatePpmCall, N> {
            self.call_builder(&swapRatePpmCall(_0))
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`tronReader`] function.
        pub fn tronReader(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, tronReaderCall, N> {
            self.call_builder(&tronReaderCall)
        }
        ///Creates a new call builder for the [`tronUsdt`] function.
        pub fn tronUsdt(&self) -> alloy_contract::SolCallBuilder<&P, tronUsdtCall, N> {
            self.call_builder(&tronUsdtCall)
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<&P, unpauseCall, N> {
            self.call_builder(&unpauseCall)
        }
        ///Creates a new call builder for the [`usdt`] function.
        pub fn usdt(&self) -> alloy_contract::SolCallBuilder<&P, usdtCall, N> {
            self.call_builder(&usdtCall)
        }
        ///Creates a new call builder for the [`usdtBalance`] function.
        pub fn usdtBalance(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, usdtBalanceCall, N> {
            self.call_builder(&usdtBalanceCall)
        }
        ///Creates a new call builder for the [`withdraw`] function.
        pub fn withdraw(
            &self,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, withdrawCall, N> {
            self.call_builder(&withdrawCall { amount })
        }
        ///Creates a new call builder for the [`withdrawProtocolProfit`] function.
        pub fn withdrawProtocolProfit(
            &self,
            amount: alloy::sol_types::private::primitives::aliases::I256,
        ) -> alloy_contract::SolCallBuilder<&P, withdrawProtocolProfitCall, N> {
            self.call_builder(
                &withdrawProtocolProfitCall {
                    amount,
                },
            )
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > UntronV3HarnessInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`BridgerSet`] event.
        pub fn BridgerSet_filter(&self) -> alloy_contract::Event<&P, BridgerSet, N> {
            self.event_filter::<BridgerSet>()
        }
        ///Creates a new event filter for the [`ChainDeprecatedSet`] event.
        pub fn ChainDeprecatedSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, ChainDeprecatedSet, N> {
            self.event_filter::<ChainDeprecatedSet>()
        }
        ///Creates a new event filter for the [`ClaimCreated`] event.
        pub fn ClaimCreated_filter(&self) -> alloy_contract::Event<&P, ClaimCreated, N> {
            self.event_filter::<ClaimCreated>()
        }
        ///Creates a new event filter for the [`ClaimFilled`] event.
        pub fn ClaimFilled_filter(&self) -> alloy_contract::Event<&P, ClaimFilled, N> {
            self.event_filter::<ClaimFilled>()
        }
        ///Creates a new event filter for the [`ControllerEventChainTipUpdated`] event.
        pub fn ControllerEventChainTipUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, ControllerEventChainTipUpdated, N> {
            self.event_filter::<ControllerEventChainTipUpdated>()
        }
        ///Creates a new event filter for the [`ControllerEventProcessed`] event.
        pub fn ControllerEventProcessed_filter(
            &self,
        ) -> alloy_contract::Event<&P, ControllerEventProcessed, N> {
            self.event_filter::<ControllerEventProcessed>()
        }
        ///Creates a new event filter for the [`EventAppended`] event.
        pub fn EventAppended_filter(
            &self,
        ) -> alloy_contract::Event<&P, EventAppended, N> {
            self.event_filter::<EventAppended>()
        }
        ///Creates a new event filter for the [`LeaseCreated`] event.
        pub fn LeaseCreated_filter(&self) -> alloy_contract::Event<&P, LeaseCreated, N> {
            self.event_filter::<LeaseCreated>()
        }
        ///Creates a new event filter for the [`LeaseNonceUpdated`] event.
        pub fn LeaseNonceUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, LeaseNonceUpdated, N> {
            self.event_filter::<LeaseNonceUpdated>()
        }
        ///Creates a new event filter for the [`LesseePayoutConfigRateLimitSet`] event.
        pub fn LesseePayoutConfigRateLimitSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, LesseePayoutConfigRateLimitSet, N> {
            self.event_filter::<LesseePayoutConfigRateLimitSet>()
        }
        ///Creates a new event filter for the [`LpDeposited`] event.
        pub fn LpDeposited_filter(&self) -> alloy_contract::Event<&P, LpDeposited, N> {
            self.event_filter::<LpDeposited>()
        }
        ///Creates a new event filter for the [`LpSet`] event.
        pub fn LpSet_filter(&self) -> alloy_contract::Event<&P, LpSet, N> {
            self.event_filter::<LpSet>()
        }
        ///Creates a new event filter for the [`LpWithdrawn`] event.
        pub fn LpWithdrawn_filter(&self) -> alloy_contract::Event<&P, LpWithdrawn, N> {
            self.event_filter::<LpWithdrawn>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<&P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<&P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`PayoutConfigUpdated`] event.
        pub fn PayoutConfigUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, PayoutConfigUpdated, N> {
            self.event_filter::<PayoutConfigUpdated>()
        }
        ///Creates a new event filter for the [`ProtocolFlatFeeFloorSet`] event.
        pub fn ProtocolFlatFeeFloorSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, ProtocolFlatFeeFloorSet, N> {
            self.event_filter::<ProtocolFlatFeeFloorSet>()
        }
        ///Creates a new event filter for the [`ProtocolFloorSet`] event.
        pub fn ProtocolFloorSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, ProtocolFloorSet, N> {
            self.event_filter::<ProtocolFloorSet>()
        }
        ///Creates a new event filter for the [`ProtocolMaxLeaseDurationSet`] event.
        pub fn ProtocolMaxLeaseDurationSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, ProtocolMaxLeaseDurationSet, N> {
            self.event_filter::<ProtocolMaxLeaseDurationSet>()
        }
        ///Creates a new event filter for the [`ProtocolPnlUpdated`] event.
        pub fn ProtocolPnlUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, ProtocolPnlUpdated, N> {
            self.event_filter::<ProtocolPnlUpdated>()
        }
        ///Creates a new event filter for the [`RealtorLeaseRateLimitSet`] event.
        pub fn RealtorLeaseRateLimitSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, RealtorLeaseRateLimitSet, N> {
            self.event_filter::<RealtorLeaseRateLimitSet>()
        }
        ///Creates a new event filter for the [`RealtorMaxLeaseDurationSet`] event.
        pub fn RealtorMaxLeaseDurationSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, RealtorMaxLeaseDurationSet, N> {
            self.event_filter::<RealtorMaxLeaseDurationSet>()
        }
        ///Creates a new event filter for the [`RealtorMinFeeSet`] event.
        pub fn RealtorMinFeeSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, RealtorMinFeeSet, N> {
            self.event_filter::<RealtorMinFeeSet>()
        }
        ///Creates a new event filter for the [`RealtorMinFlatFeeSet`] event.
        pub fn RealtorMinFlatFeeSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, RealtorMinFlatFeeSet, N> {
            self.event_filter::<RealtorMinFlatFeeSet>()
        }
        ///Creates a new event filter for the [`RealtorSet`] event.
        pub fn RealtorSet_filter(&self) -> alloy_contract::Event<&P, RealtorSet, N> {
            self.event_filter::<RealtorSet>()
        }
        ///Creates a new event filter for the [`SwapRateSet`] event.
        pub fn SwapRateSet_filter(&self) -> alloy_contract::Event<&P, SwapRateSet, N> {
            self.event_filter::<SwapRateSet>()
        }
        ///Creates a new event filter for the [`TokensRescued`] event.
        pub fn TokensRescued_filter(
            &self,
        ) -> alloy_contract::Event<&P, TokensRescued, N> {
            self.event_filter::<TokensRescued>()
        }
        ///Creates a new event filter for the [`TronReaderSet`] event.
        pub fn TronReaderSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, TronReaderSet, N> {
            self.event_filter::<TronReaderSet>()
        }
        ///Creates a new event filter for the [`TronUsdtSet`] event.
        pub fn TronUsdtSet_filter(&self) -> alloy_contract::Event<&P, TronUsdtSet, N> {
            self.event_filter::<TronUsdtSet>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<&P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
        ///Creates a new event filter for the [`UsdtSet`] event.
        pub fn UsdtSet_filter(&self) -> alloy_contract::Event<&P, UsdtSet, N> {
            self.event_filter::<UsdtSet>()
        }
    }
}
