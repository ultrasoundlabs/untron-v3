/**

Generated by the following Solidity interface...
```solidity
interface TronLightClientHarness {
    error BlockNotRelayed();
    error BlockTooOld();
    error CheckpointNotFinalized(uint256 offset, uint8 distinct);
    error InvalidChain();
    error InvalidCompressedSignaturesLength();
    error InvalidCompressedTronBlockMetadataLength();
    error InvalidIntersectionClaim(uint256 blockNumber, bytes32 blockId);
    error InvalidIntersectionOffset(uint256 intersectionOffset, uint256 numBlocks);
    error InvalidParentBlockId(bytes32 yours, bytes32 real);
    error InvalidSrIndex(uint256 index);
    error InvalidStoreOffset(uint256 offset, uint256 numBlocks);
    error InvalidWitnessDelegateeIndex(uint256 index);
    error InvalidWitnessSigner();
    error Sha256PrecompileFailed();
    error SrSetNotSorted(uint256 index, bytes20 prev, bytes20 next);
    error StoreOffsetsNotStrictlyIncreasing(uint256 prev, uint256 next);
    error TooManyBlocks(uint256 numBlocks);
    error UnanchoredBlockRange();

    event LatestProvenBlockUpdated(bytes32 indexed previousLatest, bytes32 indexed newLatest, uint256 newBlockNumber);
    event TronBlockStored(uint256 indexed blockNumber, bytes32 indexed blockId, bytes32 txTrieRoot, uint32 timestamp);
    event TronLightClientConfigured(address indexed blockRangeProver, bytes32 indexed srDataHash, bytes32 indexed initialBlockId, bytes32 initialTxTrieRoot, uint32 initialTimestamp, bytes20[27] srs, bytes20[27] witnessDelegatees);

    constructor(address p, bytes32 initial, bytes32 initialTxTrieRoot, uint32 initialTimestamp, bytes20[27] srs_, bytes20[27] witnessDelegatees_, bytes32 srDataHash_);

    function BLOCK_RANGE_PROVER() external view returns (address);
    function SR_DATA_HASH() external view returns (bytes32);
    function benchAdvanceAndHash(bytes32 startingBlockId, bytes memory meta, uint256 numBlocks) external view returns (bytes32 acc);
    function benchDecode(bytes memory data, uint256 numBlocks) external pure returns (bytes32 acc);
    function benchDecodeMinimal(bytes memory data, uint256 numBlocks) external pure returns (bytes32 acc);
    function benchEncodeHeaderDirectNoSrLookup(bytes32 parentHash, bytes32 txTrieRoot, uint32 timestampSec, bytes20 witness, uint256 firstBlockNumber, uint256 iters) external pure returns (uint256 usedTotal, bytes32 acc);
    function benchEncodeHeaderFromMeta(bytes32 startingBlockId, bytes memory meta, uint256 numBlocks) external view returns (uint256 usedTotal, bytes32 acc);
    function benchEncodeHeaderFromMetaNoSrLookup(bytes32 startingBlockId, bytes memory meta, uint256 numBlocks, bytes20 witness) external pure returns (uint256 usedTotal, bytes32 acc);
    function benchFullVerifyNoStore(bytes32 startingBlockId, bytes memory meta, bytes memory sigs, uint256 numBlocks) external view returns (bytes32 acc);
    function benchMakeBlockId(bytes32 startingBlockId, bytes32 blockHash, uint256 numBlocks) external pure returns (bytes32 acc);
    function benchNoop(uint256 iters) external pure returns (uint256 acc);
    function benchRecoverSigner(bytes32 digest, bytes memory sigs, uint256 numBlocks) external view returns (bytes20 acc);
    function benchSha256AfterEncode(bytes32 startingBlockId, bytes memory meta, uint256 numBlocks) external view returns (bytes32 acc);
    function benchSrAt(bytes memory meta, uint256 numBlocks) external view returns (bytes20 acc);
    function benchSrAtOnly(uint8 witnessIndex, uint256 iters) external view returns (bytes20 acc);
    function benchWitnessDelegateeAt(bytes memory meta, uint256 numBlocks) external view returns (bytes20 acc);
    function decodeAt(bytes memory data, uint256 idx) external pure returns (bytes32 parentHash, bytes32 txTrieRoot, uint32 timestamp, uint8 witnessIndex);
    function encodeBlockHeaderPublic(bytes32 parentHash, bytes32 txTrieRoot, uint32 timestamp, uint8 witnessIndex, uint256 n) external view returns (bytes memory);
    function eventChainTip() external view returns (bytes32);
    function getBlockId(uint256 blockNumber) external view returns (bytes32 blockId);
    function getBlockTimestamp(uint256 blockNumber) external view returns (uint32 timestamp);
    function getTxTrieRoot(uint256 blockNumber) external view returns (bytes32 txTrieRoot);
    function hashBlockPublic(bytes32 parentHash, bytes32 txTrieRoot, uint32 timestamp, uint8 witnessIndex, uint256 n) external view returns (bytes32);
    function latestProvenBlock() external view returns (bytes32);
    function proveBlockRange(bytes32 startingBlock, bytes32 endingBlock, bytes32 endingBlockTxTrieRoot, uint32 endingBlockTimestamp, bytes memory zkProof) external;
    function proveBlocks(bytes32 startingBlock, bytes memory compressedTronBlockMetadata, bytes memory compressedSignatures, uint256 intersectionOffset, uint256 storeOffsets16) external;
    function srs(uint256 index) external view returns (bytes20 sr);
    function witnessDelegatees(uint256 index) external view returns (bytes20 delegatee);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "p",
        "type": "address",
        "internalType": "contract IBlockRangeProver"
      },
      {
        "name": "initial",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "initialTxTrieRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "initialTimestamp",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "srs_",
        "type": "bytes20[27]",
        "internalType": "bytes20[27]"
      },
      {
        "name": "witnessDelegatees_",
        "type": "bytes20[27]",
        "internalType": "bytes20[27]"
      },
      {
        "name": "srDataHash_",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "BLOCK_RANGE_PROVER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBlockRangeProver"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SR_DATA_HASH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "benchAdvanceAndHash",
    "inputs": [
      {
        "name": "startingBlockId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "meta",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "acc",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "benchDecode",
    "inputs": [
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "acc",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "benchDecodeMinimal",
    "inputs": [
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "acc",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "benchEncodeHeaderDirectNoSrLookup",
    "inputs": [
      {
        "name": "parentHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "txTrieRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "timestampSec",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "witness",
        "type": "bytes20",
        "internalType": "bytes20"
      },
      {
        "name": "firstBlockNumber",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "iters",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "usedTotal",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "acc",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "benchEncodeHeaderFromMeta",
    "inputs": [
      {
        "name": "startingBlockId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "meta",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "usedTotal",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "acc",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "benchEncodeHeaderFromMetaNoSrLookup",
    "inputs": [
      {
        "name": "startingBlockId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "meta",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "witness",
        "type": "bytes20",
        "internalType": "bytes20"
      }
    ],
    "outputs": [
      {
        "name": "usedTotal",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "acc",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "benchFullVerifyNoStore",
    "inputs": [
      {
        "name": "startingBlockId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "meta",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "sigs",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "acc",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "benchMakeBlockId",
    "inputs": [
      {
        "name": "startingBlockId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "blockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "acc",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "benchNoop",
    "inputs": [
      {
        "name": "iters",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "acc",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "benchRecoverSigner",
    "inputs": [
      {
        "name": "digest",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "sigs",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "acc",
        "type": "bytes20",
        "internalType": "bytes20"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "benchSha256AfterEncode",
    "inputs": [
      {
        "name": "startingBlockId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "meta",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "acc",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "benchSrAt",
    "inputs": [
      {
        "name": "meta",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "acc",
        "type": "bytes20",
        "internalType": "bytes20"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "benchSrAtOnly",
    "inputs": [
      {
        "name": "witnessIndex",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "iters",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "acc",
        "type": "bytes20",
        "internalType": "bytes20"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "benchWitnessDelegateeAt",
    "inputs": [
      {
        "name": "meta",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "acc",
        "type": "bytes20",
        "internalType": "bytes20"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "decodeAt",
    "inputs": [
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "idx",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "parentHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "txTrieRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "timestamp",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "witnessIndex",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "encodeBlockHeaderPublic",
    "inputs": [
      {
        "name": "parentHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "txTrieRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "timestamp",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "witnessIndex",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "n",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eventChainTip",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBlockId",
    "inputs": [
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "blockId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBlockTimestamp",
    "inputs": [
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "timestamp",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getTxTrieRoot",
    "inputs": [
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "txTrieRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "hashBlockPublic",
    "inputs": [
      {
        "name": "parentHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "txTrieRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "timestamp",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "witnessIndex",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "n",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "latestProvenBlock",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proveBlockRange",
    "inputs": [
      {
        "name": "startingBlock",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "endingBlock",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "endingBlockTxTrieRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "endingBlockTimestamp",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "zkProof",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "proveBlocks",
    "inputs": [
      {
        "name": "startingBlock",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "compressedTronBlockMetadata",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "compressedSignatures",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "intersectionOffset",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "storeOffsets16",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "srs",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "sr",
        "type": "bytes20",
        "internalType": "bytes20"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "witnessDelegatees",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "delegatee",
        "type": "bytes20",
        "internalType": "bytes20"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "LatestProvenBlockUpdated",
    "inputs": [
      {
        "name": "previousLatest",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newLatest",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newBlockNumber",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TronBlockStored",
    "inputs": [
      {
        "name": "blockNumber",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "blockId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "txTrieRoot",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "timestamp",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TronLightClientConfigured",
    "inputs": [
      {
        "name": "blockRangeProver",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "srDataHash",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "initialBlockId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "initialTxTrieRoot",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "initialTimestamp",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      },
      {
        "name": "srs",
        "type": "bytes20[27]",
        "indexed": false,
        "internalType": "bytes20[27]"
      },
      {
        "name": "witnessDelegatees",
        "type": "bytes20[27]",
        "indexed": false,
        "internalType": "bytes20[27]"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "BlockNotRelayed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BlockTooOld",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CheckpointNotFinalized",
    "inputs": [
      {
        "name": "offset",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "distinct",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidChain",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidCompressedSignaturesLength",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidCompressedTronBlockMetadataLength",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidIntersectionClaim",
    "inputs": [
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "blockId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidIntersectionOffset",
    "inputs": [
      {
        "name": "intersectionOffset",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidParentBlockId",
    "inputs": [
      {
        "name": "yours",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "real",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidSrIndex",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidStoreOffset",
    "inputs": [
      {
        "name": "offset",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidWitnessDelegateeIndex",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidWitnessSigner",
    "inputs": []
  },
  {
    "type": "error",
    "name": "Sha256PrecompileFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SrSetNotSorted",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "prev",
        "type": "bytes20",
        "internalType": "bytes20"
      },
      {
        "name": "next",
        "type": "bytes20",
        "internalType": "bytes20"
      }
    ]
  },
  {
    "type": "error",
    "name": "StoreOffsetsNotStrictlyIncreasing",
    "inputs": [
      {
        "name": "prev",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "next",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "TooManyBlocks",
    "inputs": [
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "UnanchoredBlockRange",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod TronLightClientHarness {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6109206040526101626107808181526002916137226107a039604051602001610028919061088e565b60408051601f1981840301815290829052610042916108c6565b602060405180830381855afa15801561005d573d5f5f3e3d5ffd5b5050506040513d601f19601f8201168201806040525081019061008091906108d1565b5f5534801561008d575f5ffd5b506040516138c43803806138c48339810160408190526100ac91610983565b6001600160a01b0387166080528686868686868660015b601b811015610159575f846100d9600184610a12565b601b81106100e9576100e9610a37565b602002015190505f8583601b811061010357610103610a37565b60200201519050606081811c9083901c1061014f57604051624c919360e81b8152600481018490526001600160601b031980841660248301528216604482015260640160405180910390fd5b50506001016100c3565b50825f60200201516001600160601b03191660a05282600160200201516001600160601b03191660c05282600260200201516001600160601b03191660e05282600360200201516001600160601b0319166101005282600460200201516001600160601b0319166101205282600560200201516001600160601b0319166101405282600660200201516001600160601b0319166101605282600760200201516001600160601b0319166101805282600860200201516001600160601b0319166101a05282600960200201516001600160601b0319166101c05282600a60200201516001600160601b0319166101e05282600b60200201516001600160601b0319166102005282600c60200201516001600160601b0319166102205282600d60200201516001600160601b0319166102405282600e60200201516001600160601b0319166102605282600f60200201516001600160601b0319166102805282601060200201516001600160601b0319166102a05282601160200201516001600160601b0319166102c05282601260200201516001600160601b0319166102e05282601360200201516001600160601b0319166103005282601460200201516001600160601b0319166103205282601560200201516001600160601b0319166103405282601660200201516001600160601b0319166103605282601760200201516001600160601b0319166103805282601860200201516001600160601b0319166103a05282601960200201516001600160601b0319166103c05282601a60200201516001600160601b0319166103e052815f60200201516001600160601b0319166104005281600160200201516001600160601b0319166104205281600260200201516001600160601b0319166104405281600360200201516001600160601b0319166104605281600460200201516001600160601b0319166104805281600560200201516001600160601b0319166104a05281600660200201516001600160601b0319166104c05281600760200201516001600160601b0319166104e05281600860200201516001600160601b0319166105005281600960200201516001600160601b0319166105205281600a60200201516001600160601b0319166105405281600b60200201516001600160601b0319166105605281600c60200201516001600160601b0319166105805281600d60200201516001600160601b0319166105a05281600e60200201516001600160601b0319166105c05281600f60200201516001600160601b0319166105e05281601060200201516001600160601b0319166106005281601160200201516001600160601b0319166106205281601260200201516001600160601b0319166106405281601360200201516001600160601b0319166106605281601460200201516001600160601b0319166106805281601560200201516001600160601b0319166106a05281601660200201516001600160601b0319166106c05281601760200201516001600160601b0319166106e05281601860200201516001600160601b0319166107005281601960200201516001600160601b0319166107205281601a60200201516001600160601b0319166107405261076081905261060e8782888888888861062c565b6106198686866106ae565b5050505050505050505050505050610b3c565b61066f5f5160206137025f395f51905f528888888888888860405160200161065a9796959493929190610a7d565b60408051601f19818403018152919052610729565b8486886001600160a01b03165f5160206137025f395f51905f528787878760405161069d9493929190610ad6565b60405180910390a450505050505050565b5f6106b98460c01c90565b5f8181526002602090815260408083208890556003825280832087905560049091529020805463ffffffff191663ffffffff851617905590506106fe818585856107a3565b6001548161070c8260c01c90565b1015610722576001859055610722818684610817565b5050505050565b60025f5443428585604051602001610745959493929190610b0e565b60408051601f198184030181529082905261075f916108c6565b602060405180830381855afa15801561077a573d5f5f3e3d5ffd5b5050506040513d601f19601f8201168201806040525081019061079d91906108d1565b5f555050565b60408051602081018690529081018490526060810183905263ffffffff821660808201526107e2905f5160206138845f395f51905f529060a00161065a565b6040805183815263ffffffff83166020820152849186915f5160206138845f395f51905f52910160405180910390a350505050565b60408051602081018590529081018390526060810182905261084a905f5160206138a45f395f51905f529060800161065a565b81835f5160206138a45f395f51905f528360405161086a91815260200190565b60405180910390a3505050565b5f81518060208401855e5f93019283525090919050565b7f54726f6e4c69676874436c69656e74496e6465780a000000000000000000000081525f6108bf6015830184610877565b9392505050565b5f6108bf8284610877565b5f602082840312156108e1575f5ffd5b5051919050565b80516001600160601b0319811681146108ff575f5ffd5b919050565b5f82601f830112610913575f5ffd5b60405161036081016001600160401b038111828210171561094257634e487b7160e01b5f52604160045260245ffd5b60405280610360840185811115610957575f5ffd5b845b818110156109785761096a816108e8565b835260209283019201610959565b509195945050505050565b5f5f5f5f5f5f5f610760888a03121561099a575f5ffd5b87516001600160a01b03811681146109b0575f5ffd5b602089015160408a015160608b0151929950909750955063ffffffff811681146109d8575f5ffd5b93506109e78960808a01610904565b92506109f7896103e08a01610904565b91505f61074089015190508091505092959891949750929550565b81810381811115610a3157634e487b7160e01b5f52601160045260245ffd5b92915050565b634e487b7160e01b5f52603260045260245ffd5b805f5b601b811015610a775781516001600160601b031916845260209384019390910190600101610a4e565b50505050565b6001600160a01b038816815260208101879052604081018690526060810185905263ffffffff841660808201526107608101610abc60a0830185610a4b565b610aca610400830184610a4b565b98975050505050505050565b84815263ffffffff841660208201526107008101610af76040830185610a4b565b610b056103a0830184610a4b565b95945050505050565b8581528460208201528360408201528260608201525f610b316080830184610877565b979650505050505050565b60805160a05160c05160e05161010051610120516101405161016051610180516101a0516101c0516101e05161020051610220516102405161026051610280516102a0516102c0516102e05161030051610320516103405161036051610380516103a0516103c0516103e05161040051610420516104405161046051610480516104a0516104c0516104e05161050051610520516105405161056051610580516105a0516105c0516105e05161060051610620516106405161066051610680516106a0516106c0516106e0516107005161072051610740516107605161297d610d855f395f81816102d601526109b901525f61132501525f6112f601525f6112c701525f61129801525f61126901525f61123a01525f61120b01525f6111dc01525f6111ad01525f61117e01525f61114f01525f61112001525f6110f101525f6110c201525f61109301525f61106401525f61103501525f61100601525f610fd701525f610fa801525f610f7901525f610f4a01525f610f1b01525f610eec01525f610ebd01525f610e8e01525f610e5f01525f611cfc01525f611ccd01525f611c9e01525f611c6f01525f611c4001525f611c1101525f611be201525f611bb301525f611b8401525f611b5501525f611b2601525f611af701525f611ac801525f611a9901525f611a6a01525f611a3b01525f611a0c01525f6119dd01525f6119ae01525f61197f01525f61195001525f61192101525f6118f201525f6118c301525f61189401525f61186501525f61183601525f81816103dd015261098c015261297d5ff3fe608060405234801561000f575f5ffd5b50600436106101bb575f3560e01c8063810b38fa116100f3578063bf14763511610093578063c813bf7e1161006e578063c813bf7e14610417578063c8be60a214610459578063ca6a66a21461046c578063eccddc321461047f575f5ffd5b8063bf147635146103a5578063c49d3258146103c5578063c57312b3146103d8575f5ffd5b8063a664336d116100ce578063a664336d14610344578063a867cec314610357578063ba4213221461037f578063bae88e2e14610392575f5ffd5b8063810b38fa1461030b57806381e1d4fa1461031e5780639257d6a614610331575f5ffd5b806339adfeff1161015e57806347e26f1a1161013957806347e26f1a146102a15780634d53e931146102c957806356dd9c10146102d1578063779982cc146102f8575f5ffd5b806339adfeff146102685780633c4f102b1461027b578063415efc971461028e575f5ffd5b806324fb3d1a1161019957806324fb3d1a14610218578063257dba8614610239578063295b3d611461024c57806336429b231461025f575f5ffd5b806312d713c2146101bf578063175767dc146101f057806322690a4914610205575b5f5ffd5b6101d26101cd3660046123d4565b610492565b6040516001600160601b031990911681526020015b60405180910390f35b6102036101fe366004612430565b6104a2565b005b6101d26102133660046124b7565b61063b565b61022b6102263660046124b7565b610683565b6040519081526020016101e7565b61022b6102473660046124ff565b6106c9565b61022b61025a3660046123d4565b610755565b61022b60015481565b6101d26102763660046123d4565b610794565b61022b61028936600461254e565b61079e565b61022b61029c366004612577565b6107ee565b6102b46102af3660046123d4565b6108cb565b60405163ffffffff90911681526020016101e7565b61022b5f5481565b61022b7f000000000000000000000000000000000000000000000000000000000000000081565b61022b6103063660046124b7565b610910565b61020361031936600461260b565b610953565b61022b61032c3660046123d4565b610a2d565b6101d261033f3660046124ff565b610a59565b6101d26103523660046124b7565b610ab5565b61036a61036536600461268e565b610af1565b604080519283526020830191909152016101e7565b61022b61038d3660046123d4565b610b9a565b61022b6103a0366004612700565b610bb7565b6103b86103b3366004612700565b610bf4565b6040516101e7919061274a565b61036a6103d336600461277f565b610c35565b6103ff7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016101e7565b61042a6104253660046124b7565b610ca9565b6040516101e79493929190938452602084019290925263ffffffff16604083015260ff16606082015260800190565b61036a6104673660046124ff565b610cc9565b61022b61047a3660046124ff565b610d75565b6101d261048d3660046127d3565b610e21565b5f61049c82610e54565b92915050565b848015806104b957506104b660458261280f565b15155b156104d7576040516319d1d62d60e21b815260040160405180910390fd5b5f6104e3604583612836565b905061ffff8111156105105760405163e082840b60e01b8152600481018290526024015b60405180910390fd5b61051b604182612849565b851461053a57604051633fc186d360e01b815260040160405180910390fd5b61056f6040518060a001604052805f81526020015f81526020015f81526020015f151581526020015f63ffffffff1681525090565b89815261057c8a60c01c90565b6020820181905261058d908b611365565b15801560608301526105c9575f1985146105c4576040516312a4724760e01b81526004810186905260248101839052604401610507565b6105f3565b8185106105f3576040516312a4724760e01b81526004810186905260248101839052604401610507565b6105fd84836113ac565b61060d818a8a8a8a878b8b611472565b806060015161062f57604051639e25652d60e01b815260040160405180910390fd5b50505050505050505050565b5f80805b83811015610677575f610653878784611753565b93505050505f6106658260ff16610e54565b60601c9390931892505060010161063f565b5060601b949350505050565b5f805b828110156106c1575f5f5f61069c888886611753565b60ff1663ffffffff909116979092189690961818945050600190920191506106869050565b509392505050565b6040805160a0810182525f60208201819052918101829052606081018290526080810182905285815260c086901c602082015260408051608080825260a082019092525f916020820181803683370190505090505f5b8481101561074a575f5f610736858a8a868861178a565b60ff1696189590951894505060010161071f565b505050949350505050565b5f8181526002602052604081205480610781576040516335ae903b60e01b815260040160405180910390fd5b50505f9081526003602052604090205490565b5f61049c8261182b565b5f5f6107aa8560c01c90565b90505f5b838110156107e5575f6107c18284612860565b6107cc906001612860565b90506107d88187611d3c565b90931892506001016107ae565b50509392505050565b6040805160a0810182525f60208201819052918101829052606081018290526080810182905287815260c088901c602082015260408051608080825260a082019092525f916020820181803683370190505090505f5b848110156108be575f5f61085b858c8c868861178a565b915091505f61086d838b8b8789611d5f565b90505f61087c8360ff16610e54565b90506001600160601b0319828116908216146108ab57604051634012d81f60e11b815260040160405180910390fd5b5060601c95909518945050600101610844565b5050509695505050505050565b5f81815260026020526040812054806108f7576040516335ae903b60e01b815260040160405180910390fd5b50505f9081526004602052604090205463ffffffff1690565b5f805b828110156106c1575f5f5f5f61092a898987611753565b60ff1663ffffffff90911698909218189690961895909518945050600190920191506109139050565b6001548614610975576040516330bfef3b60e21b815260040160405180910390fd5b604051634d19d99b60e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690634d19d99b906109ed907f0000000000000000000000000000000000000000000000000000000000000000908a908a908a908a908a908a90600401612873565b5f604051808303815f87803b158015610a04575f5ffd5b505af1158015610a16573d5f5f3e3d5ffd5b50505050610a25858585611e32565b505050505050565b5f818152600260205260408120548061049c576040516335ae903b60e01b815260040160405180910390fd5b60408051608080825260a082019092525f918291906020820181803683370190505090505f805b84811015610aa7575f610a968989898588611d5f565b60601c929092189150600101610a80565b5060601b9695505050505050565b5f80805b83811015610677575f610acd878784611753565b93505050505f610adf8260ff1661182b565b60601c93909318925050600101610ab9565b5f5f5f610afe8860c01c90565b60408051608080825260a082019092529192505f91906020820181803683370190505090505f5b86811015610b8d575f5f5f610b3b8c8c86611753565b50919450925090505f610b4e8588612860565b610b59906001612860565b90505f610b6a878686868f87611ead565b9050610b76818b612860565b99509790971896505060019092019150610b259050565b5050509550959350505050565b5f805b82811015610bb15790810190600101610b9d565b50919050565b60408051608080825260a082019092525f91829190602082018180368337019050509050610be9878787878786611f9a565b979650505050505050565b60408051608080825260a082019092526060915f91906020820181803683370190505090505f610c28828989898989611fe9565b8252509695505050505050565b60408051608080825260a082019092525f91829182916020820181803683370190505090505f5b84811015610c9c575f610c6f8288612860565b90505f610c80848d8d8d8d87611ead565b9050610c8c8187612860565b9550939093189250600101610c5c565b5050965096945050505050565b5f5f5f5f610cb8878787611753565b929a91995097509095509350505050565b5f5f5f610cd68760c01c90565b60408051608080825260a082019092529192505f91906020820181803683370190505090505f5b85811015610d69575f5f5f5f610d148c8c87611753565b93509350935093505f8588610d299190612860565b610d34906001612860565b90505f610d45888787878787611fe9565b9050610d51818c612860565b9a509890981897505060019093019250610cfd915050565b50505094509492505050565b5f5f610d818660c01c90565b60408051608080825260a082019092529192505f91906020820181803683370190505090505f5b8481101561074a575f5f5f5f610dbf8b8b87611753565b93509350935093505f8588610dd49190612860565b610ddf906001612860565b90505f610df0888787878787611fe9565b90505f60205f8360208c0160025afa610e07575f5ffd5b50505f519890981897505060019093019250610da8915050565b5f80805b83811015610e4957610e398560ff1661182b565b60601c9190911890600101610e25565b5060601b9392505050565b5f815f03610e8357507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600103610eb257507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600203610ee157507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600303610f1057507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600403610f3f57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600503610f6e57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600603610f9d57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600703610fcc57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600803610ffb57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160090361102a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600a0361105957507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600b0361108857507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600c036110b757507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600d036110e657507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600e0361111557507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600f0361114457507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160100361117357507f0000000000000000000000000000000000000000000000000000000000000000919050565b816011036111a257507f0000000000000000000000000000000000000000000000000000000000000000919050565b816012036111d157507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160130361120057507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160140361122f57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160150361125e57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160160361128d57507f0000000000000000000000000000000000000000000000000000000000000000919050565b816017036112bc57507f0000000000000000000000000000000000000000000000000000000000000000919050565b816018036112eb57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160190361131a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601a0361134957507f0000000000000000000000000000000000000000000000000000000000000000919050565b60405163f0b1444b60e01b815260048101839052602401610507565b5f8281526002602052604081205480156113a3578281146113995760405163057f3fa760e51b815260040160405180910390fd5b600191505061049c565b505f9392505050565b5f8080805b6010811015610a25575f6113c587836120e6565b905061fffe1981016113db57600192505061146a565b821561140457604051637db4d41760e11b81526004810182905260248101879052604401610507565b85811061142e57604051637db4d41760e11b81526004810182905260248101879052604401610507565b83801561143b5750848111155b1561146357604051638f16148f60e01b81526004810186905260248101829052604401610507565b9350600192505b6001016113b1565b60408051608080825260a082019092525f9160208201818036833701905050905061149b612362565b825f5b86811015611661575f5f5f6114b68f8f8f878b61178a565b915091505f6114c8838e8e888c611d5f565b90506114d68260ff16610e54565b6001600160601b031982811691161461150257604051634012d81f60e11b815260040160405180910390fd5b600160ff83161b93505f5b8760a0015181101561154a578488608001518260108110611530576115306128ca565b6020020180519190911763ffffffff16905260010161150d565b505050506115598d8389612101565b61ffff83811614801590611570575061ffff831682145b1561165857835160a085015161ffff851691829160108110611594576115946128ca565b61ffff909216602092830291909101528e519086015160a0870151601081106115bf576115bf6128ca565b60200201526040808f01519086015160a0870151601081106115e3576115e36128ca565b602002015260808e0151606086015160a087015160108110611607576116076128ca565b63ffffffff9092166020929092020152608085015160a086015183919060108110611634576116346128ca565b63ffffffff90921660209290920201525060a084018051600101905260109290921c915b5060010161149e565b505f5b8260a00151811015611745575f6116948460800151836010811061168a5761168a6128ca565b602002015161218e565b9050601360ff821610156116e357835182601081106116b5576116b56128ca565b602002015160405163595e108960e01b815261ffff909116600482015260ff82166024820152604401610507565b61173c846020015183601081106116fc576116fc6128ca565b602002015185604001518460108110611717576117176128ca565b602002015186606001518560108110611732576117326128ca565b6020020151611e32565b50600101611664565b505050505050505050505050565b5f80808080611763604587612849565b979097018035986020820135985060409091013560e081901c975060041a95509350505050565b5f5f5f5f5f5f61179b8a8a8a611753565b93509350935093508094508a5f015184146117d6578a516040516364ef389160e11b8152610507918691600401918252602082015260400190565b60208b018051600101908190526117f59085908590859085908c611f9a565b95506118058b6020015187611d3c565b8b525060408a019190915263ffffffff1660809098019790975290969095509350505050565b5f815f0361185a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160010361188957507f0000000000000000000000000000000000000000000000000000000000000000919050565b816002036118b857507f0000000000000000000000000000000000000000000000000000000000000000919050565b816003036118e757507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160040361191657507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160050361194557507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160060361197457507f0000000000000000000000000000000000000000000000000000000000000000919050565b816007036119a357507f0000000000000000000000000000000000000000000000000000000000000000919050565b816008036119d257507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600903611a0157507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600a03611a3057507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600b03611a5f57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600c03611a8e57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600d03611abd57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600e03611aec57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600f03611b1b57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601003611b4a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601103611b7957507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601203611ba857507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601303611bd757507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601403611c0657507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601503611c3557507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601603611c6457507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601703611c9357507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601803611cc257507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601903611cf157507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601a03611d2057507f0000000000000000000000000000000000000000000000000000000000000000919050565b6040516363cb5a4160e01b815260048101839052602401610507565b5f80611d4d6001600160c01b6128de565b60c085901b9084161791505092915050565b5f60418302850180359060208101359060400135831a601b811015611d8257601b015b8060ff16601b14158015611d9a57508060ff16601c14155b15611db857604051634012d81f60e11b815260040160405180910390fd5b5f5f602087018b81528360208201528560408201528460608201526020816080836001612710fa92506001600160a01b03815116915050811580611e0357506001600160a01b038116155b15611e2157604051634012d81f60e11b815260040160405180910390fd5b60601b9a9950505050505050505050565b5f611e3d8460c01c90565b5f8181526002602090815260408083208890556003825280832087905560049091529020805463ffffffff191663ffffffff85161790559050611e82818585856121b8565b60015481611e908260c01c90565b1015611ea6576001859055611ea6818684612262565b5050505050565b5f80611ec163ffffffff86166103e8612849565b9050606084901c602089018060088153600101835b607f811115611ef7576080607f82161782536001919091019060071c611ed6565b607f8116825350600101601281536001016020815360018101899052602101601a815360010160208153600181018a905260210160388153600101855b607f811115611f55576080607f82161782536001919091019060071c611f34565b607f8116825350600101604a81536001016015815360010160418153606083901b60018201526015016050815360010160208153036001019998505050505050505050565b5f5f611faa838989898989611fe9565b90505f60205f836020870160025afa90505f51925080611fdd57604051636eae559f60e11b815260040160405180910390fd5b50509695505050505050565b5f80611ffd63ffffffff86166103e8612849565b90505f61200c8560ff1661182b565b9050606081901c60208a018060088153600101845b607f811115612042576080607f82161782536001919091019060071c612021565b607f81168253506001016012815360010160208153600181018a9052602101601a815360010160208153600181018b905260210160388153600101865b607f8111156120a0576080607f82161782536001919091019060071c61207f565b607f8116825350600101604a81536001016015815360010160418153606083901b60018201526015016050815360010160208153036001019a9950505050505050505050565b5f61ffff6120f5836010612849565b84901c16905092915050565b8260600151806121115750808214155b1561211b57505050565b6020808401515f908152600290915260409020548061215d576020840151845160405163956d18e960e01b815260048101929092526024820152604401610507565b8351811461217e5760405163057f3fa760e51b815260040160405180910390fd5b5050600160609092019190915250565b5f5b63ffffffff8216156121b3576121a76001836128f1565b90911690600101612190565b919050565b60408051602081018690529081018490526060810183905263ffffffff8216608082015261221a907f19ec6ad7452d744382e0f59064017dca56d2b3b9a42026c6803afc5a145cd1119060a0015b6040516020818303038152906040526122e8565b6040805183815263ffffffff83166020820152849186917f19ec6ad7452d744382e0f59064017dca56d2b3b9a42026c6803afc5a145cd111910160405180910390a350505050565b6040805160208101859052908101839052606081018290526122a8907fa9fe701b4da2ff675cfd0dc541fb373a46a72c5c258a99fe850852dc75d3a1cb90608001612206565b81837fa9fe701b4da2ff675cfd0dc541fb373a46a72c5c258a99fe850852dc75d3a1cb836040516122db91815260200190565b60405180910390a3505050565b60025f5443428585604051602001612304959493929190612924565b60408051601f198184030181529082905261231e91612947565b602060405180830381855afa158015612339573d5f5f3e3d5ffd5b5050506040513d601f19601f8201168201806040525081019061235c9190612959565b5f555050565b6040518060c001604052806123756123b5565b81526020016123826123b5565b815260200161238f6123b5565b815260200161239c6123b5565b81526020016123a96123b5565b81526020015f81525090565b6040518061020001604052806010906020820280368337509192915050565b5f602082840312156123e4575f5ffd5b5035919050565b5f5f83601f8401126123fb575f5ffd5b50813567ffffffffffffffff811115612412575f5ffd5b602083019150836020828501011115612429575f5ffd5b9250929050565b5f5f5f5f5f5f5f60a0888a031215612446575f5ffd5b87359650602088013567ffffffffffffffff811115612463575f5ffd5b61246f8a828b016123eb565b909750955050604088013567ffffffffffffffff81111561248e575f5ffd5b61249a8a828b016123eb565b989b979a5095989597966060870135966080013595509350505050565b5f5f5f604084860312156124c9575f5ffd5b833567ffffffffffffffff8111156124df575f5ffd5b6124eb868287016123eb565b909790965060209590950135949350505050565b5f5f5f5f60608587031215612512575f5ffd5b84359350602085013567ffffffffffffffff81111561252f575f5ffd5b61253b878288016123eb565b9598909750949560400135949350505050565b5f5f5f60608486031215612560575f5ffd5b505081359360208301359350604090920135919050565b5f5f5f5f5f5f6080878903121561258c575f5ffd5b86359550602087013567ffffffffffffffff8111156125a9575f5ffd5b6125b589828a016123eb565b909650945050604087013567ffffffffffffffff8111156125d4575f5ffd5b6125e089828a016123eb565b979a9699509497949695606090950135949350505050565b803563ffffffff811681146121b3575f5ffd5b5f5f5f5f5f5f60a08789031215612620575f5ffd5b86359550602087013594506040870135935061263e606088016125f8565b9250608087013567ffffffffffffffff811115612659575f5ffd5b61266589828a016123eb565b979a9699509497509295939492505050565b80356001600160601b0319811681146121b3575f5ffd5b5f5f5f5f5f608086880312156126a2575f5ffd5b85359450602086013567ffffffffffffffff8111156126bf575f5ffd5b6126cb888289016123eb565b909550935050604086013591506126e460608701612677565b90509295509295909350565b803560ff811681146121b3575f5ffd5b5f5f5f5f5f60a08688031215612714575f5ffd5b853594506020860135935061272b604087016125f8565b9250612739606087016126f0565b949793965091946080013592915050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b5f5f5f5f5f5f60c08789031215612794575f5ffd5b86359550602087013594506127ab604088016125f8565b93506127b960608801612677565b9598949750929560808101359460a0909101359350915050565b5f5f604083850312156127e4575f5ffd5b6127ed836126f0565b946020939093013593505050565b634e487b7160e01b5f52601260045260245ffd5b5f8261281d5761281d6127fb565b500690565b634e487b7160e01b5f52601160045260245ffd5b5f82612844576128446127fb565b500490565b808202811582820484141761049c5761049c612822565b8082018082111561049c5761049c612822565b87815286602082015285604082015284606082015263ffffffff8416608082015260c060a08201528160c0820152818360e08301375f81830160e090810191909152601f909201601f191601019695505050505050565b634e487b7160e01b5f52603260045260245ffd5b8181038181111561049c5761049c612822565b63ffffffff828116828216039081111561049c5761049c612822565b5f81518060208401855e5f93019283525090919050565b8581528460208201528360408201528260608201525f610be9608083018461290d565b5f612952828461290d565b9392505050565b5f60208284031215612969575f5ffd5b505191905056fea164736f6c634300081b000a08a67b41721e6d18eb5a3f0d47535037e75548f56ff91770d850aec7bf23ef4a4a757374696e2053756e20697320726573706f6e7369626c6520666f722073657474696e67206261636b2074686520696e6576697461626c6520676c6f62616c20737461626c65636f696e207265766f6c7574696f6e206279207965617273207468726f756768206578706c6f6974696e672054726f6e20555344542773206e6574776f726b206566666563747320616e6420696d706f73696e672076656e646f72206c6f636b2d696e206f6e2068756e6472656473206f66206d696c6c696f6e73206f662070656f706c6520696e2074686520546869726420576f726c642c2077686f2072656c79206f6e20737461626c65636f696e7320666f722072656d697474616e63657320616e6420746f2073746f726520746865697220736176696e677320696e20756e737461626c652c206f766572726567756c617465642065636f6e6f6d6965732e204c6574277320556e74726f6e207468652050656f706c652e19ec6ad7452d744382e0f59064017dca56d2b3b9a42026c6803afc5a145cd111a9fe701b4da2ff675cfd0dc541fb373a46a72c5c258a99fe850852dc75d3a1cb
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\t `@Ra\x01ba\x07\x80\x81\x81R`\x02\x91a7\"a\x07\xA09`@Q` \x01a\0(\x91\x90a\x08\x8EV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\0B\x91a\x08\xC6V[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\0]W=__>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\0\x80\x91\x90a\x08\xD1V[_U4\x80\x15a\0\x8DW__\xFD[P`@Qa8\xC48\x03\x80a8\xC4\x839\x81\x01`@\x81\x90Ra\0\xAC\x91a\t\x83V[`\x01`\x01`\xA0\x1B\x03\x87\x16`\x80R\x86\x86\x86\x86\x86\x86\x86`\x01[`\x1B\x81\x10\x15a\x01YW_\x84a\0\xD9`\x01\x84a\n\x12V[`\x1B\x81\x10a\0\xE9Wa\0\xE9a\n7V[` \x02\x01Q\x90P_\x85\x83`\x1B\x81\x10a\x01\x03Wa\x01\x03a\n7V[` \x02\x01Q\x90P``\x81\x81\x1C\x90\x83\x90\x1C\x10a\x01OW`@QbL\x91\x93`\xE8\x1B\x81R`\x04\x81\x01\x84\x90R`\x01`\x01``\x1B\x03\x19\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01`@Q\x80\x91\x03\x90\xFD[PP`\x01\x01a\0\xC3V[P\x82_` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16`\xA0R\x82`\x01` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16`\xC0R\x82`\x02` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16`\xE0R\x82`\x03` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01\0R\x82`\x04` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01 R\x82`\x05` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01@R\x82`\x06` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01`R\x82`\x07` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01\x80R\x82`\x08` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01\xA0R\x82`\t` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01\xC0R\x82`\n` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01\xE0R\x82`\x0B` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02\0R\x82`\x0C` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02 R\x82`\r` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02@R\x82`\x0E` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02`R\x82`\x0F` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02\x80R\x82`\x10` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02\xA0R\x82`\x11` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02\xC0R\x82`\x12` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02\xE0R\x82`\x13` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03\0R\x82`\x14` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03 R\x82`\x15` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03@R\x82`\x16` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03`R\x82`\x17` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03\x80R\x82`\x18` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03\xA0R\x82`\x19` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03\xC0R\x82`\x1A` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03\xE0R\x81_` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04\0R\x81`\x01` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04 R\x81`\x02` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04@R\x81`\x03` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04`R\x81`\x04` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04\x80R\x81`\x05` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04\xA0R\x81`\x06` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04\xC0R\x81`\x07` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04\xE0R\x81`\x08` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05\0R\x81`\t` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05 R\x81`\n` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05@R\x81`\x0B` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05`R\x81`\x0C` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05\x80R\x81`\r` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05\xA0R\x81`\x0E` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05\xC0R\x81`\x0F` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05\xE0R\x81`\x10` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06\0R\x81`\x11` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06 R\x81`\x12` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06@R\x81`\x13` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06`R\x81`\x14` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06\x80R\x81`\x15` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06\xA0R\x81`\x16` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06\xC0R\x81`\x17` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06\xE0R\x81`\x18` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x07\0R\x81`\x19` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x07 R\x81`\x1A` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x07@Ra\x07`\x81\x90Ra\x06\x0E\x87\x82\x88\x88\x88\x88\x88a\x06,V[a\x06\x19\x86\x86\x86a\x06\xAEV[PPPPPPPPPPPPPPa\x0B<V[a\x06o_Q` a7\x02_9_Q\x90_R\x88\x88\x88\x88\x88\x88\x88`@Q` \x01a\x06Z\x97\x96\x95\x94\x93\x92\x91\x90a\n}V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90Ra\x07)V[\x84\x86\x88`\x01`\x01`\xA0\x1B\x03\x16_Q` a7\x02_9_Q\x90_R\x87\x87\x87\x87`@Qa\x06\x9D\x94\x93\x92\x91\x90a\n\xD6V[`@Q\x80\x91\x03\x90\xA4PPPPPPPV[_a\x06\xB9\x84`\xC0\x1C\x90V[_\x81\x81R`\x02` \x90\x81R`@\x80\x83 \x88\x90U`\x03\x82R\x80\x83 \x87\x90U`\x04\x90\x91R\x90 \x80Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x85\x16\x17\x90U\x90Pa\x06\xFE\x81\x85\x85\x85a\x07\xA3V[`\x01T\x81a\x07\x0C\x82`\xC0\x1C\x90V[\x10\x15a\x07\"W`\x01\x85\x90Ua\x07\"\x81\x86\x84a\x08\x17V[PPPPPV[`\x02_TCB\x85\x85`@Q` \x01a\x07E\x95\x94\x93\x92\x91\x90a\x0B\x0EV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x07_\x91a\x08\xC6V[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\x07zW=__>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07\x9D\x91\x90a\x08\xD1V[_UPPV[`@\x80Q` \x81\x01\x86\x90R\x90\x81\x01\x84\x90R``\x81\x01\x83\x90Rc\xFF\xFF\xFF\xFF\x82\x16`\x80\x82\x01Ra\x07\xE2\x90_Q` a8\x84_9_Q\x90_R\x90`\xA0\x01a\x06ZV[`@\x80Q\x83\x81Rc\xFF\xFF\xFF\xFF\x83\x16` \x82\x01R\x84\x91\x86\x91_Q` a8\x84_9_Q\x90_R\x91\x01`@Q\x80\x91\x03\x90\xA3PPPPV[`@\x80Q` \x81\x01\x85\x90R\x90\x81\x01\x83\x90R``\x81\x01\x82\x90Ra\x08J\x90_Q` a8\xA4_9_Q\x90_R\x90`\x80\x01a\x06ZV[\x81\x83_Q` a8\xA4_9_Q\x90_R\x83`@Qa\x08j\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA3PPPV[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[\x7FTronLightClientIndex\n\0\0\0\0\0\0\0\0\0\0\0\x81R_a\x08\xBF`\x15\x83\x01\x84a\x08wV[\x93\x92PPPV[_a\x08\xBF\x82\x84a\x08wV[_` \x82\x84\x03\x12\x15a\x08\xE1W__\xFD[PQ\x91\x90PV[\x80Q`\x01`\x01``\x1B\x03\x19\x81\x16\x81\x14a\x08\xFFW__\xFD[\x91\x90PV[_\x82`\x1F\x83\x01\x12a\t\x13W__\xFD[`@Qa\x03`\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\tBWcNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@R\x80a\x03`\x84\x01\x85\x81\x11\x15a\tWW__\xFD[\x84[\x81\x81\x10\x15a\txWa\tj\x81a\x08\xE8V[\x83R` \x92\x83\x01\x92\x01a\tYV[P\x91\x95\x94PPPPPV[_______a\x07`\x88\x8A\x03\x12\x15a\t\x9AW__\xFD[\x87Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\t\xB0W__\xFD[` \x89\x01Q`@\x8A\x01Q``\x8B\x01Q\x92\x99P\x90\x97P\x95Pc\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\t\xD8W__\xFD[\x93Pa\t\xE7\x89`\x80\x8A\x01a\t\x04V[\x92Pa\t\xF7\x89a\x03\xE0\x8A\x01a\t\x04V[\x91P_a\x07@\x89\x01Q\x90P\x80\x91PP\x92\x95\x98\x91\x94\x97P\x92\x95PV[\x81\x81\x03\x81\x81\x11\x15a\n1WcNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x92\x91PPV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x80_[`\x1B\x81\x10\x15a\nwW\x81Q`\x01`\x01``\x1B\x03\x19\x16\x84R` \x93\x84\x01\x93\x90\x91\x01\x90`\x01\x01a\nNV[PPPPV[`\x01`\x01`\xA0\x1B\x03\x88\x16\x81R` \x81\x01\x87\x90R`@\x81\x01\x86\x90R``\x81\x01\x85\x90Rc\xFF\xFF\xFF\xFF\x84\x16`\x80\x82\x01Ra\x07`\x81\x01a\n\xBC`\xA0\x83\x01\x85a\nKV[a\n\xCAa\x04\0\x83\x01\x84a\nKV[\x98\x97PPPPPPPPV[\x84\x81Rc\xFF\xFF\xFF\xFF\x84\x16` \x82\x01Ra\x07\0\x81\x01a\n\xF7`@\x83\x01\x85a\nKV[a\x0B\x05a\x03\xA0\x83\x01\x84a\nKV[\x95\x94PPPPPV[\x85\x81R\x84` \x82\x01R\x83`@\x82\x01R\x82``\x82\x01R_a\x0B1`\x80\x83\x01\x84a\x08wV[\x97\x96PPPPPPPV[`\x80Q`\xA0Q`\xC0Q`\xE0Qa\x01\0Qa\x01 Qa\x01@Qa\x01`Qa\x01\x80Qa\x01\xA0Qa\x01\xC0Qa\x01\xE0Qa\x02\0Qa\x02 Qa\x02@Qa\x02`Qa\x02\x80Qa\x02\xA0Qa\x02\xC0Qa\x02\xE0Qa\x03\0Qa\x03 Qa\x03@Qa\x03`Qa\x03\x80Qa\x03\xA0Qa\x03\xC0Qa\x03\xE0Qa\x04\0Qa\x04 Qa\x04@Qa\x04`Qa\x04\x80Qa\x04\xA0Qa\x04\xC0Qa\x04\xE0Qa\x05\0Qa\x05 Qa\x05@Qa\x05`Qa\x05\x80Qa\x05\xA0Qa\x05\xC0Qa\x05\xE0Qa\x06\0Qa\x06 Qa\x06@Qa\x06`Qa\x06\x80Qa\x06\xA0Qa\x06\xC0Qa\x06\xE0Qa\x07\0Qa\x07 Qa\x07@Qa\x07`Qa)}a\r\x85_9_\x81\x81a\x02\xD6\x01Ra\t\xB9\x01R_a\x13%\x01R_a\x12\xF6\x01R_a\x12\xC7\x01R_a\x12\x98\x01R_a\x12i\x01R_a\x12:\x01R_a\x12\x0B\x01R_a\x11\xDC\x01R_a\x11\xAD\x01R_a\x11~\x01R_a\x11O\x01R_a\x11 \x01R_a\x10\xF1\x01R_a\x10\xC2\x01R_a\x10\x93\x01R_a\x10d\x01R_a\x105\x01R_a\x10\x06\x01R_a\x0F\xD7\x01R_a\x0F\xA8\x01R_a\x0Fy\x01R_a\x0FJ\x01R_a\x0F\x1B\x01R_a\x0E\xEC\x01R_a\x0E\xBD\x01R_a\x0E\x8E\x01R_a\x0E_\x01R_a\x1C\xFC\x01R_a\x1C\xCD\x01R_a\x1C\x9E\x01R_a\x1Co\x01R_a\x1C@\x01R_a\x1C\x11\x01R_a\x1B\xE2\x01R_a\x1B\xB3\x01R_a\x1B\x84\x01R_a\x1BU\x01R_a\x1B&\x01R_a\x1A\xF7\x01R_a\x1A\xC8\x01R_a\x1A\x99\x01R_a\x1Aj\x01R_a\x1A;\x01R_a\x1A\x0C\x01R_a\x19\xDD\x01R_a\x19\xAE\x01R_a\x19\x7F\x01R_a\x19P\x01R_a\x19!\x01R_a\x18\xF2\x01R_a\x18\xC3\x01R_a\x18\x94\x01R_a\x18e\x01R_a\x186\x01R_\x81\x81a\x03\xDD\x01Ra\t\x8C\x01Ra)}_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01\xBBW_5`\xE0\x1C\x80c\x81\x0B8\xFA\x11a\0\xF3W\x80c\xBF\x14v5\x11a\0\x93W\x80c\xC8\x13\xBF~\x11a\0nW\x80c\xC8\x13\xBF~\x14a\x04\x17W\x80c\xC8\xBE`\xA2\x14a\x04YW\x80c\xCAjf\xA2\x14a\x04lW\x80c\xEC\xCD\xDC2\x14a\x04\x7FW__\xFD[\x80c\xBF\x14v5\x14a\x03\xA5W\x80c\xC4\x9D2X\x14a\x03\xC5W\x80c\xC5s\x12\xB3\x14a\x03\xD8W__\xFD[\x80c\xA6d3m\x11a\0\xCEW\x80c\xA6d3m\x14a\x03DW\x80c\xA8g\xCE\xC3\x14a\x03WW\x80c\xBAB\x13\"\x14a\x03\x7FW\x80c\xBA\xE8\x8E.\x14a\x03\x92W__\xFD[\x80c\x81\x0B8\xFA\x14a\x03\x0BW\x80c\x81\xE1\xD4\xFA\x14a\x03\x1EW\x80c\x92W\xD6\xA6\x14a\x031W__\xFD[\x80c9\xAD\xFE\xFF\x11a\x01^W\x80cG\xE2o\x1A\x11a\x019W\x80cG\xE2o\x1A\x14a\x02\xA1W\x80cMS\xE91\x14a\x02\xC9W\x80cV\xDD\x9C\x10\x14a\x02\xD1W\x80cw\x99\x82\xCC\x14a\x02\xF8W__\xFD[\x80c9\xAD\xFE\xFF\x14a\x02hW\x80c<O\x10+\x14a\x02{W\x80cA^\xFC\x97\x14a\x02\x8EW__\xFD[\x80c$\xFB=\x1A\x11a\x01\x99W\x80c$\xFB=\x1A\x14a\x02\x18W\x80c%}\xBA\x86\x14a\x029W\x80c)[=a\x14a\x02LW\x80c6B\x9B#\x14a\x02_W__\xFD[\x80c\x12\xD7\x13\xC2\x14a\x01\xBFW\x80c\x17Wg\xDC\x14a\x01\xF0W\x80c\"i\nI\x14a\x02\x05W[__\xFD[a\x01\xD2a\x01\xCD6`\x04a#\xD4V[a\x04\x92V[`@Q`\x01`\x01``\x1B\x03\x19\x90\x91\x16\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x02\x03a\x01\xFE6`\x04a$0V[a\x04\xA2V[\0[a\x01\xD2a\x02\x136`\x04a$\xB7V[a\x06;V[a\x02+a\x02&6`\x04a$\xB7V[a\x06\x83V[`@Q\x90\x81R` \x01a\x01\xE7V[a\x02+a\x02G6`\x04a$\xFFV[a\x06\xC9V[a\x02+a\x02Z6`\x04a#\xD4V[a\x07UV[a\x02+`\x01T\x81V[a\x01\xD2a\x02v6`\x04a#\xD4V[a\x07\x94V[a\x02+a\x02\x896`\x04a%NV[a\x07\x9EV[a\x02+a\x02\x9C6`\x04a%wV[a\x07\xEEV[a\x02\xB4a\x02\xAF6`\x04a#\xD4V[a\x08\xCBV[`@Qc\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\xE7V[a\x02+_T\x81V[a\x02+\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x02+a\x03\x066`\x04a$\xB7V[a\t\x10V[a\x02\x03a\x03\x196`\x04a&\x0BV[a\tSV[a\x02+a\x03,6`\x04a#\xD4V[a\n-V[a\x01\xD2a\x03?6`\x04a$\xFFV[a\nYV[a\x01\xD2a\x03R6`\x04a$\xB7V[a\n\xB5V[a\x03ja\x03e6`\x04a&\x8EV[a\n\xF1V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x01\xE7V[a\x02+a\x03\x8D6`\x04a#\xD4V[a\x0B\x9AV[a\x02+a\x03\xA06`\x04a'\0V[a\x0B\xB7V[a\x03\xB8a\x03\xB36`\x04a'\0V[a\x0B\xF4V[`@Qa\x01\xE7\x91\x90a'JV[a\x03ja\x03\xD36`\x04a'\x7FV[a\x0C5V[a\x03\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\xE7V[a\x04*a\x04%6`\x04a$\xB7V[a\x0C\xA9V[`@Qa\x01\xE7\x94\x93\x92\x91\x90\x93\x84R` \x84\x01\x92\x90\x92Rc\xFF\xFF\xFF\xFF\x16`@\x83\x01R`\xFF\x16``\x82\x01R`\x80\x01\x90V[a\x03ja\x04g6`\x04a$\xFFV[a\x0C\xC9V[a\x02+a\x04z6`\x04a$\xFFV[a\ruV[a\x01\xD2a\x04\x8D6`\x04a'\xD3V[a\x0E!V[_a\x04\x9C\x82a\x0ETV[\x92\x91PPV[\x84\x80\x15\x80a\x04\xB9WPa\x04\xB6`E\x82a(\x0FV[\x15\x15[\x15a\x04\xD7W`@Qc\x19\xD1\xD6-`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x04\xE3`E\x83a(6V[\x90Pa\xFF\xFF\x81\x11\x15a\x05\x10W`@Qc\xE0\x82\x84\x0B`\xE0\x1B\x81R`\x04\x81\x01\x82\x90R`$\x01[`@Q\x80\x91\x03\x90\xFD[a\x05\x1B`A\x82a(IV[\x85\x14a\x05:W`@Qc?\xC1\x86\xD3`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x05o`@Q\x80`\xA0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x15\x15\x81R` \x01_c\xFF\xFF\xFF\xFF\x16\x81RP\x90V[\x89\x81Ra\x05|\x8A`\xC0\x1C\x90V[` \x82\x01\x81\x90Ra\x05\x8D\x90\x8Ba\x13eV[\x15\x80\x15``\x83\x01Ra\x05\xC9W_\x19\x85\x14a\x05\xC4W`@Qc\x12\xA4rG`\xE0\x1B\x81R`\x04\x81\x01\x86\x90R`$\x81\x01\x83\x90R`D\x01a\x05\x07V[a\x05\xF3V[\x81\x85\x10a\x05\xF3W`@Qc\x12\xA4rG`\xE0\x1B\x81R`\x04\x81\x01\x86\x90R`$\x81\x01\x83\x90R`D\x01a\x05\x07V[a\x05\xFD\x84\x83a\x13\xACV[a\x06\r\x81\x8A\x8A\x8A\x8A\x87\x8B\x8Ba\x14rV[\x80``\x01Qa\x06/W`@Qc\x9E%e-`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPPPPPPPPPV[_\x80\x80[\x83\x81\x10\x15a\x06wW_a\x06S\x87\x87\x84a\x17SV[\x93PPPP_a\x06e\x82`\xFF\x16a\x0ETV[``\x1C\x93\x90\x93\x18\x92PP`\x01\x01a\x06?V[P``\x1B\x94\x93PPPPV[_\x80[\x82\x81\x10\x15a\x06\xC1W___a\x06\x9C\x88\x88\x86a\x17SV[`\xFF\x16c\xFF\xFF\xFF\xFF\x90\x91\x16\x97\x90\x92\x18\x96\x90\x96\x18\x18\x94PP`\x01\x90\x92\x01\x91Pa\x06\x86\x90PV[P\x93\x92PPPV[`@\x80Q`\xA0\x81\x01\x82R_` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R\x85\x81R`\xC0\x86\x90\x1C` \x82\x01R`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R_\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90P_[\x84\x81\x10\x15a\x07JW__a\x076\x85\x8A\x8A\x86\x88a\x17\x8AV[`\xFF\x16\x96\x18\x95\x90\x95\x18\x94PP`\x01\x01a\x07\x1FV[PPP\x94\x93PPPPV[_\x81\x81R`\x02` R`@\x81 T\x80a\x07\x81W`@Qc5\xAE\x90;`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP_\x90\x81R`\x03` R`@\x90 T\x90V[_a\x04\x9C\x82a\x18+V[__a\x07\xAA\x85`\xC0\x1C\x90V[\x90P_[\x83\x81\x10\x15a\x07\xE5W_a\x07\xC1\x82\x84a(`V[a\x07\xCC\x90`\x01a(`V[\x90Pa\x07\xD8\x81\x87a\x1D<V[\x90\x93\x18\x92P`\x01\x01a\x07\xAEV[PP\x93\x92PPPV[`@\x80Q`\xA0\x81\x01\x82R_` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R\x87\x81R`\xC0\x88\x90\x1C` \x82\x01R`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R_\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90P_[\x84\x81\x10\x15a\x08\xBEW__a\x08[\x85\x8C\x8C\x86\x88a\x17\x8AV[\x91P\x91P_a\x08m\x83\x8B\x8B\x87\x89a\x1D_V[\x90P_a\x08|\x83`\xFF\x16a\x0ETV[\x90P`\x01`\x01``\x1B\x03\x19\x82\x81\x16\x90\x82\x16\x14a\x08\xABW`@Qc@\x12\xD8\x1F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[P``\x1C\x95\x90\x95\x18\x94PP`\x01\x01a\x08DV[PPP\x96\x95PPPPPPV[_\x81\x81R`\x02` R`@\x81 T\x80a\x08\xF7W`@Qc5\xAE\x90;`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP_\x90\x81R`\x04` R`@\x90 Tc\xFF\xFF\xFF\xFF\x16\x90V[_\x80[\x82\x81\x10\x15a\x06\xC1W____a\t*\x89\x89\x87a\x17SV[`\xFF\x16c\xFF\xFF\xFF\xFF\x90\x91\x16\x98\x90\x92\x18\x18\x96\x90\x96\x18\x95\x90\x95\x18\x94PP`\x01\x90\x92\x01\x91Pa\t\x13\x90PV[`\x01T\x86\x14a\tuW`@Qc0\xBF\xEF;`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@QcM\x19\xD9\x9B`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90cM\x19\xD9\x9B\x90a\t\xED\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x8A\x90\x8A\x90\x8A\x90\x8A\x90\x8A\x90\x8A\x90`\x04\x01a(sV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\n\x04W__\xFD[PZ\xF1\x15\x80\x15a\n\x16W=__>=_\xFD[PPPPa\n%\x85\x85\x85a\x1E2V[PPPPPPV[_\x81\x81R`\x02` R`@\x81 T\x80a\x04\x9CW`@Qc5\xAE\x90;`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R_\x91\x82\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P_\x80[\x84\x81\x10\x15a\n\xA7W_a\n\x96\x89\x89\x89\x85\x88a\x1D_V[``\x1C\x92\x90\x92\x18\x91P`\x01\x01a\n\x80V[P``\x1B\x96\x95PPPPPPV[_\x80\x80[\x83\x81\x10\x15a\x06wW_a\n\xCD\x87\x87\x84a\x17SV[\x93PPPP_a\n\xDF\x82`\xFF\x16a\x18+V[``\x1C\x93\x90\x93\x18\x92PP`\x01\x01a\n\xB9V[___a\n\xFE\x88`\xC0\x1C\x90V[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R\x91\x92P_\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P_[\x86\x81\x10\x15a\x0B\x8DW___a\x0B;\x8C\x8C\x86a\x17SV[P\x91\x94P\x92P\x90P_a\x0BN\x85\x88a(`V[a\x0BY\x90`\x01a(`V[\x90P_a\x0Bj\x87\x86\x86\x86\x8F\x87a\x1E\xADV[\x90Pa\x0Bv\x81\x8Ba(`V[\x99P\x97\x90\x97\x18\x96PP`\x01\x90\x92\x01\x91Pa\x0B%\x90PV[PPP\x95P\x95\x93PPPPV[_\x80[\x82\x81\x10\x15a\x0B\xB1W\x90\x81\x01\x90`\x01\x01a\x0B\x9DV[P\x91\x90PV[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R_\x91\x82\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90Pa\x0B\xE9\x87\x87\x87\x87\x87\x86a\x1F\x9AV[\x97\x96PPPPPPPV[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R``\x91_\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P_a\x0C(\x82\x89\x89\x89\x89\x89a\x1F\xE9V[\x82RP\x96\x95PPPPPPV[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R_\x91\x82\x91\x82\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90P_[\x84\x81\x10\x15a\x0C\x9CW_a\x0Co\x82\x88a(`V[\x90P_a\x0C\x80\x84\x8D\x8D\x8D\x8D\x87a\x1E\xADV[\x90Pa\x0C\x8C\x81\x87a(`V[\x95P\x93\x90\x93\x18\x92P`\x01\x01a\x0C\\V[PP\x96P\x96\x94PPPPPV[____a\x0C\xB8\x87\x87\x87a\x17SV[\x92\x9A\x91\x99P\x97P\x90\x95P\x93PPPPV[___a\x0C\xD6\x87`\xC0\x1C\x90V[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R\x91\x92P_\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P_[\x85\x81\x10\x15a\riW____a\r\x14\x8C\x8C\x87a\x17SV[\x93P\x93P\x93P\x93P_\x85\x88a\r)\x91\x90a(`V[a\r4\x90`\x01a(`V[\x90P_a\rE\x88\x87\x87\x87\x87\x87a\x1F\xE9V[\x90Pa\rQ\x81\x8Ca(`V[\x9AP\x98\x90\x98\x18\x97PP`\x01\x90\x93\x01\x92Pa\x0C\xFD\x91PPV[PPP\x94P\x94\x92PPPV[__a\r\x81\x86`\xC0\x1C\x90V[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R\x91\x92P_\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P_[\x84\x81\x10\x15a\x07JW____a\r\xBF\x8B\x8B\x87a\x17SV[\x93P\x93P\x93P\x93P_\x85\x88a\r\xD4\x91\x90a(`V[a\r\xDF\x90`\x01a(`V[\x90P_a\r\xF0\x88\x87\x87\x87\x87\x87a\x1F\xE9V[\x90P_` _\x83` \x8C\x01`\x02Z\xFAa\x0E\x07W__\xFD[PP_Q\x98\x90\x98\x18\x97PP`\x01\x90\x93\x01\x92Pa\r\xA8\x91PPV[_\x80\x80[\x83\x81\x10\x15a\x0EIWa\x0E9\x85`\xFF\x16a\x18+V[``\x1C\x91\x90\x91\x18\x90`\x01\x01a\x0E%V[P``\x1B\x93\x92PPPV[_\x81_\x03a\x0E\x83WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x01\x03a\x0E\xB2WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x02\x03a\x0E\xE1WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x03\x03a\x0F\x10WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x04\x03a\x0F?WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x05\x03a\x0FnWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x06\x03a\x0F\x9DWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x07\x03a\x0F\xCCWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x08\x03a\x0F\xFBWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\t\x03a\x10*WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\n\x03a\x10YWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0B\x03a\x10\x88WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0C\x03a\x10\xB7WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\r\x03a\x10\xE6WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0E\x03a\x11\x15WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0F\x03a\x11DWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x10\x03a\x11sWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x11\x03a\x11\xA2WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x12\x03a\x11\xD1WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x13\x03a\x12\0WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x14\x03a\x12/WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x15\x03a\x12^WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x16\x03a\x12\x8DWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x17\x03a\x12\xBCWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x18\x03a\x12\xEBWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x19\x03a\x13\x1AWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x1A\x03a\x13IWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[`@Qc\xF0\xB1DK`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x05\x07V[_\x82\x81R`\x02` R`@\x81 T\x80\x15a\x13\xA3W\x82\x81\x14a\x13\x99W`@Qc\x05\x7F?\xA7`\xE5\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01\x91PPa\x04\x9CV[P_\x93\x92PPPV[_\x80\x80\x80[`\x10\x81\x10\x15a\n%W_a\x13\xC5\x87\x83a \xE6V[\x90Pa\xFF\xFE\x19\x81\x01a\x13\xDBW`\x01\x92PPa\x14jV[\x82\x15a\x14\x04W`@Qc}\xB4\xD4\x17`\xE1\x1B\x81R`\x04\x81\x01\x82\x90R`$\x81\x01\x87\x90R`D\x01a\x05\x07V[\x85\x81\x10a\x14.W`@Qc}\xB4\xD4\x17`\xE1\x1B\x81R`\x04\x81\x01\x82\x90R`$\x81\x01\x87\x90R`D\x01a\x05\x07V[\x83\x80\x15a\x14;WP\x84\x81\x11\x15[\x15a\x14cW`@Qc\x8F\x16\x14\x8F`\xE0\x1B\x81R`\x04\x81\x01\x86\x90R`$\x81\x01\x82\x90R`D\x01a\x05\x07V[\x93P`\x01\x92P[`\x01\x01a\x13\xB1V[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R_\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90Pa\x14\x9Ba#bV[\x82_[\x86\x81\x10\x15a\x16aW___a\x14\xB6\x8F\x8F\x8F\x87\x8Ba\x17\x8AV[\x91P\x91P_a\x14\xC8\x83\x8E\x8E\x88\x8Ca\x1D_V[\x90Pa\x14\xD6\x82`\xFF\x16a\x0ETV[`\x01`\x01``\x1B\x03\x19\x82\x81\x16\x91\x16\x14a\x15\x02W`@Qc@\x12\xD8\x1F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\xFF\x83\x16\x1B\x93P_[\x87`\xA0\x01Q\x81\x10\x15a\x15JW\x84\x88`\x80\x01Q\x82`\x10\x81\x10a\x150Wa\x150a(\xCAV[` \x02\x01\x80Q\x91\x90\x91\x17c\xFF\xFF\xFF\xFF\x16\x90R`\x01\x01a\x15\rV[PPPPa\x15Y\x8D\x83\x89a!\x01V[a\xFF\xFF\x83\x81\x16\x14\x80\x15\x90a\x15pWPa\xFF\xFF\x83\x16\x82\x14[\x15a\x16XW\x83Q`\xA0\x85\x01Qa\xFF\xFF\x85\x16\x91\x82\x91`\x10\x81\x10a\x15\x94Wa\x15\x94a(\xCAV[a\xFF\xFF\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01R\x8EQ\x90\x86\x01Q`\xA0\x87\x01Q`\x10\x81\x10a\x15\xBFWa\x15\xBFa(\xCAV[` \x02\x01R`@\x80\x8F\x01Q\x90\x86\x01Q`\xA0\x87\x01Q`\x10\x81\x10a\x15\xE3Wa\x15\xE3a(\xCAV[` \x02\x01R`\x80\x8E\x01Q``\x86\x01Q`\xA0\x87\x01Q`\x10\x81\x10a\x16\x07Wa\x16\x07a(\xCAV[c\xFF\xFF\xFF\xFF\x90\x92\x16` \x92\x90\x92\x02\x01R`\x80\x85\x01Q`\xA0\x86\x01Q\x83\x91\x90`\x10\x81\x10a\x164Wa\x164a(\xCAV[c\xFF\xFF\xFF\xFF\x90\x92\x16` \x92\x90\x92\x02\x01RP`\xA0\x84\x01\x80Q`\x01\x01\x90R`\x10\x92\x90\x92\x1C\x91[P`\x01\x01a\x14\x9EV[P_[\x82`\xA0\x01Q\x81\x10\x15a\x17EW_a\x16\x94\x84`\x80\x01Q\x83`\x10\x81\x10a\x16\x8AWa\x16\x8Aa(\xCAV[` \x02\x01Qa!\x8EV[\x90P`\x13`\xFF\x82\x16\x10\x15a\x16\xE3W\x83Q\x82`\x10\x81\x10a\x16\xB5Wa\x16\xB5a(\xCAV[` \x02\x01Q`@QcY^\x10\x89`\xE0\x1B\x81Ra\xFF\xFF\x90\x91\x16`\x04\x82\x01R`\xFF\x82\x16`$\x82\x01R`D\x01a\x05\x07V[a\x17<\x84` \x01Q\x83`\x10\x81\x10a\x16\xFCWa\x16\xFCa(\xCAV[` \x02\x01Q\x85`@\x01Q\x84`\x10\x81\x10a\x17\x17Wa\x17\x17a(\xCAV[` \x02\x01Q\x86``\x01Q\x85`\x10\x81\x10a\x172Wa\x172a(\xCAV[` \x02\x01Qa\x1E2V[P`\x01\x01a\x16dV[PPPPPPPPPPPPV[_\x80\x80\x80\x80a\x17c`E\x87a(IV[\x97\x90\x97\x01\x805\x98` \x82\x015\x98P`@\x90\x91\x015`\xE0\x81\x90\x1C\x97P`\x04\x1A\x95P\x93PPPPV[______a\x17\x9B\x8A\x8A\x8Aa\x17SV[\x93P\x93P\x93P\x93P\x80\x94P\x8A_\x01Q\x84\x14a\x17\xD6W\x8AQ`@Qcd\xEF8\x91`\xE1\x1B\x81Ra\x05\x07\x91\x86\x91`\x04\x01\x91\x82R` \x82\x01R`@\x01\x90V[` \x8B\x01\x80Q`\x01\x01\x90\x81\x90Ra\x17\xF5\x90\x85\x90\x85\x90\x85\x90\x85\x90\x8Ca\x1F\x9AV[\x95Pa\x18\x05\x8B` \x01Q\x87a\x1D<V[\x8BRP`@\x8A\x01\x91\x90\x91Rc\xFF\xFF\xFF\xFF\x16`\x80\x90\x98\x01\x97\x90\x97R\x90\x96\x90\x95P\x93PPPPV[_\x81_\x03a\x18ZWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x01\x03a\x18\x89WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x02\x03a\x18\xB8WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x03\x03a\x18\xE7WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x04\x03a\x19\x16WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x05\x03a\x19EWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x06\x03a\x19tWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x07\x03a\x19\xA3WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x08\x03a\x19\xD2WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\t\x03a\x1A\x01WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\n\x03a\x1A0WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0B\x03a\x1A_WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0C\x03a\x1A\x8EWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\r\x03a\x1A\xBDWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0E\x03a\x1A\xECWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0F\x03a\x1B\x1BWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x10\x03a\x1BJWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x11\x03a\x1ByWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x12\x03a\x1B\xA8WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x13\x03a\x1B\xD7WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x14\x03a\x1C\x06WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x15\x03a\x1C5WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x16\x03a\x1CdWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x17\x03a\x1C\x93WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x18\x03a\x1C\xC2WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x19\x03a\x1C\xF1WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x1A\x03a\x1D WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[`@Qcc\xCBZA`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x05\x07V[_\x80a\x1DM`\x01`\x01`\xC0\x1Ba(\xDEV[`\xC0\x85\x90\x1B\x90\x84\x16\x17\x91PP\x92\x91PPV[_`A\x83\x02\x85\x01\x805\x90` \x81\x015\x90`@\x015\x83\x1A`\x1B\x81\x10\x15a\x1D\x82W`\x1B\x01[\x80`\xFF\x16`\x1B\x14\x15\x80\x15a\x1D\x9AWP\x80`\xFF\x16`\x1C\x14\x15[\x15a\x1D\xB8W`@Qc@\x12\xD8\x1F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[__` \x87\x01\x8B\x81R\x83` \x82\x01R\x85`@\x82\x01R\x84``\x82\x01R` \x81`\x80\x83`\x01a'\x10\xFA\x92P`\x01`\x01`\xA0\x1B\x03\x81Q\x16\x91PP\x81\x15\x80a\x1E\x03WP`\x01`\x01`\xA0\x1B\x03\x81\x16\x15[\x15a\x1E!W`@Qc@\x12\xD8\x1F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[``\x1B\x9A\x99PPPPPPPPPPV[_a\x1E=\x84`\xC0\x1C\x90V[_\x81\x81R`\x02` \x90\x81R`@\x80\x83 \x88\x90U`\x03\x82R\x80\x83 \x87\x90U`\x04\x90\x91R\x90 \x80Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x85\x16\x17\x90U\x90Pa\x1E\x82\x81\x85\x85\x85a!\xB8V[`\x01T\x81a\x1E\x90\x82`\xC0\x1C\x90V[\x10\x15a\x1E\xA6W`\x01\x85\x90Ua\x1E\xA6\x81\x86\x84a\"bV[PPPPPV[_\x80a\x1E\xC1c\xFF\xFF\xFF\xFF\x86\x16a\x03\xE8a(IV[\x90P``\x84\x90\x1C` \x89\x01\x80`\x08\x81S`\x01\x01\x83[`\x7F\x81\x11\x15a\x1E\xF7W`\x80`\x7F\x82\x16\x17\x82S`\x01\x91\x90\x91\x01\x90`\x07\x1Ca\x1E\xD6V[`\x7F\x81\x16\x82SP`\x01\x01`\x12\x81S`\x01\x01` \x81S`\x01\x81\x01\x89\x90R`!\x01`\x1A\x81S`\x01\x01` \x81S`\x01\x81\x01\x8A\x90R`!\x01`8\x81S`\x01\x01\x85[`\x7F\x81\x11\x15a\x1FUW`\x80`\x7F\x82\x16\x17\x82S`\x01\x91\x90\x91\x01\x90`\x07\x1Ca\x1F4V[`\x7F\x81\x16\x82SP`\x01\x01`J\x81S`\x01\x01`\x15\x81S`\x01\x01`A\x81S``\x83\x90\x1B`\x01\x82\x01R`\x15\x01`P\x81S`\x01\x01` \x81S\x03`\x01\x01\x99\x98PPPPPPPPPV[__a\x1F\xAA\x83\x89\x89\x89\x89\x89a\x1F\xE9V[\x90P_` _\x83` \x87\x01`\x02Z\xFA\x90P_Q\x92P\x80a\x1F\xDDW`@Qcn\xAEU\x9F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP\x96\x95PPPPPPV[_\x80a\x1F\xFDc\xFF\xFF\xFF\xFF\x86\x16a\x03\xE8a(IV[\x90P_a \x0C\x85`\xFF\x16a\x18+V[\x90P``\x81\x90\x1C` \x8A\x01\x80`\x08\x81S`\x01\x01\x84[`\x7F\x81\x11\x15a BW`\x80`\x7F\x82\x16\x17\x82S`\x01\x91\x90\x91\x01\x90`\x07\x1Ca !V[`\x7F\x81\x16\x82SP`\x01\x01`\x12\x81S`\x01\x01` \x81S`\x01\x81\x01\x8A\x90R`!\x01`\x1A\x81S`\x01\x01` \x81S`\x01\x81\x01\x8B\x90R`!\x01`8\x81S`\x01\x01\x86[`\x7F\x81\x11\x15a \xA0W`\x80`\x7F\x82\x16\x17\x82S`\x01\x91\x90\x91\x01\x90`\x07\x1Ca \x7FV[`\x7F\x81\x16\x82SP`\x01\x01`J\x81S`\x01\x01`\x15\x81S`\x01\x01`A\x81S``\x83\x90\x1B`\x01\x82\x01R`\x15\x01`P\x81S`\x01\x01` \x81S\x03`\x01\x01\x9A\x99PPPPPPPPPPV[_a\xFF\xFFa \xF5\x83`\x10a(IV[\x84\x90\x1C\x16\x90P\x92\x91PPV[\x82``\x01Q\x80a!\x11WP\x80\x82\x14\x15[\x15a!\x1BWPPPV[` \x80\x84\x01Q_\x90\x81R`\x02\x90\x91R`@\x90 T\x80a!]W` \x84\x01Q\x84Q`@Qc\x95m\x18\xE9`\xE0\x1B\x81R`\x04\x81\x01\x92\x90\x92R`$\x82\x01R`D\x01a\x05\x07V[\x83Q\x81\x14a!~W`@Qc\x05\x7F?\xA7`\xE5\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP`\x01``\x90\x92\x01\x91\x90\x91RPV[_[c\xFF\xFF\xFF\xFF\x82\x16\x15a!\xB3Wa!\xA7`\x01\x83a(\xF1V[\x90\x91\x16\x90`\x01\x01a!\x90V[\x91\x90PV[`@\x80Q` \x81\x01\x86\x90R\x90\x81\x01\x84\x90R``\x81\x01\x83\x90Rc\xFF\xFF\xFF\xFF\x82\x16`\x80\x82\x01Ra\"\x1A\x90\x7F\x19\xECj\xD7E-tC\x82\xE0\xF5\x90d\x01}\xCAV\xD2\xB3\xB9\xA4 &\xC6\x80:\xFCZ\x14\\\xD1\x11\x90`\xA0\x01[`@Q` \x81\x83\x03\x03\x81R\x90`@Ra\"\xE8V[`@\x80Q\x83\x81Rc\xFF\xFF\xFF\xFF\x83\x16` \x82\x01R\x84\x91\x86\x91\x7F\x19\xECj\xD7E-tC\x82\xE0\xF5\x90d\x01}\xCAV\xD2\xB3\xB9\xA4 &\xC6\x80:\xFCZ\x14\\\xD1\x11\x91\x01`@Q\x80\x91\x03\x90\xA3PPPPV[`@\x80Q` \x81\x01\x85\x90R\x90\x81\x01\x83\x90R``\x81\x01\x82\x90Ra\"\xA8\x90\x7F\xA9\xFEp\x1BM\xA2\xFFg\\\xFD\r\xC5A\xFB7:F\xA7,\\%\x8A\x99\xFE\x85\x08R\xDCu\xD3\xA1\xCB\x90`\x80\x01a\"\x06V[\x81\x83\x7F\xA9\xFEp\x1BM\xA2\xFFg\\\xFD\r\xC5A\xFB7:F\xA7,\\%\x8A\x99\xFE\x85\x08R\xDCu\xD3\xA1\xCB\x83`@Qa\"\xDB\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA3PPPV[`\x02_TCB\x85\x85`@Q` \x01a#\x04\x95\x94\x93\x92\x91\x90a)$V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra#\x1E\x91a)GV[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a#9W=__>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a#\\\x91\x90a)YV[_UPPV[`@Q\x80`\xC0\x01`@R\x80a#ua#\xB5V[\x81R` \x01a#\x82a#\xB5V[\x81R` \x01a#\x8Fa#\xB5V[\x81R` \x01a#\x9Ca#\xB5V[\x81R` \x01a#\xA9a#\xB5V[\x81R` \x01_\x81RP\x90V[`@Q\x80a\x02\0\x01`@R\x80`\x10\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[_` \x82\x84\x03\x12\x15a#\xE4W__\xFD[P5\x91\x90PV[__\x83`\x1F\x84\x01\x12a#\xFBW__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$\x12W__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a$)W__\xFD[\x92P\x92\x90PV[_______`\xA0\x88\x8A\x03\x12\x15a$FW__\xFD[\x875\x96P` \x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$cW__\xFD[a$o\x8A\x82\x8B\x01a#\xEBV[\x90\x97P\x95PP`@\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$\x8EW__\xFD[a$\x9A\x8A\x82\x8B\x01a#\xEBV[\x98\x9B\x97\x9AP\x95\x98\x95\x97\x96``\x87\x015\x96`\x80\x015\x95P\x93PPPPV[___`@\x84\x86\x03\x12\x15a$\xC9W__\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$\xDFW__\xFD[a$\xEB\x86\x82\x87\x01a#\xEBV[\x90\x97\x90\x96P` \x95\x90\x95\x015\x94\x93PPPPV[____``\x85\x87\x03\x12\x15a%\x12W__\xFD[\x845\x93P` \x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a%/W__\xFD[a%;\x87\x82\x88\x01a#\xEBV[\x95\x98\x90\x97P\x94\x95`@\x015\x94\x93PPPPV[___``\x84\x86\x03\x12\x15a%`W__\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[______`\x80\x87\x89\x03\x12\x15a%\x8CW__\xFD[\x865\x95P` \x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a%\xA9W__\xFD[a%\xB5\x89\x82\x8A\x01a#\xEBV[\x90\x96P\x94PP`@\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a%\xD4W__\xFD[a%\xE0\x89\x82\x8A\x01a#\xEBV[\x97\x9A\x96\x99P\x94\x97\x94\x96\x95``\x90\x95\x015\x94\x93PPPPV[\x805c\xFF\xFF\xFF\xFF\x81\x16\x81\x14a!\xB3W__\xFD[______`\xA0\x87\x89\x03\x12\x15a& W__\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015\x93Pa&>``\x88\x01a%\xF8V[\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a&YW__\xFD[a&e\x89\x82\x8A\x01a#\xEBV[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[\x805`\x01`\x01``\x1B\x03\x19\x81\x16\x81\x14a!\xB3W__\xFD[_____`\x80\x86\x88\x03\x12\x15a&\xA2W__\xFD[\x855\x94P` \x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a&\xBFW__\xFD[a&\xCB\x88\x82\x89\x01a#\xEBV[\x90\x95P\x93PP`@\x86\x015\x91Pa&\xE4``\x87\x01a&wV[\x90P\x92\x95P\x92\x95\x90\x93PV[\x805`\xFF\x81\x16\x81\x14a!\xB3W__\xFD[_____`\xA0\x86\x88\x03\x12\x15a'\x14W__\xFD[\x855\x94P` \x86\x015\x93Pa'+`@\x87\x01a%\xF8V[\x92Pa'9``\x87\x01a&\xF0V[\x94\x97\x93\x96P\x91\x94`\x80\x015\x92\x91PPV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[______`\xC0\x87\x89\x03\x12\x15a'\x94W__\xFD[\x865\x95P` \x87\x015\x94Pa'\xAB`@\x88\x01a%\xF8V[\x93Pa'\xB9``\x88\x01a&wV[\x95\x98\x94\x97P\x92\x95`\x80\x81\x015\x94`\xA0\x90\x91\x015\x93P\x91PPV[__`@\x83\x85\x03\x12\x15a'\xE4W__\xFD[a'\xED\x83a&\xF0V[\x94` \x93\x90\x93\x015\x93PPPV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_\x82a(\x1DWa(\x1Da'\xFBV[P\x06\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[_\x82a(DWa(Da'\xFBV[P\x04\x90V[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x04\x9CWa\x04\x9Ca(\"V[\x80\x82\x01\x80\x82\x11\x15a\x04\x9CWa\x04\x9Ca(\"V[\x87\x81R\x86` \x82\x01R\x85`@\x82\x01R\x84``\x82\x01Rc\xFF\xFF\xFF\xFF\x84\x16`\x80\x82\x01R`\xC0`\xA0\x82\x01R\x81`\xC0\x82\x01R\x81\x83`\xE0\x83\x017_\x81\x83\x01`\xE0\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x96\x95PPPPPPV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x04\x9CWa\x04\x9Ca(\"V[c\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x04\x9CWa\x04\x9Ca(\"V[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[\x85\x81R\x84` \x82\x01R\x83`@\x82\x01R\x82``\x82\x01R_a\x0B\xE9`\x80\x83\x01\x84a)\rV[_a)R\x82\x84a)\rV[\x93\x92PPPV[_` \x82\x84\x03\x12\x15a)iW__\xFD[PQ\x91\x90PV\xFE\xA1dsolcC\0\x08\x1B\0\n\x08\xA6{Ar\x1Em\x18\xEBZ?\rGSP7\xE7UH\xF5o\xF9\x17p\xD8P\xAE\xC7\xBF#\xEFJJustin Sun is responsible for setting back the inevitable global stablecoin revolution by years through exploiting Tron USDT's network effects and imposing vendor lock-in on hundreds of millions of people in the Third World, who rely on stablecoins for remittances and to store their savings in unstable, overregulated economies. Let's Untron the People.\x19\xECj\xD7E-tC\x82\xE0\xF5\x90d\x01}\xCAV\xD2\xB3\xB9\xA4 &\xC6\x80:\xFCZ\x14\\\xD1\x11\xA9\xFEp\x1BM\xA2\xFFg\\\xFD\r\xC5A\xFB7:F\xA7,\\%\x8A\x99\xFE\x85\x08R\xDCu\xD3\xA1\xCB",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b50600436106101bb575f3560e01c8063810b38fa116100f3578063bf14763511610093578063c813bf7e1161006e578063c813bf7e14610417578063c8be60a214610459578063ca6a66a21461046c578063eccddc321461047f575f5ffd5b8063bf147635146103a5578063c49d3258146103c5578063c57312b3146103d8575f5ffd5b8063a664336d116100ce578063a664336d14610344578063a867cec314610357578063ba4213221461037f578063bae88e2e14610392575f5ffd5b8063810b38fa1461030b57806381e1d4fa1461031e5780639257d6a614610331575f5ffd5b806339adfeff1161015e57806347e26f1a1161013957806347e26f1a146102a15780634d53e931146102c957806356dd9c10146102d1578063779982cc146102f8575f5ffd5b806339adfeff146102685780633c4f102b1461027b578063415efc971461028e575f5ffd5b806324fb3d1a1161019957806324fb3d1a14610218578063257dba8614610239578063295b3d611461024c57806336429b231461025f575f5ffd5b806312d713c2146101bf578063175767dc146101f057806322690a4914610205575b5f5ffd5b6101d26101cd3660046123d4565b610492565b6040516001600160601b031990911681526020015b60405180910390f35b6102036101fe366004612430565b6104a2565b005b6101d26102133660046124b7565b61063b565b61022b6102263660046124b7565b610683565b6040519081526020016101e7565b61022b6102473660046124ff565b6106c9565b61022b61025a3660046123d4565b610755565b61022b60015481565b6101d26102763660046123d4565b610794565b61022b61028936600461254e565b61079e565b61022b61029c366004612577565b6107ee565b6102b46102af3660046123d4565b6108cb565b60405163ffffffff90911681526020016101e7565b61022b5f5481565b61022b7f000000000000000000000000000000000000000000000000000000000000000081565b61022b6103063660046124b7565b610910565b61020361031936600461260b565b610953565b61022b61032c3660046123d4565b610a2d565b6101d261033f3660046124ff565b610a59565b6101d26103523660046124b7565b610ab5565b61036a61036536600461268e565b610af1565b604080519283526020830191909152016101e7565b61022b61038d3660046123d4565b610b9a565b61022b6103a0366004612700565b610bb7565b6103b86103b3366004612700565b610bf4565b6040516101e7919061274a565b61036a6103d336600461277f565b610c35565b6103ff7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016101e7565b61042a6104253660046124b7565b610ca9565b6040516101e79493929190938452602084019290925263ffffffff16604083015260ff16606082015260800190565b61036a6104673660046124ff565b610cc9565b61022b61047a3660046124ff565b610d75565b6101d261048d3660046127d3565b610e21565b5f61049c82610e54565b92915050565b848015806104b957506104b660458261280f565b15155b156104d7576040516319d1d62d60e21b815260040160405180910390fd5b5f6104e3604583612836565b905061ffff8111156105105760405163e082840b60e01b8152600481018290526024015b60405180910390fd5b61051b604182612849565b851461053a57604051633fc186d360e01b815260040160405180910390fd5b61056f6040518060a001604052805f81526020015f81526020015f81526020015f151581526020015f63ffffffff1681525090565b89815261057c8a60c01c90565b6020820181905261058d908b611365565b15801560608301526105c9575f1985146105c4576040516312a4724760e01b81526004810186905260248101839052604401610507565b6105f3565b8185106105f3576040516312a4724760e01b81526004810186905260248101839052604401610507565b6105fd84836113ac565b61060d818a8a8a8a878b8b611472565b806060015161062f57604051639e25652d60e01b815260040160405180910390fd5b50505050505050505050565b5f80805b83811015610677575f610653878784611753565b93505050505f6106658260ff16610e54565b60601c9390931892505060010161063f565b5060601b949350505050565b5f805b828110156106c1575f5f5f61069c888886611753565b60ff1663ffffffff909116979092189690961818945050600190920191506106869050565b509392505050565b6040805160a0810182525f60208201819052918101829052606081018290526080810182905285815260c086901c602082015260408051608080825260a082019092525f916020820181803683370190505090505f5b8481101561074a575f5f610736858a8a868861178a565b60ff1696189590951894505060010161071f565b505050949350505050565b5f8181526002602052604081205480610781576040516335ae903b60e01b815260040160405180910390fd5b50505f9081526003602052604090205490565b5f61049c8261182b565b5f5f6107aa8560c01c90565b90505f5b838110156107e5575f6107c18284612860565b6107cc906001612860565b90506107d88187611d3c565b90931892506001016107ae565b50509392505050565b6040805160a0810182525f60208201819052918101829052606081018290526080810182905287815260c088901c602082015260408051608080825260a082019092525f916020820181803683370190505090505f5b848110156108be575f5f61085b858c8c868861178a565b915091505f61086d838b8b8789611d5f565b90505f61087c8360ff16610e54565b90506001600160601b0319828116908216146108ab57604051634012d81f60e11b815260040160405180910390fd5b5060601c95909518945050600101610844565b5050509695505050505050565b5f81815260026020526040812054806108f7576040516335ae903b60e01b815260040160405180910390fd5b50505f9081526004602052604090205463ffffffff1690565b5f805b828110156106c1575f5f5f5f61092a898987611753565b60ff1663ffffffff90911698909218189690961895909518945050600190920191506109139050565b6001548614610975576040516330bfef3b60e21b815260040160405180910390fd5b604051634d19d99b60e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690634d19d99b906109ed907f0000000000000000000000000000000000000000000000000000000000000000908a908a908a908a908a908a90600401612873565b5f604051808303815f87803b158015610a04575f5ffd5b505af1158015610a16573d5f5f3e3d5ffd5b50505050610a25858585611e32565b505050505050565b5f818152600260205260408120548061049c576040516335ae903b60e01b815260040160405180910390fd5b60408051608080825260a082019092525f918291906020820181803683370190505090505f805b84811015610aa7575f610a968989898588611d5f565b60601c929092189150600101610a80565b5060601b9695505050505050565b5f80805b83811015610677575f610acd878784611753565b93505050505f610adf8260ff1661182b565b60601c93909318925050600101610ab9565b5f5f5f610afe8860c01c90565b60408051608080825260a082019092529192505f91906020820181803683370190505090505f5b86811015610b8d575f5f5f610b3b8c8c86611753565b50919450925090505f610b4e8588612860565b610b59906001612860565b90505f610b6a878686868f87611ead565b9050610b76818b612860565b99509790971896505060019092019150610b259050565b5050509550959350505050565b5f805b82811015610bb15790810190600101610b9d565b50919050565b60408051608080825260a082019092525f91829190602082018180368337019050509050610be9878787878786611f9a565b979650505050505050565b60408051608080825260a082019092526060915f91906020820181803683370190505090505f610c28828989898989611fe9565b8252509695505050505050565b60408051608080825260a082019092525f91829182916020820181803683370190505090505f5b84811015610c9c575f610c6f8288612860565b90505f610c80848d8d8d8d87611ead565b9050610c8c8187612860565b9550939093189250600101610c5c565b5050965096945050505050565b5f5f5f5f610cb8878787611753565b929a91995097509095509350505050565b5f5f5f610cd68760c01c90565b60408051608080825260a082019092529192505f91906020820181803683370190505090505f5b85811015610d69575f5f5f5f610d148c8c87611753565b93509350935093505f8588610d299190612860565b610d34906001612860565b90505f610d45888787878787611fe9565b9050610d51818c612860565b9a509890981897505060019093019250610cfd915050565b50505094509492505050565b5f5f610d818660c01c90565b60408051608080825260a082019092529192505f91906020820181803683370190505090505f5b8481101561074a575f5f5f5f610dbf8b8b87611753565b93509350935093505f8588610dd49190612860565b610ddf906001612860565b90505f610df0888787878787611fe9565b90505f60205f8360208c0160025afa610e07575f5ffd5b50505f519890981897505060019093019250610da8915050565b5f80805b83811015610e4957610e398560ff1661182b565b60601c9190911890600101610e25565b5060601b9392505050565b5f815f03610e8357507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600103610eb257507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600203610ee157507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600303610f1057507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600403610f3f57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600503610f6e57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600603610f9d57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600703610fcc57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600803610ffb57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160090361102a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600a0361105957507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600b0361108857507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600c036110b757507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600d036110e657507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600e0361111557507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600f0361114457507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160100361117357507f0000000000000000000000000000000000000000000000000000000000000000919050565b816011036111a257507f0000000000000000000000000000000000000000000000000000000000000000919050565b816012036111d157507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160130361120057507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160140361122f57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160150361125e57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160160361128d57507f0000000000000000000000000000000000000000000000000000000000000000919050565b816017036112bc57507f0000000000000000000000000000000000000000000000000000000000000000919050565b816018036112eb57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160190361131a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601a0361134957507f0000000000000000000000000000000000000000000000000000000000000000919050565b60405163f0b1444b60e01b815260048101839052602401610507565b5f8281526002602052604081205480156113a3578281146113995760405163057f3fa760e51b815260040160405180910390fd5b600191505061049c565b505f9392505050565b5f8080805b6010811015610a25575f6113c587836120e6565b905061fffe1981016113db57600192505061146a565b821561140457604051637db4d41760e11b81526004810182905260248101879052604401610507565b85811061142e57604051637db4d41760e11b81526004810182905260248101879052604401610507565b83801561143b5750848111155b1561146357604051638f16148f60e01b81526004810186905260248101829052604401610507565b9350600192505b6001016113b1565b60408051608080825260a082019092525f9160208201818036833701905050905061149b612362565b825f5b86811015611661575f5f5f6114b68f8f8f878b61178a565b915091505f6114c8838e8e888c611d5f565b90506114d68260ff16610e54565b6001600160601b031982811691161461150257604051634012d81f60e11b815260040160405180910390fd5b600160ff83161b93505f5b8760a0015181101561154a578488608001518260108110611530576115306128ca565b6020020180519190911763ffffffff16905260010161150d565b505050506115598d8389612101565b61ffff83811614801590611570575061ffff831682145b1561165857835160a085015161ffff851691829160108110611594576115946128ca565b61ffff909216602092830291909101528e519086015160a0870151601081106115bf576115bf6128ca565b60200201526040808f01519086015160a0870151601081106115e3576115e36128ca565b602002015260808e0151606086015160a087015160108110611607576116076128ca565b63ffffffff9092166020929092020152608085015160a086015183919060108110611634576116346128ca565b63ffffffff90921660209290920201525060a084018051600101905260109290921c915b5060010161149e565b505f5b8260a00151811015611745575f6116948460800151836010811061168a5761168a6128ca565b602002015161218e565b9050601360ff821610156116e357835182601081106116b5576116b56128ca565b602002015160405163595e108960e01b815261ffff909116600482015260ff82166024820152604401610507565b61173c846020015183601081106116fc576116fc6128ca565b602002015185604001518460108110611717576117176128ca565b602002015186606001518560108110611732576117326128ca565b6020020151611e32565b50600101611664565b505050505050505050505050565b5f80808080611763604587612849565b979097018035986020820135985060409091013560e081901c975060041a95509350505050565b5f5f5f5f5f5f61179b8a8a8a611753565b93509350935093508094508a5f015184146117d6578a516040516364ef389160e11b8152610507918691600401918252602082015260400190565b60208b018051600101908190526117f59085908590859085908c611f9a565b95506118058b6020015187611d3c565b8b525060408a019190915263ffffffff1660809098019790975290969095509350505050565b5f815f0361185a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160010361188957507f0000000000000000000000000000000000000000000000000000000000000000919050565b816002036118b857507f0000000000000000000000000000000000000000000000000000000000000000919050565b816003036118e757507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160040361191657507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160050361194557507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160060361197457507f0000000000000000000000000000000000000000000000000000000000000000919050565b816007036119a357507f0000000000000000000000000000000000000000000000000000000000000000919050565b816008036119d257507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600903611a0157507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600a03611a3057507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600b03611a5f57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600c03611a8e57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600d03611abd57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600e03611aec57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600f03611b1b57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601003611b4a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601103611b7957507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601203611ba857507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601303611bd757507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601403611c0657507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601503611c3557507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601603611c6457507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601703611c9357507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601803611cc257507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601903611cf157507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601a03611d2057507f0000000000000000000000000000000000000000000000000000000000000000919050565b6040516363cb5a4160e01b815260048101839052602401610507565b5f80611d4d6001600160c01b6128de565b60c085901b9084161791505092915050565b5f60418302850180359060208101359060400135831a601b811015611d8257601b015b8060ff16601b14158015611d9a57508060ff16601c14155b15611db857604051634012d81f60e11b815260040160405180910390fd5b5f5f602087018b81528360208201528560408201528460608201526020816080836001612710fa92506001600160a01b03815116915050811580611e0357506001600160a01b038116155b15611e2157604051634012d81f60e11b815260040160405180910390fd5b60601b9a9950505050505050505050565b5f611e3d8460c01c90565b5f8181526002602090815260408083208890556003825280832087905560049091529020805463ffffffff191663ffffffff85161790559050611e82818585856121b8565b60015481611e908260c01c90565b1015611ea6576001859055611ea6818684612262565b5050505050565b5f80611ec163ffffffff86166103e8612849565b9050606084901c602089018060088153600101835b607f811115611ef7576080607f82161782536001919091019060071c611ed6565b607f8116825350600101601281536001016020815360018101899052602101601a815360010160208153600181018a905260210160388153600101855b607f811115611f55576080607f82161782536001919091019060071c611f34565b607f8116825350600101604a81536001016015815360010160418153606083901b60018201526015016050815360010160208153036001019998505050505050505050565b5f5f611faa838989898989611fe9565b90505f60205f836020870160025afa90505f51925080611fdd57604051636eae559f60e11b815260040160405180910390fd5b50509695505050505050565b5f80611ffd63ffffffff86166103e8612849565b90505f61200c8560ff1661182b565b9050606081901c60208a018060088153600101845b607f811115612042576080607f82161782536001919091019060071c612021565b607f81168253506001016012815360010160208153600181018a9052602101601a815360010160208153600181018b905260210160388153600101865b607f8111156120a0576080607f82161782536001919091019060071c61207f565b607f8116825350600101604a81536001016015815360010160418153606083901b60018201526015016050815360010160208153036001019a9950505050505050505050565b5f61ffff6120f5836010612849565b84901c16905092915050565b8260600151806121115750808214155b1561211b57505050565b6020808401515f908152600290915260409020548061215d576020840151845160405163956d18e960e01b815260048101929092526024820152604401610507565b8351811461217e5760405163057f3fa760e51b815260040160405180910390fd5b5050600160609092019190915250565b5f5b63ffffffff8216156121b3576121a76001836128f1565b90911690600101612190565b919050565b60408051602081018690529081018490526060810183905263ffffffff8216608082015261221a907f19ec6ad7452d744382e0f59064017dca56d2b3b9a42026c6803afc5a145cd1119060a0015b6040516020818303038152906040526122e8565b6040805183815263ffffffff83166020820152849186917f19ec6ad7452d744382e0f59064017dca56d2b3b9a42026c6803afc5a145cd111910160405180910390a350505050565b6040805160208101859052908101839052606081018290526122a8907fa9fe701b4da2ff675cfd0dc541fb373a46a72c5c258a99fe850852dc75d3a1cb90608001612206565b81837fa9fe701b4da2ff675cfd0dc541fb373a46a72c5c258a99fe850852dc75d3a1cb836040516122db91815260200190565b60405180910390a3505050565b60025f5443428585604051602001612304959493929190612924565b60408051601f198184030181529082905261231e91612947565b602060405180830381855afa158015612339573d5f5f3e3d5ffd5b5050506040513d601f19601f8201168201806040525081019061235c9190612959565b5f555050565b6040518060c001604052806123756123b5565b81526020016123826123b5565b815260200161238f6123b5565b815260200161239c6123b5565b81526020016123a96123b5565b81526020015f81525090565b6040518061020001604052806010906020820280368337509192915050565b5f602082840312156123e4575f5ffd5b5035919050565b5f5f83601f8401126123fb575f5ffd5b50813567ffffffffffffffff811115612412575f5ffd5b602083019150836020828501011115612429575f5ffd5b9250929050565b5f5f5f5f5f5f5f60a0888a031215612446575f5ffd5b87359650602088013567ffffffffffffffff811115612463575f5ffd5b61246f8a828b016123eb565b909750955050604088013567ffffffffffffffff81111561248e575f5ffd5b61249a8a828b016123eb565b989b979a5095989597966060870135966080013595509350505050565b5f5f5f604084860312156124c9575f5ffd5b833567ffffffffffffffff8111156124df575f5ffd5b6124eb868287016123eb565b909790965060209590950135949350505050565b5f5f5f5f60608587031215612512575f5ffd5b84359350602085013567ffffffffffffffff81111561252f575f5ffd5b61253b878288016123eb565b9598909750949560400135949350505050565b5f5f5f60608486031215612560575f5ffd5b505081359360208301359350604090920135919050565b5f5f5f5f5f5f6080878903121561258c575f5ffd5b86359550602087013567ffffffffffffffff8111156125a9575f5ffd5b6125b589828a016123eb565b909650945050604087013567ffffffffffffffff8111156125d4575f5ffd5b6125e089828a016123eb565b979a9699509497949695606090950135949350505050565b803563ffffffff811681146121b3575f5ffd5b5f5f5f5f5f5f60a08789031215612620575f5ffd5b86359550602087013594506040870135935061263e606088016125f8565b9250608087013567ffffffffffffffff811115612659575f5ffd5b61266589828a016123eb565b979a9699509497509295939492505050565b80356001600160601b0319811681146121b3575f5ffd5b5f5f5f5f5f608086880312156126a2575f5ffd5b85359450602086013567ffffffffffffffff8111156126bf575f5ffd5b6126cb888289016123eb565b909550935050604086013591506126e460608701612677565b90509295509295909350565b803560ff811681146121b3575f5ffd5b5f5f5f5f5f60a08688031215612714575f5ffd5b853594506020860135935061272b604087016125f8565b9250612739606087016126f0565b949793965091946080013592915050565b602081525f82518060208401528060208501604085015e5f604082850101526040601f19601f83011684010191505092915050565b5f5f5f5f5f5f60c08789031215612794575f5ffd5b86359550602087013594506127ab604088016125f8565b93506127b960608801612677565b9598949750929560808101359460a0909101359350915050565b5f5f604083850312156127e4575f5ffd5b6127ed836126f0565b946020939093013593505050565b634e487b7160e01b5f52601260045260245ffd5b5f8261281d5761281d6127fb565b500690565b634e487b7160e01b5f52601160045260245ffd5b5f82612844576128446127fb565b500490565b808202811582820484141761049c5761049c612822565b8082018082111561049c5761049c612822565b87815286602082015285604082015284606082015263ffffffff8416608082015260c060a08201528160c0820152818360e08301375f81830160e090810191909152601f909201601f191601019695505050505050565b634e487b7160e01b5f52603260045260245ffd5b8181038181111561049c5761049c612822565b63ffffffff828116828216039081111561049c5761049c612822565b5f81518060208401855e5f93019283525090919050565b8581528460208201528360408201528260608201525f610be9608083018461290d565b5f612952828461290d565b9392505050565b5f60208284031215612969575f5ffd5b505191905056fea164736f6c634300081b000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\x01\xBBW_5`\xE0\x1C\x80c\x81\x0B8\xFA\x11a\0\xF3W\x80c\xBF\x14v5\x11a\0\x93W\x80c\xC8\x13\xBF~\x11a\0nW\x80c\xC8\x13\xBF~\x14a\x04\x17W\x80c\xC8\xBE`\xA2\x14a\x04YW\x80c\xCAjf\xA2\x14a\x04lW\x80c\xEC\xCD\xDC2\x14a\x04\x7FW__\xFD[\x80c\xBF\x14v5\x14a\x03\xA5W\x80c\xC4\x9D2X\x14a\x03\xC5W\x80c\xC5s\x12\xB3\x14a\x03\xD8W__\xFD[\x80c\xA6d3m\x11a\0\xCEW\x80c\xA6d3m\x14a\x03DW\x80c\xA8g\xCE\xC3\x14a\x03WW\x80c\xBAB\x13\"\x14a\x03\x7FW\x80c\xBA\xE8\x8E.\x14a\x03\x92W__\xFD[\x80c\x81\x0B8\xFA\x14a\x03\x0BW\x80c\x81\xE1\xD4\xFA\x14a\x03\x1EW\x80c\x92W\xD6\xA6\x14a\x031W__\xFD[\x80c9\xAD\xFE\xFF\x11a\x01^W\x80cG\xE2o\x1A\x11a\x019W\x80cG\xE2o\x1A\x14a\x02\xA1W\x80cMS\xE91\x14a\x02\xC9W\x80cV\xDD\x9C\x10\x14a\x02\xD1W\x80cw\x99\x82\xCC\x14a\x02\xF8W__\xFD[\x80c9\xAD\xFE\xFF\x14a\x02hW\x80c<O\x10+\x14a\x02{W\x80cA^\xFC\x97\x14a\x02\x8EW__\xFD[\x80c$\xFB=\x1A\x11a\x01\x99W\x80c$\xFB=\x1A\x14a\x02\x18W\x80c%}\xBA\x86\x14a\x029W\x80c)[=a\x14a\x02LW\x80c6B\x9B#\x14a\x02_W__\xFD[\x80c\x12\xD7\x13\xC2\x14a\x01\xBFW\x80c\x17Wg\xDC\x14a\x01\xF0W\x80c\"i\nI\x14a\x02\x05W[__\xFD[a\x01\xD2a\x01\xCD6`\x04a#\xD4V[a\x04\x92V[`@Q`\x01`\x01``\x1B\x03\x19\x90\x91\x16\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\x02\x03a\x01\xFE6`\x04a$0V[a\x04\xA2V[\0[a\x01\xD2a\x02\x136`\x04a$\xB7V[a\x06;V[a\x02+a\x02&6`\x04a$\xB7V[a\x06\x83V[`@Q\x90\x81R` \x01a\x01\xE7V[a\x02+a\x02G6`\x04a$\xFFV[a\x06\xC9V[a\x02+a\x02Z6`\x04a#\xD4V[a\x07UV[a\x02+`\x01T\x81V[a\x01\xD2a\x02v6`\x04a#\xD4V[a\x07\x94V[a\x02+a\x02\x896`\x04a%NV[a\x07\x9EV[a\x02+a\x02\x9C6`\x04a%wV[a\x07\xEEV[a\x02\xB4a\x02\xAF6`\x04a#\xD4V[a\x08\xCBV[`@Qc\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\x01\xE7V[a\x02+_T\x81V[a\x02+\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x02+a\x03\x066`\x04a$\xB7V[a\t\x10V[a\x02\x03a\x03\x196`\x04a&\x0BV[a\tSV[a\x02+a\x03,6`\x04a#\xD4V[a\n-V[a\x01\xD2a\x03?6`\x04a$\xFFV[a\nYV[a\x01\xD2a\x03R6`\x04a$\xB7V[a\n\xB5V[a\x03ja\x03e6`\x04a&\x8EV[a\n\xF1V[`@\x80Q\x92\x83R` \x83\x01\x91\x90\x91R\x01a\x01\xE7V[a\x02+a\x03\x8D6`\x04a#\xD4V[a\x0B\x9AV[a\x02+a\x03\xA06`\x04a'\0V[a\x0B\xB7V[a\x03\xB8a\x03\xB36`\x04a'\0V[a\x0B\xF4V[`@Qa\x01\xE7\x91\x90a'JV[a\x03ja\x03\xD36`\x04a'\x7FV[a\x0C5V[a\x03\xFF\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\x01\xE7V[a\x04*a\x04%6`\x04a$\xB7V[a\x0C\xA9V[`@Qa\x01\xE7\x94\x93\x92\x91\x90\x93\x84R` \x84\x01\x92\x90\x92Rc\xFF\xFF\xFF\xFF\x16`@\x83\x01R`\xFF\x16``\x82\x01R`\x80\x01\x90V[a\x03ja\x04g6`\x04a$\xFFV[a\x0C\xC9V[a\x02+a\x04z6`\x04a$\xFFV[a\ruV[a\x01\xD2a\x04\x8D6`\x04a'\xD3V[a\x0E!V[_a\x04\x9C\x82a\x0ETV[\x92\x91PPV[\x84\x80\x15\x80a\x04\xB9WPa\x04\xB6`E\x82a(\x0FV[\x15\x15[\x15a\x04\xD7W`@Qc\x19\xD1\xD6-`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x04\xE3`E\x83a(6V[\x90Pa\xFF\xFF\x81\x11\x15a\x05\x10W`@Qc\xE0\x82\x84\x0B`\xE0\x1B\x81R`\x04\x81\x01\x82\x90R`$\x01[`@Q\x80\x91\x03\x90\xFD[a\x05\x1B`A\x82a(IV[\x85\x14a\x05:W`@Qc?\xC1\x86\xD3`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x05o`@Q\x80`\xA0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x15\x15\x81R` \x01_c\xFF\xFF\xFF\xFF\x16\x81RP\x90V[\x89\x81Ra\x05|\x8A`\xC0\x1C\x90V[` \x82\x01\x81\x90Ra\x05\x8D\x90\x8Ba\x13eV[\x15\x80\x15``\x83\x01Ra\x05\xC9W_\x19\x85\x14a\x05\xC4W`@Qc\x12\xA4rG`\xE0\x1B\x81R`\x04\x81\x01\x86\x90R`$\x81\x01\x83\x90R`D\x01a\x05\x07V[a\x05\xF3V[\x81\x85\x10a\x05\xF3W`@Qc\x12\xA4rG`\xE0\x1B\x81R`\x04\x81\x01\x86\x90R`$\x81\x01\x83\x90R`D\x01a\x05\x07V[a\x05\xFD\x84\x83a\x13\xACV[a\x06\r\x81\x8A\x8A\x8A\x8A\x87\x8B\x8Ba\x14rV[\x80``\x01Qa\x06/W`@Qc\x9E%e-`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPPPPPPPPPV[_\x80\x80[\x83\x81\x10\x15a\x06wW_a\x06S\x87\x87\x84a\x17SV[\x93PPPP_a\x06e\x82`\xFF\x16a\x0ETV[``\x1C\x93\x90\x93\x18\x92PP`\x01\x01a\x06?V[P``\x1B\x94\x93PPPPV[_\x80[\x82\x81\x10\x15a\x06\xC1W___a\x06\x9C\x88\x88\x86a\x17SV[`\xFF\x16c\xFF\xFF\xFF\xFF\x90\x91\x16\x97\x90\x92\x18\x96\x90\x96\x18\x18\x94PP`\x01\x90\x92\x01\x91Pa\x06\x86\x90PV[P\x93\x92PPPV[`@\x80Q`\xA0\x81\x01\x82R_` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R\x85\x81R`\xC0\x86\x90\x1C` \x82\x01R`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R_\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90P_[\x84\x81\x10\x15a\x07JW__a\x076\x85\x8A\x8A\x86\x88a\x17\x8AV[`\xFF\x16\x96\x18\x95\x90\x95\x18\x94PP`\x01\x01a\x07\x1FV[PPP\x94\x93PPPPV[_\x81\x81R`\x02` R`@\x81 T\x80a\x07\x81W`@Qc5\xAE\x90;`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP_\x90\x81R`\x03` R`@\x90 T\x90V[_a\x04\x9C\x82a\x18+V[__a\x07\xAA\x85`\xC0\x1C\x90V[\x90P_[\x83\x81\x10\x15a\x07\xE5W_a\x07\xC1\x82\x84a(`V[a\x07\xCC\x90`\x01a(`V[\x90Pa\x07\xD8\x81\x87a\x1D<V[\x90\x93\x18\x92P`\x01\x01a\x07\xAEV[PP\x93\x92PPPV[`@\x80Q`\xA0\x81\x01\x82R_` \x82\x01\x81\x90R\x91\x81\x01\x82\x90R``\x81\x01\x82\x90R`\x80\x81\x01\x82\x90R\x87\x81R`\xC0\x88\x90\x1C` \x82\x01R`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R_\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90P_[\x84\x81\x10\x15a\x08\xBEW__a\x08[\x85\x8C\x8C\x86\x88a\x17\x8AV[\x91P\x91P_a\x08m\x83\x8B\x8B\x87\x89a\x1D_V[\x90P_a\x08|\x83`\xFF\x16a\x0ETV[\x90P`\x01`\x01``\x1B\x03\x19\x82\x81\x16\x90\x82\x16\x14a\x08\xABW`@Qc@\x12\xD8\x1F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[P``\x1C\x95\x90\x95\x18\x94PP`\x01\x01a\x08DV[PPP\x96\x95PPPPPPV[_\x81\x81R`\x02` R`@\x81 T\x80a\x08\xF7W`@Qc5\xAE\x90;`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP_\x90\x81R`\x04` R`@\x90 Tc\xFF\xFF\xFF\xFF\x16\x90V[_\x80[\x82\x81\x10\x15a\x06\xC1W____a\t*\x89\x89\x87a\x17SV[`\xFF\x16c\xFF\xFF\xFF\xFF\x90\x91\x16\x98\x90\x92\x18\x18\x96\x90\x96\x18\x95\x90\x95\x18\x94PP`\x01\x90\x92\x01\x91Pa\t\x13\x90PV[`\x01T\x86\x14a\tuW`@Qc0\xBF\xEF;`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@QcM\x19\xD9\x9B`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90cM\x19\xD9\x9B\x90a\t\xED\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x8A\x90\x8A\x90\x8A\x90\x8A\x90\x8A\x90\x8A\x90`\x04\x01a(sV[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\n\x04W__\xFD[PZ\xF1\x15\x80\x15a\n\x16W=__>=_\xFD[PPPPa\n%\x85\x85\x85a\x1E2V[PPPPPPV[_\x81\x81R`\x02` R`@\x81 T\x80a\x04\x9CW`@Qc5\xAE\x90;`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R_\x91\x82\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P_\x80[\x84\x81\x10\x15a\n\xA7W_a\n\x96\x89\x89\x89\x85\x88a\x1D_V[``\x1C\x92\x90\x92\x18\x91P`\x01\x01a\n\x80V[P``\x1B\x96\x95PPPPPPV[_\x80\x80[\x83\x81\x10\x15a\x06wW_a\n\xCD\x87\x87\x84a\x17SV[\x93PPPP_a\n\xDF\x82`\xFF\x16a\x18+V[``\x1C\x93\x90\x93\x18\x92PP`\x01\x01a\n\xB9V[___a\n\xFE\x88`\xC0\x1C\x90V[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R\x91\x92P_\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P_[\x86\x81\x10\x15a\x0B\x8DW___a\x0B;\x8C\x8C\x86a\x17SV[P\x91\x94P\x92P\x90P_a\x0BN\x85\x88a(`V[a\x0BY\x90`\x01a(`V[\x90P_a\x0Bj\x87\x86\x86\x86\x8F\x87a\x1E\xADV[\x90Pa\x0Bv\x81\x8Ba(`V[\x99P\x97\x90\x97\x18\x96PP`\x01\x90\x92\x01\x91Pa\x0B%\x90PV[PPP\x95P\x95\x93PPPPV[_\x80[\x82\x81\x10\x15a\x0B\xB1W\x90\x81\x01\x90`\x01\x01a\x0B\x9DV[P\x91\x90PV[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R_\x91\x82\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90Pa\x0B\xE9\x87\x87\x87\x87\x87\x86a\x1F\x9AV[\x97\x96PPPPPPPV[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R``\x91_\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P_a\x0C(\x82\x89\x89\x89\x89\x89a\x1F\xE9V[\x82RP\x96\x95PPPPPPV[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R_\x91\x82\x91\x82\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90P_[\x84\x81\x10\x15a\x0C\x9CW_a\x0Co\x82\x88a(`V[\x90P_a\x0C\x80\x84\x8D\x8D\x8D\x8D\x87a\x1E\xADV[\x90Pa\x0C\x8C\x81\x87a(`V[\x95P\x93\x90\x93\x18\x92P`\x01\x01a\x0C\\V[PP\x96P\x96\x94PPPPPV[____a\x0C\xB8\x87\x87\x87a\x17SV[\x92\x9A\x91\x99P\x97P\x90\x95P\x93PPPPV[___a\x0C\xD6\x87`\xC0\x1C\x90V[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R\x91\x92P_\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P_[\x85\x81\x10\x15a\riW____a\r\x14\x8C\x8C\x87a\x17SV[\x93P\x93P\x93P\x93P_\x85\x88a\r)\x91\x90a(`V[a\r4\x90`\x01a(`V[\x90P_a\rE\x88\x87\x87\x87\x87\x87a\x1F\xE9V[\x90Pa\rQ\x81\x8Ca(`V[\x9AP\x98\x90\x98\x18\x97PP`\x01\x90\x93\x01\x92Pa\x0C\xFD\x91PPV[PPP\x94P\x94\x92PPPV[__a\r\x81\x86`\xC0\x1C\x90V[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R\x91\x92P_\x91\x90` \x82\x01\x81\x806\x837\x01\x90PP\x90P_[\x84\x81\x10\x15a\x07JW____a\r\xBF\x8B\x8B\x87a\x17SV[\x93P\x93P\x93P\x93P_\x85\x88a\r\xD4\x91\x90a(`V[a\r\xDF\x90`\x01a(`V[\x90P_a\r\xF0\x88\x87\x87\x87\x87\x87a\x1F\xE9V[\x90P_` _\x83` \x8C\x01`\x02Z\xFAa\x0E\x07W__\xFD[PP_Q\x98\x90\x98\x18\x97PP`\x01\x90\x93\x01\x92Pa\r\xA8\x91PPV[_\x80\x80[\x83\x81\x10\x15a\x0EIWa\x0E9\x85`\xFF\x16a\x18+V[``\x1C\x91\x90\x91\x18\x90`\x01\x01a\x0E%V[P``\x1B\x93\x92PPPV[_\x81_\x03a\x0E\x83WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x01\x03a\x0E\xB2WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x02\x03a\x0E\xE1WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x03\x03a\x0F\x10WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x04\x03a\x0F?WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x05\x03a\x0FnWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x06\x03a\x0F\x9DWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x07\x03a\x0F\xCCWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x08\x03a\x0F\xFBWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\t\x03a\x10*WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\n\x03a\x10YWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0B\x03a\x10\x88WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0C\x03a\x10\xB7WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\r\x03a\x10\xE6WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0E\x03a\x11\x15WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0F\x03a\x11DWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x10\x03a\x11sWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x11\x03a\x11\xA2WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x12\x03a\x11\xD1WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x13\x03a\x12\0WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x14\x03a\x12/WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x15\x03a\x12^WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x16\x03a\x12\x8DWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x17\x03a\x12\xBCWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x18\x03a\x12\xEBWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x19\x03a\x13\x1AWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x1A\x03a\x13IWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[`@Qc\xF0\xB1DK`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x05\x07V[_\x82\x81R`\x02` R`@\x81 T\x80\x15a\x13\xA3W\x82\x81\x14a\x13\x99W`@Qc\x05\x7F?\xA7`\xE5\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01\x91PPa\x04\x9CV[P_\x93\x92PPPV[_\x80\x80\x80[`\x10\x81\x10\x15a\n%W_a\x13\xC5\x87\x83a \xE6V[\x90Pa\xFF\xFE\x19\x81\x01a\x13\xDBW`\x01\x92PPa\x14jV[\x82\x15a\x14\x04W`@Qc}\xB4\xD4\x17`\xE1\x1B\x81R`\x04\x81\x01\x82\x90R`$\x81\x01\x87\x90R`D\x01a\x05\x07V[\x85\x81\x10a\x14.W`@Qc}\xB4\xD4\x17`\xE1\x1B\x81R`\x04\x81\x01\x82\x90R`$\x81\x01\x87\x90R`D\x01a\x05\x07V[\x83\x80\x15a\x14;WP\x84\x81\x11\x15[\x15a\x14cW`@Qc\x8F\x16\x14\x8F`\xE0\x1B\x81R`\x04\x81\x01\x86\x90R`$\x81\x01\x82\x90R`D\x01a\x05\x07V[\x93P`\x01\x92P[`\x01\x01a\x13\xB1V[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R_\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90Pa\x14\x9Ba#bV[\x82_[\x86\x81\x10\x15a\x16aW___a\x14\xB6\x8F\x8F\x8F\x87\x8Ba\x17\x8AV[\x91P\x91P_a\x14\xC8\x83\x8E\x8E\x88\x8Ca\x1D_V[\x90Pa\x14\xD6\x82`\xFF\x16a\x0ETV[`\x01`\x01``\x1B\x03\x19\x82\x81\x16\x91\x16\x14a\x15\x02W`@Qc@\x12\xD8\x1F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\xFF\x83\x16\x1B\x93P_[\x87`\xA0\x01Q\x81\x10\x15a\x15JW\x84\x88`\x80\x01Q\x82`\x10\x81\x10a\x150Wa\x150a(\xCAV[` \x02\x01\x80Q\x91\x90\x91\x17c\xFF\xFF\xFF\xFF\x16\x90R`\x01\x01a\x15\rV[PPPPa\x15Y\x8D\x83\x89a!\x01V[a\xFF\xFF\x83\x81\x16\x14\x80\x15\x90a\x15pWPa\xFF\xFF\x83\x16\x82\x14[\x15a\x16XW\x83Q`\xA0\x85\x01Qa\xFF\xFF\x85\x16\x91\x82\x91`\x10\x81\x10a\x15\x94Wa\x15\x94a(\xCAV[a\xFF\xFF\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01R\x8EQ\x90\x86\x01Q`\xA0\x87\x01Q`\x10\x81\x10a\x15\xBFWa\x15\xBFa(\xCAV[` \x02\x01R`@\x80\x8F\x01Q\x90\x86\x01Q`\xA0\x87\x01Q`\x10\x81\x10a\x15\xE3Wa\x15\xE3a(\xCAV[` \x02\x01R`\x80\x8E\x01Q``\x86\x01Q`\xA0\x87\x01Q`\x10\x81\x10a\x16\x07Wa\x16\x07a(\xCAV[c\xFF\xFF\xFF\xFF\x90\x92\x16` \x92\x90\x92\x02\x01R`\x80\x85\x01Q`\xA0\x86\x01Q\x83\x91\x90`\x10\x81\x10a\x164Wa\x164a(\xCAV[c\xFF\xFF\xFF\xFF\x90\x92\x16` \x92\x90\x92\x02\x01RP`\xA0\x84\x01\x80Q`\x01\x01\x90R`\x10\x92\x90\x92\x1C\x91[P`\x01\x01a\x14\x9EV[P_[\x82`\xA0\x01Q\x81\x10\x15a\x17EW_a\x16\x94\x84`\x80\x01Q\x83`\x10\x81\x10a\x16\x8AWa\x16\x8Aa(\xCAV[` \x02\x01Qa!\x8EV[\x90P`\x13`\xFF\x82\x16\x10\x15a\x16\xE3W\x83Q\x82`\x10\x81\x10a\x16\xB5Wa\x16\xB5a(\xCAV[` \x02\x01Q`@QcY^\x10\x89`\xE0\x1B\x81Ra\xFF\xFF\x90\x91\x16`\x04\x82\x01R`\xFF\x82\x16`$\x82\x01R`D\x01a\x05\x07V[a\x17<\x84` \x01Q\x83`\x10\x81\x10a\x16\xFCWa\x16\xFCa(\xCAV[` \x02\x01Q\x85`@\x01Q\x84`\x10\x81\x10a\x17\x17Wa\x17\x17a(\xCAV[` \x02\x01Q\x86``\x01Q\x85`\x10\x81\x10a\x172Wa\x172a(\xCAV[` \x02\x01Qa\x1E2V[P`\x01\x01a\x16dV[PPPPPPPPPPPPV[_\x80\x80\x80\x80a\x17c`E\x87a(IV[\x97\x90\x97\x01\x805\x98` \x82\x015\x98P`@\x90\x91\x015`\xE0\x81\x90\x1C\x97P`\x04\x1A\x95P\x93PPPPV[______a\x17\x9B\x8A\x8A\x8Aa\x17SV[\x93P\x93P\x93P\x93P\x80\x94P\x8A_\x01Q\x84\x14a\x17\xD6W\x8AQ`@Qcd\xEF8\x91`\xE1\x1B\x81Ra\x05\x07\x91\x86\x91`\x04\x01\x91\x82R` \x82\x01R`@\x01\x90V[` \x8B\x01\x80Q`\x01\x01\x90\x81\x90Ra\x17\xF5\x90\x85\x90\x85\x90\x85\x90\x85\x90\x8Ca\x1F\x9AV[\x95Pa\x18\x05\x8B` \x01Q\x87a\x1D<V[\x8BRP`@\x8A\x01\x91\x90\x91Rc\xFF\xFF\xFF\xFF\x16`\x80\x90\x98\x01\x97\x90\x97R\x90\x96\x90\x95P\x93PPPPV[_\x81_\x03a\x18ZWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x01\x03a\x18\x89WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x02\x03a\x18\xB8WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x03\x03a\x18\xE7WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x04\x03a\x19\x16WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x05\x03a\x19EWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x06\x03a\x19tWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x07\x03a\x19\xA3WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x08\x03a\x19\xD2WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\t\x03a\x1A\x01WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\n\x03a\x1A0WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0B\x03a\x1A_WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0C\x03a\x1A\x8EWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\r\x03a\x1A\xBDWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0E\x03a\x1A\xECWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0F\x03a\x1B\x1BWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x10\x03a\x1BJWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x11\x03a\x1ByWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x12\x03a\x1B\xA8WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x13\x03a\x1B\xD7WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x14\x03a\x1C\x06WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x15\x03a\x1C5WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x16\x03a\x1CdWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x17\x03a\x1C\x93WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x18\x03a\x1C\xC2WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x19\x03a\x1C\xF1WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x1A\x03a\x1D WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[`@Qcc\xCBZA`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x05\x07V[_\x80a\x1DM`\x01`\x01`\xC0\x1Ba(\xDEV[`\xC0\x85\x90\x1B\x90\x84\x16\x17\x91PP\x92\x91PPV[_`A\x83\x02\x85\x01\x805\x90` \x81\x015\x90`@\x015\x83\x1A`\x1B\x81\x10\x15a\x1D\x82W`\x1B\x01[\x80`\xFF\x16`\x1B\x14\x15\x80\x15a\x1D\x9AWP\x80`\xFF\x16`\x1C\x14\x15[\x15a\x1D\xB8W`@Qc@\x12\xD8\x1F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[__` \x87\x01\x8B\x81R\x83` \x82\x01R\x85`@\x82\x01R\x84``\x82\x01R` \x81`\x80\x83`\x01a'\x10\xFA\x92P`\x01`\x01`\xA0\x1B\x03\x81Q\x16\x91PP\x81\x15\x80a\x1E\x03WP`\x01`\x01`\xA0\x1B\x03\x81\x16\x15[\x15a\x1E!W`@Qc@\x12\xD8\x1F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[``\x1B\x9A\x99PPPPPPPPPPV[_a\x1E=\x84`\xC0\x1C\x90V[_\x81\x81R`\x02` \x90\x81R`@\x80\x83 \x88\x90U`\x03\x82R\x80\x83 \x87\x90U`\x04\x90\x91R\x90 \x80Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x85\x16\x17\x90U\x90Pa\x1E\x82\x81\x85\x85\x85a!\xB8V[`\x01T\x81a\x1E\x90\x82`\xC0\x1C\x90V[\x10\x15a\x1E\xA6W`\x01\x85\x90Ua\x1E\xA6\x81\x86\x84a\"bV[PPPPPV[_\x80a\x1E\xC1c\xFF\xFF\xFF\xFF\x86\x16a\x03\xE8a(IV[\x90P``\x84\x90\x1C` \x89\x01\x80`\x08\x81S`\x01\x01\x83[`\x7F\x81\x11\x15a\x1E\xF7W`\x80`\x7F\x82\x16\x17\x82S`\x01\x91\x90\x91\x01\x90`\x07\x1Ca\x1E\xD6V[`\x7F\x81\x16\x82SP`\x01\x01`\x12\x81S`\x01\x01` \x81S`\x01\x81\x01\x89\x90R`!\x01`\x1A\x81S`\x01\x01` \x81S`\x01\x81\x01\x8A\x90R`!\x01`8\x81S`\x01\x01\x85[`\x7F\x81\x11\x15a\x1FUW`\x80`\x7F\x82\x16\x17\x82S`\x01\x91\x90\x91\x01\x90`\x07\x1Ca\x1F4V[`\x7F\x81\x16\x82SP`\x01\x01`J\x81S`\x01\x01`\x15\x81S`\x01\x01`A\x81S``\x83\x90\x1B`\x01\x82\x01R`\x15\x01`P\x81S`\x01\x01` \x81S\x03`\x01\x01\x99\x98PPPPPPPPPV[__a\x1F\xAA\x83\x89\x89\x89\x89\x89a\x1F\xE9V[\x90P_` _\x83` \x87\x01`\x02Z\xFA\x90P_Q\x92P\x80a\x1F\xDDW`@Qcn\xAEU\x9F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP\x96\x95PPPPPPV[_\x80a\x1F\xFDc\xFF\xFF\xFF\xFF\x86\x16a\x03\xE8a(IV[\x90P_a \x0C\x85`\xFF\x16a\x18+V[\x90P``\x81\x90\x1C` \x8A\x01\x80`\x08\x81S`\x01\x01\x84[`\x7F\x81\x11\x15a BW`\x80`\x7F\x82\x16\x17\x82S`\x01\x91\x90\x91\x01\x90`\x07\x1Ca !V[`\x7F\x81\x16\x82SP`\x01\x01`\x12\x81S`\x01\x01` \x81S`\x01\x81\x01\x8A\x90R`!\x01`\x1A\x81S`\x01\x01` \x81S`\x01\x81\x01\x8B\x90R`!\x01`8\x81S`\x01\x01\x86[`\x7F\x81\x11\x15a \xA0W`\x80`\x7F\x82\x16\x17\x82S`\x01\x91\x90\x91\x01\x90`\x07\x1Ca \x7FV[`\x7F\x81\x16\x82SP`\x01\x01`J\x81S`\x01\x01`\x15\x81S`\x01\x01`A\x81S``\x83\x90\x1B`\x01\x82\x01R`\x15\x01`P\x81S`\x01\x01` \x81S\x03`\x01\x01\x9A\x99PPPPPPPPPPV[_a\xFF\xFFa \xF5\x83`\x10a(IV[\x84\x90\x1C\x16\x90P\x92\x91PPV[\x82``\x01Q\x80a!\x11WP\x80\x82\x14\x15[\x15a!\x1BWPPPV[` \x80\x84\x01Q_\x90\x81R`\x02\x90\x91R`@\x90 T\x80a!]W` \x84\x01Q\x84Q`@Qc\x95m\x18\xE9`\xE0\x1B\x81R`\x04\x81\x01\x92\x90\x92R`$\x82\x01R`D\x01a\x05\x07V[\x83Q\x81\x14a!~W`@Qc\x05\x7F?\xA7`\xE5\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP`\x01``\x90\x92\x01\x91\x90\x91RPV[_[c\xFF\xFF\xFF\xFF\x82\x16\x15a!\xB3Wa!\xA7`\x01\x83a(\xF1V[\x90\x91\x16\x90`\x01\x01a!\x90V[\x91\x90PV[`@\x80Q` \x81\x01\x86\x90R\x90\x81\x01\x84\x90R``\x81\x01\x83\x90Rc\xFF\xFF\xFF\xFF\x82\x16`\x80\x82\x01Ra\"\x1A\x90\x7F\x19\xECj\xD7E-tC\x82\xE0\xF5\x90d\x01}\xCAV\xD2\xB3\xB9\xA4 &\xC6\x80:\xFCZ\x14\\\xD1\x11\x90`\xA0\x01[`@Q` \x81\x83\x03\x03\x81R\x90`@Ra\"\xE8V[`@\x80Q\x83\x81Rc\xFF\xFF\xFF\xFF\x83\x16` \x82\x01R\x84\x91\x86\x91\x7F\x19\xECj\xD7E-tC\x82\xE0\xF5\x90d\x01}\xCAV\xD2\xB3\xB9\xA4 &\xC6\x80:\xFCZ\x14\\\xD1\x11\x91\x01`@Q\x80\x91\x03\x90\xA3PPPPV[`@\x80Q` \x81\x01\x85\x90R\x90\x81\x01\x83\x90R``\x81\x01\x82\x90Ra\"\xA8\x90\x7F\xA9\xFEp\x1BM\xA2\xFFg\\\xFD\r\xC5A\xFB7:F\xA7,\\%\x8A\x99\xFE\x85\x08R\xDCu\xD3\xA1\xCB\x90`\x80\x01a\"\x06V[\x81\x83\x7F\xA9\xFEp\x1BM\xA2\xFFg\\\xFD\r\xC5A\xFB7:F\xA7,\\%\x8A\x99\xFE\x85\x08R\xDCu\xD3\xA1\xCB\x83`@Qa\"\xDB\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA3PPPV[`\x02_TCB\x85\x85`@Q` \x01a#\x04\x95\x94\x93\x92\x91\x90a)$V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra#\x1E\x91a)GV[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a#9W=__>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a#\\\x91\x90a)YV[_UPPV[`@Q\x80`\xC0\x01`@R\x80a#ua#\xB5V[\x81R` \x01a#\x82a#\xB5V[\x81R` \x01a#\x8Fa#\xB5V[\x81R` \x01a#\x9Ca#\xB5V[\x81R` \x01a#\xA9a#\xB5V[\x81R` \x01_\x81RP\x90V[`@Q\x80a\x02\0\x01`@R\x80`\x10\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[_` \x82\x84\x03\x12\x15a#\xE4W__\xFD[P5\x91\x90PV[__\x83`\x1F\x84\x01\x12a#\xFBW__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$\x12W__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a$)W__\xFD[\x92P\x92\x90PV[_______`\xA0\x88\x8A\x03\x12\x15a$FW__\xFD[\x875\x96P` \x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$cW__\xFD[a$o\x8A\x82\x8B\x01a#\xEBV[\x90\x97P\x95PP`@\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$\x8EW__\xFD[a$\x9A\x8A\x82\x8B\x01a#\xEBV[\x98\x9B\x97\x9AP\x95\x98\x95\x97\x96``\x87\x015\x96`\x80\x015\x95P\x93PPPPV[___`@\x84\x86\x03\x12\x15a$\xC9W__\xFD[\x835g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a$\xDFW__\xFD[a$\xEB\x86\x82\x87\x01a#\xEBV[\x90\x97\x90\x96P` \x95\x90\x95\x015\x94\x93PPPPV[____``\x85\x87\x03\x12\x15a%\x12W__\xFD[\x845\x93P` \x85\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a%/W__\xFD[a%;\x87\x82\x88\x01a#\xEBV[\x95\x98\x90\x97P\x94\x95`@\x015\x94\x93PPPPV[___``\x84\x86\x03\x12\x15a%`W__\xFD[PP\x815\x93` \x83\x015\x93P`@\x90\x92\x015\x91\x90PV[______`\x80\x87\x89\x03\x12\x15a%\x8CW__\xFD[\x865\x95P` \x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a%\xA9W__\xFD[a%\xB5\x89\x82\x8A\x01a#\xEBV[\x90\x96P\x94PP`@\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a%\xD4W__\xFD[a%\xE0\x89\x82\x8A\x01a#\xEBV[\x97\x9A\x96\x99P\x94\x97\x94\x96\x95``\x90\x95\x015\x94\x93PPPPV[\x805c\xFF\xFF\xFF\xFF\x81\x16\x81\x14a!\xB3W__\xFD[______`\xA0\x87\x89\x03\x12\x15a& W__\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015\x93Pa&>``\x88\x01a%\xF8V[\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a&YW__\xFD[a&e\x89\x82\x8A\x01a#\xEBV[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[\x805`\x01`\x01``\x1B\x03\x19\x81\x16\x81\x14a!\xB3W__\xFD[_____`\x80\x86\x88\x03\x12\x15a&\xA2W__\xFD[\x855\x94P` \x86\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a&\xBFW__\xFD[a&\xCB\x88\x82\x89\x01a#\xEBV[\x90\x95P\x93PP`@\x86\x015\x91Pa&\xE4``\x87\x01a&wV[\x90P\x92\x95P\x92\x95\x90\x93PV[\x805`\xFF\x81\x16\x81\x14a!\xB3W__\xFD[_____`\xA0\x86\x88\x03\x12\x15a'\x14W__\xFD[\x855\x94P` \x86\x015\x93Pa'+`@\x87\x01a%\xF8V[\x92Pa'9``\x87\x01a&\xF0V[\x94\x97\x93\x96P\x91\x94`\x80\x015\x92\x91PPV[` \x81R_\x82Q\x80` \x84\x01R\x80` \x85\x01`@\x85\x01^_`@\x82\x85\x01\x01R`@`\x1F\x19`\x1F\x83\x01\x16\x84\x01\x01\x91PP\x92\x91PPV[______`\xC0\x87\x89\x03\x12\x15a'\x94W__\xFD[\x865\x95P` \x87\x015\x94Pa'\xAB`@\x88\x01a%\xF8V[\x93Pa'\xB9``\x88\x01a&wV[\x95\x98\x94\x97P\x92\x95`\x80\x81\x015\x94`\xA0\x90\x91\x015\x93P\x91PPV[__`@\x83\x85\x03\x12\x15a'\xE4W__\xFD[a'\xED\x83a&\xF0V[\x94` \x93\x90\x93\x015\x93PPPV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_\x82a(\x1DWa(\x1Da'\xFBV[P\x06\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[_\x82a(DWa(Da'\xFBV[P\x04\x90V[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x04\x9CWa\x04\x9Ca(\"V[\x80\x82\x01\x80\x82\x11\x15a\x04\x9CWa\x04\x9Ca(\"V[\x87\x81R\x86` \x82\x01R\x85`@\x82\x01R\x84``\x82\x01Rc\xFF\xFF\xFF\xFF\x84\x16`\x80\x82\x01R`\xC0`\xA0\x82\x01R\x81`\xC0\x82\x01R\x81\x83`\xE0\x83\x017_\x81\x83\x01`\xE0\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x96\x95PPPPPPV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x81\x81\x03\x81\x81\x11\x15a\x04\x9CWa\x04\x9Ca(\"V[c\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x04\x9CWa\x04\x9Ca(\"V[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[\x85\x81R\x84` \x82\x01R\x83`@\x82\x01R\x82``\x82\x01R_a\x0B\xE9`\x80\x83\x01\x84a)\rV[_a)R\x82\x84a)\rV[\x93\x92PPPV[_` \x82\x84\x03\x12\x15a)iW__\xFD[PQ\x91\x90PV\xFE\xA1dsolcC\0\x08\x1B\0\n",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `BlockNotRelayed()` and selector `0x35ae903b`.
```solidity
error BlockNotRelayed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BlockNotRelayed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BlockNotRelayed> for UnderlyingRustTuple<'_> {
            fn from(value: BlockNotRelayed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BlockNotRelayed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BlockNotRelayed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BlockNotRelayed()";
            const SELECTOR: [u8; 4] = [53u8, 174u8, 144u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `BlockTooOld()` and selector `0xc2ffbcec`.
```solidity
error BlockTooOld();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BlockTooOld;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BlockTooOld> for UnderlyingRustTuple<'_> {
            fn from(value: BlockTooOld) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BlockTooOld {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BlockTooOld {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BlockTooOld()";
            const SELECTOR: [u8; 4] = [194u8, 255u8, 188u8, 236u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CheckpointNotFinalized(uint256,uint8)` and selector `0x595e1089`.
```solidity
error CheckpointNotFinalized(uint256 offset, uint8 distinct);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CheckpointNotFinalized {
        #[allow(missing_docs)]
        pub offset: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub distinct: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<8>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            u8,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CheckpointNotFinalized> for UnderlyingRustTuple<'_> {
            fn from(value: CheckpointNotFinalized) -> Self {
                (value.offset, value.distinct)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CheckpointNotFinalized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    offset: tuple.0,
                    distinct: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CheckpointNotFinalized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CheckpointNotFinalized(uint256,uint8)";
            const SELECTOR: [u8; 4] = [89u8, 94u8, 16u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.offset),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.distinct),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidChain()` and selector `0xafe7f4e0`.
```solidity
error InvalidChain();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidChain;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidChain> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidChain) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidChain {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidChain {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidChain()";
            const SELECTOR: [u8; 4] = [175u8, 231u8, 244u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidCompressedSignaturesLength()` and selector `0x3fc186d3`.
```solidity
error InvalidCompressedSignaturesLength();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidCompressedSignaturesLength;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidCompressedSignaturesLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidCompressedSignaturesLength) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidCompressedSignaturesLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidCompressedSignaturesLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidCompressedSignaturesLength()";
            const SELECTOR: [u8; 4] = [63u8, 193u8, 134u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidCompressedTronBlockMetadataLength()` and selector `0x674758b4`.
```solidity
error InvalidCompressedTronBlockMetadataLength();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidCompressedTronBlockMetadataLength;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidCompressedTronBlockMetadataLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidCompressedTronBlockMetadataLength) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidCompressedTronBlockMetadataLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidCompressedTronBlockMetadataLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidCompressedTronBlockMetadataLength()";
            const SELECTOR: [u8; 4] = [103u8, 71u8, 88u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidIntersectionClaim(uint256,bytes32)` and selector `0x956d18e9`.
```solidity
error InvalidIntersectionClaim(uint256 blockNumber, bytes32 blockId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidIntersectionClaim {
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub blockId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidIntersectionClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidIntersectionClaim) -> Self {
                (value.blockNumber, value.blockId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidIntersectionClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    blockNumber: tuple.0,
                    blockId: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidIntersectionClaim {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidIntersectionClaim(uint256,bytes32)";
            const SELECTOR: [u8; 4] = [149u8, 109u8, 24u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockId),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidIntersectionOffset(uint256,uint256)` and selector `0x12a47247`.
```solidity
error InvalidIntersectionOffset(uint256 intersectionOffset, uint256 numBlocks);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidIntersectionOffset {
        #[allow(missing_docs)]
        pub intersectionOffset: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidIntersectionOffset>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidIntersectionOffset) -> Self {
                (value.intersectionOffset, value.numBlocks)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidIntersectionOffset {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    intersectionOffset: tuple.0,
                    numBlocks: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidIntersectionOffset {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidIntersectionOffset(uint256,uint256)";
            const SELECTOR: [u8; 4] = [18u8, 164u8, 114u8, 71u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.intersectionOffset),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidParentBlockId(bytes32,bytes32)` and selector `0xc9de7122`.
```solidity
error InvalidParentBlockId(bytes32 yours, bytes32 real);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidParentBlockId {
        #[allow(missing_docs)]
        pub yours: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub real: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidParentBlockId> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidParentBlockId) -> Self {
                (value.yours, value.real)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidParentBlockId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    yours: tuple.0,
                    real: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidParentBlockId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidParentBlockId(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [201u8, 222u8, 113u8, 34u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.yours),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.real),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidSrIndex(uint256)` and selector `0x63cb5a41`.
```solidity
error InvalidSrIndex(uint256 index);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidSrIndex {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidSrIndex> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidSrIndex) -> Self {
                (value.index,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidSrIndex {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { index: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidSrIndex {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidSrIndex(uint256)";
            const SELECTOR: [u8; 4] = [99u8, 203u8, 90u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidStoreOffset(uint256,uint256)` and selector `0xfb69a82e`.
```solidity
error InvalidStoreOffset(uint256 offset, uint256 numBlocks);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidStoreOffset {
        #[allow(missing_docs)]
        pub offset: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidStoreOffset> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidStoreOffset) -> Self {
                (value.offset, value.numBlocks)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidStoreOffset {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    offset: tuple.0,
                    numBlocks: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidStoreOffset {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidStoreOffset(uint256,uint256)";
            const SELECTOR: [u8; 4] = [251u8, 105u8, 168u8, 46u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.offset),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidWitnessDelegateeIndex(uint256)` and selector `0xf0b1444b`.
```solidity
error InvalidWitnessDelegateeIndex(uint256 index);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidWitnessDelegateeIndex {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidWitnessDelegateeIndex>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidWitnessDelegateeIndex) -> Self {
                (value.index,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidWitnessDelegateeIndex {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { index: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidWitnessDelegateeIndex {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidWitnessDelegateeIndex(uint256)";
            const SELECTOR: [u8; 4] = [240u8, 177u8, 68u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidWitnessSigner()` and selector `0x8025b03e`.
```solidity
error InvalidWitnessSigner();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidWitnessSigner;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidWitnessSigner> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidWitnessSigner) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidWitnessSigner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidWitnessSigner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidWitnessSigner()";
            const SELECTOR: [u8; 4] = [128u8, 37u8, 176u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `Sha256PrecompileFailed()` and selector `0xdd5cab3e`.
```solidity
error Sha256PrecompileFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Sha256PrecompileFailed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Sha256PrecompileFailed> for UnderlyingRustTuple<'_> {
            fn from(value: Sha256PrecompileFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Sha256PrecompileFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Sha256PrecompileFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Sha256PrecompileFailed()";
            const SELECTOR: [u8; 4] = [221u8, 92u8, 171u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SrSetNotSorted(uint256,bytes20,bytes20)` and selector `0x4c919300`.
```solidity
error SrSetNotSorted(uint256 index, bytes20 prev, bytes20 next);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SrSetNotSorted {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub prev: alloy::sol_types::private::FixedBytes<20>,
        #[allow(missing_docs)]
        pub next: alloy::sol_types::private::FixedBytes<20>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<20>,
            alloy::sol_types::sol_data::FixedBytes<20>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<20>,
            alloy::sol_types::private::FixedBytes<20>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SrSetNotSorted> for UnderlyingRustTuple<'_> {
            fn from(value: SrSetNotSorted) -> Self {
                (value.index, value.prev, value.next)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SrSetNotSorted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    index: tuple.0,
                    prev: tuple.1,
                    next: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SrSetNotSorted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SrSetNotSorted(uint256,bytes20,bytes20)";
            const SELECTOR: [u8; 4] = [76u8, 145u8, 147u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                    <alloy::sol_types::sol_data::FixedBytes<
                        20,
                    > as alloy_sol_types::SolType>::tokenize(&self.prev),
                    <alloy::sol_types::sol_data::FixedBytes<
                        20,
                    > as alloy_sol_types::SolType>::tokenize(&self.next),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `StoreOffsetsNotStrictlyIncreasing(uint256,uint256)` and selector `0x8f16148f`.
```solidity
error StoreOffsetsNotStrictlyIncreasing(uint256 prev, uint256 next);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct StoreOffsetsNotStrictlyIncreasing {
        #[allow(missing_docs)]
        pub prev: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub next: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StoreOffsetsNotStrictlyIncreasing>
        for UnderlyingRustTuple<'_> {
            fn from(value: StoreOffsetsNotStrictlyIncreasing) -> Self {
                (value.prev, value.next)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for StoreOffsetsNotStrictlyIncreasing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    prev: tuple.0,
                    next: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for StoreOffsetsNotStrictlyIncreasing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "StoreOffsetsNotStrictlyIncreasing(uint256,uint256)";
            const SELECTOR: [u8; 4] = [143u8, 22u8, 20u8, 143u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.prev),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.next),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `TooManyBlocks(uint256)` and selector `0xe082840b`.
```solidity
error TooManyBlocks(uint256 numBlocks);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TooManyBlocks {
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TooManyBlocks> for UnderlyingRustTuple<'_> {
            fn from(value: TooManyBlocks) -> Self {
                (value.numBlocks,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TooManyBlocks {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { numBlocks: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TooManyBlocks {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TooManyBlocks(uint256)";
            const SELECTOR: [u8; 4] = [224u8, 130u8, 132u8, 11u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UnanchoredBlockRange()` and selector `0x9e25652d`.
```solidity
error UnanchoredBlockRange();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnanchoredBlockRange;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnanchoredBlockRange> for UnderlyingRustTuple<'_> {
            fn from(value: UnanchoredBlockRange) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnanchoredBlockRange {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnanchoredBlockRange {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnanchoredBlockRange()";
            const SELECTOR: [u8; 4] = [158u8, 37u8, 101u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `LatestProvenBlockUpdated(bytes32,bytes32,uint256)` and selector `0xa9fe701b4da2ff675cfd0dc541fb373a46a72c5c258a99fe850852dc75d3a1cb`.
```solidity
event LatestProvenBlockUpdated(bytes32 indexed previousLatest, bytes32 indexed newLatest, uint256 newBlockNumber);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct LatestProvenBlockUpdated {
        #[allow(missing_docs)]
        pub previousLatest: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newLatest: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for LatestProvenBlockUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "LatestProvenBlockUpdated(bytes32,bytes32,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                169u8, 254u8, 112u8, 27u8, 77u8, 162u8, 255u8, 103u8, 92u8, 253u8, 13u8,
                197u8, 65u8, 251u8, 55u8, 58u8, 70u8, 167u8, 44u8, 92u8, 37u8, 138u8,
                153u8, 254u8, 133u8, 8u8, 82u8, 220u8, 117u8, 211u8, 161u8, 203u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousLatest: topics.1,
                    newLatest: topics.2,
                    newBlockNumber: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newBlockNumber),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousLatest.clone(),
                    self.newLatest.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousLatest);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newLatest);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for LatestProvenBlockUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&LatestProvenBlockUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &LatestProvenBlockUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `TronBlockStored(uint256,bytes32,bytes32,uint32)` and selector `0x19ec6ad7452d744382e0f59064017dca56d2b3b9a42026c6803afc5a145cd111`.
```solidity
event TronBlockStored(uint256 indexed blockNumber, bytes32 indexed blockId, bytes32 txTrieRoot, uint32 timestamp);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TronBlockStored {
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub blockId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub txTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub timestamp: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TronBlockStored {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "TronBlockStored(uint256,bytes32,bytes32,uint32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                25u8, 236u8, 106u8, 215u8, 69u8, 45u8, 116u8, 67u8, 130u8, 224u8, 245u8,
                144u8, 100u8, 1u8, 125u8, 202u8, 86u8, 210u8, 179u8, 185u8, 164u8, 32u8,
                38u8, 198u8, 128u8, 58u8, 252u8, 90u8, 20u8, 92u8, 209u8, 17u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    blockNumber: topics.1,
                    blockId: topics.2,
                    txTrieRoot: data.0,
                    timestamp: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.txTrieRoot),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.timestamp),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.blockNumber.clone(),
                    self.blockId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blockNumber);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blockId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TronBlockStored {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TronBlockStored> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TronBlockStored) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `TronLightClientConfigured(address,bytes32,bytes32,bytes32,uint32,bytes20[27],bytes20[27])` and selector `0x08a67b41721e6d18eb5a3f0d47535037e75548f56ff91770d850aec7bf23ef4a`.
```solidity
event TronLightClientConfigured(address indexed blockRangeProver, bytes32 indexed srDataHash, bytes32 indexed initialBlockId, bytes32 initialTxTrieRoot, uint32 initialTimestamp, bytes20[27] srs, bytes20[27] witnessDelegatees);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TronLightClientConfigured {
        #[allow(missing_docs)]
        pub blockRangeProver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub srDataHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub initialBlockId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub initialTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub initialTimestamp: u32,
        #[allow(missing_docs)]
        pub srs: [alloy::sol_types::private::FixedBytes<20>; 27usize],
        #[allow(missing_docs)]
        pub witnessDelegatees: [alloy::sol_types::private::FixedBytes<20>; 27usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TronLightClientConfigured {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<20>,
                    27usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<20>,
                    27usize,
                >,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "TronLightClientConfigured(address,bytes32,bytes32,bytes32,uint32,bytes20[27],bytes20[27])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                8u8, 166u8, 123u8, 65u8, 114u8, 30u8, 109u8, 24u8, 235u8, 90u8, 63u8,
                13u8, 71u8, 83u8, 80u8, 55u8, 231u8, 85u8, 72u8, 245u8, 111u8, 249u8,
                23u8, 112u8, 216u8, 80u8, 174u8, 199u8, 191u8, 35u8, 239u8, 74u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    blockRangeProver: topics.1,
                    srDataHash: topics.2,
                    initialBlockId: topics.3,
                    initialTxTrieRoot: data.0,
                    initialTimestamp: data.1,
                    srs: data.2,
                    witnessDelegatees: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialTxTrieRoot),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialTimestamp),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<20>,
                        27usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.srs),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<20>,
                        27usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.witnessDelegatees),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.blockRangeProver.clone(),
                    self.srDataHash.clone(),
                    self.initialBlockId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.blockRangeProver,
                );
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.srDataHash);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.initialBlockId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TronLightClientConfigured {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TronLightClientConfigured> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &TronLightClientConfigured,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address p, bytes32 initial, bytes32 initialTxTrieRoot, uint32 initialTimestamp, bytes20[27] srs_, bytes20[27] witnessDelegatees_, bytes32 srDataHash_);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub p: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub initial: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub initialTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub initialTimestamp: u32,
        #[allow(missing_docs)]
        pub srs_: [alloy::sol_types::private::FixedBytes<20>; 27usize],
        #[allow(missing_docs)]
        pub witnessDelegatees_: [alloy::sol_types::private::FixedBytes<20>; 27usize],
        #[allow(missing_docs)]
        pub srDataHash_: alloy::sol_types::private::FixedBytes<32>,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<20>,
                    27usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<20>,
                    27usize,
                >,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                u32,
                [alloy::sol_types::private::FixedBytes<20>; 27usize],
                [alloy::sol_types::private::FixedBytes<20>; 27usize],
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.p,
                        value.initial,
                        value.initialTxTrieRoot,
                        value.initialTimestamp,
                        value.srs_,
                        value.witnessDelegatees_,
                        value.srDataHash_,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        p: tuple.0,
                        initial: tuple.1,
                        initialTxTrieRoot: tuple.2,
                        initialTimestamp: tuple.3,
                        srs_: tuple.4,
                        witnessDelegatees_: tuple.5,
                        srDataHash_: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<20>,
                    27usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<20>,
                    27usize,
                >,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.p,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.initial),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialTxTrieRoot),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialTimestamp),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<20>,
                        27usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.srs_),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<20>,
                        27usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.witnessDelegatees_),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.srDataHash_),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `BLOCK_RANGE_PROVER()` and selector `0xc57312b3`.
```solidity
function BLOCK_RANGE_PROVER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BLOCK_RANGE_PROVERCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`BLOCK_RANGE_PROVER()`](BLOCK_RANGE_PROVERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BLOCK_RANGE_PROVERReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BLOCK_RANGE_PROVERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BLOCK_RANGE_PROVERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BLOCK_RANGE_PROVERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BLOCK_RANGE_PROVERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BLOCK_RANGE_PROVERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BLOCK_RANGE_PROVERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BLOCK_RANGE_PROVERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BLOCK_RANGE_PROVER()";
            const SELECTOR: [u8; 4] = [197u8, 115u8, 18u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: BLOCK_RANGE_PROVERReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: BLOCK_RANGE_PROVERReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `SR_DATA_HASH()` and selector `0x56dd9c10`.
```solidity
function SR_DATA_HASH() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SR_DATA_HASHCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`SR_DATA_HASH()`](SR_DATA_HASHCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SR_DATA_HASHReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SR_DATA_HASHCall> for UnderlyingRustTuple<'_> {
                fn from(value: SR_DATA_HASHCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SR_DATA_HASHCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SR_DATA_HASHReturn> for UnderlyingRustTuple<'_> {
                fn from(value: SR_DATA_HASHReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SR_DATA_HASHReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SR_DATA_HASHCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SR_DATA_HASH()";
            const SELECTOR: [u8; 4] = [86u8, 221u8, 156u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: SR_DATA_HASHReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: SR_DATA_HASHReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `benchAdvanceAndHash(bytes32,bytes,uint256)` and selector `0x257dba86`.
```solidity
function benchAdvanceAndHash(bytes32 startingBlockId, bytes memory meta, uint256 numBlocks) external view returns (bytes32 acc);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchAdvanceAndHashCall {
        #[allow(missing_docs)]
        pub startingBlockId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub meta: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`benchAdvanceAndHash(bytes32,bytes,uint256)`](benchAdvanceAndHashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchAdvanceAndHashReturn {
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchAdvanceAndHashCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchAdvanceAndHashCall) -> Self {
                    (value.startingBlockId, value.meta, value.numBlocks)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchAdvanceAndHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startingBlockId: tuple.0,
                        meta: tuple.1,
                        numBlocks: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchAdvanceAndHashReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchAdvanceAndHashReturn) -> Self {
                    (value.acc,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchAdvanceAndHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { acc: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for benchAdvanceAndHashCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "benchAdvanceAndHash(bytes32,bytes,uint256)";
            const SELECTOR: [u8; 4] = [37u8, 125u8, 186u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startingBlockId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.meta,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: benchAdvanceAndHashReturn = r.into();
                        r.acc
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: benchAdvanceAndHashReturn = r.into();
                        r.acc
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `benchDecode(bytes,uint256)` and selector `0x779982cc`.
```solidity
function benchDecode(bytes memory data, uint256 numBlocks) external pure returns (bytes32 acc);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchDecodeCall {
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`benchDecode(bytes,uint256)`](benchDecodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchDecodeReturn {
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchDecodeCall> for UnderlyingRustTuple<'_> {
                fn from(value: benchDecodeCall) -> Self {
                    (value.data, value.numBlocks)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for benchDecodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        data: tuple.0,
                        numBlocks: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchDecodeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: benchDecodeReturn) -> Self {
                    (value.acc,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for benchDecodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { acc: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for benchDecodeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "benchDecode(bytes,uint256)";
            const SELECTOR: [u8; 4] = [119u8, 153u8, 130u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: benchDecodeReturn = r.into();
                        r.acc
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: benchDecodeReturn = r.into();
                        r.acc
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `benchDecodeMinimal(bytes,uint256)` and selector `0x24fb3d1a`.
```solidity
function benchDecodeMinimal(bytes memory data, uint256 numBlocks) external pure returns (bytes32 acc);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchDecodeMinimalCall {
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`benchDecodeMinimal(bytes,uint256)`](benchDecodeMinimalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchDecodeMinimalReturn {
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchDecodeMinimalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchDecodeMinimalCall) -> Self {
                    (value.data, value.numBlocks)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchDecodeMinimalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        data: tuple.0,
                        numBlocks: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchDecodeMinimalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchDecodeMinimalReturn) -> Self {
                    (value.acc,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchDecodeMinimalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { acc: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for benchDecodeMinimalCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "benchDecodeMinimal(bytes,uint256)";
            const SELECTOR: [u8; 4] = [36u8, 251u8, 61u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: benchDecodeMinimalReturn = r.into();
                        r.acc
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: benchDecodeMinimalReturn = r.into();
                        r.acc
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `benchEncodeHeaderDirectNoSrLookup(bytes32,bytes32,uint32,bytes20,uint256,uint256)` and selector `0xc49d3258`.
```solidity
function benchEncodeHeaderDirectNoSrLookup(bytes32 parentHash, bytes32 txTrieRoot, uint32 timestampSec, bytes20 witness, uint256 firstBlockNumber, uint256 iters) external pure returns (uint256 usedTotal, bytes32 acc);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchEncodeHeaderDirectNoSrLookupCall {
        #[allow(missing_docs)]
        pub parentHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub txTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub timestampSec: u32,
        #[allow(missing_docs)]
        pub witness: alloy::sol_types::private::FixedBytes<20>,
        #[allow(missing_docs)]
        pub firstBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub iters: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`benchEncodeHeaderDirectNoSrLookup(bytes32,bytes32,uint32,bytes20,uint256,uint256)`](benchEncodeHeaderDirectNoSrLookupCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchEncodeHeaderDirectNoSrLookupReturn {
        #[allow(missing_docs)]
        pub usedTotal: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::FixedBytes<20>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                u32,
                alloy::sol_types::private::FixedBytes<20>,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchEncodeHeaderDirectNoSrLookupCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchEncodeHeaderDirectNoSrLookupCall) -> Self {
                    (
                        value.parentHash,
                        value.txTrieRoot,
                        value.timestampSec,
                        value.witness,
                        value.firstBlockNumber,
                        value.iters,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchEncodeHeaderDirectNoSrLookupCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        parentHash: tuple.0,
                        txTrieRoot: tuple.1,
                        timestampSec: tuple.2,
                        witness: tuple.3,
                        firstBlockNumber: tuple.4,
                        iters: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchEncodeHeaderDirectNoSrLookupReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchEncodeHeaderDirectNoSrLookupReturn) -> Self {
                    (value.usedTotal, value.acc)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchEncodeHeaderDirectNoSrLookupReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        usedTotal: tuple.0,
                        acc: tuple.1,
                    }
                }
            }
        }
        impl benchEncodeHeaderDirectNoSrLookupReturn {
            fn _tokenize(
                &self,
            ) -> <benchEncodeHeaderDirectNoSrLookupCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.usedTotal),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.acc),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for benchEncodeHeaderDirectNoSrLookupCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::FixedBytes<20>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = benchEncodeHeaderDirectNoSrLookupReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "benchEncodeHeaderDirectNoSrLookup(bytes32,bytes32,uint32,bytes20,uint256,uint256)";
            const SELECTOR: [u8; 4] = [196u8, 157u8, 50u8, 88u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.parentHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.txTrieRoot),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.timestampSec),
                    <alloy::sol_types::sol_data::FixedBytes<
                        20,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.firstBlockNumber),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.iters),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                benchEncodeHeaderDirectNoSrLookupReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `benchEncodeHeaderFromMeta(bytes32,bytes,uint256)` and selector `0xc8be60a2`.
```solidity
function benchEncodeHeaderFromMeta(bytes32 startingBlockId, bytes memory meta, uint256 numBlocks) external view returns (uint256 usedTotal, bytes32 acc);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchEncodeHeaderFromMetaCall {
        #[allow(missing_docs)]
        pub startingBlockId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub meta: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`benchEncodeHeaderFromMeta(bytes32,bytes,uint256)`](benchEncodeHeaderFromMetaCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchEncodeHeaderFromMetaReturn {
        #[allow(missing_docs)]
        pub usedTotal: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchEncodeHeaderFromMetaCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchEncodeHeaderFromMetaCall) -> Self {
                    (value.startingBlockId, value.meta, value.numBlocks)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchEncodeHeaderFromMetaCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startingBlockId: tuple.0,
                        meta: tuple.1,
                        numBlocks: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchEncodeHeaderFromMetaReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchEncodeHeaderFromMetaReturn) -> Self {
                    (value.usedTotal, value.acc)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchEncodeHeaderFromMetaReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        usedTotal: tuple.0,
                        acc: tuple.1,
                    }
                }
            }
        }
        impl benchEncodeHeaderFromMetaReturn {
            fn _tokenize(
                &self,
            ) -> <benchEncodeHeaderFromMetaCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.usedTotal),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.acc),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for benchEncodeHeaderFromMetaCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = benchEncodeHeaderFromMetaReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "benchEncodeHeaderFromMeta(bytes32,bytes,uint256)";
            const SELECTOR: [u8; 4] = [200u8, 190u8, 96u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startingBlockId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.meta,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                benchEncodeHeaderFromMetaReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `benchEncodeHeaderFromMetaNoSrLookup(bytes32,bytes,uint256,bytes20)` and selector `0xa867cec3`.
```solidity
function benchEncodeHeaderFromMetaNoSrLookup(bytes32 startingBlockId, bytes memory meta, uint256 numBlocks, bytes20 witness) external pure returns (uint256 usedTotal, bytes32 acc);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchEncodeHeaderFromMetaNoSrLookupCall {
        #[allow(missing_docs)]
        pub startingBlockId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub meta: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub witness: alloy::sol_types::private::FixedBytes<20>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`benchEncodeHeaderFromMetaNoSrLookup(bytes32,bytes,uint256,bytes20)`](benchEncodeHeaderFromMetaNoSrLookupCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchEncodeHeaderFromMetaNoSrLookupReturn {
        #[allow(missing_docs)]
        pub usedTotal: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<20>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<20>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchEncodeHeaderFromMetaNoSrLookupCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchEncodeHeaderFromMetaNoSrLookupCall) -> Self {
                    (value.startingBlockId, value.meta, value.numBlocks, value.witness)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchEncodeHeaderFromMetaNoSrLookupCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startingBlockId: tuple.0,
                        meta: tuple.1,
                        numBlocks: tuple.2,
                        witness: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchEncodeHeaderFromMetaNoSrLookupReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchEncodeHeaderFromMetaNoSrLookupReturn) -> Self {
                    (value.usedTotal, value.acc)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchEncodeHeaderFromMetaNoSrLookupReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        usedTotal: tuple.0,
                        acc: tuple.1,
                    }
                }
            }
        }
        impl benchEncodeHeaderFromMetaNoSrLookupReturn {
            fn _tokenize(
                &self,
            ) -> <benchEncodeHeaderFromMetaNoSrLookupCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.usedTotal),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.acc),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for benchEncodeHeaderFromMetaNoSrLookupCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<20>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = benchEncodeHeaderFromMetaNoSrLookupReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "benchEncodeHeaderFromMetaNoSrLookup(bytes32,bytes,uint256,bytes20)";
            const SELECTOR: [u8; 4] = [168u8, 103u8, 206u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startingBlockId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.meta,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                    <alloy::sol_types::sol_data::FixedBytes<
                        20,
                    > as alloy_sol_types::SolType>::tokenize(&self.witness),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                benchEncodeHeaderFromMetaNoSrLookupReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `benchFullVerifyNoStore(bytes32,bytes,bytes,uint256)` and selector `0x415efc97`.
```solidity
function benchFullVerifyNoStore(bytes32 startingBlockId, bytes memory meta, bytes memory sigs, uint256 numBlocks) external view returns (bytes32 acc);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchFullVerifyNoStoreCall {
        #[allow(missing_docs)]
        pub startingBlockId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub meta: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub sigs: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`benchFullVerifyNoStore(bytes32,bytes,bytes,uint256)`](benchFullVerifyNoStoreCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchFullVerifyNoStoreReturn {
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchFullVerifyNoStoreCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchFullVerifyNoStoreCall) -> Self {
                    (value.startingBlockId, value.meta, value.sigs, value.numBlocks)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchFullVerifyNoStoreCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startingBlockId: tuple.0,
                        meta: tuple.1,
                        sigs: tuple.2,
                        numBlocks: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchFullVerifyNoStoreReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchFullVerifyNoStoreReturn) -> Self {
                    (value.acc,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchFullVerifyNoStoreReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { acc: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for benchFullVerifyNoStoreCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "benchFullVerifyNoStore(bytes32,bytes,bytes,uint256)";
            const SELECTOR: [u8; 4] = [65u8, 94u8, 252u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startingBlockId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.meta,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sigs,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: benchFullVerifyNoStoreReturn = r.into();
                        r.acc
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: benchFullVerifyNoStoreReturn = r.into();
                        r.acc
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `benchMakeBlockId(bytes32,bytes32,uint256)` and selector `0x3c4f102b`.
```solidity
function benchMakeBlockId(bytes32 startingBlockId, bytes32 blockHash, uint256 numBlocks) external pure returns (bytes32 acc);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchMakeBlockIdCall {
        #[allow(missing_docs)]
        pub startingBlockId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub blockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`benchMakeBlockId(bytes32,bytes32,uint256)`](benchMakeBlockIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchMakeBlockIdReturn {
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchMakeBlockIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchMakeBlockIdCall) -> Self {
                    (value.startingBlockId, value.blockHash, value.numBlocks)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchMakeBlockIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startingBlockId: tuple.0,
                        blockHash: tuple.1,
                        numBlocks: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchMakeBlockIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchMakeBlockIdReturn) -> Self {
                    (value.acc,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchMakeBlockIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { acc: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for benchMakeBlockIdCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "benchMakeBlockId(bytes32,bytes32,uint256)";
            const SELECTOR: [u8; 4] = [60u8, 79u8, 16u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startingBlockId),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockHash),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: benchMakeBlockIdReturn = r.into();
                        r.acc
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: benchMakeBlockIdReturn = r.into();
                        r.acc
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `benchNoop(uint256)` and selector `0xba421322`.
```solidity
function benchNoop(uint256 iters) external pure returns (uint256 acc);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchNoopCall {
        #[allow(missing_docs)]
        pub iters: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`benchNoop(uint256)`](benchNoopCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchNoopReturn {
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchNoopCall> for UnderlyingRustTuple<'_> {
                fn from(value: benchNoopCall) -> Self {
                    (value.iters,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for benchNoopCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { iters: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchNoopReturn> for UnderlyingRustTuple<'_> {
                fn from(value: benchNoopReturn) -> Self {
                    (value.acc,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for benchNoopReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { acc: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for benchNoopCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "benchNoop(uint256)";
            const SELECTOR: [u8; 4] = [186u8, 66u8, 19u8, 34u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.iters),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: benchNoopReturn = r.into();
                        r.acc
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: benchNoopReturn = r.into();
                        r.acc
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `benchRecoverSigner(bytes32,bytes,uint256)` and selector `0x9257d6a6`.
```solidity
function benchRecoverSigner(bytes32 digest, bytes memory sigs, uint256 numBlocks) external view returns (bytes20 acc);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchRecoverSignerCall {
        #[allow(missing_docs)]
        pub digest: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub sigs: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`benchRecoverSigner(bytes32,bytes,uint256)`](benchRecoverSignerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchRecoverSignerReturn {
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::FixedBytes<20>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchRecoverSignerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchRecoverSignerCall) -> Self {
                    (value.digest, value.sigs, value.numBlocks)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchRecoverSignerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        digest: tuple.0,
                        sigs: tuple.1,
                        numBlocks: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<20>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchRecoverSignerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchRecoverSignerReturn) -> Self {
                    (value.acc,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchRecoverSignerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { acc: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for benchRecoverSignerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<20>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "benchRecoverSigner(bytes32,bytes,uint256)";
            const SELECTOR: [u8; 4] = [146u8, 87u8, 214u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.digest),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.sigs,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        20,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: benchRecoverSignerReturn = r.into();
                        r.acc
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: benchRecoverSignerReturn = r.into();
                        r.acc
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `benchSha256AfterEncode(bytes32,bytes,uint256)` and selector `0xca6a66a2`.
```solidity
function benchSha256AfterEncode(bytes32 startingBlockId, bytes memory meta, uint256 numBlocks) external view returns (bytes32 acc);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchSha256AfterEncodeCall {
        #[allow(missing_docs)]
        pub startingBlockId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub meta: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`benchSha256AfterEncode(bytes32,bytes,uint256)`](benchSha256AfterEncodeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchSha256AfterEncodeReturn {
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchSha256AfterEncodeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchSha256AfterEncodeCall) -> Self {
                    (value.startingBlockId, value.meta, value.numBlocks)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchSha256AfterEncodeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startingBlockId: tuple.0,
                        meta: tuple.1,
                        numBlocks: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchSha256AfterEncodeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchSha256AfterEncodeReturn) -> Self {
                    (value.acc,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchSha256AfterEncodeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { acc: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for benchSha256AfterEncodeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "benchSha256AfterEncode(bytes32,bytes,uint256)";
            const SELECTOR: [u8; 4] = [202u8, 106u8, 102u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startingBlockId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.meta,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: benchSha256AfterEncodeReturn = r.into();
                        r.acc
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: benchSha256AfterEncodeReturn = r.into();
                        r.acc
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `benchSrAt(bytes,uint256)` and selector `0xa664336d`.
```solidity
function benchSrAt(bytes memory meta, uint256 numBlocks) external view returns (bytes20 acc);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchSrAtCall {
        #[allow(missing_docs)]
        pub meta: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`benchSrAt(bytes,uint256)`](benchSrAtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchSrAtReturn {
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::FixedBytes<20>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchSrAtCall> for UnderlyingRustTuple<'_> {
                fn from(value: benchSrAtCall) -> Self {
                    (value.meta, value.numBlocks)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for benchSrAtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        meta: tuple.0,
                        numBlocks: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<20>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchSrAtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: benchSrAtReturn) -> Self {
                    (value.acc,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for benchSrAtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { acc: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for benchSrAtCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<20>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "benchSrAt(bytes,uint256)";
            const SELECTOR: [u8; 4] = [166u8, 100u8, 51u8, 109u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.meta,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        20,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: benchSrAtReturn = r.into();
                        r.acc
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: benchSrAtReturn = r.into();
                        r.acc
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `benchSrAtOnly(uint8,uint256)` and selector `0xeccddc32`.
```solidity
function benchSrAtOnly(uint8 witnessIndex, uint256 iters) external view returns (bytes20 acc);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchSrAtOnlyCall {
        #[allow(missing_docs)]
        pub witnessIndex: u8,
        #[allow(missing_docs)]
        pub iters: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`benchSrAtOnly(uint8,uint256)`](benchSrAtOnlyCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchSrAtOnlyReturn {
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::FixedBytes<20>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u8,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchSrAtOnlyCall> for UnderlyingRustTuple<'_> {
                fn from(value: benchSrAtOnlyCall) -> Self {
                    (value.witnessIndex, value.iters)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for benchSrAtOnlyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        witnessIndex: tuple.0,
                        iters: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<20>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchSrAtOnlyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: benchSrAtOnlyReturn) -> Self {
                    (value.acc,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for benchSrAtOnlyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { acc: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for benchSrAtOnlyCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<20>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "benchSrAtOnly(uint8,uint256)";
            const SELECTOR: [u8; 4] = [236u8, 205u8, 220u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.witnessIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.iters),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        20,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: benchSrAtOnlyReturn = r.into();
                        r.acc
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: benchSrAtOnlyReturn = r.into();
                        r.acc
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `benchWitnessDelegateeAt(bytes,uint256)` and selector `0x22690a49`.
```solidity
function benchWitnessDelegateeAt(bytes memory meta, uint256 numBlocks) external view returns (bytes20 acc);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchWitnessDelegateeAtCall {
        #[allow(missing_docs)]
        pub meta: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`benchWitnessDelegateeAt(bytes,uint256)`](benchWitnessDelegateeAtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct benchWitnessDelegateeAtReturn {
        #[allow(missing_docs)]
        pub acc: alloy::sol_types::private::FixedBytes<20>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchWitnessDelegateeAtCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchWitnessDelegateeAtCall) -> Self {
                    (value.meta, value.numBlocks)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchWitnessDelegateeAtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        meta: tuple.0,
                        numBlocks: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<20>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<benchWitnessDelegateeAtReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: benchWitnessDelegateeAtReturn) -> Self {
                    (value.acc,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for benchWitnessDelegateeAtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { acc: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for benchWitnessDelegateeAtCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<20>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "benchWitnessDelegateeAt(bytes,uint256)";
            const SELECTOR: [u8; 4] = [34u8, 105u8, 10u8, 73u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.meta,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        20,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: benchWitnessDelegateeAtReturn = r.into();
                        r.acc
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: benchWitnessDelegateeAtReturn = r.into();
                        r.acc
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `decodeAt(bytes,uint256)` and selector `0xc813bf7e`.
```solidity
function decodeAt(bytes memory data, uint256 idx) external pure returns (bytes32 parentHash, bytes32 txTrieRoot, uint32 timestamp, uint8 witnessIndex);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decodeAtCall {
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub idx: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`decodeAt(bytes,uint256)`](decodeAtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct decodeAtReturn {
        #[allow(missing_docs)]
        pub parentHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub txTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub timestamp: u32,
        #[allow(missing_docs)]
        pub witnessIndex: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decodeAtCall> for UnderlyingRustTuple<'_> {
                fn from(value: decodeAtCall) -> Self {
                    (value.data, value.idx)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decodeAtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        data: tuple.0,
                        idx: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<8>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                u32,
                u8,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<decodeAtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: decodeAtReturn) -> Self {
                    (
                        value.parentHash,
                        value.txTrieRoot,
                        value.timestamp,
                        value.witnessIndex,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for decodeAtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        parentHash: tuple.0,
                        txTrieRoot: tuple.1,
                        timestamp: tuple.2,
                        witnessIndex: tuple.3,
                    }
                }
            }
        }
        impl decodeAtReturn {
            fn _tokenize(
                &self,
            ) -> <decodeAtCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.parentHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.txTrieRoot),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.timestamp),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.witnessIndex),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for decodeAtCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = decodeAtReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<8>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "decodeAt(bytes,uint256)";
            const SELECTOR: [u8; 4] = [200u8, 19u8, 191u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.idx),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                decodeAtReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `encodeBlockHeaderPublic(bytes32,bytes32,uint32,uint8,uint256)` and selector `0xbf147635`.
```solidity
function encodeBlockHeaderPublic(bytes32 parentHash, bytes32 txTrieRoot, uint32 timestamp, uint8 witnessIndex, uint256 n) external view returns (bytes memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct encodeBlockHeaderPublicCall {
        #[allow(missing_docs)]
        pub parentHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub txTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub timestamp: u32,
        #[allow(missing_docs)]
        pub witnessIndex: u8,
        #[allow(missing_docs)]
        pub n: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`encodeBlockHeaderPublic(bytes32,bytes32,uint32,uint8,uint256)`](encodeBlockHeaderPublicCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct encodeBlockHeaderPublicReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                u32,
                u8,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<encodeBlockHeaderPublicCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: encodeBlockHeaderPublicCall) -> Self {
                    (
                        value.parentHash,
                        value.txTrieRoot,
                        value.timestamp,
                        value.witnessIndex,
                        value.n,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for encodeBlockHeaderPublicCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        parentHash: tuple.0,
                        txTrieRoot: tuple.1,
                        timestamp: tuple.2,
                        witnessIndex: tuple.3,
                        n: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<encodeBlockHeaderPublicReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: encodeBlockHeaderPublicReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for encodeBlockHeaderPublicReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for encodeBlockHeaderPublicCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "encodeBlockHeaderPublic(bytes32,bytes32,uint32,uint8,uint256)";
            const SELECTOR: [u8; 4] = [191u8, 20u8, 118u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.parentHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.txTrieRoot),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.timestamp),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.witnessIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.n),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: encodeBlockHeaderPublicReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: encodeBlockHeaderPublicReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `eventChainTip()` and selector `0x4d53e931`.
```solidity
function eventChainTip() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventChainTipCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`eventChainTip()`](eventChainTipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventChainTipReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventChainTipCall> for UnderlyingRustTuple<'_> {
                fn from(value: eventChainTipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventChainTipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventChainTipReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eventChainTipReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventChainTipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eventChainTipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eventChainTip()";
            const SELECTOR: [u8; 4] = [77u8, 83u8, 233u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: eventChainTipReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: eventChainTipReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getBlockId(uint256)` and selector `0x81e1d4fa`.
```solidity
function getBlockId(uint256 blockNumber) external view returns (bytes32 blockId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockIdCall {
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getBlockId(uint256)`](getBlockIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockIdReturn {
        #[allow(missing_docs)]
        pub blockId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBlockIdCall) -> Self {
                    (value.blockNumber,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBlockIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blockNumber: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockIdReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBlockIdReturn) -> Self {
                    (value.blockId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBlockIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blockId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBlockIdCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBlockId(uint256)";
            const SELECTOR: [u8; 4] = [129u8, 225u8, 212u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getBlockIdReturn = r.into();
                        r.blockId
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getBlockIdReturn = r.into();
                        r.blockId
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getBlockTimestamp(uint256)` and selector `0x47e26f1a`.
```solidity
function getBlockTimestamp(uint256 blockNumber) external view returns (uint32 timestamp);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockTimestampCall {
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getBlockTimestamp(uint256)`](getBlockTimestampCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockTimestampReturn {
        #[allow(missing_docs)]
        pub timestamp: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockTimestampCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBlockTimestampCall) -> Self {
                    (value.blockNumber,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBlockTimestampCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blockNumber: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockTimestampReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBlockTimestampReturn) -> Self {
                    (value.timestamp,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBlockTimestampReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { timestamp: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBlockTimestampCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u32;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBlockTimestamp(uint256)";
            const SELECTOR: [u8; 4] = [71u8, 226u8, 111u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getBlockTimestampReturn = r.into();
                        r.timestamp
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getBlockTimestampReturn = r.into();
                        r.timestamp
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getTxTrieRoot(uint256)` and selector `0x295b3d61`.
```solidity
function getTxTrieRoot(uint256 blockNumber) external view returns (bytes32 txTrieRoot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTxTrieRootCall {
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getTxTrieRoot(uint256)`](getTxTrieRootCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTxTrieRootReturn {
        #[allow(missing_docs)]
        pub txTrieRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTxTrieRootCall> for UnderlyingRustTuple<'_> {
                fn from(value: getTxTrieRootCall) -> Self {
                    (value.blockNumber,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getTxTrieRootCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blockNumber: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTxTrieRootReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getTxTrieRootReturn) -> Self {
                    (value.txTrieRoot,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getTxTrieRootReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { txTrieRoot: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getTxTrieRootCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getTxTrieRoot(uint256)";
            const SELECTOR: [u8; 4] = [41u8, 91u8, 61u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getTxTrieRootReturn = r.into();
                        r.txTrieRoot
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getTxTrieRootReturn = r.into();
                        r.txTrieRoot
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `hashBlockPublic(bytes32,bytes32,uint32,uint8,uint256)` and selector `0xbae88e2e`.
```solidity
function hashBlockPublic(bytes32 parentHash, bytes32 txTrieRoot, uint32 timestamp, uint8 witnessIndex, uint256 n) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hashBlockPublicCall {
        #[allow(missing_docs)]
        pub parentHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub txTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub timestamp: u32,
        #[allow(missing_docs)]
        pub witnessIndex: u8,
        #[allow(missing_docs)]
        pub n: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`hashBlockPublic(bytes32,bytes32,uint32,uint8,uint256)`](hashBlockPublicCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hashBlockPublicReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                u32,
                u8,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hashBlockPublicCall> for UnderlyingRustTuple<'_> {
                fn from(value: hashBlockPublicCall) -> Self {
                    (
                        value.parentHash,
                        value.txTrieRoot,
                        value.timestamp,
                        value.witnessIndex,
                        value.n,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hashBlockPublicCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        parentHash: tuple.0,
                        txTrieRoot: tuple.1,
                        timestamp: tuple.2,
                        witnessIndex: tuple.3,
                        n: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hashBlockPublicReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: hashBlockPublicReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for hashBlockPublicReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hashBlockPublicCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hashBlockPublic(bytes32,bytes32,uint32,uint8,uint256)";
            const SELECTOR: [u8; 4] = [186u8, 232u8, 142u8, 46u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.parentHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.txTrieRoot),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.timestamp),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.witnessIndex),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.n),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: hashBlockPublicReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: hashBlockPublicReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `latestProvenBlock()` and selector `0x36429b23`.
```solidity
function latestProvenBlock() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct latestProvenBlockCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`latestProvenBlock()`](latestProvenBlockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct latestProvenBlockReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<latestProvenBlockCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: latestProvenBlockCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for latestProvenBlockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<latestProvenBlockReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: latestProvenBlockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for latestProvenBlockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for latestProvenBlockCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "latestProvenBlock()";
            const SELECTOR: [u8; 4] = [54u8, 66u8, 155u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: latestProvenBlockReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: latestProvenBlockReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proveBlockRange(bytes32,bytes32,bytes32,uint32,bytes)` and selector `0x810b38fa`.
```solidity
function proveBlockRange(bytes32 startingBlock, bytes32 endingBlock, bytes32 endingBlockTxTrieRoot, uint32 endingBlockTimestamp, bytes memory zkProof) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proveBlockRangeCall {
        #[allow(missing_docs)]
        pub startingBlock: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endingBlock: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endingBlockTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endingBlockTimestamp: u32,
        #[allow(missing_docs)]
        pub zkProof: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`proveBlockRange(bytes32,bytes32,bytes32,uint32,bytes)`](proveBlockRangeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proveBlockRangeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                u32,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proveBlockRangeCall> for UnderlyingRustTuple<'_> {
                fn from(value: proveBlockRangeCall) -> Self {
                    (
                        value.startingBlock,
                        value.endingBlock,
                        value.endingBlockTxTrieRoot,
                        value.endingBlockTimestamp,
                        value.zkProof,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proveBlockRangeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startingBlock: tuple.0,
                        endingBlock: tuple.1,
                        endingBlockTxTrieRoot: tuple.2,
                        endingBlockTimestamp: tuple.3,
                        zkProof: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proveBlockRangeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: proveBlockRangeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for proveBlockRangeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl proveBlockRangeReturn {
            fn _tokenize(
                &self,
            ) -> <proveBlockRangeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proveBlockRangeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = proveBlockRangeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proveBlockRange(bytes32,bytes32,bytes32,uint32,bytes)";
            const SELECTOR: [u8; 4] = [129u8, 11u8, 56u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startingBlock),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endingBlock),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.endingBlockTxTrieRoot,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endingBlockTimestamp),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.zkProof,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                proveBlockRangeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proveBlocks(bytes32,bytes,bytes,uint256,uint256)` and selector `0x175767dc`.
```solidity
function proveBlocks(bytes32 startingBlock, bytes memory compressedTronBlockMetadata, bytes memory compressedSignatures, uint256 intersectionOffset, uint256 storeOffsets16) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proveBlocksCall {
        #[allow(missing_docs)]
        pub startingBlock: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub compressedTronBlockMetadata: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub compressedSignatures: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub intersectionOffset: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub storeOffsets16: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`proveBlocks(bytes32,bytes,bytes,uint256,uint256)`](proveBlocksCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proveBlocksReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proveBlocksCall> for UnderlyingRustTuple<'_> {
                fn from(value: proveBlocksCall) -> Self {
                    (
                        value.startingBlock,
                        value.compressedTronBlockMetadata,
                        value.compressedSignatures,
                        value.intersectionOffset,
                        value.storeOffsets16,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proveBlocksCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startingBlock: tuple.0,
                        compressedTronBlockMetadata: tuple.1,
                        compressedSignatures: tuple.2,
                        intersectionOffset: tuple.3,
                        storeOffsets16: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proveBlocksReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proveBlocksReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proveBlocksReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl proveBlocksReturn {
            fn _tokenize(
                &self,
            ) -> <proveBlocksCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proveBlocksCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = proveBlocksReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proveBlocks(bytes32,bytes,bytes,uint256,uint256)";
            const SELECTOR: [u8; 4] = [23u8, 87u8, 103u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startingBlock),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.compressedTronBlockMetadata,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.compressedSignatures,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.intersectionOffset),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.storeOffsets16),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                proveBlocksReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `srs(uint256)` and selector `0x39adfeff`.
```solidity
function srs(uint256 index) external view returns (bytes20 sr);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct srsCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`srs(uint256)`](srsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct srsReturn {
        #[allow(missing_docs)]
        pub sr: alloy::sol_types::private::FixedBytes<20>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<srsCall> for UnderlyingRustTuple<'_> {
                fn from(value: srsCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for srsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<20>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<srsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: srsReturn) -> Self {
                    (value.sr,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for srsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { sr: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for srsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<20>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "srs(uint256)";
            const SELECTOR: [u8; 4] = [57u8, 173u8, 254u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        20,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: srsReturn = r.into();
                        r.sr
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: srsReturn = r.into();
                        r.sr
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `witnessDelegatees(uint256)` and selector `0x12d713c2`.
```solidity
function witnessDelegatees(uint256 index) external view returns (bytes20 delegatee);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct witnessDelegateesCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`witnessDelegatees(uint256)`](witnessDelegateesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct witnessDelegateesReturn {
        #[allow(missing_docs)]
        pub delegatee: alloy::sol_types::private::FixedBytes<20>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<witnessDelegateesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: witnessDelegateesCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for witnessDelegateesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<20>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<witnessDelegateesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: witnessDelegateesReturn) -> Self {
                    (value.delegatee,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for witnessDelegateesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { delegatee: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for witnessDelegateesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<20>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "witnessDelegatees(uint256)";
            const SELECTOR: [u8; 4] = [18u8, 215u8, 19u8, 194u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        20,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: witnessDelegateesReturn = r.into();
                        r.delegatee
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: witnessDelegateesReturn = r.into();
                        r.delegatee
                    })
            }
        }
    };
    ///Container for all the [`TronLightClientHarness`](self) function calls.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum TronLightClientHarnessCalls {
        #[allow(missing_docs)]
        BLOCK_RANGE_PROVER(BLOCK_RANGE_PROVERCall),
        #[allow(missing_docs)]
        SR_DATA_HASH(SR_DATA_HASHCall),
        #[allow(missing_docs)]
        benchAdvanceAndHash(benchAdvanceAndHashCall),
        #[allow(missing_docs)]
        benchDecode(benchDecodeCall),
        #[allow(missing_docs)]
        benchDecodeMinimal(benchDecodeMinimalCall),
        #[allow(missing_docs)]
        benchEncodeHeaderDirectNoSrLookup(benchEncodeHeaderDirectNoSrLookupCall),
        #[allow(missing_docs)]
        benchEncodeHeaderFromMeta(benchEncodeHeaderFromMetaCall),
        #[allow(missing_docs)]
        benchEncodeHeaderFromMetaNoSrLookup(benchEncodeHeaderFromMetaNoSrLookupCall),
        #[allow(missing_docs)]
        benchFullVerifyNoStore(benchFullVerifyNoStoreCall),
        #[allow(missing_docs)]
        benchMakeBlockId(benchMakeBlockIdCall),
        #[allow(missing_docs)]
        benchNoop(benchNoopCall),
        #[allow(missing_docs)]
        benchRecoverSigner(benchRecoverSignerCall),
        #[allow(missing_docs)]
        benchSha256AfterEncode(benchSha256AfterEncodeCall),
        #[allow(missing_docs)]
        benchSrAt(benchSrAtCall),
        #[allow(missing_docs)]
        benchSrAtOnly(benchSrAtOnlyCall),
        #[allow(missing_docs)]
        benchWitnessDelegateeAt(benchWitnessDelegateeAtCall),
        #[allow(missing_docs)]
        decodeAt(decodeAtCall),
        #[allow(missing_docs)]
        encodeBlockHeaderPublic(encodeBlockHeaderPublicCall),
        #[allow(missing_docs)]
        eventChainTip(eventChainTipCall),
        #[allow(missing_docs)]
        getBlockId(getBlockIdCall),
        #[allow(missing_docs)]
        getBlockTimestamp(getBlockTimestampCall),
        #[allow(missing_docs)]
        getTxTrieRoot(getTxTrieRootCall),
        #[allow(missing_docs)]
        hashBlockPublic(hashBlockPublicCall),
        #[allow(missing_docs)]
        latestProvenBlock(latestProvenBlockCall),
        #[allow(missing_docs)]
        proveBlockRange(proveBlockRangeCall),
        #[allow(missing_docs)]
        proveBlocks(proveBlocksCall),
        #[allow(missing_docs)]
        srs(srsCall),
        #[allow(missing_docs)]
        witnessDelegatees(witnessDelegateesCall),
    }
    impl TronLightClientHarnessCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [18u8, 215u8, 19u8, 194u8],
            [23u8, 87u8, 103u8, 220u8],
            [34u8, 105u8, 10u8, 73u8],
            [36u8, 251u8, 61u8, 26u8],
            [37u8, 125u8, 186u8, 134u8],
            [41u8, 91u8, 61u8, 97u8],
            [54u8, 66u8, 155u8, 35u8],
            [57u8, 173u8, 254u8, 255u8],
            [60u8, 79u8, 16u8, 43u8],
            [65u8, 94u8, 252u8, 151u8],
            [71u8, 226u8, 111u8, 26u8],
            [77u8, 83u8, 233u8, 49u8],
            [86u8, 221u8, 156u8, 16u8],
            [119u8, 153u8, 130u8, 204u8],
            [129u8, 11u8, 56u8, 250u8],
            [129u8, 225u8, 212u8, 250u8],
            [146u8, 87u8, 214u8, 166u8],
            [166u8, 100u8, 51u8, 109u8],
            [168u8, 103u8, 206u8, 195u8],
            [186u8, 66u8, 19u8, 34u8],
            [186u8, 232u8, 142u8, 46u8],
            [191u8, 20u8, 118u8, 53u8],
            [196u8, 157u8, 50u8, 88u8],
            [197u8, 115u8, 18u8, 179u8],
            [200u8, 19u8, 191u8, 126u8],
            [200u8, 190u8, 96u8, 162u8],
            [202u8, 106u8, 102u8, 162u8],
            [236u8, 205u8, 220u8, 50u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(witnessDelegatees),
            ::core::stringify!(proveBlocks),
            ::core::stringify!(benchWitnessDelegateeAt),
            ::core::stringify!(benchDecodeMinimal),
            ::core::stringify!(benchAdvanceAndHash),
            ::core::stringify!(getTxTrieRoot),
            ::core::stringify!(latestProvenBlock),
            ::core::stringify!(srs),
            ::core::stringify!(benchMakeBlockId),
            ::core::stringify!(benchFullVerifyNoStore),
            ::core::stringify!(getBlockTimestamp),
            ::core::stringify!(eventChainTip),
            ::core::stringify!(SR_DATA_HASH),
            ::core::stringify!(benchDecode),
            ::core::stringify!(proveBlockRange),
            ::core::stringify!(getBlockId),
            ::core::stringify!(benchRecoverSigner),
            ::core::stringify!(benchSrAt),
            ::core::stringify!(benchEncodeHeaderFromMetaNoSrLookup),
            ::core::stringify!(benchNoop),
            ::core::stringify!(hashBlockPublic),
            ::core::stringify!(encodeBlockHeaderPublic),
            ::core::stringify!(benchEncodeHeaderDirectNoSrLookup),
            ::core::stringify!(BLOCK_RANGE_PROVER),
            ::core::stringify!(decodeAt),
            ::core::stringify!(benchEncodeHeaderFromMeta),
            ::core::stringify!(benchSha256AfterEncode),
            ::core::stringify!(benchSrAtOnly),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <witnessDelegateesCall as alloy_sol_types::SolCall>::SIGNATURE,
            <proveBlocksCall as alloy_sol_types::SolCall>::SIGNATURE,
            <benchWitnessDelegateeAtCall as alloy_sol_types::SolCall>::SIGNATURE,
            <benchDecodeMinimalCall as alloy_sol_types::SolCall>::SIGNATURE,
            <benchAdvanceAndHashCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getTxTrieRootCall as alloy_sol_types::SolCall>::SIGNATURE,
            <latestProvenBlockCall as alloy_sol_types::SolCall>::SIGNATURE,
            <srsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <benchMakeBlockIdCall as alloy_sol_types::SolCall>::SIGNATURE,
            <benchFullVerifyNoStoreCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getBlockTimestampCall as alloy_sol_types::SolCall>::SIGNATURE,
            <eventChainTipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <SR_DATA_HASHCall as alloy_sol_types::SolCall>::SIGNATURE,
            <benchDecodeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <proveBlockRangeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getBlockIdCall as alloy_sol_types::SolCall>::SIGNATURE,
            <benchRecoverSignerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <benchSrAtCall as alloy_sol_types::SolCall>::SIGNATURE,
            <benchEncodeHeaderFromMetaNoSrLookupCall as alloy_sol_types::SolCall>::SIGNATURE,
            <benchNoopCall as alloy_sol_types::SolCall>::SIGNATURE,
            <hashBlockPublicCall as alloy_sol_types::SolCall>::SIGNATURE,
            <encodeBlockHeaderPublicCall as alloy_sol_types::SolCall>::SIGNATURE,
            <benchEncodeHeaderDirectNoSrLookupCall as alloy_sol_types::SolCall>::SIGNATURE,
            <BLOCK_RANGE_PROVERCall as alloy_sol_types::SolCall>::SIGNATURE,
            <decodeAtCall as alloy_sol_types::SolCall>::SIGNATURE,
            <benchEncodeHeaderFromMetaCall as alloy_sol_types::SolCall>::SIGNATURE,
            <benchSha256AfterEncodeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <benchSrAtOnlyCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TronLightClientHarnessCalls {
        const NAME: &'static str = "TronLightClientHarnessCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 28usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BLOCK_RANGE_PROVER(_) => {
                    <BLOCK_RANGE_PROVERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SR_DATA_HASH(_) => {
                    <SR_DATA_HASHCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::benchAdvanceAndHash(_) => {
                    <benchAdvanceAndHashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::benchDecode(_) => {
                    <benchDecodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::benchDecodeMinimal(_) => {
                    <benchDecodeMinimalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::benchEncodeHeaderDirectNoSrLookup(_) => {
                    <benchEncodeHeaderDirectNoSrLookupCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::benchEncodeHeaderFromMeta(_) => {
                    <benchEncodeHeaderFromMetaCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::benchEncodeHeaderFromMetaNoSrLookup(_) => {
                    <benchEncodeHeaderFromMetaNoSrLookupCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::benchFullVerifyNoStore(_) => {
                    <benchFullVerifyNoStoreCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::benchMakeBlockId(_) => {
                    <benchMakeBlockIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::benchNoop(_) => {
                    <benchNoopCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::benchRecoverSigner(_) => {
                    <benchRecoverSignerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::benchSha256AfterEncode(_) => {
                    <benchSha256AfterEncodeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::benchSrAt(_) => {
                    <benchSrAtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::benchSrAtOnly(_) => {
                    <benchSrAtOnlyCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::benchWitnessDelegateeAt(_) => {
                    <benchWitnessDelegateeAtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::decodeAt(_) => <decodeAtCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::encodeBlockHeaderPublic(_) => {
                    <encodeBlockHeaderPublicCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eventChainTip(_) => {
                    <eventChainTipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBlockId(_) => {
                    <getBlockIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBlockTimestamp(_) => {
                    <getBlockTimestampCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getTxTrieRoot(_) => {
                    <getTxTrieRootCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hashBlockPublic(_) => {
                    <hashBlockPublicCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::latestProvenBlock(_) => {
                    <latestProvenBlockCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proveBlockRange(_) => {
                    <proveBlockRangeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proveBlocks(_) => {
                    <proveBlocksCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::srs(_) => <srsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::witnessDelegatees(_) => {
                    <witnessDelegateesCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<TronLightClientHarnessCalls>] = &[
                {
                    fn witnessDelegatees(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <witnessDelegateesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::witnessDelegatees)
                    }
                    witnessDelegatees
                },
                {
                    fn proveBlocks(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <proveBlocksCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::proveBlocks)
                    }
                    proveBlocks
                },
                {
                    fn benchWitnessDelegateeAt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchWitnessDelegateeAtCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchWitnessDelegateeAt)
                    }
                    benchWitnessDelegateeAt
                },
                {
                    fn benchDecodeMinimal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchDecodeMinimalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchDecodeMinimal)
                    }
                    benchDecodeMinimal
                },
                {
                    fn benchAdvanceAndHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchAdvanceAndHashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchAdvanceAndHash)
                    }
                    benchAdvanceAndHash
                },
                {
                    fn getTxTrieRoot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <getTxTrieRootCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::getTxTrieRoot)
                    }
                    getTxTrieRoot
                },
                {
                    fn latestProvenBlock(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <latestProvenBlockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::latestProvenBlock)
                    }
                    latestProvenBlock
                },
                {
                    fn srs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <srsCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(TronLightClientHarnessCalls::srs)
                    }
                    srs
                },
                {
                    fn benchMakeBlockId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchMakeBlockIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchMakeBlockId)
                    }
                    benchMakeBlockId
                },
                {
                    fn benchFullVerifyNoStore(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchFullVerifyNoStoreCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchFullVerifyNoStore)
                    }
                    benchFullVerifyNoStore
                },
                {
                    fn getBlockTimestamp(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <getBlockTimestampCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::getBlockTimestamp)
                    }
                    getBlockTimestamp
                },
                {
                    fn eventChainTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <eventChainTipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::eventChainTip)
                    }
                    eventChainTip
                },
                {
                    fn SR_DATA_HASH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <SR_DATA_HASHCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::SR_DATA_HASH)
                    }
                    SR_DATA_HASH
                },
                {
                    fn benchDecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchDecodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchDecode)
                    }
                    benchDecode
                },
                {
                    fn proveBlockRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <proveBlockRangeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::proveBlockRange)
                    }
                    proveBlockRange
                },
                {
                    fn getBlockId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <getBlockIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::getBlockId)
                    }
                    getBlockId
                },
                {
                    fn benchRecoverSigner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchRecoverSignerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchRecoverSigner)
                    }
                    benchRecoverSigner
                },
                {
                    fn benchSrAt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchSrAtCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(TronLightClientHarnessCalls::benchSrAt)
                    }
                    benchSrAt
                },
                {
                    fn benchEncodeHeaderFromMetaNoSrLookup(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchEncodeHeaderFromMetaNoSrLookupCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                TronLightClientHarnessCalls::benchEncodeHeaderFromMetaNoSrLookup,
                            )
                    }
                    benchEncodeHeaderFromMetaNoSrLookup
                },
                {
                    fn benchNoop(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchNoopCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(TronLightClientHarnessCalls::benchNoop)
                    }
                    benchNoop
                },
                {
                    fn hashBlockPublic(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <hashBlockPublicCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::hashBlockPublic)
                    }
                    hashBlockPublic
                },
                {
                    fn encodeBlockHeaderPublic(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <encodeBlockHeaderPublicCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::encodeBlockHeaderPublic)
                    }
                    encodeBlockHeaderPublic
                },
                {
                    fn benchEncodeHeaderDirectNoSrLookup(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchEncodeHeaderDirectNoSrLookupCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                TronLightClientHarnessCalls::benchEncodeHeaderDirectNoSrLookup,
                            )
                    }
                    benchEncodeHeaderDirectNoSrLookup
                },
                {
                    fn BLOCK_RANGE_PROVER(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <BLOCK_RANGE_PROVERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::BLOCK_RANGE_PROVER)
                    }
                    BLOCK_RANGE_PROVER
                },
                {
                    fn decodeAt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <decodeAtCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(TronLightClientHarnessCalls::decodeAt)
                    }
                    decodeAt
                },
                {
                    fn benchEncodeHeaderFromMeta(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchEncodeHeaderFromMetaCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchEncodeHeaderFromMeta)
                    }
                    benchEncodeHeaderFromMeta
                },
                {
                    fn benchSha256AfterEncode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchSha256AfterEncodeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchSha256AfterEncode)
                    }
                    benchSha256AfterEncode
                },
                {
                    fn benchSrAtOnly(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchSrAtOnlyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchSrAtOnly)
                    }
                    benchSrAtOnly
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<TronLightClientHarnessCalls>] = &[
                {
                    fn witnessDelegatees(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <witnessDelegateesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::witnessDelegatees)
                    }
                    witnessDelegatees
                },
                {
                    fn proveBlocks(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <proveBlocksCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::proveBlocks)
                    }
                    proveBlocks
                },
                {
                    fn benchWitnessDelegateeAt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchWitnessDelegateeAtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchWitnessDelegateeAt)
                    }
                    benchWitnessDelegateeAt
                },
                {
                    fn benchDecodeMinimal(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchDecodeMinimalCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchDecodeMinimal)
                    }
                    benchDecodeMinimal
                },
                {
                    fn benchAdvanceAndHash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchAdvanceAndHashCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchAdvanceAndHash)
                    }
                    benchAdvanceAndHash
                },
                {
                    fn getTxTrieRoot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <getTxTrieRootCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::getTxTrieRoot)
                    }
                    getTxTrieRoot
                },
                {
                    fn latestProvenBlock(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <latestProvenBlockCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::latestProvenBlock)
                    }
                    latestProvenBlock
                },
                {
                    fn srs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <srsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::srs)
                    }
                    srs
                },
                {
                    fn benchMakeBlockId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchMakeBlockIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchMakeBlockId)
                    }
                    benchMakeBlockId
                },
                {
                    fn benchFullVerifyNoStore(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchFullVerifyNoStoreCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchFullVerifyNoStore)
                    }
                    benchFullVerifyNoStore
                },
                {
                    fn getBlockTimestamp(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <getBlockTimestampCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::getBlockTimestamp)
                    }
                    getBlockTimestamp
                },
                {
                    fn eventChainTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <eventChainTipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::eventChainTip)
                    }
                    eventChainTip
                },
                {
                    fn SR_DATA_HASH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <SR_DATA_HASHCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::SR_DATA_HASH)
                    }
                    SR_DATA_HASH
                },
                {
                    fn benchDecode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchDecodeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchDecode)
                    }
                    benchDecode
                },
                {
                    fn proveBlockRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <proveBlockRangeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::proveBlockRange)
                    }
                    proveBlockRange
                },
                {
                    fn getBlockId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <getBlockIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::getBlockId)
                    }
                    getBlockId
                },
                {
                    fn benchRecoverSigner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchRecoverSignerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchRecoverSigner)
                    }
                    benchRecoverSigner
                },
                {
                    fn benchSrAt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchSrAtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchSrAt)
                    }
                    benchSrAt
                },
                {
                    fn benchEncodeHeaderFromMetaNoSrLookup(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchEncodeHeaderFromMetaNoSrLookupCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                TronLightClientHarnessCalls::benchEncodeHeaderFromMetaNoSrLookup,
                            )
                    }
                    benchEncodeHeaderFromMetaNoSrLookup
                },
                {
                    fn benchNoop(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchNoopCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchNoop)
                    }
                    benchNoop
                },
                {
                    fn hashBlockPublic(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <hashBlockPublicCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::hashBlockPublic)
                    }
                    hashBlockPublic
                },
                {
                    fn encodeBlockHeaderPublic(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <encodeBlockHeaderPublicCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::encodeBlockHeaderPublic)
                    }
                    encodeBlockHeaderPublic
                },
                {
                    fn benchEncodeHeaderDirectNoSrLookup(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchEncodeHeaderDirectNoSrLookupCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                TronLightClientHarnessCalls::benchEncodeHeaderDirectNoSrLookup,
                            )
                    }
                    benchEncodeHeaderDirectNoSrLookup
                },
                {
                    fn BLOCK_RANGE_PROVER(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <BLOCK_RANGE_PROVERCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::BLOCK_RANGE_PROVER)
                    }
                    BLOCK_RANGE_PROVER
                },
                {
                    fn decodeAt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <decodeAtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::decodeAt)
                    }
                    decodeAt
                },
                {
                    fn benchEncodeHeaderFromMeta(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchEncodeHeaderFromMetaCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchEncodeHeaderFromMeta)
                    }
                    benchEncodeHeaderFromMeta
                },
                {
                    fn benchSha256AfterEncode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchSha256AfterEncodeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchSha256AfterEncode)
                    }
                    benchSha256AfterEncode
                },
                {
                    fn benchSrAtOnly(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessCalls> {
                        <benchSrAtOnlyCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessCalls::benchSrAtOnly)
                    }
                    benchSrAtOnly
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BLOCK_RANGE_PROVER(inner) => {
                    <BLOCK_RANGE_PROVERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SR_DATA_HASH(inner) => {
                    <SR_DATA_HASHCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::benchAdvanceAndHash(inner) => {
                    <benchAdvanceAndHashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::benchDecode(inner) => {
                    <benchDecodeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::benchDecodeMinimal(inner) => {
                    <benchDecodeMinimalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::benchEncodeHeaderDirectNoSrLookup(inner) => {
                    <benchEncodeHeaderDirectNoSrLookupCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::benchEncodeHeaderFromMeta(inner) => {
                    <benchEncodeHeaderFromMetaCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::benchEncodeHeaderFromMetaNoSrLookup(inner) => {
                    <benchEncodeHeaderFromMetaNoSrLookupCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::benchFullVerifyNoStore(inner) => {
                    <benchFullVerifyNoStoreCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::benchMakeBlockId(inner) => {
                    <benchMakeBlockIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::benchNoop(inner) => {
                    <benchNoopCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::benchRecoverSigner(inner) => {
                    <benchRecoverSignerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::benchSha256AfterEncode(inner) => {
                    <benchSha256AfterEncodeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::benchSrAt(inner) => {
                    <benchSrAtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::benchSrAtOnly(inner) => {
                    <benchSrAtOnlyCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::benchWitnessDelegateeAt(inner) => {
                    <benchWitnessDelegateeAtCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::decodeAt(inner) => {
                    <decodeAtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::encodeBlockHeaderPublic(inner) => {
                    <encodeBlockHeaderPublicCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::eventChainTip(inner) => {
                    <eventChainTipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBlockId(inner) => {
                    <getBlockIdCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getBlockTimestamp(inner) => {
                    <getBlockTimestampCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getTxTrieRoot(inner) => {
                    <getTxTrieRootCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::hashBlockPublic(inner) => {
                    <hashBlockPublicCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::latestProvenBlock(inner) => {
                    <latestProvenBlockCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proveBlockRange(inner) => {
                    <proveBlockRangeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proveBlocks(inner) => {
                    <proveBlocksCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::srs(inner) => {
                    <srsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::witnessDelegatees(inner) => {
                    <witnessDelegateesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BLOCK_RANGE_PROVER(inner) => {
                    <BLOCK_RANGE_PROVERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SR_DATA_HASH(inner) => {
                    <SR_DATA_HASHCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::benchAdvanceAndHash(inner) => {
                    <benchAdvanceAndHashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::benchDecode(inner) => {
                    <benchDecodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::benchDecodeMinimal(inner) => {
                    <benchDecodeMinimalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::benchEncodeHeaderDirectNoSrLookup(inner) => {
                    <benchEncodeHeaderDirectNoSrLookupCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::benchEncodeHeaderFromMeta(inner) => {
                    <benchEncodeHeaderFromMetaCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::benchEncodeHeaderFromMetaNoSrLookup(inner) => {
                    <benchEncodeHeaderFromMetaNoSrLookupCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::benchFullVerifyNoStore(inner) => {
                    <benchFullVerifyNoStoreCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::benchMakeBlockId(inner) => {
                    <benchMakeBlockIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::benchNoop(inner) => {
                    <benchNoopCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::benchRecoverSigner(inner) => {
                    <benchRecoverSignerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::benchSha256AfterEncode(inner) => {
                    <benchSha256AfterEncodeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::benchSrAt(inner) => {
                    <benchSrAtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::benchSrAtOnly(inner) => {
                    <benchSrAtOnlyCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::benchWitnessDelegateeAt(inner) => {
                    <benchWitnessDelegateeAtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::decodeAt(inner) => {
                    <decodeAtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::encodeBlockHeaderPublic(inner) => {
                    <encodeBlockHeaderPublicCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eventChainTip(inner) => {
                    <eventChainTipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBlockId(inner) => {
                    <getBlockIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBlockTimestamp(inner) => {
                    <getBlockTimestampCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getTxTrieRoot(inner) => {
                    <getTxTrieRootCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hashBlockPublic(inner) => {
                    <hashBlockPublicCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::latestProvenBlock(inner) => {
                    <latestProvenBlockCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proveBlockRange(inner) => {
                    <proveBlockRangeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proveBlocks(inner) => {
                    <proveBlocksCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::srs(inner) => {
                    <srsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::witnessDelegatees(inner) => {
                    <witnessDelegateesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TronLightClientHarness`](self) custom errors.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum TronLightClientHarnessErrors {
        #[allow(missing_docs)]
        BlockNotRelayed(BlockNotRelayed),
        #[allow(missing_docs)]
        BlockTooOld(BlockTooOld),
        #[allow(missing_docs)]
        CheckpointNotFinalized(CheckpointNotFinalized),
        #[allow(missing_docs)]
        InvalidChain(InvalidChain),
        #[allow(missing_docs)]
        InvalidCompressedSignaturesLength(InvalidCompressedSignaturesLength),
        #[allow(missing_docs)]
        InvalidCompressedTronBlockMetadataLength(
            InvalidCompressedTronBlockMetadataLength,
        ),
        #[allow(missing_docs)]
        InvalidIntersectionClaim(InvalidIntersectionClaim),
        #[allow(missing_docs)]
        InvalidIntersectionOffset(InvalidIntersectionOffset),
        #[allow(missing_docs)]
        InvalidParentBlockId(InvalidParentBlockId),
        #[allow(missing_docs)]
        InvalidSrIndex(InvalidSrIndex),
        #[allow(missing_docs)]
        InvalidStoreOffset(InvalidStoreOffset),
        #[allow(missing_docs)]
        InvalidWitnessDelegateeIndex(InvalidWitnessDelegateeIndex),
        #[allow(missing_docs)]
        InvalidWitnessSigner(InvalidWitnessSigner),
        #[allow(missing_docs)]
        Sha256PrecompileFailed(Sha256PrecompileFailed),
        #[allow(missing_docs)]
        SrSetNotSorted(SrSetNotSorted),
        #[allow(missing_docs)]
        StoreOffsetsNotStrictlyIncreasing(StoreOffsetsNotStrictlyIncreasing),
        #[allow(missing_docs)]
        TooManyBlocks(TooManyBlocks),
        #[allow(missing_docs)]
        UnanchoredBlockRange(UnanchoredBlockRange),
    }
    impl TronLightClientHarnessErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [18u8, 164u8, 114u8, 71u8],
            [53u8, 174u8, 144u8, 59u8],
            [63u8, 193u8, 134u8, 211u8],
            [76u8, 145u8, 147u8, 0u8],
            [89u8, 94u8, 16u8, 137u8],
            [99u8, 203u8, 90u8, 65u8],
            [103u8, 71u8, 88u8, 180u8],
            [128u8, 37u8, 176u8, 62u8],
            [143u8, 22u8, 20u8, 143u8],
            [149u8, 109u8, 24u8, 233u8],
            [158u8, 37u8, 101u8, 45u8],
            [175u8, 231u8, 244u8, 224u8],
            [194u8, 255u8, 188u8, 236u8],
            [201u8, 222u8, 113u8, 34u8],
            [221u8, 92u8, 171u8, 62u8],
            [224u8, 130u8, 132u8, 11u8],
            [240u8, 177u8, 68u8, 75u8],
            [251u8, 105u8, 168u8, 46u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(InvalidIntersectionOffset),
            ::core::stringify!(BlockNotRelayed),
            ::core::stringify!(InvalidCompressedSignaturesLength),
            ::core::stringify!(SrSetNotSorted),
            ::core::stringify!(CheckpointNotFinalized),
            ::core::stringify!(InvalidSrIndex),
            ::core::stringify!(InvalidCompressedTronBlockMetadataLength),
            ::core::stringify!(InvalidWitnessSigner),
            ::core::stringify!(StoreOffsetsNotStrictlyIncreasing),
            ::core::stringify!(InvalidIntersectionClaim),
            ::core::stringify!(UnanchoredBlockRange),
            ::core::stringify!(InvalidChain),
            ::core::stringify!(BlockTooOld),
            ::core::stringify!(InvalidParentBlockId),
            ::core::stringify!(Sha256PrecompileFailed),
            ::core::stringify!(TooManyBlocks),
            ::core::stringify!(InvalidWitnessDelegateeIndex),
            ::core::stringify!(InvalidStoreOffset),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <InvalidIntersectionOffset as alloy_sol_types::SolError>::SIGNATURE,
            <BlockNotRelayed as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidCompressedSignaturesLength as alloy_sol_types::SolError>::SIGNATURE,
            <SrSetNotSorted as alloy_sol_types::SolError>::SIGNATURE,
            <CheckpointNotFinalized as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidSrIndex as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidCompressedTronBlockMetadataLength as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidWitnessSigner as alloy_sol_types::SolError>::SIGNATURE,
            <StoreOffsetsNotStrictlyIncreasing as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidIntersectionClaim as alloy_sol_types::SolError>::SIGNATURE,
            <UnanchoredBlockRange as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidChain as alloy_sol_types::SolError>::SIGNATURE,
            <BlockTooOld as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidParentBlockId as alloy_sol_types::SolError>::SIGNATURE,
            <Sha256PrecompileFailed as alloy_sol_types::SolError>::SIGNATURE,
            <TooManyBlocks as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidWitnessDelegateeIndex as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidStoreOffset as alloy_sol_types::SolError>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TronLightClientHarnessErrors {
        const NAME: &'static str = "TronLightClientHarnessErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 18usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BlockNotRelayed(_) => {
                    <BlockNotRelayed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BlockTooOld(_) => {
                    <BlockTooOld as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CheckpointNotFinalized(_) => {
                    <CheckpointNotFinalized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidChain(_) => {
                    <InvalidChain as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidCompressedSignaturesLength(_) => {
                    <InvalidCompressedSignaturesLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidCompressedTronBlockMetadataLength(_) => {
                    <InvalidCompressedTronBlockMetadataLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidIntersectionClaim(_) => {
                    <InvalidIntersectionClaim as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidIntersectionOffset(_) => {
                    <InvalidIntersectionOffset as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidParentBlockId(_) => {
                    <InvalidParentBlockId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidSrIndex(_) => {
                    <InvalidSrIndex as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidStoreOffset(_) => {
                    <InvalidStoreOffset as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidWitnessDelegateeIndex(_) => {
                    <InvalidWitnessDelegateeIndex as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidWitnessSigner(_) => {
                    <InvalidWitnessSigner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Sha256PrecompileFailed(_) => {
                    <Sha256PrecompileFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SrSetNotSorted(_) => {
                    <SrSetNotSorted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::StoreOffsetsNotStrictlyIncreasing(_) => {
                    <StoreOffsetsNotStrictlyIncreasing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TooManyBlocks(_) => {
                    <TooManyBlocks as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnanchoredBlockRange(_) => {
                    <UnanchoredBlockRange as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<TronLightClientHarnessErrors>] = &[
                {
                    fn InvalidIntersectionOffset(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidIntersectionOffset as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::InvalidIntersectionOffset)
                    }
                    InvalidIntersectionOffset
                },
                {
                    fn BlockNotRelayed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <BlockNotRelayed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::BlockNotRelayed)
                    }
                    BlockNotRelayed
                },
                {
                    fn InvalidCompressedSignaturesLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidCompressedSignaturesLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                TronLightClientHarnessErrors::InvalidCompressedSignaturesLength,
                            )
                    }
                    InvalidCompressedSignaturesLength
                },
                {
                    fn SrSetNotSorted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <SrSetNotSorted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::SrSetNotSorted)
                    }
                    SrSetNotSorted
                },
                {
                    fn CheckpointNotFinalized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <CheckpointNotFinalized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::CheckpointNotFinalized)
                    }
                    CheckpointNotFinalized
                },
                {
                    fn InvalidSrIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidSrIndex as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::InvalidSrIndex)
                    }
                    InvalidSrIndex
                },
                {
                    fn InvalidCompressedTronBlockMetadataLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidCompressedTronBlockMetadataLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                TronLightClientHarnessErrors::InvalidCompressedTronBlockMetadataLength,
                            )
                    }
                    InvalidCompressedTronBlockMetadataLength
                },
                {
                    fn InvalidWitnessSigner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidWitnessSigner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::InvalidWitnessSigner)
                    }
                    InvalidWitnessSigner
                },
                {
                    fn StoreOffsetsNotStrictlyIncreasing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <StoreOffsetsNotStrictlyIncreasing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                TronLightClientHarnessErrors::StoreOffsetsNotStrictlyIncreasing,
                            )
                    }
                    StoreOffsetsNotStrictlyIncreasing
                },
                {
                    fn InvalidIntersectionClaim(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidIntersectionClaim as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::InvalidIntersectionClaim)
                    }
                    InvalidIntersectionClaim
                },
                {
                    fn UnanchoredBlockRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <UnanchoredBlockRange as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::UnanchoredBlockRange)
                    }
                    UnanchoredBlockRange
                },
                {
                    fn InvalidChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidChain as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(TronLightClientHarnessErrors::InvalidChain)
                    }
                    InvalidChain
                },
                {
                    fn BlockTooOld(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <BlockTooOld as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(TronLightClientHarnessErrors::BlockTooOld)
                    }
                    BlockTooOld
                },
                {
                    fn InvalidParentBlockId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidParentBlockId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::InvalidParentBlockId)
                    }
                    InvalidParentBlockId
                },
                {
                    fn Sha256PrecompileFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <Sha256PrecompileFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::Sha256PrecompileFailed)
                    }
                    Sha256PrecompileFailed
                },
                {
                    fn TooManyBlocks(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <TooManyBlocks as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::TooManyBlocks)
                    }
                    TooManyBlocks
                },
                {
                    fn InvalidWitnessDelegateeIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidWitnessDelegateeIndex as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                TronLightClientHarnessErrors::InvalidWitnessDelegateeIndex,
                            )
                    }
                    InvalidWitnessDelegateeIndex
                },
                {
                    fn InvalidStoreOffset(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidStoreOffset as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::InvalidStoreOffset)
                    }
                    InvalidStoreOffset
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<TronLightClientHarnessErrors>] = &[
                {
                    fn InvalidIntersectionOffset(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidIntersectionOffset as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::InvalidIntersectionOffset)
                    }
                    InvalidIntersectionOffset
                },
                {
                    fn BlockNotRelayed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <BlockNotRelayed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::BlockNotRelayed)
                    }
                    BlockNotRelayed
                },
                {
                    fn InvalidCompressedSignaturesLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidCompressedSignaturesLength as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                TronLightClientHarnessErrors::InvalidCompressedSignaturesLength,
                            )
                    }
                    InvalidCompressedSignaturesLength
                },
                {
                    fn SrSetNotSorted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <SrSetNotSorted as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::SrSetNotSorted)
                    }
                    SrSetNotSorted
                },
                {
                    fn CheckpointNotFinalized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <CheckpointNotFinalized as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::CheckpointNotFinalized)
                    }
                    CheckpointNotFinalized
                },
                {
                    fn InvalidSrIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidSrIndex as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::InvalidSrIndex)
                    }
                    InvalidSrIndex
                },
                {
                    fn InvalidCompressedTronBlockMetadataLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidCompressedTronBlockMetadataLength as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                TronLightClientHarnessErrors::InvalidCompressedTronBlockMetadataLength,
                            )
                    }
                    InvalidCompressedTronBlockMetadataLength
                },
                {
                    fn InvalidWitnessSigner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidWitnessSigner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::InvalidWitnessSigner)
                    }
                    InvalidWitnessSigner
                },
                {
                    fn StoreOffsetsNotStrictlyIncreasing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <StoreOffsetsNotStrictlyIncreasing as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                TronLightClientHarnessErrors::StoreOffsetsNotStrictlyIncreasing,
                            )
                    }
                    StoreOffsetsNotStrictlyIncreasing
                },
                {
                    fn InvalidIntersectionClaim(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidIntersectionClaim as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::InvalidIntersectionClaim)
                    }
                    InvalidIntersectionClaim
                },
                {
                    fn UnanchoredBlockRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <UnanchoredBlockRange as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::UnanchoredBlockRange)
                    }
                    UnanchoredBlockRange
                },
                {
                    fn InvalidChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidChain as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::InvalidChain)
                    }
                    InvalidChain
                },
                {
                    fn BlockTooOld(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <BlockTooOld as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::BlockTooOld)
                    }
                    BlockTooOld
                },
                {
                    fn InvalidParentBlockId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidParentBlockId as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::InvalidParentBlockId)
                    }
                    InvalidParentBlockId
                },
                {
                    fn Sha256PrecompileFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <Sha256PrecompileFailed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::Sha256PrecompileFailed)
                    }
                    Sha256PrecompileFailed
                },
                {
                    fn TooManyBlocks(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <TooManyBlocks as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::TooManyBlocks)
                    }
                    TooManyBlocks
                },
                {
                    fn InvalidWitnessDelegateeIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidWitnessDelegateeIndex as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                TronLightClientHarnessErrors::InvalidWitnessDelegateeIndex,
                            )
                    }
                    InvalidWitnessDelegateeIndex
                },
                {
                    fn InvalidStoreOffset(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientHarnessErrors> {
                        <InvalidStoreOffset as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientHarnessErrors::InvalidStoreOffset)
                    }
                    InvalidStoreOffset
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BlockNotRelayed(inner) => {
                    <BlockNotRelayed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BlockTooOld(inner) => {
                    <BlockTooOld as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::CheckpointNotFinalized(inner) => {
                    <CheckpointNotFinalized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidChain(inner) => {
                    <InvalidChain as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidCompressedSignaturesLength(inner) => {
                    <InvalidCompressedSignaturesLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidCompressedTronBlockMetadataLength(inner) => {
                    <InvalidCompressedTronBlockMetadataLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidIntersectionClaim(inner) => {
                    <InvalidIntersectionClaim as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidIntersectionOffset(inner) => {
                    <InvalidIntersectionOffset as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidParentBlockId(inner) => {
                    <InvalidParentBlockId as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidSrIndex(inner) => {
                    <InvalidSrIndex as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidStoreOffset(inner) => {
                    <InvalidStoreOffset as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidWitnessDelegateeIndex(inner) => {
                    <InvalidWitnessDelegateeIndex as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidWitnessSigner(inner) => {
                    <InvalidWitnessSigner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Sha256PrecompileFailed(inner) => {
                    <Sha256PrecompileFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SrSetNotSorted(inner) => {
                    <SrSetNotSorted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::StoreOffsetsNotStrictlyIncreasing(inner) => {
                    <StoreOffsetsNotStrictlyIncreasing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TooManyBlocks(inner) => {
                    <TooManyBlocks as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::UnanchoredBlockRange(inner) => {
                    <UnanchoredBlockRange as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BlockNotRelayed(inner) => {
                    <BlockNotRelayed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BlockTooOld(inner) => {
                    <BlockTooOld as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CheckpointNotFinalized(inner) => {
                    <CheckpointNotFinalized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidChain(inner) => {
                    <InvalidChain as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidCompressedSignaturesLength(inner) => {
                    <InvalidCompressedSignaturesLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidCompressedTronBlockMetadataLength(inner) => {
                    <InvalidCompressedTronBlockMetadataLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidIntersectionClaim(inner) => {
                    <InvalidIntersectionClaim as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidIntersectionOffset(inner) => {
                    <InvalidIntersectionOffset as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidParentBlockId(inner) => {
                    <InvalidParentBlockId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidSrIndex(inner) => {
                    <InvalidSrIndex as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidStoreOffset(inner) => {
                    <InvalidStoreOffset as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidWitnessDelegateeIndex(inner) => {
                    <InvalidWitnessDelegateeIndex as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidWitnessSigner(inner) => {
                    <InvalidWitnessSigner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Sha256PrecompileFailed(inner) => {
                    <Sha256PrecompileFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SrSetNotSorted(inner) => {
                    <SrSetNotSorted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::StoreOffsetsNotStrictlyIncreasing(inner) => {
                    <StoreOffsetsNotStrictlyIncreasing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TooManyBlocks(inner) => {
                    <TooManyBlocks as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnanchoredBlockRange(inner) => {
                    <UnanchoredBlockRange as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TronLightClientHarness`](self) events.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum TronLightClientHarnessEvents {
        #[allow(missing_docs)]
        LatestProvenBlockUpdated(LatestProvenBlockUpdated),
        #[allow(missing_docs)]
        TronBlockStored(TronBlockStored),
        #[allow(missing_docs)]
        TronLightClientConfigured(TronLightClientConfigured),
    }
    impl TronLightClientHarnessEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                8u8, 166u8, 123u8, 65u8, 114u8, 30u8, 109u8, 24u8, 235u8, 90u8, 63u8,
                13u8, 71u8, 83u8, 80u8, 55u8, 231u8, 85u8, 72u8, 245u8, 111u8, 249u8,
                23u8, 112u8, 216u8, 80u8, 174u8, 199u8, 191u8, 35u8, 239u8, 74u8,
            ],
            [
                25u8, 236u8, 106u8, 215u8, 69u8, 45u8, 116u8, 67u8, 130u8, 224u8, 245u8,
                144u8, 100u8, 1u8, 125u8, 202u8, 86u8, 210u8, 179u8, 185u8, 164u8, 32u8,
                38u8, 198u8, 128u8, 58u8, 252u8, 90u8, 20u8, 92u8, 209u8, 17u8,
            ],
            [
                169u8, 254u8, 112u8, 27u8, 77u8, 162u8, 255u8, 103u8, 92u8, 253u8, 13u8,
                197u8, 65u8, 251u8, 55u8, 58u8, 70u8, 167u8, 44u8, 92u8, 37u8, 138u8,
                153u8, 254u8, 133u8, 8u8, 82u8, 220u8, 117u8, 211u8, 161u8, 203u8,
            ],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(TronLightClientConfigured),
            ::core::stringify!(TronBlockStored),
            ::core::stringify!(LatestProvenBlockUpdated),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <TronLightClientConfigured as alloy_sol_types::SolEvent>::SIGNATURE,
            <TronBlockStored as alloy_sol_types::SolEvent>::SIGNATURE,
            <LatestProvenBlockUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for TronLightClientHarnessEvents {
        const NAME: &'static str = "TronLightClientHarnessEvents";
        const COUNT: usize = 3usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <LatestProvenBlockUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <LatestProvenBlockUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::LatestProvenBlockUpdated)
                }
                Some(<TronBlockStored as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TronBlockStored as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::TronBlockStored)
                }
                Some(
                    <TronLightClientConfigured as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TronLightClientConfigured as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::TronLightClientConfigured)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for TronLightClientHarnessEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::LatestProvenBlockUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TronBlockStored(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TronLightClientConfigured(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::LatestProvenBlockUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TronBlockStored(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TronLightClientConfigured(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`TronLightClientHarness`](self) contract instance.

See the [wrapper's documentation](`TronLightClientHarnessInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> TronLightClientHarnessInstance<P, N> {
        TronLightClientHarnessInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        p: alloy::sol_types::private::Address,
        initial: alloy::sol_types::private::FixedBytes<32>,
        initialTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        initialTimestamp: u32,
        srs_: [alloy::sol_types::private::FixedBytes<20>; 27usize],
        witnessDelegatees_: [alloy::sol_types::private::FixedBytes<20>; 27usize],
        srDataHash_: alloy::sol_types::private::FixedBytes<32>,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<TronLightClientHarnessInstance<P, N>>,
    > {
        TronLightClientHarnessInstance::<
            P,
            N,
        >::deploy(
            __provider,
            p,
            initial,
            initialTxTrieRoot,
            initialTimestamp,
            srs_,
            witnessDelegatees_,
            srDataHash_,
        )
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        p: alloy::sol_types::private::Address,
        initial: alloy::sol_types::private::FixedBytes<32>,
        initialTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        initialTimestamp: u32,
        srs_: [alloy::sol_types::private::FixedBytes<20>; 27usize],
        witnessDelegatees_: [alloy::sol_types::private::FixedBytes<20>; 27usize],
        srDataHash_: alloy::sol_types::private::FixedBytes<32>,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        TronLightClientHarnessInstance::<
            P,
            N,
        >::deploy_builder(
            __provider,
            p,
            initial,
            initialTxTrieRoot,
            initialTimestamp,
            srs_,
            witnessDelegatees_,
            srDataHash_,
        )
    }
    /**A [`TronLightClientHarness`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`TronLightClientHarness`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct TronLightClientHarnessInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for TronLightClientHarnessInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("TronLightClientHarnessInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > TronLightClientHarnessInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`TronLightClientHarness`](self) contract instance.

See the [wrapper's documentation](`TronLightClientHarnessInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
            p: alloy::sol_types::private::Address,
            initial: alloy::sol_types::private::FixedBytes<32>,
            initialTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
            initialTimestamp: u32,
            srs_: [alloy::sol_types::private::FixedBytes<20>; 27usize],
            witnessDelegatees_: [alloy::sol_types::private::FixedBytes<20>; 27usize],
            srDataHash_: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::Result<TronLightClientHarnessInstance<P, N>> {
            let call_builder = Self::deploy_builder(
                __provider,
                p,
                initial,
                initialTxTrieRoot,
                initialTimestamp,
                srs_,
                witnessDelegatees_,
                srDataHash_,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            __provider: P,
            p: alloy::sol_types::private::Address,
            initial: alloy::sol_types::private::FixedBytes<32>,
            initialTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
            initialTimestamp: u32,
            srs_: [alloy::sol_types::private::FixedBytes<20>; 27usize],
            witnessDelegatees_: [alloy::sol_types::private::FixedBytes<20>; 27usize],
            srDataHash_: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            p,
                            initial,
                            initialTxTrieRoot,
                            initialTimestamp,
                            srs_,
                            witnessDelegatees_,
                            srDataHash_,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> TronLightClientHarnessInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> TronLightClientHarnessInstance<P, N> {
            TronLightClientHarnessInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > TronLightClientHarnessInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`BLOCK_RANGE_PROVER`] function.
        pub fn BLOCK_RANGE_PROVER(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, BLOCK_RANGE_PROVERCall, N> {
            self.call_builder(&BLOCK_RANGE_PROVERCall)
        }
        ///Creates a new call builder for the [`SR_DATA_HASH`] function.
        pub fn SR_DATA_HASH(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, SR_DATA_HASHCall, N> {
            self.call_builder(&SR_DATA_HASHCall)
        }
        ///Creates a new call builder for the [`benchAdvanceAndHash`] function.
        pub fn benchAdvanceAndHash(
            &self,
            startingBlockId: alloy::sol_types::private::FixedBytes<32>,
            meta: alloy::sol_types::private::Bytes,
            numBlocks: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, benchAdvanceAndHashCall, N> {
            self.call_builder(
                &benchAdvanceAndHashCall {
                    startingBlockId,
                    meta,
                    numBlocks,
                },
            )
        }
        ///Creates a new call builder for the [`benchDecode`] function.
        pub fn benchDecode(
            &self,
            data: alloy::sol_types::private::Bytes,
            numBlocks: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, benchDecodeCall, N> {
            self.call_builder(&benchDecodeCall { data, numBlocks })
        }
        ///Creates a new call builder for the [`benchDecodeMinimal`] function.
        pub fn benchDecodeMinimal(
            &self,
            data: alloy::sol_types::private::Bytes,
            numBlocks: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, benchDecodeMinimalCall, N> {
            self.call_builder(
                &benchDecodeMinimalCall {
                    data,
                    numBlocks,
                },
            )
        }
        ///Creates a new call builder for the [`benchEncodeHeaderDirectNoSrLookup`] function.
        pub fn benchEncodeHeaderDirectNoSrLookup(
            &self,
            parentHash: alloy::sol_types::private::FixedBytes<32>,
            txTrieRoot: alloy::sol_types::private::FixedBytes<32>,
            timestampSec: u32,
            witness: alloy::sol_types::private::FixedBytes<20>,
            firstBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
            iters: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            benchEncodeHeaderDirectNoSrLookupCall,
            N,
        > {
            self.call_builder(
                &benchEncodeHeaderDirectNoSrLookupCall {
                    parentHash,
                    txTrieRoot,
                    timestampSec,
                    witness,
                    firstBlockNumber,
                    iters,
                },
            )
        }
        ///Creates a new call builder for the [`benchEncodeHeaderFromMeta`] function.
        pub fn benchEncodeHeaderFromMeta(
            &self,
            startingBlockId: alloy::sol_types::private::FixedBytes<32>,
            meta: alloy::sol_types::private::Bytes,
            numBlocks: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, benchEncodeHeaderFromMetaCall, N> {
            self.call_builder(
                &benchEncodeHeaderFromMetaCall {
                    startingBlockId,
                    meta,
                    numBlocks,
                },
            )
        }
        ///Creates a new call builder for the [`benchEncodeHeaderFromMetaNoSrLookup`] function.
        pub fn benchEncodeHeaderFromMetaNoSrLookup(
            &self,
            startingBlockId: alloy::sol_types::private::FixedBytes<32>,
            meta: alloy::sol_types::private::Bytes,
            numBlocks: alloy::sol_types::private::primitives::aliases::U256,
            witness: alloy::sol_types::private::FixedBytes<20>,
        ) -> alloy_contract::SolCallBuilder<
            &P,
            benchEncodeHeaderFromMetaNoSrLookupCall,
            N,
        > {
            self.call_builder(
                &benchEncodeHeaderFromMetaNoSrLookupCall {
                    startingBlockId,
                    meta,
                    numBlocks,
                    witness,
                },
            )
        }
        ///Creates a new call builder for the [`benchFullVerifyNoStore`] function.
        pub fn benchFullVerifyNoStore(
            &self,
            startingBlockId: alloy::sol_types::private::FixedBytes<32>,
            meta: alloy::sol_types::private::Bytes,
            sigs: alloy::sol_types::private::Bytes,
            numBlocks: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, benchFullVerifyNoStoreCall, N> {
            self.call_builder(
                &benchFullVerifyNoStoreCall {
                    startingBlockId,
                    meta,
                    sigs,
                    numBlocks,
                },
            )
        }
        ///Creates a new call builder for the [`benchMakeBlockId`] function.
        pub fn benchMakeBlockId(
            &self,
            startingBlockId: alloy::sol_types::private::FixedBytes<32>,
            blockHash: alloy::sol_types::private::FixedBytes<32>,
            numBlocks: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, benchMakeBlockIdCall, N> {
            self.call_builder(
                &benchMakeBlockIdCall {
                    startingBlockId,
                    blockHash,
                    numBlocks,
                },
            )
        }
        ///Creates a new call builder for the [`benchNoop`] function.
        pub fn benchNoop(
            &self,
            iters: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, benchNoopCall, N> {
            self.call_builder(&benchNoopCall { iters })
        }
        ///Creates a new call builder for the [`benchRecoverSigner`] function.
        pub fn benchRecoverSigner(
            &self,
            digest: alloy::sol_types::private::FixedBytes<32>,
            sigs: alloy::sol_types::private::Bytes,
            numBlocks: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, benchRecoverSignerCall, N> {
            self.call_builder(
                &benchRecoverSignerCall {
                    digest,
                    sigs,
                    numBlocks,
                },
            )
        }
        ///Creates a new call builder for the [`benchSha256AfterEncode`] function.
        pub fn benchSha256AfterEncode(
            &self,
            startingBlockId: alloy::sol_types::private::FixedBytes<32>,
            meta: alloy::sol_types::private::Bytes,
            numBlocks: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, benchSha256AfterEncodeCall, N> {
            self.call_builder(
                &benchSha256AfterEncodeCall {
                    startingBlockId,
                    meta,
                    numBlocks,
                },
            )
        }
        ///Creates a new call builder for the [`benchSrAt`] function.
        pub fn benchSrAt(
            &self,
            meta: alloy::sol_types::private::Bytes,
            numBlocks: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, benchSrAtCall, N> {
            self.call_builder(&benchSrAtCall { meta, numBlocks })
        }
        ///Creates a new call builder for the [`benchSrAtOnly`] function.
        pub fn benchSrAtOnly(
            &self,
            witnessIndex: u8,
            iters: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, benchSrAtOnlyCall, N> {
            self.call_builder(
                &benchSrAtOnlyCall {
                    witnessIndex,
                    iters,
                },
            )
        }
        ///Creates a new call builder for the [`benchWitnessDelegateeAt`] function.
        pub fn benchWitnessDelegateeAt(
            &self,
            meta: alloy::sol_types::private::Bytes,
            numBlocks: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, benchWitnessDelegateeAtCall, N> {
            self.call_builder(
                &benchWitnessDelegateeAtCall {
                    meta,
                    numBlocks,
                },
            )
        }
        ///Creates a new call builder for the [`decodeAt`] function.
        pub fn decodeAt(
            &self,
            data: alloy::sol_types::private::Bytes,
            idx: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, decodeAtCall, N> {
            self.call_builder(&decodeAtCall { data, idx })
        }
        ///Creates a new call builder for the [`encodeBlockHeaderPublic`] function.
        pub fn encodeBlockHeaderPublic(
            &self,
            parentHash: alloy::sol_types::private::FixedBytes<32>,
            txTrieRoot: alloy::sol_types::private::FixedBytes<32>,
            timestamp: u32,
            witnessIndex: u8,
            n: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, encodeBlockHeaderPublicCall, N> {
            self.call_builder(
                &encodeBlockHeaderPublicCall {
                    parentHash,
                    txTrieRoot,
                    timestamp,
                    witnessIndex,
                    n,
                },
            )
        }
        ///Creates a new call builder for the [`eventChainTip`] function.
        pub fn eventChainTip(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, eventChainTipCall, N> {
            self.call_builder(&eventChainTipCall)
        }
        ///Creates a new call builder for the [`getBlockId`] function.
        pub fn getBlockId(
            &self,
            blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getBlockIdCall, N> {
            self.call_builder(&getBlockIdCall { blockNumber })
        }
        ///Creates a new call builder for the [`getBlockTimestamp`] function.
        pub fn getBlockTimestamp(
            &self,
            blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getBlockTimestampCall, N> {
            self.call_builder(
                &getBlockTimestampCall {
                    blockNumber,
                },
            )
        }
        ///Creates a new call builder for the [`getTxTrieRoot`] function.
        pub fn getTxTrieRoot(
            &self,
            blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getTxTrieRootCall, N> {
            self.call_builder(&getTxTrieRootCall { blockNumber })
        }
        ///Creates a new call builder for the [`hashBlockPublic`] function.
        pub fn hashBlockPublic(
            &self,
            parentHash: alloy::sol_types::private::FixedBytes<32>,
            txTrieRoot: alloy::sol_types::private::FixedBytes<32>,
            timestamp: u32,
            witnessIndex: u8,
            n: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, hashBlockPublicCall, N> {
            self.call_builder(
                &hashBlockPublicCall {
                    parentHash,
                    txTrieRoot,
                    timestamp,
                    witnessIndex,
                    n,
                },
            )
        }
        ///Creates a new call builder for the [`latestProvenBlock`] function.
        pub fn latestProvenBlock(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, latestProvenBlockCall, N> {
            self.call_builder(&latestProvenBlockCall)
        }
        ///Creates a new call builder for the [`proveBlockRange`] function.
        pub fn proveBlockRange(
            &self,
            startingBlock: alloy::sol_types::private::FixedBytes<32>,
            endingBlock: alloy::sol_types::private::FixedBytes<32>,
            endingBlockTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
            endingBlockTimestamp: u32,
            zkProof: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, proveBlockRangeCall, N> {
            self.call_builder(
                &proveBlockRangeCall {
                    startingBlock,
                    endingBlock,
                    endingBlockTxTrieRoot,
                    endingBlockTimestamp,
                    zkProof,
                },
            )
        }
        ///Creates a new call builder for the [`proveBlocks`] function.
        pub fn proveBlocks(
            &self,
            startingBlock: alloy::sol_types::private::FixedBytes<32>,
            compressedTronBlockMetadata: alloy::sol_types::private::Bytes,
            compressedSignatures: alloy::sol_types::private::Bytes,
            intersectionOffset: alloy::sol_types::private::primitives::aliases::U256,
            storeOffsets16: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, proveBlocksCall, N> {
            self.call_builder(
                &proveBlocksCall {
                    startingBlock,
                    compressedTronBlockMetadata,
                    compressedSignatures,
                    intersectionOffset,
                    storeOffsets16,
                },
            )
        }
        ///Creates a new call builder for the [`srs`] function.
        pub fn srs(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, srsCall, N> {
            self.call_builder(&srsCall { index })
        }
        ///Creates a new call builder for the [`witnessDelegatees`] function.
        pub fn witnessDelegatees(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, witnessDelegateesCall, N> {
            self.call_builder(&witnessDelegateesCall { index })
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > TronLightClientHarnessInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`LatestProvenBlockUpdated`] event.
        pub fn LatestProvenBlockUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, LatestProvenBlockUpdated, N> {
            self.event_filter::<LatestProvenBlockUpdated>()
        }
        ///Creates a new event filter for the [`TronBlockStored`] event.
        pub fn TronBlockStored_filter(
            &self,
        ) -> alloy_contract::Event<&P, TronBlockStored, N> {
            self.event_filter::<TronBlockStored>()
        }
        ///Creates a new event filter for the [`TronLightClientConfigured`] event.
        pub fn TronLightClientConfigured_filter(
            &self,
        ) -> alloy_contract::Event<&P, TronLightClientConfigured, N> {
            self.event_filter::<TronLightClientConfigured>()
        }
    }
}
