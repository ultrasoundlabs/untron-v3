/**

Generated by the following Solidity interface...
```solidity
interface IMessageLibManager {
    struct SetConfigParam {
        uint32 eid;
        uint32 configType;
        bytes config;
    }

    event DefaultReceiveLibrarySet(uint32 eid, address newLib);
    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);
    event DefaultSendLibrarySet(uint32 eid, address newLib);
    event LibraryRegistered(address newLib);
    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);
    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);
    event SendLibrarySet(address sender, uint32 eid, address newLib);

    function defaultReceiveLibrary(uint32 _eid) external view returns (address);
    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);
    function defaultSendLibrary(uint32 _eid) external view returns (address);
    function getConfig(address _oapp, address _lib, uint32 _eid, uint32 _configType) external view returns (bytes memory config);
    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);
    function getRegisteredLibraries() external view returns (address[] memory);
    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);
    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);
    function isRegisteredLibrary(address _lib) external view returns (bool);
    function isSupportedEid(uint32 _eid) external view returns (bool);
    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);
    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);
    function registerLibrary(address _lib) external;
    function setConfig(address _oapp, address _lib, SetConfigParam[] memory _params) external;
    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _timeout) external;
    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;
    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;
    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;
    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _gracePeriod) external;
    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "defaultReceiveLibrary",
    "inputs": [
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "defaultReceiveLibraryTimeout",
    "inputs": [
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "lib",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "defaultSendLibrary",
    "inputs": [
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getConfig",
    "inputs": [
      {
        "name": "_oapp",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_lib",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "_configType",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "config",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getReceiveLibrary",
    "inputs": [
      {
        "name": "_receiver",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "lib",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "isDefault",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRegisteredLibraries",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSendLibrary",
    "inputs": [
      {
        "name": "_sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "lib",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isDefaultSendLibrary",
    "inputs": [
      {
        "name": "_sender",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isRegisteredLibrary",
    "inputs": [
      {
        "name": "_lib",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isSupportedEid",
    "inputs": [
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isValidReceiveLibrary",
    "inputs": [
      {
        "name": "_receiver",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "_lib",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "receiveLibraryTimeout",
    "inputs": [
      {
        "name": "_receiver",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "lib",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "expiry",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "registerLibrary",
    "inputs": [
      {
        "name": "_lib",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setConfig",
    "inputs": [
      {
        "name": "_oapp",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_lib",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_params",
        "type": "tuple[]",
        "internalType": "struct SetConfigParam[]",
        "components": [
          {
            "name": "eid",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "configType",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "config",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setDefaultReceiveLibrary",
    "inputs": [
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "_newLib",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_timeout",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setDefaultReceiveLibraryTimeout",
    "inputs": [
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "_lib",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_expiry",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setDefaultSendLibrary",
    "inputs": [
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "_newLib",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setReceiveLibrary",
    "inputs": [
      {
        "name": "_oapp",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "_newLib",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_gracePeriod",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setReceiveLibraryTimeout",
    "inputs": [
      {
        "name": "_oapp",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "_lib",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_gracePeriod",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setSendLibrary",
    "inputs": [
      {
        "name": "_oapp",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_eid",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "_newLib",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "DefaultReceiveLibrarySet",
    "inputs": [
      {
        "name": "eid",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      },
      {
        "name": "newLib",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DefaultReceiveLibraryTimeoutSet",
    "inputs": [
      {
        "name": "eid",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      },
      {
        "name": "oldLib",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "expiry",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DefaultSendLibrarySet",
    "inputs": [
      {
        "name": "eid",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      },
      {
        "name": "newLib",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "LibraryRegistered",
    "inputs": [
      {
        "name": "newLib",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ReceiveLibrarySet",
    "inputs": [
      {
        "name": "receiver",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "eid",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      },
      {
        "name": "newLib",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ReceiveLibraryTimeoutSet",
    "inputs": [
      {
        "name": "receiver",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "eid",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      },
      {
        "name": "oldLib",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "timeout",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SendLibrarySet",
    "inputs": [
      {
        "name": "sender",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "eid",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      },
      {
        "name": "newLib",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod IMessageLibManager {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct SetConfigParam { uint32 eid; uint32 configType; bytes config; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SetConfigParam {
        #[allow(missing_docs)]
        pub eid: u32,
        #[allow(missing_docs)]
        pub configType: u32,
        #[allow(missing_docs)]
        pub config: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u32, u32, alloy::sol_types::private::Bytes);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SetConfigParam> for UnderlyingRustTuple<'_> {
            fn from(value: SetConfigParam) -> Self {
                (value.eid, value.configType, value.config)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SetConfigParam {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    eid: tuple.0,
                    configType: tuple.1,
                    config: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SetConfigParam {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SetConfigParam {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.eid),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.configType),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.config,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SetConfigParam {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SetConfigParam {
            const NAME: &'static str = "SetConfigParam";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SetConfigParam(uint32 eid,uint32 configType,bytes config)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.eid)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.configType)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.config,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SetConfigParam {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.eid)
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.configType,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.config,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.eid, out);
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.configType,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.config,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DefaultReceiveLibrarySet(uint32,address)` and selector `0xc16891855cffb4a5ac51ac11864a3f3c96ba816cc45fe686c987ae36277de5ec`.
```solidity
event DefaultReceiveLibrarySet(uint32 eid, address newLib);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DefaultReceiveLibrarySet {
        #[allow(missing_docs)]
        pub eid: u32,
        #[allow(missing_docs)]
        pub newLib: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DefaultReceiveLibrarySet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "DefaultReceiveLibrarySet(uint32,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                193u8, 104u8, 145u8, 133u8, 92u8, 255u8, 180u8, 165u8, 172u8, 81u8,
                172u8, 17u8, 134u8, 74u8, 63u8, 60u8, 150u8, 186u8, 129u8, 108u8, 196u8,
                95u8, 230u8, 134u8, 201u8, 135u8, 174u8, 54u8, 39u8, 125u8, 229u8, 236u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    eid: data.0,
                    newLib: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.eid),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newLib,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DefaultReceiveLibrarySet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DefaultReceiveLibrarySet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &DefaultReceiveLibrarySet,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DefaultReceiveLibraryTimeoutSet(uint32,address,uint256)` and selector `0x55b28633cdb29709386f555dfc54418592ad475ce7a65a78ac5928af60ffb8f8`.
```solidity
event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DefaultReceiveLibraryTimeoutSet {
        #[allow(missing_docs)]
        pub eid: u32,
        #[allow(missing_docs)]
        pub oldLib: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub expiry: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DefaultReceiveLibraryTimeoutSet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "DefaultReceiveLibraryTimeoutSet(uint32,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                85u8, 178u8, 134u8, 51u8, 205u8, 178u8, 151u8, 9u8, 56u8, 111u8, 85u8,
                93u8, 252u8, 84u8, 65u8, 133u8, 146u8, 173u8, 71u8, 92u8, 231u8, 166u8,
                90u8, 120u8, 172u8, 89u8, 40u8, 175u8, 96u8, 255u8, 184u8, 248u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    eid: data.0,
                    oldLib: data.1,
                    expiry: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.eid),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.oldLib,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DefaultReceiveLibraryTimeoutSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DefaultReceiveLibraryTimeoutSet>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &DefaultReceiveLibraryTimeoutSet,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DefaultSendLibrarySet(uint32,address)` and selector `0x16aa0f528038ab41019e95bae5b418a50ba8532c5800e3b7ea2f517d3fa625f5`.
```solidity
event DefaultSendLibrarySet(uint32 eid, address newLib);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DefaultSendLibrarySet {
        #[allow(missing_docs)]
        pub eid: u32,
        #[allow(missing_docs)]
        pub newLib: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DefaultSendLibrarySet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "DefaultSendLibrarySet(uint32,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                22u8, 170u8, 15u8, 82u8, 128u8, 56u8, 171u8, 65u8, 1u8, 158u8, 149u8,
                186u8, 229u8, 180u8, 24u8, 165u8, 11u8, 168u8, 83u8, 44u8, 88u8, 0u8,
                227u8, 183u8, 234u8, 47u8, 81u8, 125u8, 63u8, 166u8, 37u8, 245u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    eid: data.0,
                    newLib: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.eid),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newLib,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DefaultSendLibrarySet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DefaultSendLibrarySet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &DefaultSendLibrarySet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `LibraryRegistered(address)` and selector `0x6b374d56679ca9463f27c85c6311e2bb7fde69bf201d3da39d53f10bd9d78af5`.
```solidity
event LibraryRegistered(address newLib);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct LibraryRegistered {
        #[allow(missing_docs)]
        pub newLib: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for LibraryRegistered {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "LibraryRegistered(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                107u8, 55u8, 77u8, 86u8, 103u8, 156u8, 169u8, 70u8, 63u8, 39u8, 200u8,
                92u8, 99u8, 17u8, 226u8, 187u8, 127u8, 222u8, 105u8, 191u8, 32u8, 29u8,
                61u8, 163u8, 157u8, 83u8, 241u8, 11u8, 217u8, 215u8, 138u8, 245u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { newLib: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newLib,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for LibraryRegistered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&LibraryRegistered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &LibraryRegistered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ReceiveLibrarySet(address,uint32,address)` and selector `0xcd6f92f5ac6185a5acfa02c92090746cec64d777269cbcd0ed031e396657a1c2`.
```solidity
event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ReceiveLibrarySet {
        #[allow(missing_docs)]
        pub receiver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub eid: u32,
        #[allow(missing_docs)]
        pub newLib: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ReceiveLibrarySet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ReceiveLibrarySet(address,uint32,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                205u8, 111u8, 146u8, 245u8, 172u8, 97u8, 133u8, 165u8, 172u8, 250u8, 2u8,
                201u8, 32u8, 144u8, 116u8, 108u8, 236u8, 100u8, 215u8, 119u8, 38u8,
                156u8, 188u8, 208u8, 237u8, 3u8, 30u8, 57u8, 102u8, 87u8, 161u8, 194u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    receiver: data.0,
                    eid: data.1,
                    newLib: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.eid),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newLib,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ReceiveLibrarySet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ReceiveLibrarySet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ReceiveLibrarySet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ReceiveLibraryTimeoutSet(address,uint32,address,uint256)` and selector `0x4e0a5bbfa0c11a64effb1ada324b5437a17272e1aed9320398715ef71bb20928`.
```solidity
event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ReceiveLibraryTimeoutSet {
        #[allow(missing_docs)]
        pub receiver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub eid: u32,
        #[allow(missing_docs)]
        pub oldLib: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub timeout: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ReceiveLibraryTimeoutSet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ReceiveLibraryTimeoutSet(address,uint32,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                78u8, 10u8, 91u8, 191u8, 160u8, 193u8, 26u8, 100u8, 239u8, 251u8, 26u8,
                218u8, 50u8, 75u8, 84u8, 55u8, 161u8, 114u8, 114u8, 225u8, 174u8, 217u8,
                50u8, 3u8, 152u8, 113u8, 94u8, 247u8, 27u8, 178u8, 9u8, 40u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    receiver: data.0,
                    eid: data.1,
                    oldLib: data.2,
                    timeout: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiver,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.eid),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.oldLib,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.timeout),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ReceiveLibraryTimeoutSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ReceiveLibraryTimeoutSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &ReceiveLibraryTimeoutSet,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SendLibrarySet(address,uint32,address)` and selector `0x4cff966ebee29a156dcb34cf72c1d06231fb1777f6bdf6e8089819232f002b1c`.
```solidity
event SendLibrarySet(address sender, uint32 eid, address newLib);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SendLibrarySet {
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub eid: u32,
        #[allow(missing_docs)]
        pub newLib: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SendLibrarySet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "SendLibrarySet(address,uint32,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                76u8, 255u8, 150u8, 110u8, 190u8, 226u8, 154u8, 21u8, 109u8, 203u8, 52u8,
                207u8, 114u8, 193u8, 208u8, 98u8, 49u8, 251u8, 23u8, 119u8, 246u8, 189u8,
                246u8, 232u8, 8u8, 152u8, 25u8, 35u8, 47u8, 0u8, 43u8, 28u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    sender: data.0,
                    eid: data.1,
                    newLib: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.sender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.eid),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newLib,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SendLibrarySet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SendLibrarySet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SendLibrarySet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `defaultReceiveLibrary(uint32)` and selector `0x6f50a803`.
```solidity
function defaultReceiveLibrary(uint32 _eid) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct defaultReceiveLibraryCall {
        #[allow(missing_docs)]
        pub _eid: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`defaultReceiveLibrary(uint32)`](defaultReceiveLibraryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct defaultReceiveLibraryReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<defaultReceiveLibraryCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: defaultReceiveLibraryCall) -> Self {
                    (value._eid,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for defaultReceiveLibraryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _eid: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<defaultReceiveLibraryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: defaultReceiveLibraryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for defaultReceiveLibraryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for defaultReceiveLibraryCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "defaultReceiveLibrary(uint32)";
            const SELECTOR: [u8; 4] = [111u8, 80u8, 168u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: defaultReceiveLibraryReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: defaultReceiveLibraryReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `defaultReceiveLibraryTimeout(uint32)` and selector `0x6e83f5bb`.
```solidity
function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct defaultReceiveLibraryTimeoutCall {
        #[allow(missing_docs)]
        pub _eid: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`defaultReceiveLibraryTimeout(uint32)`](defaultReceiveLibraryTimeoutCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct defaultReceiveLibraryTimeoutReturn {
        #[allow(missing_docs)]
        pub lib: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub expiry: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<defaultReceiveLibraryTimeoutCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: defaultReceiveLibraryTimeoutCall) -> Self {
                    (value._eid,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for defaultReceiveLibraryTimeoutCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _eid: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<defaultReceiveLibraryTimeoutReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: defaultReceiveLibraryTimeoutReturn) -> Self {
                    (value.lib, value.expiry)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for defaultReceiveLibraryTimeoutReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lib: tuple.0,
                        expiry: tuple.1,
                    }
                }
            }
        }
        impl defaultReceiveLibraryTimeoutReturn {
            fn _tokenize(
                &self,
            ) -> <defaultReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.lib,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for defaultReceiveLibraryTimeoutCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = defaultReceiveLibraryTimeoutReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "defaultReceiveLibraryTimeout(uint32)";
            const SELECTOR: [u8; 4] = [110u8, 131u8, 245u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                defaultReceiveLibraryTimeoutReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `defaultSendLibrary(uint32)` and selector `0xf64be4c7`.
```solidity
function defaultSendLibrary(uint32 _eid) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct defaultSendLibraryCall {
        #[allow(missing_docs)]
        pub _eid: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`defaultSendLibrary(uint32)`](defaultSendLibraryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct defaultSendLibraryReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<defaultSendLibraryCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: defaultSendLibraryCall) -> Self {
                    (value._eid,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for defaultSendLibraryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _eid: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<defaultSendLibraryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: defaultSendLibraryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for defaultSendLibraryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for defaultSendLibraryCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "defaultSendLibrary(uint32)";
            const SELECTOR: [u8; 4] = [246u8, 75u8, 228u8, 199u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: defaultSendLibraryReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: defaultSendLibraryReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getConfig(address,address,uint32,uint32)` and selector `0x2b3197b9`.
```solidity
function getConfig(address _oapp, address _lib, uint32 _eid, uint32 _configType) external view returns (bytes memory config);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getConfigCall {
        #[allow(missing_docs)]
        pub _oapp: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _lib: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _eid: u32,
        #[allow(missing_docs)]
        pub _configType: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getConfig(address,address,uint32,uint32)`](getConfigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getConfigReturn {
        #[allow(missing_docs)]
        pub config: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                u32,
                u32,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getConfigCall> for UnderlyingRustTuple<'_> {
                fn from(value: getConfigCall) -> Self {
                    (value._oapp, value._lib, value._eid, value._configType)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getConfigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _oapp: tuple.0,
                        _lib: tuple.1,
                        _eid: tuple.2,
                        _configType: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getConfigReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getConfigReturn) -> Self {
                    (value.config,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getConfigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { config: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getConfigCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Bytes;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getConfig(address,address,uint32,uint32)";
            const SELECTOR: [u8; 4] = [43u8, 49u8, 151u8, 185u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._oapp,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._lib,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._configType),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getConfigReturn = r.into();
                        r.config
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getConfigReturn = r.into();
                        r.config
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getReceiveLibrary(address,uint32)` and selector `0x402f8468`.
```solidity
function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getReceiveLibraryCall {
        #[allow(missing_docs)]
        pub _receiver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _eid: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getReceiveLibrary(address,uint32)`](getReceiveLibraryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getReceiveLibraryReturn {
        #[allow(missing_docs)]
        pub lib: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub isDefault: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getReceiveLibraryCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getReceiveLibraryCall) -> Self {
                    (value._receiver, value._eid)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getReceiveLibraryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _receiver: tuple.0,
                        _eid: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getReceiveLibraryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getReceiveLibraryReturn) -> Self {
                    (value.lib, value.isDefault)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getReceiveLibraryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lib: tuple.0,
                        isDefault: tuple.1,
                    }
                }
            }
        }
        impl getReceiveLibraryReturn {
            fn _tokenize(
                &self,
            ) -> <getReceiveLibraryCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.lib,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.isDefault,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getReceiveLibraryCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getReceiveLibraryReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getReceiveLibrary(address,uint32)";
            const SELECTOR: [u8; 4] = [64u8, 47u8, 132u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._receiver,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                getReceiveLibraryReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRegisteredLibraries()` and selector `0x9132e5c3`.
```solidity
function getRegisteredLibraries() external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRegisteredLibrariesCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRegisteredLibraries()`](getRegisteredLibrariesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRegisteredLibrariesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRegisteredLibrariesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRegisteredLibrariesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRegisteredLibrariesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRegisteredLibrariesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getRegisteredLibrariesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getRegisteredLibrariesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRegisteredLibrariesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRegisteredLibraries()";
            const SELECTOR: [u8; 4] = [145u8, 50u8, 229u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRegisteredLibrariesReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRegisteredLibrariesReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getSendLibrary(address,uint32)` and selector `0xb96a277f`.
```solidity
function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSendLibraryCall {
        #[allow(missing_docs)]
        pub _sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _eid: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getSendLibrary(address,uint32)`](getSendLibraryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSendLibraryReturn {
        #[allow(missing_docs)]
        pub lib: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSendLibraryCall> for UnderlyingRustTuple<'_> {
                fn from(value: getSendLibraryCall) -> Self {
                    (value._sender, value._eid)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getSendLibraryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _sender: tuple.0,
                        _eid: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSendLibraryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSendLibraryReturn) -> Self {
                    (value.lib,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSendLibraryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { lib: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSendLibraryCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSendLibrary(address,uint32)";
            const SELECTOR: [u8; 4] = [185u8, 106u8, 39u8, 127u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._sender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getSendLibraryReturn = r.into();
                        r.lib
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getSendLibraryReturn = r.into();
                        r.lib
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isDefaultSendLibrary(address,uint32)` and selector `0xdc93c8a2`.
```solidity
function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isDefaultSendLibraryCall {
        #[allow(missing_docs)]
        pub _sender: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _eid: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isDefaultSendLibrary(address,uint32)`](isDefaultSendLibraryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isDefaultSendLibraryReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isDefaultSendLibraryCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isDefaultSendLibraryCall) -> Self {
                    (value._sender, value._eid)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isDefaultSendLibraryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _sender: tuple.0,
                        _eid: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isDefaultSendLibraryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isDefaultSendLibraryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isDefaultSendLibraryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isDefaultSendLibraryCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isDefaultSendLibrary(address,uint32)";
            const SELECTOR: [u8; 4] = [220u8, 147u8, 200u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._sender,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isDefaultSendLibraryReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isDefaultSendLibraryReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isRegisteredLibrary(address)` and selector `0xdc706a62`.
```solidity
function isRegisteredLibrary(address _lib) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isRegisteredLibraryCall {
        #[allow(missing_docs)]
        pub _lib: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isRegisteredLibrary(address)`](isRegisteredLibraryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isRegisteredLibraryReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isRegisteredLibraryCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isRegisteredLibraryCall) -> Self {
                    (value._lib,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isRegisteredLibraryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _lib: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isRegisteredLibraryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isRegisteredLibraryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isRegisteredLibraryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isRegisteredLibraryCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isRegisteredLibrary(address)";
            const SELECTOR: [u8; 4] = [220u8, 112u8, 106u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._lib,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isRegisteredLibraryReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isRegisteredLibraryReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isSupportedEid(uint32)` and selector `0x6750cd4c`.
```solidity
function isSupportedEid(uint32 _eid) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isSupportedEidCall {
        #[allow(missing_docs)]
        pub _eid: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isSupportedEid(uint32)`](isSupportedEidCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isSupportedEidReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isSupportedEidCall> for UnderlyingRustTuple<'_> {
                fn from(value: isSupportedEidCall) -> Self {
                    (value._eid,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isSupportedEidCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _eid: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isSupportedEidReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isSupportedEidReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isSupportedEidReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isSupportedEidCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isSupportedEid(uint32)";
            const SELECTOR: [u8; 4] = [103u8, 80u8, 205u8, 76u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isSupportedEidReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isSupportedEidReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isValidReceiveLibrary(address,uint32,address)` and selector `0x9d7f9775`.
```solidity
function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isValidReceiveLibraryCall {
        #[allow(missing_docs)]
        pub _receiver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _eid: u32,
        #[allow(missing_docs)]
        pub _lib: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isValidReceiveLibrary(address,uint32,address)`](isValidReceiveLibraryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isValidReceiveLibraryReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                u32,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isValidReceiveLibraryCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isValidReceiveLibraryCall) -> Self {
                    (value._receiver, value._eid, value._lib)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isValidReceiveLibraryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _receiver: tuple.0,
                        _eid: tuple.1,
                        _lib: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isValidReceiveLibraryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isValidReceiveLibraryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isValidReceiveLibraryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isValidReceiveLibraryCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isValidReceiveLibrary(address,uint32,address)";
            const SELECTOR: [u8; 4] = [157u8, 127u8, 151u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._receiver,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._lib,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isValidReceiveLibraryReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isValidReceiveLibraryReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `receiveLibraryTimeout(address,uint32)` and selector `0xef667aa1`.
```solidity
function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct receiveLibraryTimeoutCall {
        #[allow(missing_docs)]
        pub _receiver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _eid: u32,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`receiveLibraryTimeout(address,uint32)`](receiveLibraryTimeoutCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct receiveLibraryTimeoutReturn {
        #[allow(missing_docs)]
        pub lib: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub expiry: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<receiveLibraryTimeoutCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: receiveLibraryTimeoutCall) -> Self {
                    (value._receiver, value._eid)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for receiveLibraryTimeoutCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _receiver: tuple.0,
                        _eid: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<receiveLibraryTimeoutReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: receiveLibraryTimeoutReturn) -> Self {
                    (value.lib, value.expiry)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for receiveLibraryTimeoutReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        lib: tuple.0,
                        expiry: tuple.1,
                    }
                }
            }
        }
        impl receiveLibraryTimeoutReturn {
            fn _tokenize(
                &self,
            ) -> <receiveLibraryTimeoutCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.lib,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for receiveLibraryTimeoutCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = receiveLibraryTimeoutReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "receiveLibraryTimeout(address,uint32)";
            const SELECTOR: [u8; 4] = [239u8, 102u8, 122u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._receiver,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                receiveLibraryTimeoutReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `registerLibrary(address)` and selector `0xe8964e81`.
```solidity
function registerLibrary(address _lib) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerLibraryCall {
        #[allow(missing_docs)]
        pub _lib: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`registerLibrary(address)`](registerLibraryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerLibraryReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerLibraryCall> for UnderlyingRustTuple<'_> {
                fn from(value: registerLibraryCall) -> Self {
                    (value._lib,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registerLibraryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _lib: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerLibraryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: registerLibraryReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for registerLibraryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl registerLibraryReturn {
            fn _tokenize(
                &self,
            ) -> <registerLibraryCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for registerLibraryCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = registerLibraryReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "registerLibrary(address)";
            const SELECTOR: [u8; 4] = [232u8, 150u8, 78u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._lib,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                registerLibraryReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setConfig(address,address,(uint32,uint32,bytes)[])` and selector `0x6dbd9f90`.
```solidity
function setConfig(address _oapp, address _lib, SetConfigParam[] memory _params) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setConfigCall {
        #[allow(missing_docs)]
        pub _oapp: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _lib: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _params: alloy::sol_types::private::Vec<
            <SetConfigParam as alloy::sol_types::SolType>::RustType,
        >,
    }
    ///Container type for the return parameters of the [`setConfig(address,address,(uint32,uint32,bytes)[])`](setConfigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setConfigReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<SetConfigParam>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Vec<
                    <SetConfigParam as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setConfigCall> for UnderlyingRustTuple<'_> {
                fn from(value: setConfigCall) -> Self {
                    (value._oapp, value._lib, value._params)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setConfigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _oapp: tuple.0,
                        _lib: tuple.1,
                        _params: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setConfigReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setConfigReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setConfigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setConfigReturn {
            fn _tokenize(
                &self,
            ) -> <setConfigCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setConfigCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<SetConfigParam>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setConfigReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setConfig(address,address,(uint32,uint32,bytes)[])";
            const SELECTOR: [u8; 4] = [109u8, 189u8, 159u8, 144u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._oapp,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._lib,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        SetConfigParam,
                    > as alloy_sol_types::SolType>::tokenize(&self._params),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setConfigReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setDefaultReceiveLibrary(uint32,address,uint256)` and selector `0xa718531b`.
```solidity
function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _timeout) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDefaultReceiveLibraryCall {
        #[allow(missing_docs)]
        pub _eid: u32,
        #[allow(missing_docs)]
        pub _newLib: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _timeout: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setDefaultReceiveLibrary(uint32,address,uint256)`](setDefaultReceiveLibraryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDefaultReceiveLibraryReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u32,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDefaultReceiveLibraryCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setDefaultReceiveLibraryCall) -> Self {
                    (value._eid, value._newLib, value._timeout)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setDefaultReceiveLibraryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _eid: tuple.0,
                        _newLib: tuple.1,
                        _timeout: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDefaultReceiveLibraryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setDefaultReceiveLibraryReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setDefaultReceiveLibraryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setDefaultReceiveLibraryReturn {
            fn _tokenize(
                &self,
            ) -> <setDefaultReceiveLibraryCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setDefaultReceiveLibraryCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setDefaultReceiveLibraryReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setDefaultReceiveLibrary(uint32,address,uint256)";
            const SELECTOR: [u8; 4] = [167u8, 24u8, 83u8, 27u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._newLib,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._timeout),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setDefaultReceiveLibraryReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setDefaultReceiveLibraryTimeout(uint32,address,uint256)` and selector `0xd4b4ec8f`.
```solidity
function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDefaultReceiveLibraryTimeoutCall {
        #[allow(missing_docs)]
        pub _eid: u32,
        #[allow(missing_docs)]
        pub _lib: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _expiry: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setDefaultReceiveLibraryTimeout(uint32,address,uint256)`](setDefaultReceiveLibraryTimeoutCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDefaultReceiveLibraryTimeoutReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u32,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDefaultReceiveLibraryTimeoutCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setDefaultReceiveLibraryTimeoutCall) -> Self {
                    (value._eid, value._lib, value._expiry)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setDefaultReceiveLibraryTimeoutCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _eid: tuple.0,
                        _lib: tuple.1,
                        _expiry: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDefaultReceiveLibraryTimeoutReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setDefaultReceiveLibraryTimeoutReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setDefaultReceiveLibraryTimeoutReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setDefaultReceiveLibraryTimeoutReturn {
            fn _tokenize(
                &self,
            ) -> <setDefaultReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setDefaultReceiveLibraryTimeoutCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setDefaultReceiveLibraryTimeoutReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setDefaultReceiveLibraryTimeout(uint32,address,uint256)";
            const SELECTOR: [u8; 4] = [212u8, 180u8, 236u8, 143u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._lib,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._expiry),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setDefaultReceiveLibraryTimeoutReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setDefaultSendLibrary(uint32,address)` and selector `0xaafea312`.
```solidity
function setDefaultSendLibrary(uint32 _eid, address _newLib) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDefaultSendLibraryCall {
        #[allow(missing_docs)]
        pub _eid: u32,
        #[allow(missing_docs)]
        pub _newLib: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setDefaultSendLibrary(uint32,address)`](setDefaultSendLibraryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDefaultSendLibraryReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDefaultSendLibraryCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setDefaultSendLibraryCall) -> Self {
                    (value._eid, value._newLib)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setDefaultSendLibraryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _eid: tuple.0,
                        _newLib: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDefaultSendLibraryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setDefaultSendLibraryReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setDefaultSendLibraryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setDefaultSendLibraryReturn {
            fn _tokenize(
                &self,
            ) -> <setDefaultSendLibraryCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setDefaultSendLibraryCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setDefaultSendLibraryReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setDefaultSendLibrary(uint32,address)";
            const SELECTOR: [u8; 4] = [170u8, 254u8, 163u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._newLib,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setDefaultSendLibraryReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setReceiveLibrary(address,uint32,address,uint256)` and selector `0x6a14d715`.
```solidity
function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setReceiveLibraryCall {
        #[allow(missing_docs)]
        pub _oapp: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _eid: u32,
        #[allow(missing_docs)]
        pub _newLib: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _gracePeriod: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setReceiveLibrary(address,uint32,address,uint256)`](setReceiveLibraryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setReceiveLibraryReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                u32,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setReceiveLibraryCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setReceiveLibraryCall) -> Self {
                    (value._oapp, value._eid, value._newLib, value._gracePeriod)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setReceiveLibraryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _oapp: tuple.0,
                        _eid: tuple.1,
                        _newLib: tuple.2,
                        _gracePeriod: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setReceiveLibraryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setReceiveLibraryReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setReceiveLibraryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setReceiveLibraryReturn {
            fn _tokenize(
                &self,
            ) -> <setReceiveLibraryCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setReceiveLibraryCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setReceiveLibraryReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setReceiveLibrary(address,uint32,address,uint256)";
            const SELECTOR: [u8; 4] = [106u8, 20u8, 215u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._oapp,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._newLib,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._gracePeriod),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setReceiveLibraryReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setReceiveLibraryTimeout(address,uint32,address,uint256)` and selector `0x183c834f`.
```solidity
function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _gracePeriod) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setReceiveLibraryTimeoutCall {
        #[allow(missing_docs)]
        pub _oapp: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _eid: u32,
        #[allow(missing_docs)]
        pub _lib: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _gracePeriod: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setReceiveLibraryTimeout(address,uint32,address,uint256)`](setReceiveLibraryTimeoutCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setReceiveLibraryTimeoutReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                u32,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setReceiveLibraryTimeoutCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setReceiveLibraryTimeoutCall) -> Self {
                    (value._oapp, value._eid, value._lib, value._gracePeriod)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setReceiveLibraryTimeoutCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _oapp: tuple.0,
                        _eid: tuple.1,
                        _lib: tuple.2,
                        _gracePeriod: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setReceiveLibraryTimeoutReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setReceiveLibraryTimeoutReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setReceiveLibraryTimeoutReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setReceiveLibraryTimeoutReturn {
            fn _tokenize(
                &self,
            ) -> <setReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setReceiveLibraryTimeoutCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setReceiveLibraryTimeoutReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setReceiveLibraryTimeout(address,uint32,address,uint256)";
            const SELECTOR: [u8; 4] = [24u8, 60u8, 131u8, 79u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._oapp,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._lib,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._gracePeriod),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setReceiveLibraryTimeoutReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setSendLibrary(address,uint32,address)` and selector `0x9535ff30`.
```solidity
function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSendLibraryCall {
        #[allow(missing_docs)]
        pub _oapp: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _eid: u32,
        #[allow(missing_docs)]
        pub _newLib: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setSendLibrary(address,uint32,address)`](setSendLibraryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSendLibraryReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                u32,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSendLibraryCall> for UnderlyingRustTuple<'_> {
                fn from(value: setSendLibraryCall) -> Self {
                    (value._oapp, value._eid, value._newLib)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setSendLibraryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _oapp: tuple.0,
                        _eid: tuple.1,
                        _newLib: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSendLibraryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSendLibraryReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSendLibraryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setSendLibraryReturn {
            fn _tokenize(
                &self,
            ) -> <setSendLibraryCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setSendLibraryCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setSendLibraryReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setSendLibrary(address,uint32,address)";
            const SELECTOR: [u8; 4] = [149u8, 53u8, 255u8, 48u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._oapp,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self._eid),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._newLib,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setSendLibraryReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`IMessageLibManager`](self) function calls.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum IMessageLibManagerCalls {
        #[allow(missing_docs)]
        defaultReceiveLibrary(defaultReceiveLibraryCall),
        #[allow(missing_docs)]
        defaultReceiveLibraryTimeout(defaultReceiveLibraryTimeoutCall),
        #[allow(missing_docs)]
        defaultSendLibrary(defaultSendLibraryCall),
        #[allow(missing_docs)]
        getConfig(getConfigCall),
        #[allow(missing_docs)]
        getReceiveLibrary(getReceiveLibraryCall),
        #[allow(missing_docs)]
        getRegisteredLibraries(getRegisteredLibrariesCall),
        #[allow(missing_docs)]
        getSendLibrary(getSendLibraryCall),
        #[allow(missing_docs)]
        isDefaultSendLibrary(isDefaultSendLibraryCall),
        #[allow(missing_docs)]
        isRegisteredLibrary(isRegisteredLibraryCall),
        #[allow(missing_docs)]
        isSupportedEid(isSupportedEidCall),
        #[allow(missing_docs)]
        isValidReceiveLibrary(isValidReceiveLibraryCall),
        #[allow(missing_docs)]
        receiveLibraryTimeout(receiveLibraryTimeoutCall),
        #[allow(missing_docs)]
        registerLibrary(registerLibraryCall),
        #[allow(missing_docs)]
        setConfig(setConfigCall),
        #[allow(missing_docs)]
        setDefaultReceiveLibrary(setDefaultReceiveLibraryCall),
        #[allow(missing_docs)]
        setDefaultReceiveLibraryTimeout(setDefaultReceiveLibraryTimeoutCall),
        #[allow(missing_docs)]
        setDefaultSendLibrary(setDefaultSendLibraryCall),
        #[allow(missing_docs)]
        setReceiveLibrary(setReceiveLibraryCall),
        #[allow(missing_docs)]
        setReceiveLibraryTimeout(setReceiveLibraryTimeoutCall),
        #[allow(missing_docs)]
        setSendLibrary(setSendLibraryCall),
    }
    impl IMessageLibManagerCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [24u8, 60u8, 131u8, 79u8],
            [43u8, 49u8, 151u8, 185u8],
            [64u8, 47u8, 132u8, 104u8],
            [103u8, 80u8, 205u8, 76u8],
            [106u8, 20u8, 215u8, 21u8],
            [109u8, 189u8, 159u8, 144u8],
            [110u8, 131u8, 245u8, 187u8],
            [111u8, 80u8, 168u8, 3u8],
            [145u8, 50u8, 229u8, 195u8],
            [149u8, 53u8, 255u8, 48u8],
            [157u8, 127u8, 151u8, 117u8],
            [167u8, 24u8, 83u8, 27u8],
            [170u8, 254u8, 163u8, 18u8],
            [185u8, 106u8, 39u8, 127u8],
            [212u8, 180u8, 236u8, 143u8],
            [220u8, 112u8, 106u8, 98u8],
            [220u8, 147u8, 200u8, 162u8],
            [232u8, 150u8, 78u8, 129u8],
            [239u8, 102u8, 122u8, 161u8],
            [246u8, 75u8, 228u8, 199u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(setReceiveLibraryTimeout),
            ::core::stringify!(getConfig),
            ::core::stringify!(getReceiveLibrary),
            ::core::stringify!(isSupportedEid),
            ::core::stringify!(setReceiveLibrary),
            ::core::stringify!(setConfig),
            ::core::stringify!(defaultReceiveLibraryTimeout),
            ::core::stringify!(defaultReceiveLibrary),
            ::core::stringify!(getRegisteredLibraries),
            ::core::stringify!(setSendLibrary),
            ::core::stringify!(isValidReceiveLibrary),
            ::core::stringify!(setDefaultReceiveLibrary),
            ::core::stringify!(setDefaultSendLibrary),
            ::core::stringify!(getSendLibrary),
            ::core::stringify!(setDefaultReceiveLibraryTimeout),
            ::core::stringify!(isRegisteredLibrary),
            ::core::stringify!(isDefaultSendLibrary),
            ::core::stringify!(registerLibrary),
            ::core::stringify!(receiveLibraryTimeout),
            ::core::stringify!(defaultSendLibrary),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <setReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getConfigCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getReceiveLibraryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isSupportedEidCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setReceiveLibraryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setConfigCall as alloy_sol_types::SolCall>::SIGNATURE,
            <defaultReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::SIGNATURE,
            <defaultReceiveLibraryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getRegisteredLibrariesCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setSendLibraryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isValidReceiveLibraryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setDefaultReceiveLibraryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setDefaultSendLibraryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getSendLibraryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setDefaultReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isRegisteredLibraryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isDefaultSendLibraryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <registerLibraryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <receiveLibraryTimeoutCall as alloy_sol_types::SolCall>::SIGNATURE,
            <defaultSendLibraryCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for IMessageLibManagerCalls {
        const NAME: &'static str = "IMessageLibManagerCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 20usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::defaultReceiveLibrary(_) => {
                    <defaultReceiveLibraryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::defaultReceiveLibraryTimeout(_) => {
                    <defaultReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::defaultSendLibrary(_) => {
                    <defaultSendLibraryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getConfig(_) => {
                    <getConfigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getReceiveLibrary(_) => {
                    <getReceiveLibraryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRegisteredLibraries(_) => {
                    <getRegisteredLibrariesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSendLibrary(_) => {
                    <getSendLibraryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isDefaultSendLibrary(_) => {
                    <isDefaultSendLibraryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isRegisteredLibrary(_) => {
                    <isRegisteredLibraryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isSupportedEid(_) => {
                    <isSupportedEidCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isValidReceiveLibrary(_) => {
                    <isValidReceiveLibraryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::receiveLibraryTimeout(_) => {
                    <receiveLibraryTimeoutCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::registerLibrary(_) => {
                    <registerLibraryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setConfig(_) => {
                    <setConfigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setDefaultReceiveLibrary(_) => {
                    <setDefaultReceiveLibraryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setDefaultReceiveLibraryTimeout(_) => {
                    <setDefaultReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setDefaultSendLibrary(_) => {
                    <setDefaultSendLibraryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setReceiveLibrary(_) => {
                    <setReceiveLibraryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setReceiveLibraryTimeout(_) => {
                    <setReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setSendLibrary(_) => {
                    <setSendLibraryCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<IMessageLibManagerCalls>] = &[
                {
                    fn setReceiveLibraryTimeout(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <setReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::setReceiveLibraryTimeout)
                    }
                    setReceiveLibraryTimeout
                },
                {
                    fn getConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <getConfigCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(IMessageLibManagerCalls::getConfig)
                    }
                    getConfig
                },
                {
                    fn getReceiveLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <getReceiveLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::getReceiveLibrary)
                    }
                    getReceiveLibrary
                },
                {
                    fn isSupportedEid(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <isSupportedEidCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::isSupportedEid)
                    }
                    isSupportedEid
                },
                {
                    fn setReceiveLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <setReceiveLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::setReceiveLibrary)
                    }
                    setReceiveLibrary
                },
                {
                    fn setConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <setConfigCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(IMessageLibManagerCalls::setConfig)
                    }
                    setConfig
                },
                {
                    fn defaultReceiveLibraryTimeout(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <defaultReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::defaultReceiveLibraryTimeout)
                    }
                    defaultReceiveLibraryTimeout
                },
                {
                    fn defaultReceiveLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <defaultReceiveLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::defaultReceiveLibrary)
                    }
                    defaultReceiveLibrary
                },
                {
                    fn getRegisteredLibraries(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <getRegisteredLibrariesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::getRegisteredLibraries)
                    }
                    getRegisteredLibraries
                },
                {
                    fn setSendLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <setSendLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::setSendLibrary)
                    }
                    setSendLibrary
                },
                {
                    fn isValidReceiveLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <isValidReceiveLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::isValidReceiveLibrary)
                    }
                    isValidReceiveLibrary
                },
                {
                    fn setDefaultReceiveLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <setDefaultReceiveLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::setDefaultReceiveLibrary)
                    }
                    setDefaultReceiveLibrary
                },
                {
                    fn setDefaultSendLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <setDefaultSendLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::setDefaultSendLibrary)
                    }
                    setDefaultSendLibrary
                },
                {
                    fn getSendLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <getSendLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::getSendLibrary)
                    }
                    getSendLibrary
                },
                {
                    fn setDefaultReceiveLibraryTimeout(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <setDefaultReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                IMessageLibManagerCalls::setDefaultReceiveLibraryTimeout,
                            )
                    }
                    setDefaultReceiveLibraryTimeout
                },
                {
                    fn isRegisteredLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <isRegisteredLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::isRegisteredLibrary)
                    }
                    isRegisteredLibrary
                },
                {
                    fn isDefaultSendLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <isDefaultSendLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::isDefaultSendLibrary)
                    }
                    isDefaultSendLibrary
                },
                {
                    fn registerLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <registerLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::registerLibrary)
                    }
                    registerLibrary
                },
                {
                    fn receiveLibraryTimeout(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <receiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::receiveLibraryTimeout)
                    }
                    receiveLibraryTimeout
                },
                {
                    fn defaultSendLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <defaultSendLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IMessageLibManagerCalls::defaultSendLibrary)
                    }
                    defaultSendLibrary
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<IMessageLibManagerCalls>] = &[
                {
                    fn setReceiveLibraryTimeout(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <setReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::setReceiveLibraryTimeout)
                    }
                    setReceiveLibraryTimeout
                },
                {
                    fn getConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <getConfigCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::getConfig)
                    }
                    getConfig
                },
                {
                    fn getReceiveLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <getReceiveLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::getReceiveLibrary)
                    }
                    getReceiveLibrary
                },
                {
                    fn isSupportedEid(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <isSupportedEidCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::isSupportedEid)
                    }
                    isSupportedEid
                },
                {
                    fn setReceiveLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <setReceiveLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::setReceiveLibrary)
                    }
                    setReceiveLibrary
                },
                {
                    fn setConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <setConfigCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::setConfig)
                    }
                    setConfig
                },
                {
                    fn defaultReceiveLibraryTimeout(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <defaultReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::defaultReceiveLibraryTimeout)
                    }
                    defaultReceiveLibraryTimeout
                },
                {
                    fn defaultReceiveLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <defaultReceiveLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::defaultReceiveLibrary)
                    }
                    defaultReceiveLibrary
                },
                {
                    fn getRegisteredLibraries(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <getRegisteredLibrariesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::getRegisteredLibraries)
                    }
                    getRegisteredLibraries
                },
                {
                    fn setSendLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <setSendLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::setSendLibrary)
                    }
                    setSendLibrary
                },
                {
                    fn isValidReceiveLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <isValidReceiveLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::isValidReceiveLibrary)
                    }
                    isValidReceiveLibrary
                },
                {
                    fn setDefaultReceiveLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <setDefaultReceiveLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::setDefaultReceiveLibrary)
                    }
                    setDefaultReceiveLibrary
                },
                {
                    fn setDefaultSendLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <setDefaultSendLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::setDefaultSendLibrary)
                    }
                    setDefaultSendLibrary
                },
                {
                    fn getSendLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <getSendLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::getSendLibrary)
                    }
                    getSendLibrary
                },
                {
                    fn setDefaultReceiveLibraryTimeout(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <setDefaultReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                IMessageLibManagerCalls::setDefaultReceiveLibraryTimeout,
                            )
                    }
                    setDefaultReceiveLibraryTimeout
                },
                {
                    fn isRegisteredLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <isRegisteredLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::isRegisteredLibrary)
                    }
                    isRegisteredLibrary
                },
                {
                    fn isDefaultSendLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <isDefaultSendLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::isDefaultSendLibrary)
                    }
                    isDefaultSendLibrary
                },
                {
                    fn registerLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <registerLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::registerLibrary)
                    }
                    registerLibrary
                },
                {
                    fn receiveLibraryTimeout(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <receiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::receiveLibraryTimeout)
                    }
                    receiveLibraryTimeout
                },
                {
                    fn defaultSendLibrary(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IMessageLibManagerCalls> {
                        <defaultSendLibraryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IMessageLibManagerCalls::defaultSendLibrary)
                    }
                    defaultSendLibrary
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::defaultReceiveLibrary(inner) => {
                    <defaultReceiveLibraryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::defaultReceiveLibraryTimeout(inner) => {
                    <defaultReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::defaultSendLibrary(inner) => {
                    <defaultSendLibraryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getConfig(inner) => {
                    <getConfigCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getReceiveLibrary(inner) => {
                    <getReceiveLibraryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRegisteredLibraries(inner) => {
                    <getRegisteredLibrariesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getSendLibrary(inner) => {
                    <getSendLibraryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isDefaultSendLibrary(inner) => {
                    <isDefaultSendLibraryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isRegisteredLibrary(inner) => {
                    <isRegisteredLibraryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isSupportedEid(inner) => {
                    <isSupportedEidCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isValidReceiveLibrary(inner) => {
                    <isValidReceiveLibraryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::receiveLibraryTimeout(inner) => {
                    <receiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::registerLibrary(inner) => {
                    <registerLibraryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setConfig(inner) => {
                    <setConfigCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setDefaultReceiveLibrary(inner) => {
                    <setDefaultReceiveLibraryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setDefaultReceiveLibraryTimeout(inner) => {
                    <setDefaultReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setDefaultSendLibrary(inner) => {
                    <setDefaultSendLibraryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setReceiveLibrary(inner) => {
                    <setReceiveLibraryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setReceiveLibraryTimeout(inner) => {
                    <setReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setSendLibrary(inner) => {
                    <setSendLibraryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::defaultReceiveLibrary(inner) => {
                    <defaultReceiveLibraryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::defaultReceiveLibraryTimeout(inner) => {
                    <defaultReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::defaultSendLibrary(inner) => {
                    <defaultSendLibraryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getConfig(inner) => {
                    <getConfigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getReceiveLibrary(inner) => {
                    <getReceiveLibraryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRegisteredLibraries(inner) => {
                    <getRegisteredLibrariesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSendLibrary(inner) => {
                    <getSendLibraryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isDefaultSendLibrary(inner) => {
                    <isDefaultSendLibraryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isRegisteredLibrary(inner) => {
                    <isRegisteredLibraryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isSupportedEid(inner) => {
                    <isSupportedEidCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isValidReceiveLibrary(inner) => {
                    <isValidReceiveLibraryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::receiveLibraryTimeout(inner) => {
                    <receiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::registerLibrary(inner) => {
                    <registerLibraryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setConfig(inner) => {
                    <setConfigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setDefaultReceiveLibrary(inner) => {
                    <setDefaultReceiveLibraryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setDefaultReceiveLibraryTimeout(inner) => {
                    <setDefaultReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setDefaultSendLibrary(inner) => {
                    <setDefaultSendLibraryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setReceiveLibrary(inner) => {
                    <setReceiveLibraryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setReceiveLibraryTimeout(inner) => {
                    <setReceiveLibraryTimeoutCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setSendLibrary(inner) => {
                    <setSendLibraryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`IMessageLibManager`](self) events.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum IMessageLibManagerEvents {
        #[allow(missing_docs)]
        DefaultReceiveLibrarySet(DefaultReceiveLibrarySet),
        #[allow(missing_docs)]
        DefaultReceiveLibraryTimeoutSet(DefaultReceiveLibraryTimeoutSet),
        #[allow(missing_docs)]
        DefaultSendLibrarySet(DefaultSendLibrarySet),
        #[allow(missing_docs)]
        LibraryRegistered(LibraryRegistered),
        #[allow(missing_docs)]
        ReceiveLibrarySet(ReceiveLibrarySet),
        #[allow(missing_docs)]
        ReceiveLibraryTimeoutSet(ReceiveLibraryTimeoutSet),
        #[allow(missing_docs)]
        SendLibrarySet(SendLibrarySet),
    }
    impl IMessageLibManagerEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                22u8, 170u8, 15u8, 82u8, 128u8, 56u8, 171u8, 65u8, 1u8, 158u8, 149u8,
                186u8, 229u8, 180u8, 24u8, 165u8, 11u8, 168u8, 83u8, 44u8, 88u8, 0u8,
                227u8, 183u8, 234u8, 47u8, 81u8, 125u8, 63u8, 166u8, 37u8, 245u8,
            ],
            [
                76u8, 255u8, 150u8, 110u8, 190u8, 226u8, 154u8, 21u8, 109u8, 203u8, 52u8,
                207u8, 114u8, 193u8, 208u8, 98u8, 49u8, 251u8, 23u8, 119u8, 246u8, 189u8,
                246u8, 232u8, 8u8, 152u8, 25u8, 35u8, 47u8, 0u8, 43u8, 28u8,
            ],
            [
                78u8, 10u8, 91u8, 191u8, 160u8, 193u8, 26u8, 100u8, 239u8, 251u8, 26u8,
                218u8, 50u8, 75u8, 84u8, 55u8, 161u8, 114u8, 114u8, 225u8, 174u8, 217u8,
                50u8, 3u8, 152u8, 113u8, 94u8, 247u8, 27u8, 178u8, 9u8, 40u8,
            ],
            [
                85u8, 178u8, 134u8, 51u8, 205u8, 178u8, 151u8, 9u8, 56u8, 111u8, 85u8,
                93u8, 252u8, 84u8, 65u8, 133u8, 146u8, 173u8, 71u8, 92u8, 231u8, 166u8,
                90u8, 120u8, 172u8, 89u8, 40u8, 175u8, 96u8, 255u8, 184u8, 248u8,
            ],
            [
                107u8, 55u8, 77u8, 86u8, 103u8, 156u8, 169u8, 70u8, 63u8, 39u8, 200u8,
                92u8, 99u8, 17u8, 226u8, 187u8, 127u8, 222u8, 105u8, 191u8, 32u8, 29u8,
                61u8, 163u8, 157u8, 83u8, 241u8, 11u8, 217u8, 215u8, 138u8, 245u8,
            ],
            [
                193u8, 104u8, 145u8, 133u8, 92u8, 255u8, 180u8, 165u8, 172u8, 81u8,
                172u8, 17u8, 134u8, 74u8, 63u8, 60u8, 150u8, 186u8, 129u8, 108u8, 196u8,
                95u8, 230u8, 134u8, 201u8, 135u8, 174u8, 54u8, 39u8, 125u8, 229u8, 236u8,
            ],
            [
                205u8, 111u8, 146u8, 245u8, 172u8, 97u8, 133u8, 165u8, 172u8, 250u8, 2u8,
                201u8, 32u8, 144u8, 116u8, 108u8, 236u8, 100u8, 215u8, 119u8, 38u8,
                156u8, 188u8, 208u8, 237u8, 3u8, 30u8, 57u8, 102u8, 87u8, 161u8, 194u8,
            ],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(DefaultSendLibrarySet),
            ::core::stringify!(SendLibrarySet),
            ::core::stringify!(ReceiveLibraryTimeoutSet),
            ::core::stringify!(DefaultReceiveLibraryTimeoutSet),
            ::core::stringify!(LibraryRegistered),
            ::core::stringify!(DefaultReceiveLibrarySet),
            ::core::stringify!(ReceiveLibrarySet),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <DefaultSendLibrarySet as alloy_sol_types::SolEvent>::SIGNATURE,
            <SendLibrarySet as alloy_sol_types::SolEvent>::SIGNATURE,
            <ReceiveLibraryTimeoutSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <DefaultReceiveLibraryTimeoutSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <LibraryRegistered as alloy_sol_types::SolEvent>::SIGNATURE,
            <DefaultReceiveLibrarySet as alloy_sol_types::SolEvent>::SIGNATURE,
            <ReceiveLibrarySet as alloy_sol_types::SolEvent>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for IMessageLibManagerEvents {
        const NAME: &'static str = "IMessageLibManagerEvents";
        const COUNT: usize = 7usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <DefaultReceiveLibrarySet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DefaultReceiveLibrarySet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::DefaultReceiveLibrarySet)
                }
                Some(
                    <DefaultReceiveLibraryTimeoutSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DefaultReceiveLibraryTimeoutSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::DefaultReceiveLibraryTimeoutSet)
                }
                Some(
                    <DefaultSendLibrarySet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DefaultSendLibrarySet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::DefaultSendLibrarySet)
                }
                Some(
                    <LibraryRegistered as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <LibraryRegistered as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::LibraryRegistered)
                }
                Some(
                    <ReceiveLibrarySet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ReceiveLibrarySet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ReceiveLibrarySet)
                }
                Some(
                    <ReceiveLibraryTimeoutSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ReceiveLibraryTimeoutSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ReceiveLibraryTimeoutSet)
                }
                Some(<SendLibrarySet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <SendLibrarySet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::SendLibrarySet)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for IMessageLibManagerEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::DefaultReceiveLibrarySet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DefaultReceiveLibraryTimeoutSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DefaultSendLibrarySet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::LibraryRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ReceiveLibrarySet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ReceiveLibraryTimeoutSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SendLibrarySet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::DefaultReceiveLibrarySet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DefaultReceiveLibraryTimeoutSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DefaultSendLibrarySet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::LibraryRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ReceiveLibrarySet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ReceiveLibraryTimeoutSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SendLibrarySet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`IMessageLibManager`](self) contract instance.

See the [wrapper's documentation](`IMessageLibManagerInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> IMessageLibManagerInstance<P, N> {
        IMessageLibManagerInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<IMessageLibManagerInstance<P, N>>,
    > {
        IMessageLibManagerInstance::<P, N>::deploy(__provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        IMessageLibManagerInstance::<P, N>::deploy_builder(__provider)
    }
    /**A [`IMessageLibManager`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`IMessageLibManager`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct IMessageLibManagerInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for IMessageLibManagerInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("IMessageLibManagerInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > IMessageLibManagerInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`IMessageLibManager`](self) contract instance.

See the [wrapper's documentation](`IMessageLibManagerInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
        ) -> alloy_contract::Result<IMessageLibManagerInstance<P, N>> {
            let call_builder = Self::deploy_builder(__provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> IMessageLibManagerInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> IMessageLibManagerInstance<P, N> {
            IMessageLibManagerInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > IMessageLibManagerInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`defaultReceiveLibrary`] function.
        pub fn defaultReceiveLibrary(
            &self,
            _eid: u32,
        ) -> alloy_contract::SolCallBuilder<&P, defaultReceiveLibraryCall, N> {
            self.call_builder(&defaultReceiveLibraryCall { _eid })
        }
        ///Creates a new call builder for the [`defaultReceiveLibraryTimeout`] function.
        pub fn defaultReceiveLibraryTimeout(
            &self,
            _eid: u32,
        ) -> alloy_contract::SolCallBuilder<&P, defaultReceiveLibraryTimeoutCall, N> {
            self.call_builder(
                &defaultReceiveLibraryTimeoutCall {
                    _eid,
                },
            )
        }
        ///Creates a new call builder for the [`defaultSendLibrary`] function.
        pub fn defaultSendLibrary(
            &self,
            _eid: u32,
        ) -> alloy_contract::SolCallBuilder<&P, defaultSendLibraryCall, N> {
            self.call_builder(&defaultSendLibraryCall { _eid })
        }
        ///Creates a new call builder for the [`getConfig`] function.
        pub fn getConfig(
            &self,
            _oapp: alloy::sol_types::private::Address,
            _lib: alloy::sol_types::private::Address,
            _eid: u32,
            _configType: u32,
        ) -> alloy_contract::SolCallBuilder<&P, getConfigCall, N> {
            self.call_builder(
                &getConfigCall {
                    _oapp,
                    _lib,
                    _eid,
                    _configType,
                },
            )
        }
        ///Creates a new call builder for the [`getReceiveLibrary`] function.
        pub fn getReceiveLibrary(
            &self,
            _receiver: alloy::sol_types::private::Address,
            _eid: u32,
        ) -> alloy_contract::SolCallBuilder<&P, getReceiveLibraryCall, N> {
            self.call_builder(
                &getReceiveLibraryCall {
                    _receiver,
                    _eid,
                },
            )
        }
        ///Creates a new call builder for the [`getRegisteredLibraries`] function.
        pub fn getRegisteredLibraries(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, getRegisteredLibrariesCall, N> {
            self.call_builder(&getRegisteredLibrariesCall)
        }
        ///Creates a new call builder for the [`getSendLibrary`] function.
        pub fn getSendLibrary(
            &self,
            _sender: alloy::sol_types::private::Address,
            _eid: u32,
        ) -> alloy_contract::SolCallBuilder<&P, getSendLibraryCall, N> {
            self.call_builder(
                &getSendLibraryCall {
                    _sender,
                    _eid,
                },
            )
        }
        ///Creates a new call builder for the [`isDefaultSendLibrary`] function.
        pub fn isDefaultSendLibrary(
            &self,
            _sender: alloy::sol_types::private::Address,
            _eid: u32,
        ) -> alloy_contract::SolCallBuilder<&P, isDefaultSendLibraryCall, N> {
            self.call_builder(
                &isDefaultSendLibraryCall {
                    _sender,
                    _eid,
                },
            )
        }
        ///Creates a new call builder for the [`isRegisteredLibrary`] function.
        pub fn isRegisteredLibrary(
            &self,
            _lib: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isRegisteredLibraryCall, N> {
            self.call_builder(&isRegisteredLibraryCall { _lib })
        }
        ///Creates a new call builder for the [`isSupportedEid`] function.
        pub fn isSupportedEid(
            &self,
            _eid: u32,
        ) -> alloy_contract::SolCallBuilder<&P, isSupportedEidCall, N> {
            self.call_builder(&isSupportedEidCall { _eid })
        }
        ///Creates a new call builder for the [`isValidReceiveLibrary`] function.
        pub fn isValidReceiveLibrary(
            &self,
            _receiver: alloy::sol_types::private::Address,
            _eid: u32,
            _lib: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isValidReceiveLibraryCall, N> {
            self.call_builder(
                &isValidReceiveLibraryCall {
                    _receiver,
                    _eid,
                    _lib,
                },
            )
        }
        ///Creates a new call builder for the [`receiveLibraryTimeout`] function.
        pub fn receiveLibraryTimeout(
            &self,
            _receiver: alloy::sol_types::private::Address,
            _eid: u32,
        ) -> alloy_contract::SolCallBuilder<&P, receiveLibraryTimeoutCall, N> {
            self.call_builder(
                &receiveLibraryTimeoutCall {
                    _receiver,
                    _eid,
                },
            )
        }
        ///Creates a new call builder for the [`registerLibrary`] function.
        pub fn registerLibrary(
            &self,
            _lib: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, registerLibraryCall, N> {
            self.call_builder(&registerLibraryCall { _lib })
        }
        ///Creates a new call builder for the [`setConfig`] function.
        pub fn setConfig(
            &self,
            _oapp: alloy::sol_types::private::Address,
            _lib: alloy::sol_types::private::Address,
            _params: alloy::sol_types::private::Vec<
                <SetConfigParam as alloy::sol_types::SolType>::RustType,
            >,
        ) -> alloy_contract::SolCallBuilder<&P, setConfigCall, N> {
            self.call_builder(
                &setConfigCall {
                    _oapp,
                    _lib,
                    _params,
                },
            )
        }
        ///Creates a new call builder for the [`setDefaultReceiveLibrary`] function.
        pub fn setDefaultReceiveLibrary(
            &self,
            _eid: u32,
            _newLib: alloy::sol_types::private::Address,
            _timeout: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, setDefaultReceiveLibraryCall, N> {
            self.call_builder(
                &setDefaultReceiveLibraryCall {
                    _eid,
                    _newLib,
                    _timeout,
                },
            )
        }
        ///Creates a new call builder for the [`setDefaultReceiveLibraryTimeout`] function.
        pub fn setDefaultReceiveLibraryTimeout(
            &self,
            _eid: u32,
            _lib: alloy::sol_types::private::Address,
            _expiry: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, setDefaultReceiveLibraryTimeoutCall, N> {
            self.call_builder(
                &setDefaultReceiveLibraryTimeoutCall {
                    _eid,
                    _lib,
                    _expiry,
                },
            )
        }
        ///Creates a new call builder for the [`setDefaultSendLibrary`] function.
        pub fn setDefaultSendLibrary(
            &self,
            _eid: u32,
            _newLib: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setDefaultSendLibraryCall, N> {
            self.call_builder(
                &setDefaultSendLibraryCall {
                    _eid,
                    _newLib,
                },
            )
        }
        ///Creates a new call builder for the [`setReceiveLibrary`] function.
        pub fn setReceiveLibrary(
            &self,
            _oapp: alloy::sol_types::private::Address,
            _eid: u32,
            _newLib: alloy::sol_types::private::Address,
            _gracePeriod: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, setReceiveLibraryCall, N> {
            self.call_builder(
                &setReceiveLibraryCall {
                    _oapp,
                    _eid,
                    _newLib,
                    _gracePeriod,
                },
            )
        }
        ///Creates a new call builder for the [`setReceiveLibraryTimeout`] function.
        pub fn setReceiveLibraryTimeout(
            &self,
            _oapp: alloy::sol_types::private::Address,
            _eid: u32,
            _lib: alloy::sol_types::private::Address,
            _gracePeriod: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, setReceiveLibraryTimeoutCall, N> {
            self.call_builder(
                &setReceiveLibraryTimeoutCall {
                    _oapp,
                    _eid,
                    _lib,
                    _gracePeriod,
                },
            )
        }
        ///Creates a new call builder for the [`setSendLibrary`] function.
        pub fn setSendLibrary(
            &self,
            _oapp: alloy::sol_types::private::Address,
            _eid: u32,
            _newLib: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setSendLibraryCall, N> {
            self.call_builder(
                &setSendLibraryCall {
                    _oapp,
                    _eid,
                    _newLib,
                },
            )
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > IMessageLibManagerInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`DefaultReceiveLibrarySet`] event.
        pub fn DefaultReceiveLibrarySet_filter(
            &self,
        ) -> alloy_contract::Event<&P, DefaultReceiveLibrarySet, N> {
            self.event_filter::<DefaultReceiveLibrarySet>()
        }
        ///Creates a new event filter for the [`DefaultReceiveLibraryTimeoutSet`] event.
        pub fn DefaultReceiveLibraryTimeoutSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, DefaultReceiveLibraryTimeoutSet, N> {
            self.event_filter::<DefaultReceiveLibraryTimeoutSet>()
        }
        ///Creates a new event filter for the [`DefaultSendLibrarySet`] event.
        pub fn DefaultSendLibrarySet_filter(
            &self,
        ) -> alloy_contract::Event<&P, DefaultSendLibrarySet, N> {
            self.event_filter::<DefaultSendLibrarySet>()
        }
        ///Creates a new event filter for the [`LibraryRegistered`] event.
        pub fn LibraryRegistered_filter(
            &self,
        ) -> alloy_contract::Event<&P, LibraryRegistered, N> {
            self.event_filter::<LibraryRegistered>()
        }
        ///Creates a new event filter for the [`ReceiveLibrarySet`] event.
        pub fn ReceiveLibrarySet_filter(
            &self,
        ) -> alloy_contract::Event<&P, ReceiveLibrarySet, N> {
            self.event_filter::<ReceiveLibrarySet>()
        }
        ///Creates a new event filter for the [`ReceiveLibraryTimeoutSet`] event.
        pub fn ReceiveLibraryTimeoutSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, ReceiveLibraryTimeoutSet, N> {
            self.event_filter::<ReceiveLibraryTimeoutSet>()
        }
        ///Creates a new event filter for the [`SendLibrarySet`] event.
        pub fn SendLibrarySet_filter(
            &self,
        ) -> alloy_contract::Event<&P, SendLibrarySet, N> {
            self.event_filter::<SendLibrarySet>()
        }
    }
}
