/**

Generated by the following Solidity interface...
```solidity
interface TronLightClient {
    error BlockNotRelayed();
    error BlockTooOld();
    error CheckpointNotFinalized(uint256 offset, uint8 distinct);
    error InvalidChain();
    error InvalidCompressedSignaturesLength();
    error InvalidCompressedTronBlockMetadataLength();
    error InvalidIntersectionClaim(uint256 blockNumber, bytes32 blockId);
    error InvalidIntersectionOffset(uint256 intersectionOffset, uint256 numBlocks);
    error InvalidParentBlockId(bytes32 yours, bytes32 real);
    error InvalidSrIndex(uint256 index);
    error InvalidStoreOffset(uint256 offset, uint256 numBlocks);
    error InvalidWitnessDelegateeIndex(uint256 index);
    error InvalidWitnessSigner();
    error Sha256PrecompileFailed();
    error SrSetNotSorted(uint256 index, bytes20 prev, bytes20 next);
    error StoreOffsetsNotStrictlyIncreasing(uint256 prev, uint256 next);
    error TooManyBlocks(uint256 numBlocks);
    error UnanchoredBlockRange();

    event LatestProvenBlockUpdated(bytes32 indexed previousLatest, bytes32 indexed newLatest, uint256 newBlockNumber);
    event TronBlockStored(uint256 indexed blockNumber, bytes32 indexed blockId, bytes32 txTrieRoot, uint32 timestamp);
    event TronLightClientConfigured(address indexed blockRangeProver, bytes32 indexed srDataHash, bytes32 indexed initialBlockId, bytes32 initialTxTrieRoot, uint32 initialTimestamp, bytes20[27] srs, bytes20[27] witnessDelegatees);

    constructor(address blockRangeProver, bytes32 initialBlockHash, bytes32 initialTxTrieRoot, uint32 initialTimestamp, bytes20[27] _srs, bytes20[27] _witnessDelegatees, bytes32 srDataHash);

    function BLOCK_RANGE_PROVER() external view returns (address);
    function SR_DATA_HASH() external view returns (bytes32);
    function eventChainTip() external view returns (bytes32);
    function getBlockId(uint256 blockNumber) external view returns (bytes32 blockId);
    function getBlockTimestamp(uint256 blockNumber) external view returns (uint32 timestamp);
    function getTxTrieRoot(uint256 blockNumber) external view returns (bytes32 txTrieRoot);
    function latestProvenBlock() external view returns (bytes32);
    function proveBlockRange(bytes32 startingBlock, bytes32 endingBlock, bytes32 endingBlockTxTrieRoot, uint32 endingBlockTimestamp, bytes memory zkProof) external;
    function proveBlocks(bytes32 startingBlock, bytes memory compressedTronBlockMetadata, bytes memory compressedSignatures, uint256 intersectionOffset, uint256 storeOffsets16) external;
    function srs(uint256 index) external view returns (bytes20 sr);
    function witnessDelegatees(uint256 index) external view returns (bytes20 delegatee);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "blockRangeProver",
        "type": "address",
        "internalType": "contract IBlockRangeProver"
      },
      {
        "name": "initialBlockHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "initialTxTrieRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "initialTimestamp",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "_srs",
        "type": "bytes20[27]",
        "internalType": "bytes20[27]"
      },
      {
        "name": "_witnessDelegatees",
        "type": "bytes20[27]",
        "internalType": "bytes20[27]"
      },
      {
        "name": "srDataHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "BLOCK_RANGE_PROVER",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBlockRangeProver"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SR_DATA_HASH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eventChainTip",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBlockId",
    "inputs": [
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "blockId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBlockTimestamp",
    "inputs": [
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "timestamp",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getTxTrieRoot",
    "inputs": [
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "txTrieRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "latestProvenBlock",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proveBlockRange",
    "inputs": [
      {
        "name": "startingBlock",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "endingBlock",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "endingBlockTxTrieRoot",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "endingBlockTimestamp",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "zkProof",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "proveBlocks",
    "inputs": [
      {
        "name": "startingBlock",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "compressedTronBlockMetadata",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "compressedSignatures",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "intersectionOffset",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "storeOffsets16",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "srs",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "sr",
        "type": "bytes20",
        "internalType": "bytes20"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "witnessDelegatees",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "delegatee",
        "type": "bytes20",
        "internalType": "bytes20"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "LatestProvenBlockUpdated",
    "inputs": [
      {
        "name": "previousLatest",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newLatest",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newBlockNumber",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TronBlockStored",
    "inputs": [
      {
        "name": "blockNumber",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "blockId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "txTrieRoot",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "timestamp",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TronLightClientConfigured",
    "inputs": [
      {
        "name": "blockRangeProver",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "srDataHash",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "initialBlockId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "initialTxTrieRoot",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "initialTimestamp",
        "type": "uint32",
        "indexed": false,
        "internalType": "uint32"
      },
      {
        "name": "srs",
        "type": "bytes20[27]",
        "indexed": false,
        "internalType": "bytes20[27]"
      },
      {
        "name": "witnessDelegatees",
        "type": "bytes20[27]",
        "indexed": false,
        "internalType": "bytes20[27]"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "BlockNotRelayed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "BlockTooOld",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CheckpointNotFinalized",
    "inputs": [
      {
        "name": "offset",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "distinct",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidChain",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidCompressedSignaturesLength",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidCompressedTronBlockMetadataLength",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidIntersectionClaim",
    "inputs": [
      {
        "name": "blockNumber",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "blockId",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidIntersectionOffset",
    "inputs": [
      {
        "name": "intersectionOffset",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidParentBlockId",
    "inputs": [
      {
        "name": "yours",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "real",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidSrIndex",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidStoreOffset",
    "inputs": [
      {
        "name": "offset",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidWitnessDelegateeIndex",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidWitnessSigner",
    "inputs": []
  },
  {
    "type": "error",
    "name": "Sha256PrecompileFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SrSetNotSorted",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "prev",
        "type": "bytes20",
        "internalType": "bytes20"
      },
      {
        "name": "next",
        "type": "bytes20",
        "internalType": "bytes20"
      }
    ]
  },
  {
    "type": "error",
    "name": "StoreOffsetsNotStrictlyIncreasing",
    "inputs": [
      {
        "name": "prev",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "next",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "TooManyBlocks",
    "inputs": [
      {
        "name": "numBlocks",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "UnanchoredBlockRange",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod TronLightClient {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x610920604052610162610780818152600291612a2d6107a0396040516020016100289190610880565b60408051601f1981840301815290829052610042916108b8565b602060405180830381855afa15801561005d573d5f5f3e3d5ffd5b5050506040513d601f19601f8201168201806040525081019061008091906108c3565b5f5534801561008d575f5ffd5b50604051612bcf380380612bcf8339810160408190526100ac91610975565b6001600160a01b03871660805260015b601b811015610152575f846100d2600184610a04565b601b81106100e2576100e2610a29565b602002015190505f8583601b81106100fc576100fc610a29565b60200201519050606081811c9083901c1061014857604051624c919360e81b8152600481018490526001600160601b031980841660248301528216604482015260640160405180910390fd5b50506001016100bc565b50825f60200201516001600160601b03191660a05282600160200201516001600160601b03191660c05282600260200201516001600160601b03191660e05282600360200201516001600160601b0319166101005282600460200201516001600160601b0319166101205282600560200201516001600160601b0319166101405282600660200201516001600160601b0319166101605282600760200201516001600160601b0319166101805282600860200201516001600160601b0319166101a05282600960200201516001600160601b0319166101c05282600a60200201516001600160601b0319166101e05282600b60200201516001600160601b0319166102005282600c60200201516001600160601b0319166102205282600d60200201516001600160601b0319166102405282600e60200201516001600160601b0319166102605282600f60200201516001600160601b0319166102805282601060200201516001600160601b0319166102a05282601160200201516001600160601b0319166102c05282601260200201516001600160601b0319166102e05282601360200201516001600160601b0319166103005282601460200201516001600160601b0319166103205282601560200201516001600160601b0319166103405282601660200201516001600160601b0319166103605282601760200201516001600160601b0319166103805282601860200201516001600160601b0319166103a05282601960200201516001600160601b0319166103c05282601a60200201516001600160601b0319166103e052815f60200201516001600160601b0319166104005281600160200201516001600160601b0319166104205281600260200201516001600160601b0319166104405281600360200201516001600160601b0319166104605281600460200201516001600160601b0319166104805281600560200201516001600160601b0319166104a05281600660200201516001600160601b0319166104c05281600760200201516001600160601b0319166104e05281600860200201516001600160601b0319166105005281600960200201516001600160601b0319166105205281600a60200201516001600160601b0319166105405281600b60200201516001600160601b0319166105605281600c60200201516001600160601b0319166105805281600d60200201516001600160601b0319166105a05281600e60200201516001600160601b0319166105c05281600f60200201516001600160601b0319166105e05281601060200201516001600160601b0319166106005281601160200201516001600160601b0319166106205281601260200201516001600160601b0319166106405281601360200201516001600160601b0319166106605281601460200201516001600160601b0319166106805281601560200201516001600160601b0319166106a05281601660200201516001600160601b0319166106c05281601760200201516001600160601b0319166106e05281601860200201516001600160601b0319166107005281601960200201516001600160601b0319166107205281601a60200201516001600160601b031916610740526107608190526106078782888888888861061e565b6106128686866106a0565b50505050505050610b2e565b6106615f516020612a0d5f395f51905f528888888888888860405160200161064c9796959493929190610a6f565b60408051601f1981840301815291905261071b565b8486886001600160a01b03165f516020612a0d5f395f51905f528787878760405161068f9493929190610ac8565b60405180910390a450505050505050565b5f6106ab8460c01c90565b5f8181526002602090815260408083208890556003825280832087905560049091529020805463ffffffff191663ffffffff851617905590506106f081858585610795565b600154816106fe8260c01c90565b1015610714576001859055610714818684610809565b5050505050565b60025f5443428585604051602001610737959493929190610b00565b60408051601f1981840301815290829052610751916108b8565b602060405180830381855afa15801561076c573d5f5f3e3d5ffd5b5050506040513d601f19601f8201168201806040525081019061078f91906108c3565b5f555050565b60408051602081018690529081018490526060810183905263ffffffff821660808201526107d4905f516020612b8f5f395f51905f529060a00161064c565b6040805183815263ffffffff83166020820152849186915f516020612b8f5f395f51905f52910160405180910390a350505050565b60408051602081018590529081018390526060810182905261083c905f516020612baf5f395f51905f529060800161064c565b81835f516020612baf5f395f51905f528360405161085c91815260200190565b60405180910390a3505050565b5f81518060208401855e5f93019283525090919050565b7f54726f6e4c69676874436c69656e74496e6465780a000000000000000000000081525f6108b16015830184610869565b9392505050565b5f6108b18284610869565b5f602082840312156108d3575f5ffd5b5051919050565b80516001600160601b0319811681146108f1575f5ffd5b919050565b5f82601f830112610905575f5ffd5b60405161036081016001600160401b038111828210171561093457634e487b7160e01b5f52604160045260245ffd5b60405280610360840185811115610949575f5ffd5b845b8181101561096a5761095c816108da565b83526020928301920161094b565b509195945050505050565b5f5f5f5f5f5f5f610760888a03121561098c575f5ffd5b87516001600160a01b03811681146109a2575f5ffd5b602089015160408a015160608b0151929950909750955063ffffffff811681146109ca575f5ffd5b93506109d98960808a016108f6565b92506109e9896103e08a016108f6565b91505f61074089015190508091505092959891949750929550565b81810381811115610a2357634e487b7160e01b5f52601160045260245ffd5b92915050565b634e487b7160e01b5f52603260045260245ffd5b805f5b601b811015610a695781516001600160601b031916845260209384019390910190600101610a40565b50505050565b6001600160a01b038816815260208101879052604081018690526060810185905263ffffffff841660808201526107608101610aae60a0830185610a3d565b610abc610400830184610a3d565b98975050505050505050565b84815263ffffffff841660208201526107008101610ae96040830185610a3d565b610af76103a0830184610a3d565b95945050505050565b8581528460208201528360408201528260608201525f610b236080830184610869565b979650505050505050565b60805160a05160c05160e05161010051610120516101405161016051610180516101a0516101c0516101e05161020051610220516102405161026051610280516102a0516102c0516102e05161030051610320516103405161036051610380516103a0516103c0516103e05161040051610420516104405161046051610480516104a0516104c0516104e05161050051610520516105405161056051610580516105a0516105c0516105e05161060051610620516106405161066051610680516106a0516106c0516106e05161070051610720516107405161076051611c96610d775f395f8181610167015261048b01525f6109fc01525f6109cd01525f61099e01525f61096f01525f61094001525f61091101525f6108e201525f6108b301525f61088401525f61085501525f61082601525f6107f701525f6107c801525f61079901525f61076a01525f61073b01525f61070c01525f6106dd01525f6106ae01525f61067f01525f61065001525f61062101525f6105f201525f6105c301525f61059401525f61056501525f61053601525f61130001525f6112d101525f6112a201525f61127301525f61124401525f61121501525f6111e601525f6111b701525f61118801525f61115901525f61112a01525f6110fb01525f6110cc01525f61109d01525f61106e01525f61103f01525f61101001525f610fe101525f610fb201525f610f8301525f610f5401525f610f2501525f610ef601525f610ec701525f610e9801525f610e6901525f610e3a01525f81816101b4015261045e0152611c965ff3fe608060405234801561000f575f5ffd5b50600436106100a6575f3560e01c806347e26f1a1161006e57806347e26f1a146101325780634d53e9311461015a57806356dd9c1014610162578063810b38fa1461018957806381e1d4fa1461019c578063c57312b3146101af575f5ffd5b806312d713c2146100aa578063175767dc146100e0578063295b3d61146100f557806336429b231461011657806339adfeff1461011f575b5f5ffd5b6100bd6100b83660046119c3565b6101ee565b6040516bffffffffffffffffffffffff1990911681526020015b60405180910390f35b6100f36100ee366004611a1f565b6101fe565b005b6101086101033660046119c3565b610397565b6040519081526020016100d7565b61010860015481565b6100bd61012d3660046119c3565b6103d6565b6101456101403660046119c3565b6103e0565b60405163ffffffff90911681526020016100d7565b6101085f5481565b6101087f000000000000000000000000000000000000000000000000000000000000000081565b6100f3610197366004611aa6565b610425565b6101086101aa3660046119c3565b6104ff565b6101d67f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100d7565b5f6101f88261052b565b92915050565b848015806102155750610212604582611b30565b15155b15610233576040516319d1d62d60e21b815260040160405180910390fd5b5f61023f604583611b57565b905061ffff81111561026c5760405163e082840b60e01b8152600481018290526024015b60405180910390fd5b610277604182611b6a565b851461029657604051633fc186d360e01b815260040160405180910390fd5b6102cb6040518060a001604052805f81526020015f81526020015f81526020015f151581526020015f63ffffffff1681525090565b8981526102d88a60c01c90565b602082018190526102e9908b610a3c565b1580156060830152610325575f198514610320576040516312a4724760e01b81526004810186905260248101839052604401610263565b61034f565b81851061034f576040516312a4724760e01b81526004810186905260248101839052604401610263565b6103598483610a83565b610369818a8a8a8a878b8b610b49565b806060015161038b57604051639e25652d60e01b815260040160405180910390fd5b50505050505050505050565b5f81815260026020526040812054806103c3576040516335ae903b60e01b815260040160405180910390fd5b50505f9081526003602052604090205490565b5f6101f882610e2f565b5f818152600260205260408120548061040c576040516335ae903b60e01b815260040160405180910390fd5b50505f9081526004602052604090205463ffffffff1690565b6001548614610447576040516330bfef3b60e21b815260040160405180910390fd5b604051634d19d99b60e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690634d19d99b906104bf907f0000000000000000000000000000000000000000000000000000000000000000908a908a908a908a908a908a90600401611b81565b5f604051808303815f87803b1580156104d6575f5ffd5b505af11580156104e8573d5f5f3e3d5ffd5b505050506104f7858585611340565b505050505050565b5f81815260026020526040812054806101f8576040516335ae903b60e01b815260040160405180910390fd5b5f815f0361055a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160010361058957507f0000000000000000000000000000000000000000000000000000000000000000919050565b816002036105b857507f0000000000000000000000000000000000000000000000000000000000000000919050565b816003036105e757507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160040361061657507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160050361064557507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160060361067457507f0000000000000000000000000000000000000000000000000000000000000000919050565b816007036106a357507f0000000000000000000000000000000000000000000000000000000000000000919050565b816008036106d257507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160090361070157507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600a0361073057507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600b0361075f57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600c0361078e57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600d036107bd57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600e036107ec57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600f0361081b57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160100361084a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160110361087957507f0000000000000000000000000000000000000000000000000000000000000000919050565b816012036108a857507f0000000000000000000000000000000000000000000000000000000000000000919050565b816013036108d757507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160140361090657507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160150361093557507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160160361096457507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160170361099357507f0000000000000000000000000000000000000000000000000000000000000000919050565b816018036109c257507f0000000000000000000000000000000000000000000000000000000000000000919050565b816019036109f157507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601a03610a2057507f0000000000000000000000000000000000000000000000000000000000000000919050565b60405163f0b1444b60e01b815260048101839052602401610263565b5f828152600260205260408120548015610a7a57828114610a705760405163057f3fa760e51b815260040160405180910390fd5b60019150506101f8565b505f9392505050565b5f8080805b60108110156104f7575f610a9c87836113bb565b905061fffe198101610ab2576001925050610b41565b8215610adb57604051637db4d41760e11b81526004810182905260248101879052604401610263565b858110610b0557604051637db4d41760e11b81526004810182905260248101879052604401610263565b838015610b125750848111155b15610b3a57604051638f16148f60e01b81526004810186905260248101829052604401610263565b9350600192505b600101610a88565b60408051608080825260a082019092525f91602082018180368337019050509050610b72611951565b825f5b86811015610d3d575f5f5f610b8d8f8f8f878b6113d6565b915091505f610b9f838e8e888c611477565b9050610bad8260ff1661052b565b6bffffffffffffffffffffffff19828116911614610bde57604051634012d81f60e11b815260040160405180910390fd5b600160ff83161b93505f5b8760a00151811015610c26578488608001518260108110610c0c57610c0c611bd8565b6020020180519190911763ffffffff169052600101610be9565b50505050610c358d838961154a565b61ffff83811614801590610c4c575061ffff831682145b15610d3457835160a085015161ffff851691829160108110610c7057610c70611bd8565b61ffff909216602092830291909101528e519086015160a087015160108110610c9b57610c9b611bd8565b60200201526040808f01519086015160a087015160108110610cbf57610cbf611bd8565b602002015260808e0151606086015160a087015160108110610ce357610ce3611bd8565b63ffffffff9092166020929092020152608085015160a086015183919060108110610d1057610d10611bd8565b63ffffffff90921660209290920201525060a084018051600101905260109290921c915b50600101610b75565b505f5b8260a00151811015610e21575f610d7084608001518360108110610d6657610d66611bd8565b60200201516115d7565b9050601360ff82161015610dbf5783518260108110610d9157610d91611bd8565b602002015160405163595e108960e01b815261ffff909116600482015260ff82166024820152604401610263565b610e1884602001518360108110610dd857610dd8611bd8565b602002015185604001518460108110610df357610df3611bd8565b602002015186606001518560108110610e0e57610e0e611bd8565b6020020151611340565b50600101610d40565b505050505050505050505050565b5f815f03610e5e57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600103610e8d57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600203610ebc57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600303610eeb57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600403610f1a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600503610f4957507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600603610f7857507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600703610fa757507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600803610fd657507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160090361100557507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600a0361103457507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600b0361106357507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600c0361109257507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600d036110c157507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600e036110f057507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600f0361111f57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160100361114e57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160110361117d57507f0000000000000000000000000000000000000000000000000000000000000000919050565b816012036111ac57507f0000000000000000000000000000000000000000000000000000000000000000919050565b816013036111db57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160140361120a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160150361123957507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160160361126857507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160170361129757507f0000000000000000000000000000000000000000000000000000000000000000919050565b816018036112c657507f0000000000000000000000000000000000000000000000000000000000000000919050565b816019036112f557507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601a0361132457507f0000000000000000000000000000000000000000000000000000000000000000919050565b6040516363cb5a4160e01b815260048101839052602401610263565b5f61134b8460c01c90565b5f8181526002602090815260408083208890556003825280832087905560049091529020805463ffffffff191663ffffffff8516179055905061139081858585611601565b6001548161139e8260c01c90565b10156113b45760018590556113b48186846116ab565b5050505050565b5f61ffff6113ca836010611b6a565b84901c16905092915050565b5f5f5f5f5f5f6113e78a8a8a611731565b93509350935093508094508a5f01518414611422578a516040516364ef389160e11b8152610263918691600401918252602082015260400190565b60208b018051600101908190526114419085908590859085908c611768565b95506114518b60200151876117b7565b8b525060408a019190915263ffffffff1660809098019790975290969095509350505050565b5f60418302850180359060208101359060400135831a601b81101561149a57601b015b8060ff16601b141580156114b257508060ff16601c14155b156114d057604051634012d81f60e11b815260040160405180910390fd5b5f5f602087018b81528360208201528560408201528460608201526020816080836001612710fa92506001600160a01b0381511691505081158061151b57506001600160a01b038116155b1561153957604051634012d81f60e11b815260040160405180910390fd5b60601b9a9950505050505050505050565b82606001518061155a5750808214155b1561156457505050565b6020808401515f90815260029091526040902054806115a6576020840151845160405163956d18e960e01b815260048101929092526024820152604401610263565b835181146115c75760405163057f3fa760e51b815260040160405180910390fd5b5050600160609092019190915250565b5f5b63ffffffff8216156115fc576115f0600183611bec565b909116906001016115d9565b919050565b60408051602081018690529081018490526060810183905263ffffffff82166080820152611663907f19ec6ad7452d744382e0f59064017dca56d2b3b9a42026c6803afc5a145cd1119060a0015b6040516020818303038152906040526117da565b6040805183815263ffffffff83166020820152849186917f19ec6ad7452d744382e0f59064017dca56d2b3b9a42026c6803afc5a145cd111910160405180910390a350505050565b6040805160208101859052908101839052606081018290526116f1907fa9fe701b4da2ff675cfd0dc541fb373a46a72c5c258a99fe850852dc75d3a1cb9060800161164f565b81837fa9fe701b4da2ff675cfd0dc541fb373a46a72c5c258a99fe850852dc75d3a1cb8360405161172491815260200190565b60405180910390a3505050565b5f80808080611741604587611b6a565b979097018035986020820135985060409091013560e081901c975060041a95509350505050565b5f5f611778838989898989611854565b90505f60205f836020870160025afa90505f519250806117ab57604051636eae559f60e11b815260040160405180910390fd5b50509695505050505050565b5f806117c86001600160c01b611c08565b60c085901b9084161791505092915050565b60025f54434285856040516020016117f6959493929190611c32565b60408051601f198184030181529082905261181091611c60565b602060405180830381855afa15801561182b573d5f5f3e3d5ffd5b5050506040513d601f19601f8201168201806040525081019061184e9190611c72565b5f555050565b5f8061186863ffffffff86166103e8611b6a565b90505f6118778560ff16610e2f565b9050606081901c60208a018060088153600101845b607f8111156118ad576080607f82161782536001919091019060071c61188c565b607f81168253506001016012815360010160208153600181018a9052602101601a815360010160208153600181018b905260210160388153600101865b607f81111561190b576080607f82161782536001919091019060071c6118ea565b607f8116825350600101604a81536001016015815360010160418153606083901b60018201526015016050815360010160208153036001019a9950505050505050505050565b6040518060c001604052806119646119a4565b81526020016119716119a4565b815260200161197e6119a4565b815260200161198b6119a4565b81526020016119986119a4565b81526020015f81525090565b6040518061020001604052806010906020820280368337509192915050565b5f602082840312156119d3575f5ffd5b5035919050565b5f5f83601f8401126119ea575f5ffd5b50813567ffffffffffffffff811115611a01575f5ffd5b602083019150836020828501011115611a18575f5ffd5b9250929050565b5f5f5f5f5f5f5f60a0888a031215611a35575f5ffd5b87359650602088013567ffffffffffffffff811115611a52575f5ffd5b611a5e8a828b016119da565b909750955050604088013567ffffffffffffffff811115611a7d575f5ffd5b611a898a828b016119da565b989b979a5095989597966060870135966080013595509350505050565b5f5f5f5f5f5f60a08789031215611abb575f5ffd5b863595506020870135945060408701359350606087013563ffffffff81168114611ae3575f5ffd5b9250608087013567ffffffffffffffff811115611afe575f5ffd5b611b0a89828a016119da565b979a9699509497509295939492505050565b634e487b7160e01b5f52601260045260245ffd5b5f82611b3e57611b3e611b1c565b500690565b634e487b7160e01b5f52601160045260245ffd5b5f82611b6557611b65611b1c565b500490565b80820281158282048414176101f8576101f8611b43565b87815286602082015285604082015284606082015263ffffffff8416608082015260c060a08201528160c0820152818360e08301375f81830160e090810191909152601f909201601f191601019695505050505050565b634e487b7160e01b5f52603260045260245ffd5b63ffffffff82811682821603908111156101f8576101f8611b43565b818103818111156101f8576101f8611b43565b5f81518060208401855e5f93019283525090919050565b8581528460208201528360408201528260608201525f611c556080830184611c1b565b979650505050505050565b5f611c6b8284611c1b565b9392505050565b5f60208284031215611c82575f5ffd5b505191905056fea164736f6c634300081b000a08a67b41721e6d18eb5a3f0d47535037e75548f56ff91770d850aec7bf23ef4a4a757374696e2053756e20697320726573706f6e7369626c6520666f722073657474696e67206261636b2074686520696e6576697461626c6520676c6f62616c20737461626c65636f696e207265766f6c7574696f6e206279207965617273207468726f756768206578706c6f6974696e672054726f6e20555344542773206e6574776f726b206566666563747320616e6420696d706f73696e672076656e646f72206c6f636b2d696e206f6e2068756e6472656473206f66206d696c6c696f6e73206f662070656f706c6520696e2074686520546869726420576f726c642c2077686f2072656c79206f6e20737461626c65636f696e7320666f722072656d697474616e63657320616e6420746f2073746f726520746865697220736176696e677320696e20756e737461626c652c206f766572726567756c617465642065636f6e6f6d6965732e204c6574277320556e74726f6e207468652050656f706c652e19ec6ad7452d744382e0f59064017dca56d2b3b9a42026c6803afc5a145cd111a9fe701b4da2ff675cfd0dc541fb373a46a72c5c258a99fe850852dc75d3a1cb
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\t `@Ra\x01ba\x07\x80\x81\x81R`\x02\x91a*-a\x07\xA09`@Q` \x01a\0(\x91\x90a\x08\x80V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\0B\x91a\x08\xB8V[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\0]W=__>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\0\x80\x91\x90a\x08\xC3V[_U4\x80\x15a\0\x8DW__\xFD[P`@Qa+\xCF8\x03\x80a+\xCF\x839\x81\x01`@\x81\x90Ra\0\xAC\x91a\tuV[`\x01`\x01`\xA0\x1B\x03\x87\x16`\x80R`\x01[`\x1B\x81\x10\x15a\x01RW_\x84a\0\xD2`\x01\x84a\n\x04V[`\x1B\x81\x10a\0\xE2Wa\0\xE2a\n)V[` \x02\x01Q\x90P_\x85\x83`\x1B\x81\x10a\0\xFCWa\0\xFCa\n)V[` \x02\x01Q\x90P``\x81\x81\x1C\x90\x83\x90\x1C\x10a\x01HW`@QbL\x91\x93`\xE8\x1B\x81R`\x04\x81\x01\x84\x90R`\x01`\x01``\x1B\x03\x19\x80\x84\x16`$\x83\x01R\x82\x16`D\x82\x01R`d\x01`@Q\x80\x91\x03\x90\xFD[PP`\x01\x01a\0\xBCV[P\x82_` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16`\xA0R\x82`\x01` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16`\xC0R\x82`\x02` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16`\xE0R\x82`\x03` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01\0R\x82`\x04` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01 R\x82`\x05` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01@R\x82`\x06` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01`R\x82`\x07` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01\x80R\x82`\x08` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01\xA0R\x82`\t` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01\xC0R\x82`\n` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x01\xE0R\x82`\x0B` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02\0R\x82`\x0C` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02 R\x82`\r` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02@R\x82`\x0E` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02`R\x82`\x0F` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02\x80R\x82`\x10` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02\xA0R\x82`\x11` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02\xC0R\x82`\x12` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x02\xE0R\x82`\x13` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03\0R\x82`\x14` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03 R\x82`\x15` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03@R\x82`\x16` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03`R\x82`\x17` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03\x80R\x82`\x18` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03\xA0R\x82`\x19` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03\xC0R\x82`\x1A` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x03\xE0R\x81_` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04\0R\x81`\x01` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04 R\x81`\x02` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04@R\x81`\x03` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04`R\x81`\x04` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04\x80R\x81`\x05` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04\xA0R\x81`\x06` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04\xC0R\x81`\x07` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x04\xE0R\x81`\x08` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05\0R\x81`\t` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05 R\x81`\n` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05@R\x81`\x0B` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05`R\x81`\x0C` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05\x80R\x81`\r` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05\xA0R\x81`\x0E` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05\xC0R\x81`\x0F` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x05\xE0R\x81`\x10` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06\0R\x81`\x11` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06 R\x81`\x12` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06@R\x81`\x13` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06`R\x81`\x14` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06\x80R\x81`\x15` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06\xA0R\x81`\x16` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06\xC0R\x81`\x17` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x06\xE0R\x81`\x18` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x07\0R\x81`\x19` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x07 R\x81`\x1A` \x02\x01Q`\x01`\x01``\x1B\x03\x19\x16a\x07@Ra\x07`\x81\x90Ra\x06\x07\x87\x82\x88\x88\x88\x88\x88a\x06\x1EV[a\x06\x12\x86\x86\x86a\x06\xA0V[PPPPPPPa\x0B.V[a\x06a_Q` a*\r_9_Q\x90_R\x88\x88\x88\x88\x88\x88\x88`@Q` \x01a\x06L\x97\x96\x95\x94\x93\x92\x91\x90a\noV[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x91\x90Ra\x07\x1BV[\x84\x86\x88`\x01`\x01`\xA0\x1B\x03\x16_Q` a*\r_9_Q\x90_R\x87\x87\x87\x87`@Qa\x06\x8F\x94\x93\x92\x91\x90a\n\xC8V[`@Q\x80\x91\x03\x90\xA4PPPPPPPV[_a\x06\xAB\x84`\xC0\x1C\x90V[_\x81\x81R`\x02` \x90\x81R`@\x80\x83 \x88\x90U`\x03\x82R\x80\x83 \x87\x90U`\x04\x90\x91R\x90 \x80Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x85\x16\x17\x90U\x90Pa\x06\xF0\x81\x85\x85\x85a\x07\x95V[`\x01T\x81a\x06\xFE\x82`\xC0\x1C\x90V[\x10\x15a\x07\x14W`\x01\x85\x90Ua\x07\x14\x81\x86\x84a\x08\tV[PPPPPV[`\x02_TCB\x85\x85`@Q` \x01a\x077\x95\x94\x93\x92\x91\x90a\x0B\0V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x07Q\x91a\x08\xB8V[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\x07lW=__>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07\x8F\x91\x90a\x08\xC3V[_UPPV[`@\x80Q` \x81\x01\x86\x90R\x90\x81\x01\x84\x90R``\x81\x01\x83\x90Rc\xFF\xFF\xFF\xFF\x82\x16`\x80\x82\x01Ra\x07\xD4\x90_Q` a+\x8F_9_Q\x90_R\x90`\xA0\x01a\x06LV[`@\x80Q\x83\x81Rc\xFF\xFF\xFF\xFF\x83\x16` \x82\x01R\x84\x91\x86\x91_Q` a+\x8F_9_Q\x90_R\x91\x01`@Q\x80\x91\x03\x90\xA3PPPPV[`@\x80Q` \x81\x01\x85\x90R\x90\x81\x01\x83\x90R``\x81\x01\x82\x90Ra\x08<\x90_Q` a+\xAF_9_Q\x90_R\x90`\x80\x01a\x06LV[\x81\x83_Q` a+\xAF_9_Q\x90_R\x83`@Qa\x08\\\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA3PPPV[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[\x7FTronLightClientIndex\n\0\0\0\0\0\0\0\0\0\0\0\x81R_a\x08\xB1`\x15\x83\x01\x84a\x08iV[\x93\x92PPPV[_a\x08\xB1\x82\x84a\x08iV[_` \x82\x84\x03\x12\x15a\x08\xD3W__\xFD[PQ\x91\x90PV[\x80Q`\x01`\x01``\x1B\x03\x19\x81\x16\x81\x14a\x08\xF1W__\xFD[\x91\x90PV[_\x82`\x1F\x83\x01\x12a\t\x05W__\xFD[`@Qa\x03`\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\t4WcNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@R\x80a\x03`\x84\x01\x85\x81\x11\x15a\tIW__\xFD[\x84[\x81\x81\x10\x15a\tjWa\t\\\x81a\x08\xDAV[\x83R` \x92\x83\x01\x92\x01a\tKV[P\x91\x95\x94PPPPPV[_______a\x07`\x88\x8A\x03\x12\x15a\t\x8CW__\xFD[\x87Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\t\xA2W__\xFD[` \x89\x01Q`@\x8A\x01Q``\x8B\x01Q\x92\x99P\x90\x97P\x95Pc\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\t\xCAW__\xFD[\x93Pa\t\xD9\x89`\x80\x8A\x01a\x08\xF6V[\x92Pa\t\xE9\x89a\x03\xE0\x8A\x01a\x08\xF6V[\x91P_a\x07@\x89\x01Q\x90P\x80\x91PP\x92\x95\x98\x91\x94\x97P\x92\x95PV[\x81\x81\x03\x81\x81\x11\x15a\n#WcNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x92\x91PPV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x80_[`\x1B\x81\x10\x15a\niW\x81Q`\x01`\x01``\x1B\x03\x19\x16\x84R` \x93\x84\x01\x93\x90\x91\x01\x90`\x01\x01a\n@V[PPPPV[`\x01`\x01`\xA0\x1B\x03\x88\x16\x81R` \x81\x01\x87\x90R`@\x81\x01\x86\x90R``\x81\x01\x85\x90Rc\xFF\xFF\xFF\xFF\x84\x16`\x80\x82\x01Ra\x07`\x81\x01a\n\xAE`\xA0\x83\x01\x85a\n=V[a\n\xBCa\x04\0\x83\x01\x84a\n=V[\x98\x97PPPPPPPPV[\x84\x81Rc\xFF\xFF\xFF\xFF\x84\x16` \x82\x01Ra\x07\0\x81\x01a\n\xE9`@\x83\x01\x85a\n=V[a\n\xF7a\x03\xA0\x83\x01\x84a\n=V[\x95\x94PPPPPV[\x85\x81R\x84` \x82\x01R\x83`@\x82\x01R\x82``\x82\x01R_a\x0B#`\x80\x83\x01\x84a\x08iV[\x97\x96PPPPPPPV[`\x80Q`\xA0Q`\xC0Q`\xE0Qa\x01\0Qa\x01 Qa\x01@Qa\x01`Qa\x01\x80Qa\x01\xA0Qa\x01\xC0Qa\x01\xE0Qa\x02\0Qa\x02 Qa\x02@Qa\x02`Qa\x02\x80Qa\x02\xA0Qa\x02\xC0Qa\x02\xE0Qa\x03\0Qa\x03 Qa\x03@Qa\x03`Qa\x03\x80Qa\x03\xA0Qa\x03\xC0Qa\x03\xE0Qa\x04\0Qa\x04 Qa\x04@Qa\x04`Qa\x04\x80Qa\x04\xA0Qa\x04\xC0Qa\x04\xE0Qa\x05\0Qa\x05 Qa\x05@Qa\x05`Qa\x05\x80Qa\x05\xA0Qa\x05\xC0Qa\x05\xE0Qa\x06\0Qa\x06 Qa\x06@Qa\x06`Qa\x06\x80Qa\x06\xA0Qa\x06\xC0Qa\x06\xE0Qa\x07\0Qa\x07 Qa\x07@Qa\x07`Qa\x1C\x96a\rw_9_\x81\x81a\x01g\x01Ra\x04\x8B\x01R_a\t\xFC\x01R_a\t\xCD\x01R_a\t\x9E\x01R_a\to\x01R_a\t@\x01R_a\t\x11\x01R_a\x08\xE2\x01R_a\x08\xB3\x01R_a\x08\x84\x01R_a\x08U\x01R_a\x08&\x01R_a\x07\xF7\x01R_a\x07\xC8\x01R_a\x07\x99\x01R_a\x07j\x01R_a\x07;\x01R_a\x07\x0C\x01R_a\x06\xDD\x01R_a\x06\xAE\x01R_a\x06\x7F\x01R_a\x06P\x01R_a\x06!\x01R_a\x05\xF2\x01R_a\x05\xC3\x01R_a\x05\x94\x01R_a\x05e\x01R_a\x056\x01R_a\x13\0\x01R_a\x12\xD1\x01R_a\x12\xA2\x01R_a\x12s\x01R_a\x12D\x01R_a\x12\x15\x01R_a\x11\xE6\x01R_a\x11\xB7\x01R_a\x11\x88\x01R_a\x11Y\x01R_a\x11*\x01R_a\x10\xFB\x01R_a\x10\xCC\x01R_a\x10\x9D\x01R_a\x10n\x01R_a\x10?\x01R_a\x10\x10\x01R_a\x0F\xE1\x01R_a\x0F\xB2\x01R_a\x0F\x83\x01R_a\x0FT\x01R_a\x0F%\x01R_a\x0E\xF6\x01R_a\x0E\xC7\x01R_a\x0E\x98\x01R_a\x0Ei\x01R_a\x0E:\x01R_\x81\x81a\x01\xB4\x01Ra\x04^\x01Ra\x1C\x96_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0\xA6W_5`\xE0\x1C\x80cG\xE2o\x1A\x11a\0nW\x80cG\xE2o\x1A\x14a\x012W\x80cMS\xE91\x14a\x01ZW\x80cV\xDD\x9C\x10\x14a\x01bW\x80c\x81\x0B8\xFA\x14a\x01\x89W\x80c\x81\xE1\xD4\xFA\x14a\x01\x9CW\x80c\xC5s\x12\xB3\x14a\x01\xAFW__\xFD[\x80c\x12\xD7\x13\xC2\x14a\0\xAAW\x80c\x17Wg\xDC\x14a\0\xE0W\x80c)[=a\x14a\0\xF5W\x80c6B\x9B#\x14a\x01\x16W\x80c9\xAD\xFE\xFF\x14a\x01\x1FW[__\xFD[a\0\xBDa\0\xB86`\x04a\x19\xC3V[a\x01\xEEV[`@Qk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x91\x16\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0\xF3a\0\xEE6`\x04a\x1A\x1FV[a\x01\xFEV[\0[a\x01\x08a\x01\x036`\x04a\x19\xC3V[a\x03\x97V[`@Q\x90\x81R` \x01a\0\xD7V[a\x01\x08`\x01T\x81V[a\0\xBDa\x01-6`\x04a\x19\xC3V[a\x03\xD6V[a\x01Ea\x01@6`\x04a\x19\xC3V[a\x03\xE0V[`@Qc\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\0\xD7V[a\x01\x08_T\x81V[a\x01\x08\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\0\xF3a\x01\x976`\x04a\x1A\xA6V[a\x04%V[a\x01\x08a\x01\xAA6`\x04a\x19\xC3V[a\x04\xFFV[a\x01\xD6\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\0\xD7V[_a\x01\xF8\x82a\x05+V[\x92\x91PPV[\x84\x80\x15\x80a\x02\x15WPa\x02\x12`E\x82a\x1B0V[\x15\x15[\x15a\x023W`@Qc\x19\xD1\xD6-`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x02?`E\x83a\x1BWV[\x90Pa\xFF\xFF\x81\x11\x15a\x02lW`@Qc\xE0\x82\x84\x0B`\xE0\x1B\x81R`\x04\x81\x01\x82\x90R`$\x01[`@Q\x80\x91\x03\x90\xFD[a\x02w`A\x82a\x1BjV[\x85\x14a\x02\x96W`@Qc?\xC1\x86\xD3`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x02\xCB`@Q\x80`\xA0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x15\x15\x81R` \x01_c\xFF\xFF\xFF\xFF\x16\x81RP\x90V[\x89\x81Ra\x02\xD8\x8A`\xC0\x1C\x90V[` \x82\x01\x81\x90Ra\x02\xE9\x90\x8Ba\n<V[\x15\x80\x15``\x83\x01Ra\x03%W_\x19\x85\x14a\x03 W`@Qc\x12\xA4rG`\xE0\x1B\x81R`\x04\x81\x01\x86\x90R`$\x81\x01\x83\x90R`D\x01a\x02cV[a\x03OV[\x81\x85\x10a\x03OW`@Qc\x12\xA4rG`\xE0\x1B\x81R`\x04\x81\x01\x86\x90R`$\x81\x01\x83\x90R`D\x01a\x02cV[a\x03Y\x84\x83a\n\x83V[a\x03i\x81\x8A\x8A\x8A\x8A\x87\x8B\x8Ba\x0BIV[\x80``\x01Qa\x03\x8BW`@Qc\x9E%e-`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPPPPPPPPPV[_\x81\x81R`\x02` R`@\x81 T\x80a\x03\xC3W`@Qc5\xAE\x90;`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP_\x90\x81R`\x03` R`@\x90 T\x90V[_a\x01\xF8\x82a\x0E/V[_\x81\x81R`\x02` R`@\x81 T\x80a\x04\x0CW`@Qc5\xAE\x90;`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP_\x90\x81R`\x04` R`@\x90 Tc\xFF\xFF\xFF\xFF\x16\x90V[`\x01T\x86\x14a\x04GW`@Qc0\xBF\xEF;`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@QcM\x19\xD9\x9B`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90cM\x19\xD9\x9B\x90a\x04\xBF\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x8A\x90\x8A\x90\x8A\x90\x8A\x90\x8A\x90\x8A\x90`\x04\x01a\x1B\x81V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x04\xD6W__\xFD[PZ\xF1\x15\x80\x15a\x04\xE8W=__>=_\xFD[PPPPa\x04\xF7\x85\x85\x85a\x13@V[PPPPPPV[_\x81\x81R`\x02` R`@\x81 T\x80a\x01\xF8W`@Qc5\xAE\x90;`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x81_\x03a\x05ZWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x01\x03a\x05\x89WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x02\x03a\x05\xB8WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x03\x03a\x05\xE7WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x04\x03a\x06\x16WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x05\x03a\x06EWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x06\x03a\x06tWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x07\x03a\x06\xA3WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x08\x03a\x06\xD2WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\t\x03a\x07\x01WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\n\x03a\x070WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0B\x03a\x07_WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0C\x03a\x07\x8EWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\r\x03a\x07\xBDWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0E\x03a\x07\xECWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0F\x03a\x08\x1BWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x10\x03a\x08JWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x11\x03a\x08yWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x12\x03a\x08\xA8WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x13\x03a\x08\xD7WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x14\x03a\t\x06WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x15\x03a\t5WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x16\x03a\tdWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x17\x03a\t\x93WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x18\x03a\t\xC2WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x19\x03a\t\xF1WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x1A\x03a\n WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[`@Qc\xF0\xB1DK`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x02cV[_\x82\x81R`\x02` R`@\x81 T\x80\x15a\nzW\x82\x81\x14a\npW`@Qc\x05\x7F?\xA7`\xE5\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01\x91PPa\x01\xF8V[P_\x93\x92PPPV[_\x80\x80\x80[`\x10\x81\x10\x15a\x04\xF7W_a\n\x9C\x87\x83a\x13\xBBV[\x90Pa\xFF\xFE\x19\x81\x01a\n\xB2W`\x01\x92PPa\x0BAV[\x82\x15a\n\xDBW`@Qc}\xB4\xD4\x17`\xE1\x1B\x81R`\x04\x81\x01\x82\x90R`$\x81\x01\x87\x90R`D\x01a\x02cV[\x85\x81\x10a\x0B\x05W`@Qc}\xB4\xD4\x17`\xE1\x1B\x81R`\x04\x81\x01\x82\x90R`$\x81\x01\x87\x90R`D\x01a\x02cV[\x83\x80\x15a\x0B\x12WP\x84\x81\x11\x15[\x15a\x0B:W`@Qc\x8F\x16\x14\x8F`\xE0\x1B\x81R`\x04\x81\x01\x86\x90R`$\x81\x01\x82\x90R`D\x01a\x02cV[\x93P`\x01\x92P[`\x01\x01a\n\x88V[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R_\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90Pa\x0Bra\x19QV[\x82_[\x86\x81\x10\x15a\r=W___a\x0B\x8D\x8F\x8F\x8F\x87\x8Ba\x13\xD6V[\x91P\x91P_a\x0B\x9F\x83\x8E\x8E\x88\x8Ca\x14wV[\x90Pa\x0B\xAD\x82`\xFF\x16a\x05+V[k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x82\x81\x16\x91\x16\x14a\x0B\xDEW`@Qc@\x12\xD8\x1F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\xFF\x83\x16\x1B\x93P_[\x87`\xA0\x01Q\x81\x10\x15a\x0C&W\x84\x88`\x80\x01Q\x82`\x10\x81\x10a\x0C\x0CWa\x0C\x0Ca\x1B\xD8V[` \x02\x01\x80Q\x91\x90\x91\x17c\xFF\xFF\xFF\xFF\x16\x90R`\x01\x01a\x0B\xE9V[PPPPa\x0C5\x8D\x83\x89a\x15JV[a\xFF\xFF\x83\x81\x16\x14\x80\x15\x90a\x0CLWPa\xFF\xFF\x83\x16\x82\x14[\x15a\r4W\x83Q`\xA0\x85\x01Qa\xFF\xFF\x85\x16\x91\x82\x91`\x10\x81\x10a\x0CpWa\x0Cpa\x1B\xD8V[a\xFF\xFF\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01R\x8EQ\x90\x86\x01Q`\xA0\x87\x01Q`\x10\x81\x10a\x0C\x9BWa\x0C\x9Ba\x1B\xD8V[` \x02\x01R`@\x80\x8F\x01Q\x90\x86\x01Q`\xA0\x87\x01Q`\x10\x81\x10a\x0C\xBFWa\x0C\xBFa\x1B\xD8V[` \x02\x01R`\x80\x8E\x01Q``\x86\x01Q`\xA0\x87\x01Q`\x10\x81\x10a\x0C\xE3Wa\x0C\xE3a\x1B\xD8V[c\xFF\xFF\xFF\xFF\x90\x92\x16` \x92\x90\x92\x02\x01R`\x80\x85\x01Q`\xA0\x86\x01Q\x83\x91\x90`\x10\x81\x10a\r\x10Wa\r\x10a\x1B\xD8V[c\xFF\xFF\xFF\xFF\x90\x92\x16` \x92\x90\x92\x02\x01RP`\xA0\x84\x01\x80Q`\x01\x01\x90R`\x10\x92\x90\x92\x1C\x91[P`\x01\x01a\x0BuV[P_[\x82`\xA0\x01Q\x81\x10\x15a\x0E!W_a\rp\x84`\x80\x01Q\x83`\x10\x81\x10a\rfWa\rfa\x1B\xD8V[` \x02\x01Qa\x15\xD7V[\x90P`\x13`\xFF\x82\x16\x10\x15a\r\xBFW\x83Q\x82`\x10\x81\x10a\r\x91Wa\r\x91a\x1B\xD8V[` \x02\x01Q`@QcY^\x10\x89`\xE0\x1B\x81Ra\xFF\xFF\x90\x91\x16`\x04\x82\x01R`\xFF\x82\x16`$\x82\x01R`D\x01a\x02cV[a\x0E\x18\x84` \x01Q\x83`\x10\x81\x10a\r\xD8Wa\r\xD8a\x1B\xD8V[` \x02\x01Q\x85`@\x01Q\x84`\x10\x81\x10a\r\xF3Wa\r\xF3a\x1B\xD8V[` \x02\x01Q\x86``\x01Q\x85`\x10\x81\x10a\x0E\x0EWa\x0E\x0Ea\x1B\xD8V[` \x02\x01Qa\x13@V[P`\x01\x01a\r@V[PPPPPPPPPPPPV[_\x81_\x03a\x0E^WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x01\x03a\x0E\x8DWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x02\x03a\x0E\xBCWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x03\x03a\x0E\xEBWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x04\x03a\x0F\x1AWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x05\x03a\x0FIWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x06\x03a\x0FxWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x07\x03a\x0F\xA7WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x08\x03a\x0F\xD6WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\t\x03a\x10\x05WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\n\x03a\x104WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0B\x03a\x10cWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0C\x03a\x10\x92WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\r\x03a\x10\xC1WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0E\x03a\x10\xF0WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0F\x03a\x11\x1FWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x10\x03a\x11NWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x11\x03a\x11}WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x12\x03a\x11\xACWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x13\x03a\x11\xDBWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x14\x03a\x12\nWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x15\x03a\x129WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x16\x03a\x12hWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x17\x03a\x12\x97WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x18\x03a\x12\xC6WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x19\x03a\x12\xF5WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x1A\x03a\x13$WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[`@Qcc\xCBZA`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x02cV[_a\x13K\x84`\xC0\x1C\x90V[_\x81\x81R`\x02` \x90\x81R`@\x80\x83 \x88\x90U`\x03\x82R\x80\x83 \x87\x90U`\x04\x90\x91R\x90 \x80Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x85\x16\x17\x90U\x90Pa\x13\x90\x81\x85\x85\x85a\x16\x01V[`\x01T\x81a\x13\x9E\x82`\xC0\x1C\x90V[\x10\x15a\x13\xB4W`\x01\x85\x90Ua\x13\xB4\x81\x86\x84a\x16\xABV[PPPPPV[_a\xFF\xFFa\x13\xCA\x83`\x10a\x1BjV[\x84\x90\x1C\x16\x90P\x92\x91PPV[______a\x13\xE7\x8A\x8A\x8Aa\x171V[\x93P\x93P\x93P\x93P\x80\x94P\x8A_\x01Q\x84\x14a\x14\"W\x8AQ`@Qcd\xEF8\x91`\xE1\x1B\x81Ra\x02c\x91\x86\x91`\x04\x01\x91\x82R` \x82\x01R`@\x01\x90V[` \x8B\x01\x80Q`\x01\x01\x90\x81\x90Ra\x14A\x90\x85\x90\x85\x90\x85\x90\x85\x90\x8Ca\x17hV[\x95Pa\x14Q\x8B` \x01Q\x87a\x17\xB7V[\x8BRP`@\x8A\x01\x91\x90\x91Rc\xFF\xFF\xFF\xFF\x16`\x80\x90\x98\x01\x97\x90\x97R\x90\x96\x90\x95P\x93PPPPV[_`A\x83\x02\x85\x01\x805\x90` \x81\x015\x90`@\x015\x83\x1A`\x1B\x81\x10\x15a\x14\x9AW`\x1B\x01[\x80`\xFF\x16`\x1B\x14\x15\x80\x15a\x14\xB2WP\x80`\xFF\x16`\x1C\x14\x15[\x15a\x14\xD0W`@Qc@\x12\xD8\x1F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[__` \x87\x01\x8B\x81R\x83` \x82\x01R\x85`@\x82\x01R\x84``\x82\x01R` \x81`\x80\x83`\x01a'\x10\xFA\x92P`\x01`\x01`\xA0\x1B\x03\x81Q\x16\x91PP\x81\x15\x80a\x15\x1BWP`\x01`\x01`\xA0\x1B\x03\x81\x16\x15[\x15a\x159W`@Qc@\x12\xD8\x1F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[``\x1B\x9A\x99PPPPPPPPPPV[\x82``\x01Q\x80a\x15ZWP\x80\x82\x14\x15[\x15a\x15dWPPPV[` \x80\x84\x01Q_\x90\x81R`\x02\x90\x91R`@\x90 T\x80a\x15\xA6W` \x84\x01Q\x84Q`@Qc\x95m\x18\xE9`\xE0\x1B\x81R`\x04\x81\x01\x92\x90\x92R`$\x82\x01R`D\x01a\x02cV[\x83Q\x81\x14a\x15\xC7W`@Qc\x05\x7F?\xA7`\xE5\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP`\x01``\x90\x92\x01\x91\x90\x91RPV[_[c\xFF\xFF\xFF\xFF\x82\x16\x15a\x15\xFCWa\x15\xF0`\x01\x83a\x1B\xECV[\x90\x91\x16\x90`\x01\x01a\x15\xD9V[\x91\x90PV[`@\x80Q` \x81\x01\x86\x90R\x90\x81\x01\x84\x90R``\x81\x01\x83\x90Rc\xFF\xFF\xFF\xFF\x82\x16`\x80\x82\x01Ra\x16c\x90\x7F\x19\xECj\xD7E-tC\x82\xE0\xF5\x90d\x01}\xCAV\xD2\xB3\xB9\xA4 &\xC6\x80:\xFCZ\x14\\\xD1\x11\x90`\xA0\x01[`@Q` \x81\x83\x03\x03\x81R\x90`@Ra\x17\xDAV[`@\x80Q\x83\x81Rc\xFF\xFF\xFF\xFF\x83\x16` \x82\x01R\x84\x91\x86\x91\x7F\x19\xECj\xD7E-tC\x82\xE0\xF5\x90d\x01}\xCAV\xD2\xB3\xB9\xA4 &\xC6\x80:\xFCZ\x14\\\xD1\x11\x91\x01`@Q\x80\x91\x03\x90\xA3PPPPV[`@\x80Q` \x81\x01\x85\x90R\x90\x81\x01\x83\x90R``\x81\x01\x82\x90Ra\x16\xF1\x90\x7F\xA9\xFEp\x1BM\xA2\xFFg\\\xFD\r\xC5A\xFB7:F\xA7,\\%\x8A\x99\xFE\x85\x08R\xDCu\xD3\xA1\xCB\x90`\x80\x01a\x16OV[\x81\x83\x7F\xA9\xFEp\x1BM\xA2\xFFg\\\xFD\r\xC5A\xFB7:F\xA7,\\%\x8A\x99\xFE\x85\x08R\xDCu\xD3\xA1\xCB\x83`@Qa\x17$\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA3PPPV[_\x80\x80\x80\x80a\x17A`E\x87a\x1BjV[\x97\x90\x97\x01\x805\x98` \x82\x015\x98P`@\x90\x91\x015`\xE0\x81\x90\x1C\x97P`\x04\x1A\x95P\x93PPPPV[__a\x17x\x83\x89\x89\x89\x89\x89a\x18TV[\x90P_` _\x83` \x87\x01`\x02Z\xFA\x90P_Q\x92P\x80a\x17\xABW`@Qcn\xAEU\x9F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP\x96\x95PPPPPPV[_\x80a\x17\xC8`\x01`\x01`\xC0\x1Ba\x1C\x08V[`\xC0\x85\x90\x1B\x90\x84\x16\x17\x91PP\x92\x91PPV[`\x02_TCB\x85\x85`@Q` \x01a\x17\xF6\x95\x94\x93\x92\x91\x90a\x1C2V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x18\x10\x91a\x1C`V[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\x18+W=__>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x18N\x91\x90a\x1CrV[_UPPV[_\x80a\x18hc\xFF\xFF\xFF\xFF\x86\x16a\x03\xE8a\x1BjV[\x90P_a\x18w\x85`\xFF\x16a\x0E/V[\x90P``\x81\x90\x1C` \x8A\x01\x80`\x08\x81S`\x01\x01\x84[`\x7F\x81\x11\x15a\x18\xADW`\x80`\x7F\x82\x16\x17\x82S`\x01\x91\x90\x91\x01\x90`\x07\x1Ca\x18\x8CV[`\x7F\x81\x16\x82SP`\x01\x01`\x12\x81S`\x01\x01` \x81S`\x01\x81\x01\x8A\x90R`!\x01`\x1A\x81S`\x01\x01` \x81S`\x01\x81\x01\x8B\x90R`!\x01`8\x81S`\x01\x01\x86[`\x7F\x81\x11\x15a\x19\x0BW`\x80`\x7F\x82\x16\x17\x82S`\x01\x91\x90\x91\x01\x90`\x07\x1Ca\x18\xEAV[`\x7F\x81\x16\x82SP`\x01\x01`J\x81S`\x01\x01`\x15\x81S`\x01\x01`A\x81S``\x83\x90\x1B`\x01\x82\x01R`\x15\x01`P\x81S`\x01\x01` \x81S\x03`\x01\x01\x9A\x99PPPPPPPPPPV[`@Q\x80`\xC0\x01`@R\x80a\x19da\x19\xA4V[\x81R` \x01a\x19qa\x19\xA4V[\x81R` \x01a\x19~a\x19\xA4V[\x81R` \x01a\x19\x8Ba\x19\xA4V[\x81R` \x01a\x19\x98a\x19\xA4V[\x81R` \x01_\x81RP\x90V[`@Q\x80a\x02\0\x01`@R\x80`\x10\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x19\xD3W__\xFD[P5\x91\x90PV[__\x83`\x1F\x84\x01\x12a\x19\xEAW__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1A\x01W__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a\x1A\x18W__\xFD[\x92P\x92\x90PV[_______`\xA0\x88\x8A\x03\x12\x15a\x1A5W__\xFD[\x875\x96P` \x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1ARW__\xFD[a\x1A^\x8A\x82\x8B\x01a\x19\xDAV[\x90\x97P\x95PP`@\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1A}W__\xFD[a\x1A\x89\x8A\x82\x8B\x01a\x19\xDAV[\x98\x9B\x97\x9AP\x95\x98\x95\x97\x96``\x87\x015\x96`\x80\x015\x95P\x93PPPPV[______`\xA0\x87\x89\x03\x12\x15a\x1A\xBBW__\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015c\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x1A\xE3W__\xFD[\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1A\xFEW__\xFD[a\x1B\n\x89\x82\x8A\x01a\x19\xDAV[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_\x82a\x1B>Wa\x1B>a\x1B\x1CV[P\x06\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[_\x82a\x1BeWa\x1Bea\x1B\x1CV[P\x04\x90V[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x01\xF8Wa\x01\xF8a\x1BCV[\x87\x81R\x86` \x82\x01R\x85`@\x82\x01R\x84``\x82\x01Rc\xFF\xFF\xFF\xFF\x84\x16`\x80\x82\x01R`\xC0`\xA0\x82\x01R\x81`\xC0\x82\x01R\x81\x83`\xE0\x83\x017_\x81\x83\x01`\xE0\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x96\x95PPPPPPV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[c\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x01\xF8Wa\x01\xF8a\x1BCV[\x81\x81\x03\x81\x81\x11\x15a\x01\xF8Wa\x01\xF8a\x1BCV[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[\x85\x81R\x84` \x82\x01R\x83`@\x82\x01R\x82``\x82\x01R_a\x1CU`\x80\x83\x01\x84a\x1C\x1BV[\x97\x96PPPPPPPV[_a\x1Ck\x82\x84a\x1C\x1BV[\x93\x92PPPV[_` \x82\x84\x03\x12\x15a\x1C\x82W__\xFD[PQ\x91\x90PV\xFE\xA1dsolcC\0\x08\x1B\0\n\x08\xA6{Ar\x1Em\x18\xEBZ?\rGSP7\xE7UH\xF5o\xF9\x17p\xD8P\xAE\xC7\xBF#\xEFJJustin Sun is responsible for setting back the inevitable global stablecoin revolution by years through exploiting Tron USDT's network effects and imposing vendor lock-in on hundreds of millions of people in the Third World, who rely on stablecoins for remittances and to store their savings in unstable, overregulated economies. Let's Untron the People.\x19\xECj\xD7E-tC\x82\xE0\xF5\x90d\x01}\xCAV\xD2\xB3\xB9\xA4 &\xC6\x80:\xFCZ\x14\\\xD1\x11\xA9\xFEp\x1BM\xA2\xFFg\\\xFD\r\xC5A\xFB7:F\xA7,\\%\x8A\x99\xFE\x85\x08R\xDCu\xD3\xA1\xCB",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b50600436106100a6575f3560e01c806347e26f1a1161006e57806347e26f1a146101325780634d53e9311461015a57806356dd9c1014610162578063810b38fa1461018957806381e1d4fa1461019c578063c57312b3146101af575f5ffd5b806312d713c2146100aa578063175767dc146100e0578063295b3d61146100f557806336429b231461011657806339adfeff1461011f575b5f5ffd5b6100bd6100b83660046119c3565b6101ee565b6040516bffffffffffffffffffffffff1990911681526020015b60405180910390f35b6100f36100ee366004611a1f565b6101fe565b005b6101086101033660046119c3565b610397565b6040519081526020016100d7565b61010860015481565b6100bd61012d3660046119c3565b6103d6565b6101456101403660046119c3565b6103e0565b60405163ffffffff90911681526020016100d7565b6101085f5481565b6101087f000000000000000000000000000000000000000000000000000000000000000081565b6100f3610197366004611aa6565b610425565b6101086101aa3660046119c3565b6104ff565b6101d67f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100d7565b5f6101f88261052b565b92915050565b848015806102155750610212604582611b30565b15155b15610233576040516319d1d62d60e21b815260040160405180910390fd5b5f61023f604583611b57565b905061ffff81111561026c5760405163e082840b60e01b8152600481018290526024015b60405180910390fd5b610277604182611b6a565b851461029657604051633fc186d360e01b815260040160405180910390fd5b6102cb6040518060a001604052805f81526020015f81526020015f81526020015f151581526020015f63ffffffff1681525090565b8981526102d88a60c01c90565b602082018190526102e9908b610a3c565b1580156060830152610325575f198514610320576040516312a4724760e01b81526004810186905260248101839052604401610263565b61034f565b81851061034f576040516312a4724760e01b81526004810186905260248101839052604401610263565b6103598483610a83565b610369818a8a8a8a878b8b610b49565b806060015161038b57604051639e25652d60e01b815260040160405180910390fd5b50505050505050505050565b5f81815260026020526040812054806103c3576040516335ae903b60e01b815260040160405180910390fd5b50505f9081526003602052604090205490565b5f6101f882610e2f565b5f818152600260205260408120548061040c576040516335ae903b60e01b815260040160405180910390fd5b50505f9081526004602052604090205463ffffffff1690565b6001548614610447576040516330bfef3b60e21b815260040160405180910390fd5b604051634d19d99b60e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690634d19d99b906104bf907f0000000000000000000000000000000000000000000000000000000000000000908a908a908a908a908a908a90600401611b81565b5f604051808303815f87803b1580156104d6575f5ffd5b505af11580156104e8573d5f5f3e3d5ffd5b505050506104f7858585611340565b505050505050565b5f81815260026020526040812054806101f8576040516335ae903b60e01b815260040160405180910390fd5b5f815f0361055a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160010361058957507f0000000000000000000000000000000000000000000000000000000000000000919050565b816002036105b857507f0000000000000000000000000000000000000000000000000000000000000000919050565b816003036105e757507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160040361061657507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160050361064557507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160060361067457507f0000000000000000000000000000000000000000000000000000000000000000919050565b816007036106a357507f0000000000000000000000000000000000000000000000000000000000000000919050565b816008036106d257507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160090361070157507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600a0361073057507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600b0361075f57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600c0361078e57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600d036107bd57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600e036107ec57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600f0361081b57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160100361084a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160110361087957507f0000000000000000000000000000000000000000000000000000000000000000919050565b816012036108a857507f0000000000000000000000000000000000000000000000000000000000000000919050565b816013036108d757507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160140361090657507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160150361093557507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160160361096457507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160170361099357507f0000000000000000000000000000000000000000000000000000000000000000919050565b816018036109c257507f0000000000000000000000000000000000000000000000000000000000000000919050565b816019036109f157507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601a03610a2057507f0000000000000000000000000000000000000000000000000000000000000000919050565b60405163f0b1444b60e01b815260048101839052602401610263565b5f828152600260205260408120548015610a7a57828114610a705760405163057f3fa760e51b815260040160405180910390fd5b60019150506101f8565b505f9392505050565b5f8080805b60108110156104f7575f610a9c87836113bb565b905061fffe198101610ab2576001925050610b41565b8215610adb57604051637db4d41760e11b81526004810182905260248101879052604401610263565b858110610b0557604051637db4d41760e11b81526004810182905260248101879052604401610263565b838015610b125750848111155b15610b3a57604051638f16148f60e01b81526004810186905260248101829052604401610263565b9350600192505b600101610a88565b60408051608080825260a082019092525f91602082018180368337019050509050610b72611951565b825f5b86811015610d3d575f5f5f610b8d8f8f8f878b6113d6565b915091505f610b9f838e8e888c611477565b9050610bad8260ff1661052b565b6bffffffffffffffffffffffff19828116911614610bde57604051634012d81f60e11b815260040160405180910390fd5b600160ff83161b93505f5b8760a00151811015610c26578488608001518260108110610c0c57610c0c611bd8565b6020020180519190911763ffffffff169052600101610be9565b50505050610c358d838961154a565b61ffff83811614801590610c4c575061ffff831682145b15610d3457835160a085015161ffff851691829160108110610c7057610c70611bd8565b61ffff909216602092830291909101528e519086015160a087015160108110610c9b57610c9b611bd8565b60200201526040808f01519086015160a087015160108110610cbf57610cbf611bd8565b602002015260808e0151606086015160a087015160108110610ce357610ce3611bd8565b63ffffffff9092166020929092020152608085015160a086015183919060108110610d1057610d10611bd8565b63ffffffff90921660209290920201525060a084018051600101905260109290921c915b50600101610b75565b505f5b8260a00151811015610e21575f610d7084608001518360108110610d6657610d66611bd8565b60200201516115d7565b9050601360ff82161015610dbf5783518260108110610d9157610d91611bd8565b602002015160405163595e108960e01b815261ffff909116600482015260ff82166024820152604401610263565b610e1884602001518360108110610dd857610dd8611bd8565b602002015185604001518460108110610df357610df3611bd8565b602002015186606001518560108110610e0e57610e0e611bd8565b6020020151611340565b50600101610d40565b505050505050505050505050565b5f815f03610e5e57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600103610e8d57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600203610ebc57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600303610eeb57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600403610f1a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600503610f4957507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600603610f7857507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600703610fa757507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600803610fd657507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160090361100557507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600a0361103457507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600b0361106357507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600c0361109257507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600d036110c157507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600e036110f057507f0000000000000000000000000000000000000000000000000000000000000000919050565b81600f0361111f57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160100361114e57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160110361117d57507f0000000000000000000000000000000000000000000000000000000000000000919050565b816012036111ac57507f0000000000000000000000000000000000000000000000000000000000000000919050565b816013036111db57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160140361120a57507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160150361123957507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160160361126857507f0000000000000000000000000000000000000000000000000000000000000000919050565b8160170361129757507f0000000000000000000000000000000000000000000000000000000000000000919050565b816018036112c657507f0000000000000000000000000000000000000000000000000000000000000000919050565b816019036112f557507f0000000000000000000000000000000000000000000000000000000000000000919050565b81601a0361132457507f0000000000000000000000000000000000000000000000000000000000000000919050565b6040516363cb5a4160e01b815260048101839052602401610263565b5f61134b8460c01c90565b5f8181526002602090815260408083208890556003825280832087905560049091529020805463ffffffff191663ffffffff8516179055905061139081858585611601565b6001548161139e8260c01c90565b10156113b45760018590556113b48186846116ab565b5050505050565b5f61ffff6113ca836010611b6a565b84901c16905092915050565b5f5f5f5f5f5f6113e78a8a8a611731565b93509350935093508094508a5f01518414611422578a516040516364ef389160e11b8152610263918691600401918252602082015260400190565b60208b018051600101908190526114419085908590859085908c611768565b95506114518b60200151876117b7565b8b525060408a019190915263ffffffff1660809098019790975290969095509350505050565b5f60418302850180359060208101359060400135831a601b81101561149a57601b015b8060ff16601b141580156114b257508060ff16601c14155b156114d057604051634012d81f60e11b815260040160405180910390fd5b5f5f602087018b81528360208201528560408201528460608201526020816080836001612710fa92506001600160a01b0381511691505081158061151b57506001600160a01b038116155b1561153957604051634012d81f60e11b815260040160405180910390fd5b60601b9a9950505050505050505050565b82606001518061155a5750808214155b1561156457505050565b6020808401515f90815260029091526040902054806115a6576020840151845160405163956d18e960e01b815260048101929092526024820152604401610263565b835181146115c75760405163057f3fa760e51b815260040160405180910390fd5b5050600160609092019190915250565b5f5b63ffffffff8216156115fc576115f0600183611bec565b909116906001016115d9565b919050565b60408051602081018690529081018490526060810183905263ffffffff82166080820152611663907f19ec6ad7452d744382e0f59064017dca56d2b3b9a42026c6803afc5a145cd1119060a0015b6040516020818303038152906040526117da565b6040805183815263ffffffff83166020820152849186917f19ec6ad7452d744382e0f59064017dca56d2b3b9a42026c6803afc5a145cd111910160405180910390a350505050565b6040805160208101859052908101839052606081018290526116f1907fa9fe701b4da2ff675cfd0dc541fb373a46a72c5c258a99fe850852dc75d3a1cb9060800161164f565b81837fa9fe701b4da2ff675cfd0dc541fb373a46a72c5c258a99fe850852dc75d3a1cb8360405161172491815260200190565b60405180910390a3505050565b5f80808080611741604587611b6a565b979097018035986020820135985060409091013560e081901c975060041a95509350505050565b5f5f611778838989898989611854565b90505f60205f836020870160025afa90505f519250806117ab57604051636eae559f60e11b815260040160405180910390fd5b50509695505050505050565b5f806117c86001600160c01b611c08565b60c085901b9084161791505092915050565b60025f54434285856040516020016117f6959493929190611c32565b60408051601f198184030181529082905261181091611c60565b602060405180830381855afa15801561182b573d5f5f3e3d5ffd5b5050506040513d601f19601f8201168201806040525081019061184e9190611c72565b5f555050565b5f8061186863ffffffff86166103e8611b6a565b90505f6118778560ff16610e2f565b9050606081901c60208a018060088153600101845b607f8111156118ad576080607f82161782536001919091019060071c61188c565b607f81168253506001016012815360010160208153600181018a9052602101601a815360010160208153600181018b905260210160388153600101865b607f81111561190b576080607f82161782536001919091019060071c6118ea565b607f8116825350600101604a81536001016015815360010160418153606083901b60018201526015016050815360010160208153036001019a9950505050505050505050565b6040518060c001604052806119646119a4565b81526020016119716119a4565b815260200161197e6119a4565b815260200161198b6119a4565b81526020016119986119a4565b81526020015f81525090565b6040518061020001604052806010906020820280368337509192915050565b5f602082840312156119d3575f5ffd5b5035919050565b5f5f83601f8401126119ea575f5ffd5b50813567ffffffffffffffff811115611a01575f5ffd5b602083019150836020828501011115611a18575f5ffd5b9250929050565b5f5f5f5f5f5f5f60a0888a031215611a35575f5ffd5b87359650602088013567ffffffffffffffff811115611a52575f5ffd5b611a5e8a828b016119da565b909750955050604088013567ffffffffffffffff811115611a7d575f5ffd5b611a898a828b016119da565b989b979a5095989597966060870135966080013595509350505050565b5f5f5f5f5f5f60a08789031215611abb575f5ffd5b863595506020870135945060408701359350606087013563ffffffff81168114611ae3575f5ffd5b9250608087013567ffffffffffffffff811115611afe575f5ffd5b611b0a89828a016119da565b979a9699509497509295939492505050565b634e487b7160e01b5f52601260045260245ffd5b5f82611b3e57611b3e611b1c565b500690565b634e487b7160e01b5f52601160045260245ffd5b5f82611b6557611b65611b1c565b500490565b80820281158282048414176101f8576101f8611b43565b87815286602082015285604082015284606082015263ffffffff8416608082015260c060a08201528160c0820152818360e08301375f81830160e090810191909152601f909201601f191601019695505050505050565b634e487b7160e01b5f52603260045260245ffd5b63ffffffff82811682821603908111156101f8576101f8611b43565b818103818111156101f8576101f8611b43565b5f81518060208401855e5f93019283525090919050565b8581528460208201528360408201528260608201525f611c556080830184611c1b565b979650505050505050565b5f611c6b8284611c1b565b9392505050565b5f60208284031215611c82575f5ffd5b505191905056fea164736f6c634300081b000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0\xA6W_5`\xE0\x1C\x80cG\xE2o\x1A\x11a\0nW\x80cG\xE2o\x1A\x14a\x012W\x80cMS\xE91\x14a\x01ZW\x80cV\xDD\x9C\x10\x14a\x01bW\x80c\x81\x0B8\xFA\x14a\x01\x89W\x80c\x81\xE1\xD4\xFA\x14a\x01\x9CW\x80c\xC5s\x12\xB3\x14a\x01\xAFW__\xFD[\x80c\x12\xD7\x13\xC2\x14a\0\xAAW\x80c\x17Wg\xDC\x14a\0\xE0W\x80c)[=a\x14a\0\xF5W\x80c6B\x9B#\x14a\x01\x16W\x80c9\xAD\xFE\xFF\x14a\x01\x1FW[__\xFD[a\0\xBDa\0\xB86`\x04a\x19\xC3V[a\x01\xEEV[`@Qk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90\x91\x16\x81R` \x01[`@Q\x80\x91\x03\x90\xF3[a\0\xF3a\0\xEE6`\x04a\x1A\x1FV[a\x01\xFEV[\0[a\x01\x08a\x01\x036`\x04a\x19\xC3V[a\x03\x97V[`@Q\x90\x81R` \x01a\0\xD7V[a\x01\x08`\x01T\x81V[a\0\xBDa\x01-6`\x04a\x19\xC3V[a\x03\xD6V[a\x01Ea\x01@6`\x04a\x19\xC3V[a\x03\xE0V[`@Qc\xFF\xFF\xFF\xFF\x90\x91\x16\x81R` \x01a\0\xD7V[a\x01\x08_T\x81V[a\x01\x08\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\0\xF3a\x01\x976`\x04a\x1A\xA6V[a\x04%V[a\x01\x08a\x01\xAA6`\x04a\x19\xC3V[a\x04\xFFV[a\x01\xD6\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x01a\0\xD7V[_a\x01\xF8\x82a\x05+V[\x92\x91PPV[\x84\x80\x15\x80a\x02\x15WPa\x02\x12`E\x82a\x1B0V[\x15\x15[\x15a\x023W`@Qc\x19\xD1\xD6-`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_a\x02?`E\x83a\x1BWV[\x90Pa\xFF\xFF\x81\x11\x15a\x02lW`@Qc\xE0\x82\x84\x0B`\xE0\x1B\x81R`\x04\x81\x01\x82\x90R`$\x01[`@Q\x80\x91\x03\x90\xFD[a\x02w`A\x82a\x1BjV[\x85\x14a\x02\x96W`@Qc?\xC1\x86\xD3`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[a\x02\xCB`@Q\x80`\xA0\x01`@R\x80_\x81R` \x01_\x81R` \x01_\x81R` \x01_\x15\x15\x81R` \x01_c\xFF\xFF\xFF\xFF\x16\x81RP\x90V[\x89\x81Ra\x02\xD8\x8A`\xC0\x1C\x90V[` \x82\x01\x81\x90Ra\x02\xE9\x90\x8Ba\n<V[\x15\x80\x15``\x83\x01Ra\x03%W_\x19\x85\x14a\x03 W`@Qc\x12\xA4rG`\xE0\x1B\x81R`\x04\x81\x01\x86\x90R`$\x81\x01\x83\x90R`D\x01a\x02cV[a\x03OV[\x81\x85\x10a\x03OW`@Qc\x12\xA4rG`\xE0\x1B\x81R`\x04\x81\x01\x86\x90R`$\x81\x01\x83\x90R`D\x01a\x02cV[a\x03Y\x84\x83a\n\x83V[a\x03i\x81\x8A\x8A\x8A\x8A\x87\x8B\x8Ba\x0BIV[\x80``\x01Qa\x03\x8BW`@Qc\x9E%e-`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PPPPPPPPPPV[_\x81\x81R`\x02` R`@\x81 T\x80a\x03\xC3W`@Qc5\xAE\x90;`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP_\x90\x81R`\x03` R`@\x90 T\x90V[_a\x01\xF8\x82a\x0E/V[_\x81\x81R`\x02` R`@\x81 T\x80a\x04\x0CW`@Qc5\xAE\x90;`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP_\x90\x81R`\x04` R`@\x90 Tc\xFF\xFF\xFF\xFF\x16\x90V[`\x01T\x86\x14a\x04GW`@Qc0\xBF\xEF;`\xE2\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`@QcM\x19\xD9\x9B`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90cM\x19\xD9\x9B\x90a\x04\xBF\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x8A\x90\x8A\x90\x8A\x90\x8A\x90\x8A\x90\x8A\x90`\x04\x01a\x1B\x81V[_`@Q\x80\x83\x03\x81_\x87\x80;\x15\x80\x15a\x04\xD6W__\xFD[PZ\xF1\x15\x80\x15a\x04\xE8W=__>=_\xFD[PPPPa\x04\xF7\x85\x85\x85a\x13@V[PPPPPPV[_\x81\x81R`\x02` R`@\x81 T\x80a\x01\xF8W`@Qc5\xAE\x90;`\xE0\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[_\x81_\x03a\x05ZWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x01\x03a\x05\x89WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x02\x03a\x05\xB8WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x03\x03a\x05\xE7WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x04\x03a\x06\x16WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x05\x03a\x06EWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x06\x03a\x06tWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x07\x03a\x06\xA3WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x08\x03a\x06\xD2WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\t\x03a\x07\x01WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\n\x03a\x070WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0B\x03a\x07_WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0C\x03a\x07\x8EWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\r\x03a\x07\xBDWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0E\x03a\x07\xECWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0F\x03a\x08\x1BWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x10\x03a\x08JWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x11\x03a\x08yWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x12\x03a\x08\xA8WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x13\x03a\x08\xD7WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x14\x03a\t\x06WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x15\x03a\t5WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x16\x03a\tdWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x17\x03a\t\x93WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x18\x03a\t\xC2WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x19\x03a\t\xF1WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x1A\x03a\n WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[`@Qc\xF0\xB1DK`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x02cV[_\x82\x81R`\x02` R`@\x81 T\x80\x15a\nzW\x82\x81\x14a\npW`@Qc\x05\x7F?\xA7`\xE5\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01\x91PPa\x01\xF8V[P_\x93\x92PPPV[_\x80\x80\x80[`\x10\x81\x10\x15a\x04\xF7W_a\n\x9C\x87\x83a\x13\xBBV[\x90Pa\xFF\xFE\x19\x81\x01a\n\xB2W`\x01\x92PPa\x0BAV[\x82\x15a\n\xDBW`@Qc}\xB4\xD4\x17`\xE1\x1B\x81R`\x04\x81\x01\x82\x90R`$\x81\x01\x87\x90R`D\x01a\x02cV[\x85\x81\x10a\x0B\x05W`@Qc}\xB4\xD4\x17`\xE1\x1B\x81R`\x04\x81\x01\x82\x90R`$\x81\x01\x87\x90R`D\x01a\x02cV[\x83\x80\x15a\x0B\x12WP\x84\x81\x11\x15[\x15a\x0B:W`@Qc\x8F\x16\x14\x8F`\xE0\x1B\x81R`\x04\x81\x01\x86\x90R`$\x81\x01\x82\x90R`D\x01a\x02cV[\x93P`\x01\x92P[`\x01\x01a\n\x88V[`@\x80Q`\x80\x80\x82R`\xA0\x82\x01\x90\x92R_\x91` \x82\x01\x81\x806\x837\x01\x90PP\x90Pa\x0Bra\x19QV[\x82_[\x86\x81\x10\x15a\r=W___a\x0B\x8D\x8F\x8F\x8F\x87\x8Ba\x13\xD6V[\x91P\x91P_a\x0B\x9F\x83\x8E\x8E\x88\x8Ca\x14wV[\x90Pa\x0B\xAD\x82`\xFF\x16a\x05+V[k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x82\x81\x16\x91\x16\x14a\x0B\xDEW`@Qc@\x12\xD8\x1F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[`\x01`\xFF\x83\x16\x1B\x93P_[\x87`\xA0\x01Q\x81\x10\x15a\x0C&W\x84\x88`\x80\x01Q\x82`\x10\x81\x10a\x0C\x0CWa\x0C\x0Ca\x1B\xD8V[` \x02\x01\x80Q\x91\x90\x91\x17c\xFF\xFF\xFF\xFF\x16\x90R`\x01\x01a\x0B\xE9V[PPPPa\x0C5\x8D\x83\x89a\x15JV[a\xFF\xFF\x83\x81\x16\x14\x80\x15\x90a\x0CLWPa\xFF\xFF\x83\x16\x82\x14[\x15a\r4W\x83Q`\xA0\x85\x01Qa\xFF\xFF\x85\x16\x91\x82\x91`\x10\x81\x10a\x0CpWa\x0Cpa\x1B\xD8V[a\xFF\xFF\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01R\x8EQ\x90\x86\x01Q`\xA0\x87\x01Q`\x10\x81\x10a\x0C\x9BWa\x0C\x9Ba\x1B\xD8V[` \x02\x01R`@\x80\x8F\x01Q\x90\x86\x01Q`\xA0\x87\x01Q`\x10\x81\x10a\x0C\xBFWa\x0C\xBFa\x1B\xD8V[` \x02\x01R`\x80\x8E\x01Q``\x86\x01Q`\xA0\x87\x01Q`\x10\x81\x10a\x0C\xE3Wa\x0C\xE3a\x1B\xD8V[c\xFF\xFF\xFF\xFF\x90\x92\x16` \x92\x90\x92\x02\x01R`\x80\x85\x01Q`\xA0\x86\x01Q\x83\x91\x90`\x10\x81\x10a\r\x10Wa\r\x10a\x1B\xD8V[c\xFF\xFF\xFF\xFF\x90\x92\x16` \x92\x90\x92\x02\x01RP`\xA0\x84\x01\x80Q`\x01\x01\x90R`\x10\x92\x90\x92\x1C\x91[P`\x01\x01a\x0BuV[P_[\x82`\xA0\x01Q\x81\x10\x15a\x0E!W_a\rp\x84`\x80\x01Q\x83`\x10\x81\x10a\rfWa\rfa\x1B\xD8V[` \x02\x01Qa\x15\xD7V[\x90P`\x13`\xFF\x82\x16\x10\x15a\r\xBFW\x83Q\x82`\x10\x81\x10a\r\x91Wa\r\x91a\x1B\xD8V[` \x02\x01Q`@QcY^\x10\x89`\xE0\x1B\x81Ra\xFF\xFF\x90\x91\x16`\x04\x82\x01R`\xFF\x82\x16`$\x82\x01R`D\x01a\x02cV[a\x0E\x18\x84` \x01Q\x83`\x10\x81\x10a\r\xD8Wa\r\xD8a\x1B\xD8V[` \x02\x01Q\x85`@\x01Q\x84`\x10\x81\x10a\r\xF3Wa\r\xF3a\x1B\xD8V[` \x02\x01Q\x86``\x01Q\x85`\x10\x81\x10a\x0E\x0EWa\x0E\x0Ea\x1B\xD8V[` \x02\x01Qa\x13@V[P`\x01\x01a\r@V[PPPPPPPPPPPPV[_\x81_\x03a\x0E^WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x01\x03a\x0E\x8DWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x02\x03a\x0E\xBCWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x03\x03a\x0E\xEBWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x04\x03a\x0F\x1AWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x05\x03a\x0FIWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x06\x03a\x0FxWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x07\x03a\x0F\xA7WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x08\x03a\x0F\xD6WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\t\x03a\x10\x05WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\n\x03a\x104WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0B\x03a\x10cWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0C\x03a\x10\x92WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\r\x03a\x10\xC1WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0E\x03a\x10\xF0WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x0F\x03a\x11\x1FWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x10\x03a\x11NWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x11\x03a\x11}WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x12\x03a\x11\xACWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x13\x03a\x11\xDBWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x14\x03a\x12\nWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x15\x03a\x129WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x16\x03a\x12hWP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x17\x03a\x12\x97WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x18\x03a\x12\xC6WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x19\x03a\x12\xF5WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[\x81`\x1A\x03a\x13$WP\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x90PV[`@Qcc\xCBZA`\xE0\x1B\x81R`\x04\x81\x01\x83\x90R`$\x01a\x02cV[_a\x13K\x84`\xC0\x1C\x90V[_\x81\x81R`\x02` \x90\x81R`@\x80\x83 \x88\x90U`\x03\x82R\x80\x83 \x87\x90U`\x04\x90\x91R\x90 \x80Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x85\x16\x17\x90U\x90Pa\x13\x90\x81\x85\x85\x85a\x16\x01V[`\x01T\x81a\x13\x9E\x82`\xC0\x1C\x90V[\x10\x15a\x13\xB4W`\x01\x85\x90Ua\x13\xB4\x81\x86\x84a\x16\xABV[PPPPPV[_a\xFF\xFFa\x13\xCA\x83`\x10a\x1BjV[\x84\x90\x1C\x16\x90P\x92\x91PPV[______a\x13\xE7\x8A\x8A\x8Aa\x171V[\x93P\x93P\x93P\x93P\x80\x94P\x8A_\x01Q\x84\x14a\x14\"W\x8AQ`@Qcd\xEF8\x91`\xE1\x1B\x81Ra\x02c\x91\x86\x91`\x04\x01\x91\x82R` \x82\x01R`@\x01\x90V[` \x8B\x01\x80Q`\x01\x01\x90\x81\x90Ra\x14A\x90\x85\x90\x85\x90\x85\x90\x85\x90\x8Ca\x17hV[\x95Pa\x14Q\x8B` \x01Q\x87a\x17\xB7V[\x8BRP`@\x8A\x01\x91\x90\x91Rc\xFF\xFF\xFF\xFF\x16`\x80\x90\x98\x01\x97\x90\x97R\x90\x96\x90\x95P\x93PPPPV[_`A\x83\x02\x85\x01\x805\x90` \x81\x015\x90`@\x015\x83\x1A`\x1B\x81\x10\x15a\x14\x9AW`\x1B\x01[\x80`\xFF\x16`\x1B\x14\x15\x80\x15a\x14\xB2WP\x80`\xFF\x16`\x1C\x14\x15[\x15a\x14\xD0W`@Qc@\x12\xD8\x1F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[__` \x87\x01\x8B\x81R\x83` \x82\x01R\x85`@\x82\x01R\x84``\x82\x01R` \x81`\x80\x83`\x01a'\x10\xFA\x92P`\x01`\x01`\xA0\x1B\x03\x81Q\x16\x91PP\x81\x15\x80a\x15\x1BWP`\x01`\x01`\xA0\x1B\x03\x81\x16\x15[\x15a\x159W`@Qc@\x12\xD8\x1F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[``\x1B\x9A\x99PPPPPPPPPPV[\x82``\x01Q\x80a\x15ZWP\x80\x82\x14\x15[\x15a\x15dWPPPV[` \x80\x84\x01Q_\x90\x81R`\x02\x90\x91R`@\x90 T\x80a\x15\xA6W` \x84\x01Q\x84Q`@Qc\x95m\x18\xE9`\xE0\x1B\x81R`\x04\x81\x01\x92\x90\x92R`$\x82\x01R`D\x01a\x02cV[\x83Q\x81\x14a\x15\xC7W`@Qc\x05\x7F?\xA7`\xE5\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP`\x01``\x90\x92\x01\x91\x90\x91RPV[_[c\xFF\xFF\xFF\xFF\x82\x16\x15a\x15\xFCWa\x15\xF0`\x01\x83a\x1B\xECV[\x90\x91\x16\x90`\x01\x01a\x15\xD9V[\x91\x90PV[`@\x80Q` \x81\x01\x86\x90R\x90\x81\x01\x84\x90R``\x81\x01\x83\x90Rc\xFF\xFF\xFF\xFF\x82\x16`\x80\x82\x01Ra\x16c\x90\x7F\x19\xECj\xD7E-tC\x82\xE0\xF5\x90d\x01}\xCAV\xD2\xB3\xB9\xA4 &\xC6\x80:\xFCZ\x14\\\xD1\x11\x90`\xA0\x01[`@Q` \x81\x83\x03\x03\x81R\x90`@Ra\x17\xDAV[`@\x80Q\x83\x81Rc\xFF\xFF\xFF\xFF\x83\x16` \x82\x01R\x84\x91\x86\x91\x7F\x19\xECj\xD7E-tC\x82\xE0\xF5\x90d\x01}\xCAV\xD2\xB3\xB9\xA4 &\xC6\x80:\xFCZ\x14\\\xD1\x11\x91\x01`@Q\x80\x91\x03\x90\xA3PPPPV[`@\x80Q` \x81\x01\x85\x90R\x90\x81\x01\x83\x90R``\x81\x01\x82\x90Ra\x16\xF1\x90\x7F\xA9\xFEp\x1BM\xA2\xFFg\\\xFD\r\xC5A\xFB7:F\xA7,\\%\x8A\x99\xFE\x85\x08R\xDCu\xD3\xA1\xCB\x90`\x80\x01a\x16OV[\x81\x83\x7F\xA9\xFEp\x1BM\xA2\xFFg\\\xFD\r\xC5A\xFB7:F\xA7,\\%\x8A\x99\xFE\x85\x08R\xDCu\xD3\xA1\xCB\x83`@Qa\x17$\x91\x81R` \x01\x90V[`@Q\x80\x91\x03\x90\xA3PPPV[_\x80\x80\x80\x80a\x17A`E\x87a\x1BjV[\x97\x90\x97\x01\x805\x98` \x82\x015\x98P`@\x90\x91\x015`\xE0\x81\x90\x1C\x97P`\x04\x1A\x95P\x93PPPPV[__a\x17x\x83\x89\x89\x89\x89\x89a\x18TV[\x90P_` _\x83` \x87\x01`\x02Z\xFA\x90P_Q\x92P\x80a\x17\xABW`@Qcn\xAEU\x9F`\xE1\x1B\x81R`\x04\x01`@Q\x80\x91\x03\x90\xFD[PP\x96\x95PPPPPPV[_\x80a\x17\xC8`\x01`\x01`\xC0\x1Ba\x1C\x08V[`\xC0\x85\x90\x1B\x90\x84\x16\x17\x91PP\x92\x91PPV[`\x02_TCB\x85\x85`@Q` \x01a\x17\xF6\x95\x94\x93\x92\x91\x90a\x1C2V[`@\x80Q`\x1F\x19\x81\x84\x03\x01\x81R\x90\x82\x90Ra\x18\x10\x91a\x1C`V[` `@Q\x80\x83\x03\x81\x85Z\xFA\x15\x80\x15a\x18+W=__>=_\xFD[PPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x18N\x91\x90a\x1CrV[_UPPV[_\x80a\x18hc\xFF\xFF\xFF\xFF\x86\x16a\x03\xE8a\x1BjV[\x90P_a\x18w\x85`\xFF\x16a\x0E/V[\x90P``\x81\x90\x1C` \x8A\x01\x80`\x08\x81S`\x01\x01\x84[`\x7F\x81\x11\x15a\x18\xADW`\x80`\x7F\x82\x16\x17\x82S`\x01\x91\x90\x91\x01\x90`\x07\x1Ca\x18\x8CV[`\x7F\x81\x16\x82SP`\x01\x01`\x12\x81S`\x01\x01` \x81S`\x01\x81\x01\x8A\x90R`!\x01`\x1A\x81S`\x01\x01` \x81S`\x01\x81\x01\x8B\x90R`!\x01`8\x81S`\x01\x01\x86[`\x7F\x81\x11\x15a\x19\x0BW`\x80`\x7F\x82\x16\x17\x82S`\x01\x91\x90\x91\x01\x90`\x07\x1Ca\x18\xEAV[`\x7F\x81\x16\x82SP`\x01\x01`J\x81S`\x01\x01`\x15\x81S`\x01\x01`A\x81S``\x83\x90\x1B`\x01\x82\x01R`\x15\x01`P\x81S`\x01\x01` \x81S\x03`\x01\x01\x9A\x99PPPPPPPPPPV[`@Q\x80`\xC0\x01`@R\x80a\x19da\x19\xA4V[\x81R` \x01a\x19qa\x19\xA4V[\x81R` \x01a\x19~a\x19\xA4V[\x81R` \x01a\x19\x8Ba\x19\xA4V[\x81R` \x01a\x19\x98a\x19\xA4V[\x81R` \x01_\x81RP\x90V[`@Q\x80a\x02\0\x01`@R\x80`\x10\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[_` \x82\x84\x03\x12\x15a\x19\xD3W__\xFD[P5\x91\x90PV[__\x83`\x1F\x84\x01\x12a\x19\xEAW__\xFD[P\x815g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1A\x01W__\xFD[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15a\x1A\x18W__\xFD[\x92P\x92\x90PV[_______`\xA0\x88\x8A\x03\x12\x15a\x1A5W__\xFD[\x875\x96P` \x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1ARW__\xFD[a\x1A^\x8A\x82\x8B\x01a\x19\xDAV[\x90\x97P\x95PP`@\x88\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1A}W__\xFD[a\x1A\x89\x8A\x82\x8B\x01a\x19\xDAV[\x98\x9B\x97\x9AP\x95\x98\x95\x97\x96``\x87\x015\x96`\x80\x015\x95P\x93PPPPV[______`\xA0\x87\x89\x03\x12\x15a\x1A\xBBW__\xFD[\x865\x95P` \x87\x015\x94P`@\x87\x015\x93P``\x87\x015c\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x1A\xE3W__\xFD[\x92P`\x80\x87\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11\x15a\x1A\xFEW__\xFD[a\x1B\n\x89\x82\x8A\x01a\x19\xDAV[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_\x82a\x1B>Wa\x1B>a\x1B\x1CV[P\x06\x90V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[_\x82a\x1BeWa\x1Bea\x1B\x1CV[P\x04\x90V[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a\x01\xF8Wa\x01\xF8a\x1BCV[\x87\x81R\x86` \x82\x01R\x85`@\x82\x01R\x84``\x82\x01Rc\xFF\xFF\xFF\xFF\x84\x16`\x80\x82\x01R`\xC0`\xA0\x82\x01R\x81`\xC0\x82\x01R\x81\x83`\xE0\x83\x017_\x81\x83\x01`\xE0\x90\x81\x01\x91\x90\x91R`\x1F\x90\x92\x01`\x1F\x19\x16\x01\x01\x96\x95PPPPPPV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[c\xFF\xFF\xFF\xFF\x82\x81\x16\x82\x82\x16\x03\x90\x81\x11\x15a\x01\xF8Wa\x01\xF8a\x1BCV[\x81\x81\x03\x81\x81\x11\x15a\x01\xF8Wa\x01\xF8a\x1BCV[_\x81Q\x80` \x84\x01\x85^_\x93\x01\x92\x83RP\x90\x91\x90PV[\x85\x81R\x84` \x82\x01R\x83`@\x82\x01R\x82``\x82\x01R_a\x1CU`\x80\x83\x01\x84a\x1C\x1BV[\x97\x96PPPPPPPV[_a\x1Ck\x82\x84a\x1C\x1BV[\x93\x92PPPV[_` \x82\x84\x03\x12\x15a\x1C\x82W__\xFD[PQ\x91\x90PV\xFE\xA1dsolcC\0\x08\x1B\0\n",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `BlockNotRelayed()` and selector `0x35ae903b`.
```solidity
error BlockNotRelayed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BlockNotRelayed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BlockNotRelayed> for UnderlyingRustTuple<'_> {
            fn from(value: BlockNotRelayed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BlockNotRelayed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BlockNotRelayed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BlockNotRelayed()";
            const SELECTOR: [u8; 4] = [53u8, 174u8, 144u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `BlockTooOld()` and selector `0xc2ffbcec`.
```solidity
error BlockTooOld();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BlockTooOld;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BlockTooOld> for UnderlyingRustTuple<'_> {
            fn from(value: BlockTooOld) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BlockTooOld {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BlockTooOld {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BlockTooOld()";
            const SELECTOR: [u8; 4] = [194u8, 255u8, 188u8, 236u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CheckpointNotFinalized(uint256,uint8)` and selector `0x595e1089`.
```solidity
error CheckpointNotFinalized(uint256 offset, uint8 distinct);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CheckpointNotFinalized {
        #[allow(missing_docs)]
        pub offset: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub distinct: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<8>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            u8,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CheckpointNotFinalized> for UnderlyingRustTuple<'_> {
            fn from(value: CheckpointNotFinalized) -> Self {
                (value.offset, value.distinct)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CheckpointNotFinalized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    offset: tuple.0,
                    distinct: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CheckpointNotFinalized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CheckpointNotFinalized(uint256,uint8)";
            const SELECTOR: [u8; 4] = [89u8, 94u8, 16u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.offset),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.distinct),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidChain()` and selector `0xafe7f4e0`.
```solidity
error InvalidChain();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidChain;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidChain> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidChain) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidChain {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidChain {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidChain()";
            const SELECTOR: [u8; 4] = [175u8, 231u8, 244u8, 224u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidCompressedSignaturesLength()` and selector `0x3fc186d3`.
```solidity
error InvalidCompressedSignaturesLength();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidCompressedSignaturesLength;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidCompressedSignaturesLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidCompressedSignaturesLength) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidCompressedSignaturesLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidCompressedSignaturesLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidCompressedSignaturesLength()";
            const SELECTOR: [u8; 4] = [63u8, 193u8, 134u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidCompressedTronBlockMetadataLength()` and selector `0x674758b4`.
```solidity
error InvalidCompressedTronBlockMetadataLength();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidCompressedTronBlockMetadataLength;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidCompressedTronBlockMetadataLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidCompressedTronBlockMetadataLength) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidCompressedTronBlockMetadataLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidCompressedTronBlockMetadataLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidCompressedTronBlockMetadataLength()";
            const SELECTOR: [u8; 4] = [103u8, 71u8, 88u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidIntersectionClaim(uint256,bytes32)` and selector `0x956d18e9`.
```solidity
error InvalidIntersectionClaim(uint256 blockNumber, bytes32 blockId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidIntersectionClaim {
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub blockId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidIntersectionClaim>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidIntersectionClaim) -> Self {
                (value.blockNumber, value.blockId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidIntersectionClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    blockNumber: tuple.0,
                    blockId: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidIntersectionClaim {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidIntersectionClaim(uint256,bytes32)";
            const SELECTOR: [u8; 4] = [149u8, 109u8, 24u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockId),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidIntersectionOffset(uint256,uint256)` and selector `0x12a47247`.
```solidity
error InvalidIntersectionOffset(uint256 intersectionOffset, uint256 numBlocks);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidIntersectionOffset {
        #[allow(missing_docs)]
        pub intersectionOffset: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidIntersectionOffset>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidIntersectionOffset) -> Self {
                (value.intersectionOffset, value.numBlocks)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidIntersectionOffset {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    intersectionOffset: tuple.0,
                    numBlocks: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidIntersectionOffset {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidIntersectionOffset(uint256,uint256)";
            const SELECTOR: [u8; 4] = [18u8, 164u8, 114u8, 71u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.intersectionOffset),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidParentBlockId(bytes32,bytes32)` and selector `0xc9de7122`.
```solidity
error InvalidParentBlockId(bytes32 yours, bytes32 real);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidParentBlockId {
        #[allow(missing_docs)]
        pub yours: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub real: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidParentBlockId> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidParentBlockId) -> Self {
                (value.yours, value.real)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidParentBlockId {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    yours: tuple.0,
                    real: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidParentBlockId {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidParentBlockId(bytes32,bytes32)";
            const SELECTOR: [u8; 4] = [201u8, 222u8, 113u8, 34u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.yours),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.real),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidSrIndex(uint256)` and selector `0x63cb5a41`.
```solidity
error InvalidSrIndex(uint256 index);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidSrIndex {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidSrIndex> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidSrIndex) -> Self {
                (value.index,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidSrIndex {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { index: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidSrIndex {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidSrIndex(uint256)";
            const SELECTOR: [u8; 4] = [99u8, 203u8, 90u8, 65u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidStoreOffset(uint256,uint256)` and selector `0xfb69a82e`.
```solidity
error InvalidStoreOffset(uint256 offset, uint256 numBlocks);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidStoreOffset {
        #[allow(missing_docs)]
        pub offset: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidStoreOffset> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidStoreOffset) -> Self {
                (value.offset, value.numBlocks)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidStoreOffset {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    offset: tuple.0,
                    numBlocks: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidStoreOffset {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidStoreOffset(uint256,uint256)";
            const SELECTOR: [u8; 4] = [251u8, 105u8, 168u8, 46u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.offset),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidWitnessDelegateeIndex(uint256)` and selector `0xf0b1444b`.
```solidity
error InvalidWitnessDelegateeIndex(uint256 index);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidWitnessDelegateeIndex {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidWitnessDelegateeIndex>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidWitnessDelegateeIndex) -> Self {
                (value.index,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidWitnessDelegateeIndex {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { index: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidWitnessDelegateeIndex {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidWitnessDelegateeIndex(uint256)";
            const SELECTOR: [u8; 4] = [240u8, 177u8, 68u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidWitnessSigner()` and selector `0x8025b03e`.
```solidity
error InvalidWitnessSigner();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidWitnessSigner;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidWitnessSigner> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidWitnessSigner) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidWitnessSigner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidWitnessSigner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidWitnessSigner()";
            const SELECTOR: [u8; 4] = [128u8, 37u8, 176u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `Sha256PrecompileFailed()` and selector `0xdd5cab3e`.
```solidity
error Sha256PrecompileFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Sha256PrecompileFailed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Sha256PrecompileFailed> for UnderlyingRustTuple<'_> {
            fn from(value: Sha256PrecompileFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Sha256PrecompileFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Sha256PrecompileFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Sha256PrecompileFailed()";
            const SELECTOR: [u8; 4] = [221u8, 92u8, 171u8, 62u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SrSetNotSorted(uint256,bytes20,bytes20)` and selector `0x4c919300`.
```solidity
error SrSetNotSorted(uint256 index, bytes20 prev, bytes20 next);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SrSetNotSorted {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub prev: alloy::sol_types::private::FixedBytes<20>,
        #[allow(missing_docs)]
        pub next: alloy::sol_types::private::FixedBytes<20>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<20>,
            alloy::sol_types::sol_data::FixedBytes<20>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<20>,
            alloy::sol_types::private::FixedBytes<20>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SrSetNotSorted> for UnderlyingRustTuple<'_> {
            fn from(value: SrSetNotSorted) -> Self {
                (value.index, value.prev, value.next)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SrSetNotSorted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    index: tuple.0,
                    prev: tuple.1,
                    next: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SrSetNotSorted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SrSetNotSorted(uint256,bytes20,bytes20)";
            const SELECTOR: [u8; 4] = [76u8, 145u8, 147u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                    <alloy::sol_types::sol_data::FixedBytes<
                        20,
                    > as alloy_sol_types::SolType>::tokenize(&self.prev),
                    <alloy::sol_types::sol_data::FixedBytes<
                        20,
                    > as alloy_sol_types::SolType>::tokenize(&self.next),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `StoreOffsetsNotStrictlyIncreasing(uint256,uint256)` and selector `0x8f16148f`.
```solidity
error StoreOffsetsNotStrictlyIncreasing(uint256 prev, uint256 next);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct StoreOffsetsNotStrictlyIncreasing {
        #[allow(missing_docs)]
        pub prev: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub next: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StoreOffsetsNotStrictlyIncreasing>
        for UnderlyingRustTuple<'_> {
            fn from(value: StoreOffsetsNotStrictlyIncreasing) -> Self {
                (value.prev, value.next)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for StoreOffsetsNotStrictlyIncreasing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    prev: tuple.0,
                    next: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for StoreOffsetsNotStrictlyIncreasing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "StoreOffsetsNotStrictlyIncreasing(uint256,uint256)";
            const SELECTOR: [u8; 4] = [143u8, 22u8, 20u8, 143u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.prev),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.next),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `TooManyBlocks(uint256)` and selector `0xe082840b`.
```solidity
error TooManyBlocks(uint256 numBlocks);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TooManyBlocks {
        #[allow(missing_docs)]
        pub numBlocks: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TooManyBlocks> for UnderlyingRustTuple<'_> {
            fn from(value: TooManyBlocks) -> Self {
                (value.numBlocks,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TooManyBlocks {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { numBlocks: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TooManyBlocks {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TooManyBlocks(uint256)";
            const SELECTOR: [u8; 4] = [224u8, 130u8, 132u8, 11u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.numBlocks),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UnanchoredBlockRange()` and selector `0x9e25652d`.
```solidity
error UnanchoredBlockRange();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnanchoredBlockRange;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnanchoredBlockRange> for UnderlyingRustTuple<'_> {
            fn from(value: UnanchoredBlockRange) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnanchoredBlockRange {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnanchoredBlockRange {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnanchoredBlockRange()";
            const SELECTOR: [u8; 4] = [158u8, 37u8, 101u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `LatestProvenBlockUpdated(bytes32,bytes32,uint256)` and selector `0xa9fe701b4da2ff675cfd0dc541fb373a46a72c5c258a99fe850852dc75d3a1cb`.
```solidity
event LatestProvenBlockUpdated(bytes32 indexed previousLatest, bytes32 indexed newLatest, uint256 newBlockNumber);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct LatestProvenBlockUpdated {
        #[allow(missing_docs)]
        pub previousLatest: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newLatest: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for LatestProvenBlockUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "LatestProvenBlockUpdated(bytes32,bytes32,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                169u8, 254u8, 112u8, 27u8, 77u8, 162u8, 255u8, 103u8, 92u8, 253u8, 13u8,
                197u8, 65u8, 251u8, 55u8, 58u8, 70u8, 167u8, 44u8, 92u8, 37u8, 138u8,
                153u8, 254u8, 133u8, 8u8, 82u8, 220u8, 117u8, 211u8, 161u8, 203u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousLatest: topics.1,
                    newLatest: topics.2,
                    newBlockNumber: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newBlockNumber),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousLatest.clone(),
                    self.newLatest.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousLatest);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newLatest);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for LatestProvenBlockUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&LatestProvenBlockUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &LatestProvenBlockUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `TronBlockStored(uint256,bytes32,bytes32,uint32)` and selector `0x19ec6ad7452d744382e0f59064017dca56d2b3b9a42026c6803afc5a145cd111`.
```solidity
event TronBlockStored(uint256 indexed blockNumber, bytes32 indexed blockId, bytes32 txTrieRoot, uint32 timestamp);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TronBlockStored {
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub blockId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub txTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub timestamp: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TronBlockStored {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "TronBlockStored(uint256,bytes32,bytes32,uint32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                25u8, 236u8, 106u8, 215u8, 69u8, 45u8, 116u8, 67u8, 130u8, 224u8, 245u8,
                144u8, 100u8, 1u8, 125u8, 202u8, 86u8, 210u8, 179u8, 185u8, 164u8, 32u8,
                38u8, 198u8, 128u8, 58u8, 252u8, 90u8, 20u8, 92u8, 209u8, 17u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    blockNumber: topics.1,
                    blockId: topics.2,
                    txTrieRoot: data.0,
                    timestamp: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.txTrieRoot),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.timestamp),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.blockNumber.clone(),
                    self.blockId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blockNumber);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blockId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TronBlockStored {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TronBlockStored> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TronBlockStored) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `TronLightClientConfigured(address,bytes32,bytes32,bytes32,uint32,bytes20[27],bytes20[27])` and selector `0x08a67b41721e6d18eb5a3f0d47535037e75548f56ff91770d850aec7bf23ef4a`.
```solidity
event TronLightClientConfigured(address indexed blockRangeProver, bytes32 indexed srDataHash, bytes32 indexed initialBlockId, bytes32 initialTxTrieRoot, uint32 initialTimestamp, bytes20[27] srs, bytes20[27] witnessDelegatees);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct TronLightClientConfigured {
        #[allow(missing_docs)]
        pub blockRangeProver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub srDataHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub initialBlockId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub initialTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub initialTimestamp: u32,
        #[allow(missing_docs)]
        pub srs: [alloy::sol_types::private::FixedBytes<20>; 27usize],
        #[allow(missing_docs)]
        pub witnessDelegatees: [alloy::sol_types::private::FixedBytes<20>; 27usize],
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TronLightClientConfigured {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<20>,
                    27usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<20>,
                    27usize,
                >,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "TronLightClientConfigured(address,bytes32,bytes32,bytes32,uint32,bytes20[27],bytes20[27])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                8u8, 166u8, 123u8, 65u8, 114u8, 30u8, 109u8, 24u8, 235u8, 90u8, 63u8,
                13u8, 71u8, 83u8, 80u8, 55u8, 231u8, 85u8, 72u8, 245u8, 111u8, 249u8,
                23u8, 112u8, 216u8, 80u8, 174u8, 199u8, 191u8, 35u8, 239u8, 74u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    blockRangeProver: topics.1,
                    srDataHash: topics.2,
                    initialBlockId: topics.3,
                    initialTxTrieRoot: data.0,
                    initialTimestamp: data.1,
                    srs: data.2,
                    witnessDelegatees: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialTxTrieRoot),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialTimestamp),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<20>,
                        27usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.srs),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<20>,
                        27usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.witnessDelegatees),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.blockRangeProver.clone(),
                    self.srDataHash.clone(),
                    self.initialBlockId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.blockRangeProver,
                );
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.srDataHash);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.initialBlockId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TronLightClientConfigured {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TronLightClientConfigured> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &TronLightClientConfigured,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address blockRangeProver, bytes32 initialBlockHash, bytes32 initialTxTrieRoot, uint32 initialTimestamp, bytes20[27] _srs, bytes20[27] _witnessDelegatees, bytes32 srDataHash);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub blockRangeProver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub initialBlockHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub initialTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub initialTimestamp: u32,
        #[allow(missing_docs)]
        pub _srs: [alloy::sol_types::private::FixedBytes<20>; 27usize],
        #[allow(missing_docs)]
        pub _witnessDelegatees: [alloy::sol_types::private::FixedBytes<20>; 27usize],
        #[allow(missing_docs)]
        pub srDataHash: alloy::sol_types::private::FixedBytes<32>,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<20>,
                    27usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<20>,
                    27usize,
                >,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                u32,
                [alloy::sol_types::private::FixedBytes<20>; 27usize],
                [alloy::sol_types::private::FixedBytes<20>; 27usize],
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value.blockRangeProver,
                        value.initialBlockHash,
                        value.initialTxTrieRoot,
                        value.initialTimestamp,
                        value._srs,
                        value._witnessDelegatees,
                        value.srDataHash,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blockRangeProver: tuple.0,
                        initialBlockHash: tuple.1,
                        initialTxTrieRoot: tuple.2,
                        initialTimestamp: tuple.3,
                        _srs: tuple.4,
                        _witnessDelegatees: tuple.5,
                        srDataHash: tuple.6,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<20>,
                    27usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::FixedBytes<20>,
                    27usize,
                >,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.blockRangeProver,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialBlockHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialTxTrieRoot),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.initialTimestamp),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<20>,
                        27usize,
                    > as alloy_sol_types::SolType>::tokenize(&self._srs),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::FixedBytes<20>,
                        27usize,
                    > as alloy_sol_types::SolType>::tokenize(&self._witnessDelegatees),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.srDataHash),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `BLOCK_RANGE_PROVER()` and selector `0xc57312b3`.
```solidity
function BLOCK_RANGE_PROVER() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BLOCK_RANGE_PROVERCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`BLOCK_RANGE_PROVER()`](BLOCK_RANGE_PROVERCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BLOCK_RANGE_PROVERReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BLOCK_RANGE_PROVERCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: BLOCK_RANGE_PROVERCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BLOCK_RANGE_PROVERCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BLOCK_RANGE_PROVERReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BLOCK_RANGE_PROVERReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BLOCK_RANGE_PROVERReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BLOCK_RANGE_PROVERCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BLOCK_RANGE_PROVER()";
            const SELECTOR: [u8; 4] = [197u8, 115u8, 18u8, 179u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: BLOCK_RANGE_PROVERReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: BLOCK_RANGE_PROVERReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `SR_DATA_HASH()` and selector `0x56dd9c10`.
```solidity
function SR_DATA_HASH() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SR_DATA_HASHCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`SR_DATA_HASH()`](SR_DATA_HASHCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SR_DATA_HASHReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SR_DATA_HASHCall> for UnderlyingRustTuple<'_> {
                fn from(value: SR_DATA_HASHCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SR_DATA_HASHCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SR_DATA_HASHReturn> for UnderlyingRustTuple<'_> {
                fn from(value: SR_DATA_HASHReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SR_DATA_HASHReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SR_DATA_HASHCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SR_DATA_HASH()";
            const SELECTOR: [u8; 4] = [86u8, 221u8, 156u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: SR_DATA_HASHReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: SR_DATA_HASHReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `eventChainTip()` and selector `0x4d53e931`.
```solidity
function eventChainTip() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventChainTipCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`eventChainTip()`](eventChainTipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventChainTipReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventChainTipCall> for UnderlyingRustTuple<'_> {
                fn from(value: eventChainTipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventChainTipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventChainTipReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eventChainTipReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventChainTipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eventChainTipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eventChainTip()";
            const SELECTOR: [u8; 4] = [77u8, 83u8, 233u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: eventChainTipReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: eventChainTipReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getBlockId(uint256)` and selector `0x81e1d4fa`.
```solidity
function getBlockId(uint256 blockNumber) external view returns (bytes32 blockId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockIdCall {
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getBlockId(uint256)`](getBlockIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockIdReturn {
        #[allow(missing_docs)]
        pub blockId: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBlockIdCall) -> Self {
                    (value.blockNumber,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBlockIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blockNumber: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockIdReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBlockIdReturn) -> Self {
                    (value.blockId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBlockIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blockId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBlockIdCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBlockId(uint256)";
            const SELECTOR: [u8; 4] = [129u8, 225u8, 212u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getBlockIdReturn = r.into();
                        r.blockId
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getBlockIdReturn = r.into();
                        r.blockId
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getBlockTimestamp(uint256)` and selector `0x47e26f1a`.
```solidity
function getBlockTimestamp(uint256 blockNumber) external view returns (uint32 timestamp);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockTimestampCall {
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getBlockTimestamp(uint256)`](getBlockTimestampCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlockTimestampReturn {
        #[allow(missing_docs)]
        pub timestamp: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockTimestampCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBlockTimestampCall) -> Self {
                    (value.blockNumber,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBlockTimestampCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blockNumber: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlockTimestampReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBlockTimestampReturn) -> Self {
                    (value.timestamp,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBlockTimestampReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { timestamp: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBlockTimestampCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u32;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBlockTimestamp(uint256)";
            const SELECTOR: [u8; 4] = [71u8, 226u8, 111u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getBlockTimestampReturn = r.into();
                        r.timestamp
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getBlockTimestampReturn = r.into();
                        r.timestamp
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getTxTrieRoot(uint256)` and selector `0x295b3d61`.
```solidity
function getTxTrieRoot(uint256 blockNumber) external view returns (bytes32 txTrieRoot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTxTrieRootCall {
        #[allow(missing_docs)]
        pub blockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getTxTrieRoot(uint256)`](getTxTrieRootCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTxTrieRootReturn {
        #[allow(missing_docs)]
        pub txTrieRoot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTxTrieRootCall> for UnderlyingRustTuple<'_> {
                fn from(value: getTxTrieRootCall) -> Self {
                    (value.blockNumber,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getTxTrieRootCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blockNumber: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTxTrieRootReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getTxTrieRootReturn) -> Self {
                    (value.txTrieRoot,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getTxTrieRootReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { txTrieRoot: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getTxTrieRootCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getTxTrieRoot(uint256)";
            const SELECTOR: [u8; 4] = [41u8, 91u8, 61u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getTxTrieRootReturn = r.into();
                        r.txTrieRoot
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getTxTrieRootReturn = r.into();
                        r.txTrieRoot
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `latestProvenBlock()` and selector `0x36429b23`.
```solidity
function latestProvenBlock() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct latestProvenBlockCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`latestProvenBlock()`](latestProvenBlockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct latestProvenBlockReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<latestProvenBlockCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: latestProvenBlockCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for latestProvenBlockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<latestProvenBlockReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: latestProvenBlockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for latestProvenBlockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for latestProvenBlockCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "latestProvenBlock()";
            const SELECTOR: [u8; 4] = [54u8, 66u8, 155u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: latestProvenBlockReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: latestProvenBlockReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proveBlockRange(bytes32,bytes32,bytes32,uint32,bytes)` and selector `0x810b38fa`.
```solidity
function proveBlockRange(bytes32 startingBlock, bytes32 endingBlock, bytes32 endingBlockTxTrieRoot, uint32 endingBlockTimestamp, bytes memory zkProof) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proveBlockRangeCall {
        #[allow(missing_docs)]
        pub startingBlock: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endingBlock: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endingBlockTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub endingBlockTimestamp: u32,
        #[allow(missing_docs)]
        pub zkProof: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`proveBlockRange(bytes32,bytes32,bytes32,uint32,bytes)`](proveBlockRangeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proveBlockRangeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::FixedBytes<32>,
                u32,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proveBlockRangeCall> for UnderlyingRustTuple<'_> {
                fn from(value: proveBlockRangeCall) -> Self {
                    (
                        value.startingBlock,
                        value.endingBlock,
                        value.endingBlockTxTrieRoot,
                        value.endingBlockTimestamp,
                        value.zkProof,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proveBlockRangeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startingBlock: tuple.0,
                        endingBlock: tuple.1,
                        endingBlockTxTrieRoot: tuple.2,
                        endingBlockTimestamp: tuple.3,
                        zkProof: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proveBlockRangeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: proveBlockRangeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for proveBlockRangeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl proveBlockRangeReturn {
            fn _tokenize(
                &self,
            ) -> <proveBlockRangeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proveBlockRangeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = proveBlockRangeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proveBlockRange(bytes32,bytes32,bytes32,uint32,bytes)";
            const SELECTOR: [u8; 4] = [129u8, 11u8, 56u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startingBlock),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endingBlock),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.endingBlockTxTrieRoot,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.endingBlockTimestamp),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.zkProof,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                proveBlockRangeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proveBlocks(bytes32,bytes,bytes,uint256,uint256)` and selector `0x175767dc`.
```solidity
function proveBlocks(bytes32 startingBlock, bytes memory compressedTronBlockMetadata, bytes memory compressedSignatures, uint256 intersectionOffset, uint256 storeOffsets16) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proveBlocksCall {
        #[allow(missing_docs)]
        pub startingBlock: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub compressedTronBlockMetadata: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub compressedSignatures: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub intersectionOffset: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub storeOffsets16: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`proveBlocks(bytes32,bytes,bytes,uint256,uint256)`](proveBlocksCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proveBlocksReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proveBlocksCall> for UnderlyingRustTuple<'_> {
                fn from(value: proveBlocksCall) -> Self {
                    (
                        value.startingBlock,
                        value.compressedTronBlockMetadata,
                        value.compressedSignatures,
                        value.intersectionOffset,
                        value.storeOffsets16,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proveBlocksCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        startingBlock: tuple.0,
                        compressedTronBlockMetadata: tuple.1,
                        compressedSignatures: tuple.2,
                        intersectionOffset: tuple.3,
                        storeOffsets16: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proveBlocksReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proveBlocksReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proveBlocksReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl proveBlocksReturn {
            fn _tokenize(
                &self,
            ) -> <proveBlocksCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proveBlocksCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = proveBlocksReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proveBlocks(bytes32,bytes,bytes,uint256,uint256)";
            const SELECTOR: [u8; 4] = [23u8, 87u8, 103u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.startingBlock),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.compressedTronBlockMetadata,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.compressedSignatures,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.intersectionOffset),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.storeOffsets16),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                proveBlocksReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `srs(uint256)` and selector `0x39adfeff`.
```solidity
function srs(uint256 index) external view returns (bytes20 sr);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct srsCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`srs(uint256)`](srsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct srsReturn {
        #[allow(missing_docs)]
        pub sr: alloy::sol_types::private::FixedBytes<20>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<srsCall> for UnderlyingRustTuple<'_> {
                fn from(value: srsCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for srsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<20>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<srsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: srsReturn) -> Self {
                    (value.sr,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for srsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { sr: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for srsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<20>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "srs(uint256)";
            const SELECTOR: [u8; 4] = [57u8, 173u8, 254u8, 255u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        20,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: srsReturn = r.into();
                        r.sr
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: srsReturn = r.into();
                        r.sr
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `witnessDelegatees(uint256)` and selector `0x12d713c2`.
```solidity
function witnessDelegatees(uint256 index) external view returns (bytes20 delegatee);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct witnessDelegateesCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`witnessDelegatees(uint256)`](witnessDelegateesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct witnessDelegateesReturn {
        #[allow(missing_docs)]
        pub delegatee: alloy::sol_types::private::FixedBytes<20>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<witnessDelegateesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: witnessDelegateesCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for witnessDelegateesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<20>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<witnessDelegateesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: witnessDelegateesReturn) -> Self {
                    (value.delegatee,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for witnessDelegateesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { delegatee: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for witnessDelegateesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<20>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<20>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "witnessDelegatees(uint256)";
            const SELECTOR: [u8; 4] = [18u8, 215u8, 19u8, 194u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        20,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: witnessDelegateesReturn = r.into();
                        r.delegatee
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: witnessDelegateesReturn = r.into();
                        r.delegatee
                    })
            }
        }
    };
    ///Container for all the [`TronLightClient`](self) function calls.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum TronLightClientCalls {
        #[allow(missing_docs)]
        BLOCK_RANGE_PROVER(BLOCK_RANGE_PROVERCall),
        #[allow(missing_docs)]
        SR_DATA_HASH(SR_DATA_HASHCall),
        #[allow(missing_docs)]
        eventChainTip(eventChainTipCall),
        #[allow(missing_docs)]
        getBlockId(getBlockIdCall),
        #[allow(missing_docs)]
        getBlockTimestamp(getBlockTimestampCall),
        #[allow(missing_docs)]
        getTxTrieRoot(getTxTrieRootCall),
        #[allow(missing_docs)]
        latestProvenBlock(latestProvenBlockCall),
        #[allow(missing_docs)]
        proveBlockRange(proveBlockRangeCall),
        #[allow(missing_docs)]
        proveBlocks(proveBlocksCall),
        #[allow(missing_docs)]
        srs(srsCall),
        #[allow(missing_docs)]
        witnessDelegatees(witnessDelegateesCall),
    }
    impl TronLightClientCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [18u8, 215u8, 19u8, 194u8],
            [23u8, 87u8, 103u8, 220u8],
            [41u8, 91u8, 61u8, 97u8],
            [54u8, 66u8, 155u8, 35u8],
            [57u8, 173u8, 254u8, 255u8],
            [71u8, 226u8, 111u8, 26u8],
            [77u8, 83u8, 233u8, 49u8],
            [86u8, 221u8, 156u8, 16u8],
            [129u8, 11u8, 56u8, 250u8],
            [129u8, 225u8, 212u8, 250u8],
            [197u8, 115u8, 18u8, 179u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(witnessDelegatees),
            ::core::stringify!(proveBlocks),
            ::core::stringify!(getTxTrieRoot),
            ::core::stringify!(latestProvenBlock),
            ::core::stringify!(srs),
            ::core::stringify!(getBlockTimestamp),
            ::core::stringify!(eventChainTip),
            ::core::stringify!(SR_DATA_HASH),
            ::core::stringify!(proveBlockRange),
            ::core::stringify!(getBlockId),
            ::core::stringify!(BLOCK_RANGE_PROVER),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <witnessDelegateesCall as alloy_sol_types::SolCall>::SIGNATURE,
            <proveBlocksCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getTxTrieRootCall as alloy_sol_types::SolCall>::SIGNATURE,
            <latestProvenBlockCall as alloy_sol_types::SolCall>::SIGNATURE,
            <srsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getBlockTimestampCall as alloy_sol_types::SolCall>::SIGNATURE,
            <eventChainTipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <SR_DATA_HASHCall as alloy_sol_types::SolCall>::SIGNATURE,
            <proveBlockRangeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getBlockIdCall as alloy_sol_types::SolCall>::SIGNATURE,
            <BLOCK_RANGE_PROVERCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TronLightClientCalls {
        const NAME: &'static str = "TronLightClientCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 11usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BLOCK_RANGE_PROVER(_) => {
                    <BLOCK_RANGE_PROVERCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SR_DATA_HASH(_) => {
                    <SR_DATA_HASHCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eventChainTip(_) => {
                    <eventChainTipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBlockId(_) => {
                    <getBlockIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBlockTimestamp(_) => {
                    <getBlockTimestampCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getTxTrieRoot(_) => {
                    <getTxTrieRootCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::latestProvenBlock(_) => {
                    <latestProvenBlockCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proveBlockRange(_) => {
                    <proveBlockRangeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proveBlocks(_) => {
                    <proveBlocksCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::srs(_) => <srsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::witnessDelegatees(_) => {
                    <witnessDelegateesCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<TronLightClientCalls>] = &[
                {
                    fn witnessDelegatees(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <witnessDelegateesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientCalls::witnessDelegatees)
                    }
                    witnessDelegatees
                },
                {
                    fn proveBlocks(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <proveBlocksCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientCalls::proveBlocks)
                    }
                    proveBlocks
                },
                {
                    fn getTxTrieRoot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <getTxTrieRootCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientCalls::getTxTrieRoot)
                    }
                    getTxTrieRoot
                },
                {
                    fn latestProvenBlock(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <latestProvenBlockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientCalls::latestProvenBlock)
                    }
                    latestProvenBlock
                },
                {
                    fn srs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <srsCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(TronLightClientCalls::srs)
                    }
                    srs
                },
                {
                    fn getBlockTimestamp(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <getBlockTimestampCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientCalls::getBlockTimestamp)
                    }
                    getBlockTimestamp
                },
                {
                    fn eventChainTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <eventChainTipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientCalls::eventChainTip)
                    }
                    eventChainTip
                },
                {
                    fn SR_DATA_HASH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <SR_DATA_HASHCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientCalls::SR_DATA_HASH)
                    }
                    SR_DATA_HASH
                },
                {
                    fn proveBlockRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <proveBlockRangeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientCalls::proveBlockRange)
                    }
                    proveBlockRange
                },
                {
                    fn getBlockId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <getBlockIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientCalls::getBlockId)
                    }
                    getBlockId
                },
                {
                    fn BLOCK_RANGE_PROVER(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <BLOCK_RANGE_PROVERCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientCalls::BLOCK_RANGE_PROVER)
                    }
                    BLOCK_RANGE_PROVER
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<TronLightClientCalls>] = &[
                {
                    fn witnessDelegatees(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <witnessDelegateesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientCalls::witnessDelegatees)
                    }
                    witnessDelegatees
                },
                {
                    fn proveBlocks(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <proveBlocksCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientCalls::proveBlocks)
                    }
                    proveBlocks
                },
                {
                    fn getTxTrieRoot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <getTxTrieRootCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientCalls::getTxTrieRoot)
                    }
                    getTxTrieRoot
                },
                {
                    fn latestProvenBlock(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <latestProvenBlockCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientCalls::latestProvenBlock)
                    }
                    latestProvenBlock
                },
                {
                    fn srs(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <srsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientCalls::srs)
                    }
                    srs
                },
                {
                    fn getBlockTimestamp(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <getBlockTimestampCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientCalls::getBlockTimestamp)
                    }
                    getBlockTimestamp
                },
                {
                    fn eventChainTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <eventChainTipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientCalls::eventChainTip)
                    }
                    eventChainTip
                },
                {
                    fn SR_DATA_HASH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <SR_DATA_HASHCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientCalls::SR_DATA_HASH)
                    }
                    SR_DATA_HASH
                },
                {
                    fn proveBlockRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <proveBlockRangeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientCalls::proveBlockRange)
                    }
                    proveBlockRange
                },
                {
                    fn getBlockId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <getBlockIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientCalls::getBlockId)
                    }
                    getBlockId
                },
                {
                    fn BLOCK_RANGE_PROVER(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientCalls> {
                        <BLOCK_RANGE_PROVERCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientCalls::BLOCK_RANGE_PROVER)
                    }
                    BLOCK_RANGE_PROVER
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BLOCK_RANGE_PROVER(inner) => {
                    <BLOCK_RANGE_PROVERCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SR_DATA_HASH(inner) => {
                    <SR_DATA_HASHCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::eventChainTip(inner) => {
                    <eventChainTipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBlockId(inner) => {
                    <getBlockIdCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getBlockTimestamp(inner) => {
                    <getBlockTimestampCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getTxTrieRoot(inner) => {
                    <getTxTrieRootCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::latestProvenBlock(inner) => {
                    <latestProvenBlockCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proveBlockRange(inner) => {
                    <proveBlockRangeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proveBlocks(inner) => {
                    <proveBlocksCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::srs(inner) => {
                    <srsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::witnessDelegatees(inner) => {
                    <witnessDelegateesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BLOCK_RANGE_PROVER(inner) => {
                    <BLOCK_RANGE_PROVERCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SR_DATA_HASH(inner) => {
                    <SR_DATA_HASHCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eventChainTip(inner) => {
                    <eventChainTipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBlockId(inner) => {
                    <getBlockIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBlockTimestamp(inner) => {
                    <getBlockTimestampCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getTxTrieRoot(inner) => {
                    <getTxTrieRootCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::latestProvenBlock(inner) => {
                    <latestProvenBlockCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proveBlockRange(inner) => {
                    <proveBlockRangeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proveBlocks(inner) => {
                    <proveBlocksCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::srs(inner) => {
                    <srsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::witnessDelegatees(inner) => {
                    <witnessDelegateesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TronLightClient`](self) custom errors.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum TronLightClientErrors {
        #[allow(missing_docs)]
        BlockNotRelayed(BlockNotRelayed),
        #[allow(missing_docs)]
        BlockTooOld(BlockTooOld),
        #[allow(missing_docs)]
        CheckpointNotFinalized(CheckpointNotFinalized),
        #[allow(missing_docs)]
        InvalidChain(InvalidChain),
        #[allow(missing_docs)]
        InvalidCompressedSignaturesLength(InvalidCompressedSignaturesLength),
        #[allow(missing_docs)]
        InvalidCompressedTronBlockMetadataLength(
            InvalidCompressedTronBlockMetadataLength,
        ),
        #[allow(missing_docs)]
        InvalidIntersectionClaim(InvalidIntersectionClaim),
        #[allow(missing_docs)]
        InvalidIntersectionOffset(InvalidIntersectionOffset),
        #[allow(missing_docs)]
        InvalidParentBlockId(InvalidParentBlockId),
        #[allow(missing_docs)]
        InvalidSrIndex(InvalidSrIndex),
        #[allow(missing_docs)]
        InvalidStoreOffset(InvalidStoreOffset),
        #[allow(missing_docs)]
        InvalidWitnessDelegateeIndex(InvalidWitnessDelegateeIndex),
        #[allow(missing_docs)]
        InvalidWitnessSigner(InvalidWitnessSigner),
        #[allow(missing_docs)]
        Sha256PrecompileFailed(Sha256PrecompileFailed),
        #[allow(missing_docs)]
        SrSetNotSorted(SrSetNotSorted),
        #[allow(missing_docs)]
        StoreOffsetsNotStrictlyIncreasing(StoreOffsetsNotStrictlyIncreasing),
        #[allow(missing_docs)]
        TooManyBlocks(TooManyBlocks),
        #[allow(missing_docs)]
        UnanchoredBlockRange(UnanchoredBlockRange),
    }
    impl TronLightClientErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [18u8, 164u8, 114u8, 71u8],
            [53u8, 174u8, 144u8, 59u8],
            [63u8, 193u8, 134u8, 211u8],
            [76u8, 145u8, 147u8, 0u8],
            [89u8, 94u8, 16u8, 137u8],
            [99u8, 203u8, 90u8, 65u8],
            [103u8, 71u8, 88u8, 180u8],
            [128u8, 37u8, 176u8, 62u8],
            [143u8, 22u8, 20u8, 143u8],
            [149u8, 109u8, 24u8, 233u8],
            [158u8, 37u8, 101u8, 45u8],
            [175u8, 231u8, 244u8, 224u8],
            [194u8, 255u8, 188u8, 236u8],
            [201u8, 222u8, 113u8, 34u8],
            [221u8, 92u8, 171u8, 62u8],
            [224u8, 130u8, 132u8, 11u8],
            [240u8, 177u8, 68u8, 75u8],
            [251u8, 105u8, 168u8, 46u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(InvalidIntersectionOffset),
            ::core::stringify!(BlockNotRelayed),
            ::core::stringify!(InvalidCompressedSignaturesLength),
            ::core::stringify!(SrSetNotSorted),
            ::core::stringify!(CheckpointNotFinalized),
            ::core::stringify!(InvalidSrIndex),
            ::core::stringify!(InvalidCompressedTronBlockMetadataLength),
            ::core::stringify!(InvalidWitnessSigner),
            ::core::stringify!(StoreOffsetsNotStrictlyIncreasing),
            ::core::stringify!(InvalidIntersectionClaim),
            ::core::stringify!(UnanchoredBlockRange),
            ::core::stringify!(InvalidChain),
            ::core::stringify!(BlockTooOld),
            ::core::stringify!(InvalidParentBlockId),
            ::core::stringify!(Sha256PrecompileFailed),
            ::core::stringify!(TooManyBlocks),
            ::core::stringify!(InvalidWitnessDelegateeIndex),
            ::core::stringify!(InvalidStoreOffset),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <InvalidIntersectionOffset as alloy_sol_types::SolError>::SIGNATURE,
            <BlockNotRelayed as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidCompressedSignaturesLength as alloy_sol_types::SolError>::SIGNATURE,
            <SrSetNotSorted as alloy_sol_types::SolError>::SIGNATURE,
            <CheckpointNotFinalized as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidSrIndex as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidCompressedTronBlockMetadataLength as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidWitnessSigner as alloy_sol_types::SolError>::SIGNATURE,
            <StoreOffsetsNotStrictlyIncreasing as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidIntersectionClaim as alloy_sol_types::SolError>::SIGNATURE,
            <UnanchoredBlockRange as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidChain as alloy_sol_types::SolError>::SIGNATURE,
            <BlockTooOld as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidParentBlockId as alloy_sol_types::SolError>::SIGNATURE,
            <Sha256PrecompileFailed as alloy_sol_types::SolError>::SIGNATURE,
            <TooManyBlocks as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidWitnessDelegateeIndex as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidStoreOffset as alloy_sol_types::SolError>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TronLightClientErrors {
        const NAME: &'static str = "TronLightClientErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 18usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::BlockNotRelayed(_) => {
                    <BlockNotRelayed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BlockTooOld(_) => {
                    <BlockTooOld as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CheckpointNotFinalized(_) => {
                    <CheckpointNotFinalized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidChain(_) => {
                    <InvalidChain as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidCompressedSignaturesLength(_) => {
                    <InvalidCompressedSignaturesLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidCompressedTronBlockMetadataLength(_) => {
                    <InvalidCompressedTronBlockMetadataLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidIntersectionClaim(_) => {
                    <InvalidIntersectionClaim as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidIntersectionOffset(_) => {
                    <InvalidIntersectionOffset as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidParentBlockId(_) => {
                    <InvalidParentBlockId as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidSrIndex(_) => {
                    <InvalidSrIndex as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidStoreOffset(_) => {
                    <InvalidStoreOffset as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidWitnessDelegateeIndex(_) => {
                    <InvalidWitnessDelegateeIndex as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidWitnessSigner(_) => {
                    <InvalidWitnessSigner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Sha256PrecompileFailed(_) => {
                    <Sha256PrecompileFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SrSetNotSorted(_) => {
                    <SrSetNotSorted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::StoreOffsetsNotStrictlyIncreasing(_) => {
                    <StoreOffsetsNotStrictlyIncreasing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TooManyBlocks(_) => {
                    <TooManyBlocks as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnanchoredBlockRange(_) => {
                    <UnanchoredBlockRange as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<TronLightClientErrors>] = &[
                {
                    fn InvalidIntersectionOffset(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidIntersectionOffset as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientErrors::InvalidIntersectionOffset)
                    }
                    InvalidIntersectionOffset
                },
                {
                    fn BlockNotRelayed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <BlockNotRelayed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientErrors::BlockNotRelayed)
                    }
                    BlockNotRelayed
                },
                {
                    fn InvalidCompressedSignaturesLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidCompressedSignaturesLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                TronLightClientErrors::InvalidCompressedSignaturesLength,
                            )
                    }
                    InvalidCompressedSignaturesLength
                },
                {
                    fn SrSetNotSorted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <SrSetNotSorted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientErrors::SrSetNotSorted)
                    }
                    SrSetNotSorted
                },
                {
                    fn CheckpointNotFinalized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <CheckpointNotFinalized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientErrors::CheckpointNotFinalized)
                    }
                    CheckpointNotFinalized
                },
                {
                    fn InvalidSrIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidSrIndex as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientErrors::InvalidSrIndex)
                    }
                    InvalidSrIndex
                },
                {
                    fn InvalidCompressedTronBlockMetadataLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidCompressedTronBlockMetadataLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                TronLightClientErrors::InvalidCompressedTronBlockMetadataLength,
                            )
                    }
                    InvalidCompressedTronBlockMetadataLength
                },
                {
                    fn InvalidWitnessSigner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidWitnessSigner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientErrors::InvalidWitnessSigner)
                    }
                    InvalidWitnessSigner
                },
                {
                    fn StoreOffsetsNotStrictlyIncreasing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <StoreOffsetsNotStrictlyIncreasing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                TronLightClientErrors::StoreOffsetsNotStrictlyIncreasing,
                            )
                    }
                    StoreOffsetsNotStrictlyIncreasing
                },
                {
                    fn InvalidIntersectionClaim(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidIntersectionClaim as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientErrors::InvalidIntersectionClaim)
                    }
                    InvalidIntersectionClaim
                },
                {
                    fn UnanchoredBlockRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <UnanchoredBlockRange as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientErrors::UnanchoredBlockRange)
                    }
                    UnanchoredBlockRange
                },
                {
                    fn InvalidChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidChain as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(TronLightClientErrors::InvalidChain)
                    }
                    InvalidChain
                },
                {
                    fn BlockTooOld(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <BlockTooOld as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(TronLightClientErrors::BlockTooOld)
                    }
                    BlockTooOld
                },
                {
                    fn InvalidParentBlockId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidParentBlockId as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientErrors::InvalidParentBlockId)
                    }
                    InvalidParentBlockId
                },
                {
                    fn Sha256PrecompileFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <Sha256PrecompileFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientErrors::Sha256PrecompileFailed)
                    }
                    Sha256PrecompileFailed
                },
                {
                    fn TooManyBlocks(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <TooManyBlocks as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientErrors::TooManyBlocks)
                    }
                    TooManyBlocks
                },
                {
                    fn InvalidWitnessDelegateeIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidWitnessDelegateeIndex as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientErrors::InvalidWitnessDelegateeIndex)
                    }
                    InvalidWitnessDelegateeIndex
                },
                {
                    fn InvalidStoreOffset(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidStoreOffset as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(TronLightClientErrors::InvalidStoreOffset)
                    }
                    InvalidStoreOffset
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<TronLightClientErrors>] = &[
                {
                    fn InvalidIntersectionOffset(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidIntersectionOffset as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientErrors::InvalidIntersectionOffset)
                    }
                    InvalidIntersectionOffset
                },
                {
                    fn BlockNotRelayed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <BlockNotRelayed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientErrors::BlockNotRelayed)
                    }
                    BlockNotRelayed
                },
                {
                    fn InvalidCompressedSignaturesLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidCompressedSignaturesLength as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                TronLightClientErrors::InvalidCompressedSignaturesLength,
                            )
                    }
                    InvalidCompressedSignaturesLength
                },
                {
                    fn SrSetNotSorted(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <SrSetNotSorted as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientErrors::SrSetNotSorted)
                    }
                    SrSetNotSorted
                },
                {
                    fn CheckpointNotFinalized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <CheckpointNotFinalized as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientErrors::CheckpointNotFinalized)
                    }
                    CheckpointNotFinalized
                },
                {
                    fn InvalidSrIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidSrIndex as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientErrors::InvalidSrIndex)
                    }
                    InvalidSrIndex
                },
                {
                    fn InvalidCompressedTronBlockMetadataLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidCompressedTronBlockMetadataLength as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                TronLightClientErrors::InvalidCompressedTronBlockMetadataLength,
                            )
                    }
                    InvalidCompressedTronBlockMetadataLength
                },
                {
                    fn InvalidWitnessSigner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidWitnessSigner as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientErrors::InvalidWitnessSigner)
                    }
                    InvalidWitnessSigner
                },
                {
                    fn StoreOffsetsNotStrictlyIncreasing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <StoreOffsetsNotStrictlyIncreasing as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                TronLightClientErrors::StoreOffsetsNotStrictlyIncreasing,
                            )
                    }
                    StoreOffsetsNotStrictlyIncreasing
                },
                {
                    fn InvalidIntersectionClaim(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidIntersectionClaim as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientErrors::InvalidIntersectionClaim)
                    }
                    InvalidIntersectionClaim
                },
                {
                    fn UnanchoredBlockRange(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <UnanchoredBlockRange as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientErrors::UnanchoredBlockRange)
                    }
                    UnanchoredBlockRange
                },
                {
                    fn InvalidChain(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidChain as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientErrors::InvalidChain)
                    }
                    InvalidChain
                },
                {
                    fn BlockTooOld(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <BlockTooOld as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientErrors::BlockTooOld)
                    }
                    BlockTooOld
                },
                {
                    fn InvalidParentBlockId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidParentBlockId as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientErrors::InvalidParentBlockId)
                    }
                    InvalidParentBlockId
                },
                {
                    fn Sha256PrecompileFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <Sha256PrecompileFailed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientErrors::Sha256PrecompileFailed)
                    }
                    Sha256PrecompileFailed
                },
                {
                    fn TooManyBlocks(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <TooManyBlocks as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientErrors::TooManyBlocks)
                    }
                    TooManyBlocks
                },
                {
                    fn InvalidWitnessDelegateeIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidWitnessDelegateeIndex as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientErrors::InvalidWitnessDelegateeIndex)
                    }
                    InvalidWitnessDelegateeIndex
                },
                {
                    fn InvalidStoreOffset(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<TronLightClientErrors> {
                        <InvalidStoreOffset as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(TronLightClientErrors::InvalidStoreOffset)
                    }
                    InvalidStoreOffset
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::BlockNotRelayed(inner) => {
                    <BlockNotRelayed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BlockTooOld(inner) => {
                    <BlockTooOld as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::CheckpointNotFinalized(inner) => {
                    <CheckpointNotFinalized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidChain(inner) => {
                    <InvalidChain as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidCompressedSignaturesLength(inner) => {
                    <InvalidCompressedSignaturesLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidCompressedTronBlockMetadataLength(inner) => {
                    <InvalidCompressedTronBlockMetadataLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidIntersectionClaim(inner) => {
                    <InvalidIntersectionClaim as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidIntersectionOffset(inner) => {
                    <InvalidIntersectionOffset as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidParentBlockId(inner) => {
                    <InvalidParentBlockId as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidSrIndex(inner) => {
                    <InvalidSrIndex as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidStoreOffset(inner) => {
                    <InvalidStoreOffset as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidWitnessDelegateeIndex(inner) => {
                    <InvalidWitnessDelegateeIndex as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidWitnessSigner(inner) => {
                    <InvalidWitnessSigner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Sha256PrecompileFailed(inner) => {
                    <Sha256PrecompileFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SrSetNotSorted(inner) => {
                    <SrSetNotSorted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::StoreOffsetsNotStrictlyIncreasing(inner) => {
                    <StoreOffsetsNotStrictlyIncreasing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TooManyBlocks(inner) => {
                    <TooManyBlocks as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::UnanchoredBlockRange(inner) => {
                    <UnanchoredBlockRange as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::BlockNotRelayed(inner) => {
                    <BlockNotRelayed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BlockTooOld(inner) => {
                    <BlockTooOld as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CheckpointNotFinalized(inner) => {
                    <CheckpointNotFinalized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidChain(inner) => {
                    <InvalidChain as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidCompressedSignaturesLength(inner) => {
                    <InvalidCompressedSignaturesLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidCompressedTronBlockMetadataLength(inner) => {
                    <InvalidCompressedTronBlockMetadataLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidIntersectionClaim(inner) => {
                    <InvalidIntersectionClaim as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidIntersectionOffset(inner) => {
                    <InvalidIntersectionOffset as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidParentBlockId(inner) => {
                    <InvalidParentBlockId as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidSrIndex(inner) => {
                    <InvalidSrIndex as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidStoreOffset(inner) => {
                    <InvalidStoreOffset as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidWitnessDelegateeIndex(inner) => {
                    <InvalidWitnessDelegateeIndex as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidWitnessSigner(inner) => {
                    <InvalidWitnessSigner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Sha256PrecompileFailed(inner) => {
                    <Sha256PrecompileFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SrSetNotSorted(inner) => {
                    <SrSetNotSorted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::StoreOffsetsNotStrictlyIncreasing(inner) => {
                    <StoreOffsetsNotStrictlyIncreasing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TooManyBlocks(inner) => {
                    <TooManyBlocks as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnanchoredBlockRange(inner) => {
                    <UnanchoredBlockRange as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`TronLightClient`](self) events.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum TronLightClientEvents {
        #[allow(missing_docs)]
        LatestProvenBlockUpdated(LatestProvenBlockUpdated),
        #[allow(missing_docs)]
        TronBlockStored(TronBlockStored),
        #[allow(missing_docs)]
        TronLightClientConfigured(TronLightClientConfigured),
    }
    impl TronLightClientEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                8u8, 166u8, 123u8, 65u8, 114u8, 30u8, 109u8, 24u8, 235u8, 90u8, 63u8,
                13u8, 71u8, 83u8, 80u8, 55u8, 231u8, 85u8, 72u8, 245u8, 111u8, 249u8,
                23u8, 112u8, 216u8, 80u8, 174u8, 199u8, 191u8, 35u8, 239u8, 74u8,
            ],
            [
                25u8, 236u8, 106u8, 215u8, 69u8, 45u8, 116u8, 67u8, 130u8, 224u8, 245u8,
                144u8, 100u8, 1u8, 125u8, 202u8, 86u8, 210u8, 179u8, 185u8, 164u8, 32u8,
                38u8, 198u8, 128u8, 58u8, 252u8, 90u8, 20u8, 92u8, 209u8, 17u8,
            ],
            [
                169u8, 254u8, 112u8, 27u8, 77u8, 162u8, 255u8, 103u8, 92u8, 253u8, 13u8,
                197u8, 65u8, 251u8, 55u8, 58u8, 70u8, 167u8, 44u8, 92u8, 37u8, 138u8,
                153u8, 254u8, 133u8, 8u8, 82u8, 220u8, 117u8, 211u8, 161u8, 203u8,
            ],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(TronLightClientConfigured),
            ::core::stringify!(TronBlockStored),
            ::core::stringify!(LatestProvenBlockUpdated),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <TronLightClientConfigured as alloy_sol_types::SolEvent>::SIGNATURE,
            <TronBlockStored as alloy_sol_types::SolEvent>::SIGNATURE,
            <LatestProvenBlockUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for TronLightClientEvents {
        const NAME: &'static str = "TronLightClientEvents";
        const COUNT: usize = 3usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <LatestProvenBlockUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <LatestProvenBlockUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::LatestProvenBlockUpdated)
                }
                Some(<TronBlockStored as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TronBlockStored as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::TronBlockStored)
                }
                Some(
                    <TronLightClientConfigured as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <TronLightClientConfigured as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::TronLightClientConfigured)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for TronLightClientEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::LatestProvenBlockUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TronBlockStored(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TronLightClientConfigured(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::LatestProvenBlockUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TronBlockStored(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TronLightClientConfigured(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`TronLightClient`](self) contract instance.

See the [wrapper's documentation](`TronLightClientInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> TronLightClientInstance<P, N> {
        TronLightClientInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        blockRangeProver: alloy::sol_types::private::Address,
        initialBlockHash: alloy::sol_types::private::FixedBytes<32>,
        initialTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        initialTimestamp: u32,
        _srs: [alloy::sol_types::private::FixedBytes<20>; 27usize],
        _witnessDelegatees: [alloy::sol_types::private::FixedBytes<20>; 27usize],
        srDataHash: alloy::sol_types::private::FixedBytes<32>,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<TronLightClientInstance<P, N>>,
    > {
        TronLightClientInstance::<
            P,
            N,
        >::deploy(
            __provider,
            blockRangeProver,
            initialBlockHash,
            initialTxTrieRoot,
            initialTimestamp,
            _srs,
            _witnessDelegatees,
            srDataHash,
        )
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        blockRangeProver: alloy::sol_types::private::Address,
        initialBlockHash: alloy::sol_types::private::FixedBytes<32>,
        initialTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
        initialTimestamp: u32,
        _srs: [alloy::sol_types::private::FixedBytes<20>; 27usize],
        _witnessDelegatees: [alloy::sol_types::private::FixedBytes<20>; 27usize],
        srDataHash: alloy::sol_types::private::FixedBytes<32>,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        TronLightClientInstance::<
            P,
            N,
        >::deploy_builder(
            __provider,
            blockRangeProver,
            initialBlockHash,
            initialTxTrieRoot,
            initialTimestamp,
            _srs,
            _witnessDelegatees,
            srDataHash,
        )
    }
    /**A [`TronLightClient`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`TronLightClient`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct TronLightClientInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for TronLightClientInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("TronLightClientInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > TronLightClientInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`TronLightClient`](self) contract instance.

See the [wrapper's documentation](`TronLightClientInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
            blockRangeProver: alloy::sol_types::private::Address,
            initialBlockHash: alloy::sol_types::private::FixedBytes<32>,
            initialTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
            initialTimestamp: u32,
            _srs: [alloy::sol_types::private::FixedBytes<20>; 27usize],
            _witnessDelegatees: [alloy::sol_types::private::FixedBytes<20>; 27usize],
            srDataHash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::Result<TronLightClientInstance<P, N>> {
            let call_builder = Self::deploy_builder(
                __provider,
                blockRangeProver,
                initialBlockHash,
                initialTxTrieRoot,
                initialTimestamp,
                _srs,
                _witnessDelegatees,
                srDataHash,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            __provider: P,
            blockRangeProver: alloy::sol_types::private::Address,
            initialBlockHash: alloy::sol_types::private::FixedBytes<32>,
            initialTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
            initialTimestamp: u32,
            _srs: [alloy::sol_types::private::FixedBytes<20>; 27usize],
            _witnessDelegatees: [alloy::sol_types::private::FixedBytes<20>; 27usize],
            srDataHash: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            blockRangeProver,
                            initialBlockHash,
                            initialTxTrieRoot,
                            initialTimestamp,
                            _srs,
                            _witnessDelegatees,
                            srDataHash,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> TronLightClientInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> TronLightClientInstance<P, N> {
            TronLightClientInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > TronLightClientInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`BLOCK_RANGE_PROVER`] function.
        pub fn BLOCK_RANGE_PROVER(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, BLOCK_RANGE_PROVERCall, N> {
            self.call_builder(&BLOCK_RANGE_PROVERCall)
        }
        ///Creates a new call builder for the [`SR_DATA_HASH`] function.
        pub fn SR_DATA_HASH(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, SR_DATA_HASHCall, N> {
            self.call_builder(&SR_DATA_HASHCall)
        }
        ///Creates a new call builder for the [`eventChainTip`] function.
        pub fn eventChainTip(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, eventChainTipCall, N> {
            self.call_builder(&eventChainTipCall)
        }
        ///Creates a new call builder for the [`getBlockId`] function.
        pub fn getBlockId(
            &self,
            blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getBlockIdCall, N> {
            self.call_builder(&getBlockIdCall { blockNumber })
        }
        ///Creates a new call builder for the [`getBlockTimestamp`] function.
        pub fn getBlockTimestamp(
            &self,
            blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getBlockTimestampCall, N> {
            self.call_builder(
                &getBlockTimestampCall {
                    blockNumber,
                },
            )
        }
        ///Creates a new call builder for the [`getTxTrieRoot`] function.
        pub fn getTxTrieRoot(
            &self,
            blockNumber: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getTxTrieRootCall, N> {
            self.call_builder(&getTxTrieRootCall { blockNumber })
        }
        ///Creates a new call builder for the [`latestProvenBlock`] function.
        pub fn latestProvenBlock(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, latestProvenBlockCall, N> {
            self.call_builder(&latestProvenBlockCall)
        }
        ///Creates a new call builder for the [`proveBlockRange`] function.
        pub fn proveBlockRange(
            &self,
            startingBlock: alloy::sol_types::private::FixedBytes<32>,
            endingBlock: alloy::sol_types::private::FixedBytes<32>,
            endingBlockTxTrieRoot: alloy::sol_types::private::FixedBytes<32>,
            endingBlockTimestamp: u32,
            zkProof: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, proveBlockRangeCall, N> {
            self.call_builder(
                &proveBlockRangeCall {
                    startingBlock,
                    endingBlock,
                    endingBlockTxTrieRoot,
                    endingBlockTimestamp,
                    zkProof,
                },
            )
        }
        ///Creates a new call builder for the [`proveBlocks`] function.
        pub fn proveBlocks(
            &self,
            startingBlock: alloy::sol_types::private::FixedBytes<32>,
            compressedTronBlockMetadata: alloy::sol_types::private::Bytes,
            compressedSignatures: alloy::sol_types::private::Bytes,
            intersectionOffset: alloy::sol_types::private::primitives::aliases::U256,
            storeOffsets16: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, proveBlocksCall, N> {
            self.call_builder(
                &proveBlocksCall {
                    startingBlock,
                    compressedTronBlockMetadata,
                    compressedSignatures,
                    intersectionOffset,
                    storeOffsets16,
                },
            )
        }
        ///Creates a new call builder for the [`srs`] function.
        pub fn srs(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, srsCall, N> {
            self.call_builder(&srsCall { index })
        }
        ///Creates a new call builder for the [`witnessDelegatees`] function.
        pub fn witnessDelegatees(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, witnessDelegateesCall, N> {
            self.call_builder(&witnessDelegateesCall { index })
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > TronLightClientInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`LatestProvenBlockUpdated`] event.
        pub fn LatestProvenBlockUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, LatestProvenBlockUpdated, N> {
            self.event_filter::<LatestProvenBlockUpdated>()
        }
        ///Creates a new event filter for the [`TronBlockStored`] event.
        pub fn TronBlockStored_filter(
            &self,
        ) -> alloy_contract::Event<&P, TronBlockStored, N> {
            self.event_filter::<TronBlockStored>()
        }
        ///Creates a new event filter for the [`TronLightClientConfigured`] event.
        pub fn TronLightClientConfigured_filter(
            &self,
        ) -> alloy_contract::Event<&P, TronLightClientConfigured, N> {
            self.event_filter::<TronLightClientConfigured>()
        }
    }
}
