This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: protos/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  address.rs
  grpc.rs
  lib.rs
  proof.rs
  wallet.rs
testdata/
  fixtures/
    trc20_tx_78115149.sample.json
    tron_headers_78000000_78000099.sample.json
    tron_tx_proof_78812179_1d649769f0ecf78bd6812226d067144bca18b4d01fb34cfdb260fd51cc3072db.json
build.rs
Cargo.toml

================================================================
Files
================================================================

================
File: src/address.rs
================
use alloy::primitives::Address;
use sha2::{Digest, Sha256};
use std::fmt;
use std::str::FromStr;

/// Tron mainnet base58check address (0x41 || addr20).
///
/// - In-memory representation is always the 20-byte EVM-form `Address`.
/// - String representation is always canonical Tron base58check (T...).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct TronAddress(Address);

impl TronAddress {
    pub const MAINNET_PREFIX: u8 = 0x41;

    pub fn from_evm(addr: Address) -> Self {
        Self(addr)
    }

    pub fn evm(self) -> Address {
        self.0
    }

    pub fn from_base58check(value: &str) -> anyhow::Result<Self> {
        let payload = bs58::decode(value)
            .with_check(None)
            .into_vec()
            .map_err(|e| anyhow::Error::new(e).context("base58check decode"))?;

        if payload.len() != 21 {
            anyhow::bail!(
                "invalid Tron address length: expected 21 bytes, got {}",
                payload.len()
            );
        }
        if payload[0] != Self::MAINNET_PREFIX {
            anyhow::bail!(
                "unexpected Tron address prefix: expected 0x{:02x}, got 0x{:02x}",
                Self::MAINNET_PREFIX,
                payload[0],
            );
        }

        Ok(Self(Address::from_slice(&payload[1..])))
    }

    /// Parses either Tron base58check (T...) or EVM hex (0x...).
    pub fn parse_text(value: &str) -> anyhow::Result<Self> {
        let trimmed = value.trim();
        if trimmed.starts_with('T') {
            return Self::from_base58check(trimmed);
        }
        if let Ok(evm) = trimmed.parse::<Address>() {
            return Ok(Self::from_evm(evm));
        }
        anyhow::bail!("invalid Tron address text: {value}");
    }

    pub fn to_base58check(self) -> String {
        let mut payload = [0u8; 21];
        payload[0] = Self::MAINNET_PREFIX;
        payload[1..].copy_from_slice(self.0.as_slice());

        let mut hasher = Sha256::new();
        hasher.update(payload);
        let first = hasher.finalize_reset();
        hasher.update(first);
        let second = hasher.finalize();
        let checksum = &second[..4];

        let mut with_checksum = [0u8; 25];
        with_checksum[..21].copy_from_slice(&payload);
        with_checksum[21..].copy_from_slice(checksum);

        bs58::encode(with_checksum).into_string()
    }

    /// 0x41 || addr20 (21 bytes), for Tron gRPC `owner_address`/`contract_address`.
    pub fn prefixed_bytes(self) -> [u8; 21] {
        let mut out = [0u8; 21];
        out[0] = Self::MAINNET_PREFIX;
        out[1..].copy_from_slice(self.0.as_slice());
        out
    }
}

impl From<Address> for TronAddress {
    fn from(value: Address) -> Self {
        Self::from_evm(value)
    }
}

impl From<TronAddress> for Address {
    fn from(value: TronAddress) -> Self {
        value.0
    }
}

impl fmt::Display for TronAddress {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.to_base58check())
    }
}

impl FromStr for TronAddress {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::parse_text(s)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use alloy::primitives::Address;

    #[test]
    fn base58check_roundtrip() {
        let addr20 = Address::from_slice(&[0x11u8; 20]);
        let tron = TronAddress::from_evm(addr20);

        let s = tron.to_base58check();
        let parsed = TronAddress::from_base58check(&s).unwrap();
        assert_eq!(parsed, tron);
        assert_eq!(parsed.to_string(), s);
    }

    #[test]
    fn parse_text_accepts_hex_or_tron() {
        let addr: Address = "0x0000000000000000000000000000000000000001"
            .parse()
            .unwrap();
        let tron = TronAddress::parse_text("0x0000000000000000000000000000000000000001").unwrap();
        assert_eq!(tron.evm(), addr);

        let tron2 = TronAddress::parse_text(&tron.to_base58check()).unwrap();
        assert_eq!(tron2, tron);
    }

    #[test]
    fn from_base58check_rejects_wrong_prefix() {
        let addr20 = Address::from_slice(&[0x22u8; 20]);
        let mut payload = [0u8; 21];
        payload[0] = 0x42;
        payload[1..].copy_from_slice(addr20.as_slice());

        let mut hasher = Sha256::new();
        hasher.update(payload);
        let first = hasher.finalize_reset();
        hasher.update(first);
        let second = hasher.finalize();
        let checksum = &second[..4];

        let mut with_checksum = [0u8; 25];
        with_checksum[..21].copy_from_slice(&payload);
        with_checksum[21..].copy_from_slice(checksum);

        let s = bs58::encode(with_checksum).into_string();
        let err = TronAddress::from_base58check(&s).unwrap_err().to_string();
        assert!(err.contains("unexpected Tron address prefix"));
    }

    #[test]
    fn prefixed_bytes_has_mainnet_prefix() {
        let addr20 = Address::from_slice(&[0x33u8; 20]);
        let tron = TronAddress::from_evm(addr20);
        let b = tron.prefixed_bytes();
        assert_eq!(b[0], TronAddress::MAINNET_PREFIX);
        assert_eq!(&b[1..], addr20.as_slice());
    }
}

================
File: src/grpc.rs
================
use super::protocol::{
    Account, BlockExtention, BytesMessage, EmptyMessage, NumberMessage, Return, Transaction,
    TransactionExtention, TransactionInfo, TriggerSmartContract, wallet_client::WalletClient,
};
use anyhow::{Context, Result};
use std::str::FromStr;
use tonic::{Request, metadata::MetadataValue, transport::Channel};

#[derive(Clone)]
pub struct TronGrpc {
    api_key: Option<MetadataValue<tonic::metadata::Ascii>>,
    wallet: WalletClient<Channel>,
}

impl TronGrpc {
    pub async fn connect(grpc_url: &str, api_key: Option<&str>) -> Result<Self> {
        let channel = Channel::from_shared(grpc_url.to_string())
            .context("invalid TRON_GRPC_URL")?
            .connect()
            .await
            .context("connect TRON gRPC")?;

        let api_key = match api_key {
            Some(k) if !k.trim().is_empty() => {
                Some(MetadataValue::from_str(k).context("invalid TRON_API_KEY (metadata value)")?)
            }
            _ => None,
        };

        Ok(Self {
            api_key,
            wallet: WalletClient::new(channel),
        })
    }

    fn req<T>(&self, msg: T) -> Request<T> {
        let mut req = Request::new(msg);
        if let Some(key) = &self.api_key {
            req.metadata_mut().insert("tron-pro-api-key", key.clone());
        }
        req
    }

    pub async fn get_now_block2(&mut self) -> Result<BlockExtention> {
        let resp = self
            .wallet
            .get_now_block2(self.req(EmptyMessage {}))
            .await
            .context("GetNowBlock2")?;
        Ok(resp.into_inner())
    }

    pub async fn get_block_by_num2(&mut self, num: i64) -> Result<BlockExtention> {
        let resp = self
            .wallet
            .get_block_by_num2(self.req(NumberMessage { num }))
            .await
            .context("GetBlockByNum2")?;
        Ok(resp.into_inner())
    }

    pub async fn get_transaction_info_by_id(&mut self, txid: [u8; 32]) -> Result<TransactionInfo> {
        let resp = self
            .wallet
            .get_transaction_info_by_id(self.req(BytesMessage {
                value: txid.to_vec(),
            }))
            .await
            .context("GetTransactionInfoById")?;
        Ok(resp.into_inner())
    }

    pub async fn trigger_contract(
        &mut self,
        msg: TriggerSmartContract,
    ) -> Result<TransactionExtention> {
        let resp = self
            .wallet
            .trigger_contract(self.req(msg))
            .await
            .context("TriggerContract")?;
        Ok(resp.into_inner())
    }

    pub async fn trigger_constant_contract(
        &mut self,
        msg: TriggerSmartContract,
    ) -> Result<TransactionExtention> {
        let resp = self
            .wallet
            .trigger_constant_contract(self.req(msg))
            .await
            .context("TriggerConstantContract")?;
        Ok(resp.into_inner())
    }

    pub async fn broadcast_transaction(&mut self, tx: Transaction) -> Result<Return> {
        let resp = self
            .wallet
            .broadcast_transaction(self.req(tx))
            .await
            .context("BroadcastTransaction")?;
        Ok(resp.into_inner())
    }

    pub async fn get_account(&mut self, address_prefixed: Vec<u8>) -> Result<Account> {
        let resp = self
            .wallet
            .get_account(self.req(Account {
                address: address_prefixed,
                ..Default::default()
            }))
            .await
            .context("GetAccount")?;
        Ok(resp.into_inner())
    }
}

================
File: src/lib.rs
================
pub mod address;
pub mod grpc;
pub mod proof;
pub mod wallet;

pub use address::TronAddress;
pub use grpc::TronGrpc;
pub use proof::{TronTxProofBuilder, TronTxProofBundle};
pub use wallet::TronWallet;

pub mod protocol {
    #![allow(clippy::all, clippy::pedantic, clippy::nursery)]
    #![allow(
        dead_code,
        unused_imports,
        unused_variables,
        non_snake_case,
        non_camel_case_types,
        non_upper_case_globals
    )]

    tonic::include_proto!("protocol");
}

================
File: src/proof.rs
================
use super::grpc::TronGrpc;
use super::protocol::{BlockExtention, BlockHeader};
use alloy::primitives::{FixedBytes, U256};
use anyhow::{Context, Result};
use prost::Message;
use sha2::{Digest, Sha256};

pub struct TronTxProofBundle {
    pub blocks: [Vec<u8>; 20],
    pub encoded_tx: Vec<u8>,
    pub proof: Vec<FixedBytes<32>>,
    pub index: U256,
}

pub struct TronTxProofBuilder {
    /// Must be 19 for the hub's `bytes[20]` proof format.
    pub finality_blocks: u64,
}

impl TronTxProofBuilder {
    pub fn new(finality_blocks: u64) -> Self {
        Self { finality_blocks }
    }

    pub async fn build(&self, grpc: &mut TronGrpc, txid: [u8; 32]) -> Result<TronTxProofBundle> {
        if self.finality_blocks != 19 {
            anyhow::bail!(
                "unsupported Tron finality_blocks: expected 19, got {}",
                self.finality_blocks
            );
        }

        let tx_info = grpc
            .get_transaction_info_by_id(txid)
            .await
            .context("get tx info")?;
        let tron_block_number =
            u64::try_from(tx_info.block_number).context("Tron tx blockNumber out of range")?;

        let head = tron_head_block(grpc).await?;
        if head < tron_block_number + self.finality_blocks {
            anyhow::bail!(
                "tx not finalized: head={}, tx_block={}, need >= {}",
                head,
                tron_block_number,
                tron_block_number + self.finality_blocks
            );
        }

        // Fetch the tx block (with tx list) first.
        let tx_block = grpc
            .get_block_by_num2(i64::try_from(tron_block_number)?)
            .await
            .context("get tx block")?;

        let (tx_index, encoded_tx, tx_trie_root) = extract_tx_and_root(&tx_block, txid)?;

        let leaves = tx_block
            .transactions
            .iter()
            .map(|txe| {
                let tx = txe
                    .transaction
                    .as_ref()
                    .context("missing Transaction in TransactionExtention")?;
                Ok(sha256_bytes32(&tx.encode_to_vec()))
            })
            .collect::<Result<Vec<_>>>()?;

        let (proof, index, computed_root) = merkle_proof_sha256(&leaves, tx_index)?;
        if computed_root.as_slice() != tx_trie_root.as_slice() {
            anyhow::bail!(
                "computed txTrieRoot mismatch (encoding/proof algo bug): computed=0x{}, header=0x{}",
                hex::encode(computed_root),
                hex::encode(tx_trie_root),
            );
        }

        // Fetch 19 blocks after, for the hub's stateful Tron reader.
        let mut blocks: [Vec<u8>; 20] = std::array::from_fn(|_| Vec::new());
        blocks[0] = encode_block_header(&tx_block.block_header)?;
        for (i, block) in blocks.iter_mut().enumerate().skip(1) {
            let num = tron_block_number + (i as u64);
            let b = grpc
                .get_block_by_num2(i64::try_from(num)?)
                .await
                .with_context(|| format!("get block {num}"))?;
            *block = encode_block_header(&b.block_header)?;
        }

        Ok(TronTxProofBundle {
            blocks,
            encoded_tx,
            proof,
            index,
        })
    }
}

async fn tron_head_block(grpc: &mut TronGrpc) -> Result<u64> {
    let b = grpc.get_now_block2().await.context("get now block")?;
    let raw = b
        .block_header
        .as_ref()
        .and_then(|h| h.raw_data.as_ref())
        .context("missing now block header.raw_data")?;
    u64::try_from(raw.number).context("now block number out of range")
}

fn extract_tx_and_root(b: &BlockExtention, txid: [u8; 32]) -> Result<(usize, Vec<u8>, Vec<u8>)> {
    let header_raw = b
        .block_header
        .as_ref()
        .and_then(|h| h.raw_data.as_ref())
        .context("missing block_header.raw_data")?;
    let tx_trie_root = header_raw.tx_trie_root.clone();

    for (idx, txe) in b.transactions.iter().enumerate() {
        if txe.txid.as_slice() == txid {
            let tx = txe
                .transaction
                .as_ref()
                .context("missing Transaction in TransactionExtention")?;
            return Ok((idx, tx.encode_to_vec(), tx_trie_root));
        }
    }

    anyhow::bail!("tx not found in block tx list");
}

fn encode_block_header(h: &Option<BlockHeader>) -> Result<Vec<u8>> {
    let h = h.as_ref().context("missing block_header")?;
    encode_block_header_stateful(h)
}

fn sha256_bytes32(bytes: &[u8]) -> FixedBytes<32> {
    let digest = Sha256::digest(bytes);
    FixedBytes::from_slice(&digest)
}

/// Encode a Tron `BlockHeader` in the exact fixed format expected by `StatefulTronTxReader`.
///
/// The onchain verifier expects:
/// - total length 174 bytes,
/// - `raw_data` length 105 bytes (0x69),
/// - `witness_signature` length 65 bytes (0x41),
/// - and specific field ordering with current-era varint lengths:
///   - timestamp (ms): 6 bytes varint
///   - block number: 4 bytes varint
///
/// If any of these assumptions are violated (future-proofing / different Tron network),
/// we fail fast so the relayer doesn't submit transactions that are guaranteed to revert.
fn encode_block_header_stateful(h: &BlockHeader) -> Result<Vec<u8>> {
    let raw = h
        .raw_data
        .as_ref()
        .context("missing block_header.raw_data")?;

    let ts_ms = u64::try_from(raw.timestamp).context("header timestamp out of range")?;
    let number = u64::try_from(raw.number).context("header number out of range")?;
    let version = u64::try_from(raw.version).context("header version out of range")?;

    let tx_trie_root = raw.tx_trie_root.as_slice();
    if tx_trie_root.len() != 32 {
        anyhow::bail!("unexpected txTrieRoot length: {}", tx_trie_root.len());
    }
    let parent_hash = raw.parent_hash.as_slice();
    if parent_hash.len() != 32 {
        anyhow::bail!("unexpected parentHash length: {}", parent_hash.len());
    }

    let witness_addr = raw.witness_address.as_slice();
    if witness_addr.len() != 21 {
        anyhow::bail!("unexpected witness_address length: {}", witness_addr.len());
    }

    let sig = h.witness_signature.as_slice();
    if sig.len() != 65 {
        anyhow::bail!("unexpected witness_signature length: {}", sig.len());
    }

    // Build the raw_data message (105 bytes).
    let ts_var = encode_varint_fixed(ts_ms, 6)?;
    let num_var = encode_varint_fixed(number, 4)?;
    let ver_var = encode_varint_fixed(version, 1)?;

    let mut raw_data = Vec::with_capacity(105);
    raw_data.push(0x08); // field 1 (timestamp), wire 0
    raw_data.extend_from_slice(&ts_var);
    raw_data.push(0x12); // field 2 (txTrieRoot), wire 2
    raw_data.push(0x20); // length 32
    raw_data.extend_from_slice(tx_trie_root);
    raw_data.push(0x1a); // field 3 (parentHash), wire 2
    raw_data.push(0x20); // length 32
    raw_data.extend_from_slice(parent_hash);
    raw_data.push(0x38); // field 7 (number), wire 0
    raw_data.extend_from_slice(&num_var);
    raw_data.push(0x4a); // field 9 (witness_address), wire 2
    raw_data.push(0x15); // length 21
    raw_data.extend_from_slice(witness_addr);
    raw_data.push(0x50); // field 10 (version), wire 0
    raw_data.extend_from_slice(&ver_var);

    if raw_data.len() != 105 {
        anyhow::bail!("unexpected raw_data length: {}", raw_data.len());
    }

    // Wrap in BlockHeader framing.
    let mut out = Vec::with_capacity(174);
    out.push(0x0a); // field 1 (raw_data), wire 2
    out.push(0x69); // length 105
    out.extend_from_slice(&raw_data);
    out.push(0x12); // field 2 (witness_signature), wire 2
    out.push(0x41); // length 65
    out.extend_from_slice(sig);

    if out.len() != 174 {
        anyhow::bail!("unexpected encoded header length: {}", out.len());
    }
    Ok(out)
}

fn encode_varint_fixed(mut v: u64, expected_len: usize) -> Result<Vec<u8>> {
    let mut out = Vec::new();
    while v >= 0x80 {
        out.push(((v as u8) & 0x7f) | 0x80);
        v >>= 7;
    }
    out.push(v as u8);

    if out.len() != expected_len {
        anyhow::bail!(
            "unexpected varint length: got {}, expected {}",
            out.len(),
            expected_len
        );
    }
    Ok(out)
}

fn merkle_proof_sha256(
    leaves: &[FixedBytes<32>],
    leaf_index: usize,
) -> Result<(Vec<FixedBytes<32>>, U256, FixedBytes<32>)> {
    if leaves.is_empty() {
        anyhow::bail!("empty merkle tree");
    }
    if leaf_index >= leaves.len() {
        anyhow::bail!("leaf index out of range");
    }

    let mut idx = leaf_index;
    let mut level = leaves.to_vec();
    let mut proof = Vec::new();
    let mut index_bits = U256::ZERO;
    let mut bit = 0u32;

    while level.len() > 1 {
        // Tron txTrieRoot uses a "carry-up" Merkle tree:
        // when a level has an odd count, the final node is promoted unchanged to the next level
        // (it is NOT duplicated and hashed with itself).
        //
        // That means a path can "skip" a level with no sibling/hash step.
        let has_no_sibling = (level.len() & 1) == 1 && idx == level.len() - 1;
        if !has_no_sibling {
            let is_right = (idx & 1) == 1;
            if is_right {
                index_bits |= U256::from(1u64) << bit;
            }

            let sibling_idx = if is_right { idx - 1 } else { idx + 1 };
            let sibling = level[sibling_idx];
            proof.push(sibling);
            bit += 1;
        }

        let mut next = Vec::with_capacity(level.len().div_ceil(2));
        for j in (0..level.len()).step_by(2) {
            let left = level[j];
            let right = if j + 1 < level.len() {
                level[j + 1]
            } else {
                // Promote last node when odd.
                next.push(left);
                break;
            };
            next.push(sha256_concat(left, right));
        }

        idx /= 2;
        level = next;
    }

    Ok((proof, index_bits, level[0]))
}

fn sha256_concat(a: FixedBytes<32>, b: FixedBytes<32>) -> FixedBytes<32> {
    let mut hasher = Sha256::new();
    hasher.update(a.as_slice());
    hasher.update(b.as_slice());
    let digest = hasher.finalize();
    FixedBytes::from_slice(&digest)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::address::TronAddress;
    use crate::protocol::{BlockExtention, BlockHeader, Transaction, TransactionExtention};
    use k256::ecdsa::signature::DigestVerifier;
    use k256::ecdsa::{RecoveryId, Signature, VerifyingKey};
    use prost::Message;
    use serde::Deserialize;
    use std::path::PathBuf;

    fn workspace_path(rel: &str) -> PathBuf {
        PathBuf::from(env!("CARGO_MANIFEST_DIR")).join(rel)
    }

    fn decode_hex0x(s: &str) -> Vec<u8> {
        let s = s.strip_prefix("0x").unwrap_or(s);
        hex::decode(s).expect("valid hex")
    }

    #[derive(Deserialize)]
    struct TronHeadersSampleFixture {
        #[allow(dead_code)]
        network: String,
        #[serde(rename = "indices")]
        #[allow(dead_code)]
        indices: Vec<usize>,
        #[serde(rename = "blockNumbers")]
        #[allow(dead_code)]
        block_numbers: Vec<String>,
        #[serde(rename = "blockHeaderRawBytes")]
        block_header_raw_bytes: Vec<String>,
        #[serde(rename = "witnessSignatures")]
        witness_signatures: Vec<String>,
    }

    fn load_tron_headers_sample_fixture() -> TronHeadersSampleFixture {
        let path = workspace_path("testdata/fixtures/tron_headers_78000000_78000099.sample.json");
        let json = std::fs::read_to_string(path).expect("read tron fixture json");
        serde_json::from_str(&json).expect("parse tron fixture json")
    }

    #[derive(Deserialize)]
    struct Trc20TxSampleFixture {
        #[serde(rename = "txId")]
        tx_id: String,
        #[serde(rename = "txLeaf")]
        tx_leaf: String,
        #[serde(rename = "encodedTx")]
        encoded_tx: String,
        #[serde(rename = "tronTokenEvm")]
        tron_token_evm: String,
        #[serde(rename = "fromTron")]
        from_tron: String,
        #[serde(rename = "toTron")]
        to_tron: String,
        #[serde(rename = "amount")]
        amount: String,
        #[serde(rename = "isTransferFrom")]
        is_transfer_from: bool,
        #[serde(rename = "success")]
        success: bool,
        #[serde(rename = "selector")]
        selector: String,
    }

    #[derive(Deserialize)]
    struct Trc20TxSampleFile {
        #[allow(dead_code)]
        network: String,
        #[allow(dead_code)]
        #[serde(rename = "blockNumber")]
        block_number: String,
        #[serde(rename = "tx")]
        tx: Trc20TxSampleFixture,
    }

    fn load_trc20_sample_fixture() -> Trc20TxSampleFile {
        let path = workspace_path("testdata/fixtures/trc20_tx_78115149.sample.json");
        let json = std::fs::read_to_string(path).expect("read trc20 fixture json");
        serde_json::from_str(&json).expect("parse trc20 fixture json")
    }

    #[test]
    fn encode_varint_fixed_rejects_unexpected_len() {
        let err = encode_varint_fixed(0, 6).unwrap_err().to_string();
        assert!(err.contains("unexpected varint length"));
    }

    #[test]
    fn merkle_proof_roundtrips_root_with_index_bits() {
        let leaves = vec![
            sha256_bytes32(b"a"),
            sha256_bytes32(b"b"),
            sha256_bytes32(b"c"),
        ];

        for leaf_index in 0..leaves.len() {
            let (proof, index_bits, root) = merkle_proof_sha256(&leaves, leaf_index).unwrap();
            let expected_len = match leaf_index {
                2 => 1,
                _ => 2,
            };
            assert_eq!(proof.len(), expected_len);

            let mut cur = leaves[leaf_index];
            for (bit, sib) in proof.into_iter().enumerate() {
                let is_right = ((index_bits >> bit) & U256::from(1u64)) == U256::from(1u64);
                cur = if is_right {
                    sha256_concat(sib, cur)
                } else {
                    sha256_concat(cur, sib)
                };
            }

            assert_eq!(cur, root);
        }
    }

    #[test]
    fn merkle_proof_carry_up_skips_unpaired_levels() {
        let leaves = vec![
            sha256_bytes32(b"a"),
            sha256_bytes32(b"b"),
            sha256_bytes32(b"c"),
            sha256_bytes32(b"d"),
            sha256_bytes32(b"e"),
        ];

        // The last leaf in an odd-sized tree is promoted twice (5 -> 3 -> 2),
        // so it only has a single hashing step at the final level (2 -> 1).
        let (proof, index_bits, root) = merkle_proof_sha256(&leaves, 4).unwrap();
        assert_eq!(proof.len(), 1);

        let mut cur = leaves[4];
        for (bit, sib) in proof.into_iter().enumerate() {
            let is_right = ((index_bits >> bit) & U256::from(1u64)) == U256::from(1u64);
            cur = if is_right {
                sha256_concat(sib, cur)
            } else {
                sha256_concat(cur, sib)
            };
        }
        assert_eq!(cur, root);
    }

    #[test]
    fn encode_block_header_stateful_has_fixed_layout() {
        let ts_ms: u64 = 1u64 << 35;
        let number: u64 = 1u64 << 21;

        let mut tx_trie_root = vec![0u8; 32];
        tx_trie_root[0] = 1;
        let mut parent_hash = vec![0u8; 32];
        parent_hash[0] = 2;

        let mut witness_address = vec![0u8; 21];
        witness_address[0] = TronAddress::MAINNET_PREFIX;
        witness_address[1..].copy_from_slice(&[0x33u8; 20]);

        let raw = crate::protocol::block_header::Raw {
            timestamp: i64::try_from(ts_ms).unwrap(),
            tx_trie_root,
            parent_hash,
            number: i64::try_from(number).unwrap(),
            witness_id: 0,
            witness_address,
            version: 1,
            account_state_root: Vec::new(),
        };

        let header = BlockHeader {
            raw_data: Some(raw),
            witness_signature: vec![0x44u8; 65],
        };

        let out = encode_block_header_stateful(&header).unwrap();
        assert_eq!(out.len(), 174);
        assert_eq!(out[0], 0x0a);
        assert_eq!(out[1], 0x69);
        assert_eq!(out[107], 0x12);
        assert_eq!(out[108], 0x41);
        assert_eq!(&out[109..], vec![0x44u8; 65].as_slice());
    }

    #[test]
    fn encode_block_header_stateful_matches_real_mainnet_fixture_bytes() {
        let fixture = load_tron_headers_sample_fixture();
        assert_eq!(
            fixture.block_header_raw_bytes.len(),
            fixture.witness_signatures.len()
        );
        assert!(!fixture.block_header_raw_bytes.is_empty());

        for i in 0..fixture.block_header_raw_bytes.len() {
            let raw_bytes = decode_hex0x(&fixture.block_header_raw_bytes[i]);
            let sig_bytes = decode_hex0x(&fixture.witness_signatures[i]);
            assert_eq!(sig_bytes.len(), 65, "fixture signature len mismatch at {i}");

            // These fixtures are what Solidity uses in `StatefulTronTxReader` tests:
            // `abi.encodePacked(0x0a69, raw, 0x1241, sig)`.
            let raw = crate::protocol::block_header::Raw::decode(raw_bytes.as_slice())
                .expect("decode BlockHeader_raw");
            let header = BlockHeader {
                raw_data: Some(raw),
                witness_signature: sig_bytes.clone(),
            };

            let encoded =
                encode_block_header_stateful(&header).expect("encode_block_header_stateful");

            let mut expected = Vec::with_capacity(174);
            expected.extend_from_slice(&[0x0a, 0x69]);
            expected.extend_from_slice(&raw_bytes);
            expected.extend_from_slice(&[0x12, 0x41]);
            expected.extend_from_slice(&sig_bytes);

            assert_eq!(
                encoded, expected,
                "encoded header mismatch at fixture index {i}"
            );
        }
    }

    #[test]
    fn tx_id_and_leaf_match_real_mainnet_fixture() {
        let fixture = load_trc20_sample_fixture();
        let tx0 = fixture.tx;

        let encoded_tx_bytes = decode_hex0x(&tx0.encoded_tx);
        let expected_leaf = FixedBytes::<32>::from_slice(&decode_hex0x(&tx0.tx_leaf));
        let expected_txid = FixedBytes::<32>::from_slice(&decode_hex0x(&tx0.tx_id));

        // txLeaf = sha256(encodedTxBytes)
        let leaf = sha256_bytes32(&encoded_tx_bytes);
        assert_eq!(leaf, expected_leaf, "txLeaf mismatch");

        // txId = sha256(Transaction.raw_data bytes)
        let tx = crate::protocol::Transaction::decode(encoded_tx_bytes.as_slice())
            .expect("decode Transaction");
        // Ensure our prost encoding matches the fixture bytes (cross-language stability check).
        assert_eq!(
            tx.encode_to_vec(),
            encoded_tx_bytes,
            "Transaction encoding mismatch"
        );

        let raw = tx.raw_data.expect("fixture tx has raw_data");
        let raw_bytes = raw.encode_to_vec();
        let txid = sha256_bytes32(&raw_bytes);
        assert_eq!(txid, expected_txid, "txId mismatch");
    }

    #[test]
    fn trigger_smart_contract_elements_match_trc20_fixture() {
        let fixture = load_trc20_sample_fixture();
        let tx0 = fixture.tx;

        let encoded_tx_bytes = decode_hex0x(&tx0.encoded_tx);
        let tx = crate::protocol::Transaction::decode(encoded_tx_bytes.as_slice())
            .expect("decode Transaction");

        let ret0 = tx.ret.first().cloned().unwrap_or_default();
        let success = ret0.ret == 0 && ret0.contract_ret == 1;
        assert_eq!(success, tx0.success, "success mismatch");

        let raw = tx.raw_data.expect("fixture tx has raw_data");
        assert_eq!(raw.contract.len(), 1, "expected exactly 1 contract");
        let contract0 = raw.contract.first().expect("contract[0]");

        // TriggerSmartContract = 31
        assert_eq!(contract0.r#type, 31, "unexpected contract type");

        let any = contract0
            .parameter
            .as_ref()
            .expect("missing contract parameter");
        let trigger = crate::protocol::TriggerSmartContract::decode(any.value.as_slice())
            .expect("decode TriggerSmartContract");

        let expected_owner = decode_hex0x(&tx0.from_tron);
        assert_eq!(
            trigger.owner_address, expected_owner,
            "owner_address mismatch"
        );

        let token_evm = decode_hex0x(&tx0.tron_token_evm);
        assert_eq!(token_evm.len(), 20, "tronTokenEvm must be 20 bytes");
        let mut expected_contract = vec![0x41u8];
        expected_contract.extend_from_slice(&token_evm);
        assert_eq!(
            trigger.contract_address, expected_contract,
            "contract_address mismatch"
        );

        let expected_selector = decode_hex0x(&tx0.selector);
        assert_eq!(expected_selector.len(), 4, "selector must be 4 bytes");
        assert!(
            trigger.data.len() >= 4,
            "expected TriggerSmartContract.data to have at least 4 bytes"
        );
        assert_eq!(
            &trigger.data[..4],
            expected_selector.as_slice(),
            "selector mismatch"
        );

        // Basic sanity: the fixture "toTron" appears in calldata for transfer(address,uint256).
        let expected_to = decode_hex0x(&tx0.to_tron);
        assert_eq!(expected_to.len(), 21, "toTron must be 21 bytes");
        let to20 = &expected_to[1..];
        assert!(
            trigger.data.windows(20).any(|w| w == to20),
            "toTron (20-byte) not found in calldata"
        );

        // The amount is ABI-encoded as uint256 big-endian; ensure it appears as a 32-byte word.
        let amount: u128 = tx0.amount.parse().expect("amount fits u128");
        let mut amount_word = [0u8; 32];
        amount_word[16..].copy_from_slice(&amount.to_be_bytes());
        assert!(
            trigger.data.windows(32).any(|w| w == amount_word),
            "amount word not found in calldata"
        );

        assert_eq!(
            tx0.is_transfer_from, false,
            "fixture expects transfer (not transferFrom)"
        );
    }

    #[test]
    fn tx_signature_verifies_over_raw_data_not_full_transaction_bytes() {
        let fixture = load_trc20_sample_fixture();
        let tx0 = fixture.tx;

        let encoded_tx_bytes = decode_hex0x(&tx0.encoded_tx);
        let tx = crate::protocol::Transaction::decode(encoded_tx_bytes.as_slice())
            .expect("decode Transaction");

        let sig_bytes = tx.signature.first().expect("fixture tx has signature[0]");
        assert_eq!(sig_bytes.len(), 65, "expected 65-byte tx signature");

        let sig = Signature::try_from(&sig_bytes[..64]).expect("parse r||s signature");
        let mut v = sig_bytes[64];
        // Normalize 27/28 -> 0/1 if needed.
        if v >= 27 {
            v -= 27;
        }
        let recid = RecoveryId::try_from(v).expect("valid recovery id");

        let raw = tx.raw_data.expect("fixture tx has raw_data");
        let raw_bytes = raw.encode_to_vec();
        let digest = Sha256::new_with_prefix(&raw_bytes);

        let vk = VerifyingKey::recover_from_digest(digest.clone(), &sig, recid)
            .expect("recover verifying key from signature");
        vk.verify_digest(digest, &sig)
            .expect("signature verifies over sha256(raw_data)");

        // Safety check: signature should not verify over the full Transaction bytes.
        let wrong = vk.verify_digest(Sha256::new_with_prefix(&encoded_tx_bytes), &sig);
        assert!(
            wrong.is_err(),
            "signature unexpectedly verified over full tx bytes"
        );
    }

    #[derive(Deserialize)]
    struct TronTxProofFixture {
        #[allow(dead_code)]
        network: String,
        #[serde(rename = "blockNumber")]
        #[allow(dead_code)]
        block_number: String,
        #[serde(rename = "txId")]
        tx_id: String,
        #[serde(rename = "targetIndex")]
        target_index: usize,
        #[serde(rename = "encodedTx")]
        encoded_tx: String,
        #[serde(rename = "txLeaf")]
        tx_leaf: String,
        #[serde(rename = "headerTxTrieRoot")]
        header_tx_trie_root: String,
        #[serde(rename = "leaves")]
        leaves: Vec<String>,
        #[serde(rename = "proof")]
        proof: Vec<String>,
        #[serde(rename = "indexBits")]
        index_bits: String,
        #[serde(rename = "blocks")]
        blocks: Vec<String>,
    }

    #[test]
    fn tron_tx_proof_fixture_end_to_end_if_present() {
        let default_path = workspace_path(
            "testdata/fixtures/tron_tx_proof_78812179_1d649769f0ecf78bd6812226d067144bca18b4d01fb34cfdb260fd51cc3072db.json",
        );

        let path = std::env::var("TRON_TX_PROOF_FIXTURE")
            .ok()
            .map(PathBuf::from)
            .unwrap_or(default_path);

        if !path.exists() {
            eprintln!(
                "skipping: set TRON_TX_PROOF_FIXTURE to a generated fixture path (missing {})",
                path.display()
            );
            return;
        }

        let json = std::fs::read_to_string(&path).expect("read tx proof fixture json");
        let fixture: TronTxProofFixture =
            serde_json::from_str(&json).expect("parse tx proof fixture json");

        // Basic tx invariants.
        let encoded_tx_bytes = decode_hex0x(&fixture.encoded_tx);
        let expected_leaf = FixedBytes::<32>::from_slice(&decode_hex0x(&fixture.tx_leaf));
        let leaf = sha256_bytes32(&encoded_tx_bytes);
        assert_eq!(leaf, expected_leaf, "txLeaf mismatch");

        let tx = crate::protocol::Transaction::decode(encoded_tx_bytes.as_slice())
            .expect("decode Transaction");
        let raw = tx.raw_data.expect("fixture tx has raw_data");
        let raw_bytes = raw.encode_to_vec();
        let txid = sha256_bytes32(&raw_bytes);
        let expected_txid = FixedBytes::<32>::from_slice(&decode_hex0x(&fixture.tx_id));
        assert_eq!(txid, expected_txid, "txId mismatch");

        // Merkle proof invariants (recompute from leaves).
        let leaves = fixture
            .leaves
            .iter()
            .map(|h| FixedBytes::<32>::from_slice(&decode_hex0x(h)))
            .collect::<Vec<_>>();
        assert_eq!(
            leaves.get(fixture.target_index).copied(),
            Some(expected_leaf),
            "leaf at targetIndex mismatch"
        );

        let (proof, index_bits, root) = merkle_proof_sha256(&leaves, fixture.target_index).unwrap();
        let expected_root =
            FixedBytes::<32>::from_slice(&decode_hex0x(&fixture.header_tx_trie_root));
        assert_eq!(root, expected_root, "computed root != header txTrieRoot");

        let expected_proof = fixture
            .proof
            .iter()
            .map(|h| FixedBytes::<32>::from_slice(&decode_hex0x(h)))
            .collect::<Vec<_>>();
        assert_eq!(proof, expected_proof, "proof mismatch");

        let expected_index_bits_u256 =
            U256::from_str_radix(&fixture.index_bits, 10).expect("parse indexBits as decimal U256");
        assert_eq!(index_bits, expected_index_bits_u256, "indexBits mismatch");

        // Header encoding invariants: each block should roundtrip through our stateful encoder.
        assert_eq!(fixture.blocks.len(), 20, "expected 20 blocks");
        for (i, b) in fixture.blocks.iter().enumerate() {
            let block_bytes = decode_hex0x(b);
            assert_eq!(
                block_bytes.len(),
                174,
                "encoded block length mismatch at {i}"
            );
            assert_eq!(&block_bytes[..2], &[0x0a, 0x69], "prefix mismatch at {i}");
            assert_eq!(
                &block_bytes[107..109],
                &[0x12, 0x41],
                "sig framing mismatch at {i}"
            );

            let raw_bytes = &block_bytes[2..107];
            let sig_bytes = block_bytes[109..].to_vec();

            let raw = crate::protocol::block_header::Raw::decode(raw_bytes)
                .expect("decode BlockHeader_raw");
            let header = BlockHeader {
                raw_data: Some(raw),
                witness_signature: sig_bytes,
            };
            let re_encoded =
                encode_block_header_stateful(&header).expect("encode_block_header_stateful");
            assert_eq!(
                re_encoded, block_bytes,
                "block header encoding mismatch at {i}"
            );
        }
    }

    #[test]
    fn extract_tx_and_root_finds_tx_and_returns_header_root() {
        let txid = [0x55u8; 32];
        let header_raw = crate::protocol::block_header::Raw {
            timestamp: 0,
            tx_trie_root: vec![0x66u8; 32],
            parent_hash: vec![0u8; 32],
            number: 0,
            witness_id: 0,
            witness_address: vec![0u8; 21],
            version: 0,
            account_state_root: Vec::new(),
        };
        let header = BlockHeader {
            raw_data: Some(header_raw),
            witness_signature: vec![0u8; 65],
        };

        let tx = Transaction::default();
        let tx_bytes = tx.encode_to_vec();

        let b = BlockExtention {
            transactions: vec![TransactionExtention {
                transaction: Some(tx),
                txid: txid.to_vec(),
                constant_result: Vec::new(),
                result: None,
                energy_used: 0,
                logs: Vec::new(),
                internal_transactions: Vec::new(),
                energy_penalty: 0,
            }],
            block_header: Some(header),
            blockid: Vec::new(),
        };

        let (idx, enc, root) = extract_tx_and_root(&b, txid).unwrap();
        assert_eq!(idx, 0);
        assert_eq!(enc, tx_bytes);
        assert_eq!(root, vec![0x66u8; 32]);
    }
}

================
File: src/wallet.rs
================
use super::protocol::{Transaction, TriggerSmartContract};
use super::{address::TronAddress, grpc::TronGrpc};
use alloy::primitives::{Address, FixedBytes, U256, keccak256};
use anyhow::{Context, Result};
use k256::ecdsa::SigningKey;
use prost::Message;
use sha2::{Digest, Sha256};

pub struct TronWallet {
    key: SigningKey,
    address: TronAddress,
    fee_limit_sun: i64,
}

impl TronWallet {
    pub fn new(private_key: [u8; 32], fee_limit_sun: i64) -> Result<Self> {
        let key = SigningKey::from_slice(&private_key).context("invalid TRON private key")?;
        let address = tron_address_from_signing_key(&key);
        Ok(Self {
            key,
            address,
            fee_limit_sun: fee_limit_sun.max(0),
        })
    }

    pub fn address(&self) -> TronAddress {
        self.address
    }

    pub async fn broadcast_trigger_smart_contract(
        &self,
        grpc: &mut TronGrpc,
        contract: TronAddress,
        data: Vec<u8>,
        call_value_sun: i64,
    ) -> Result<[u8; 32]> {
        let account = grpc
            .get_account(self.address.prefixed_bytes().to_vec())
            .await
            .context("get Tron account")?;

        let balance = account.balance;
        if balance < self.fee_limit_sun {
            anyhow::bail!(
                "insufficient TRX for fee_limit: balance={} sun, fee_limit={} sun",
                balance,
                self.fee_limit_sun
            );
        }

        let tx_ext = grpc
            .trigger_contract(TriggerSmartContract {
                owner_address: self.address.prefixed_bytes().to_vec(),
                contract_address: contract.prefixed_bytes().to_vec(),
                call_value: call_value_sun,
                data,
                call_token_value: 0,
                token_id: 0,
            })
            .await
            .context("trigger_contract")?;

        let mut tx = tx_ext.transaction.context("node returned no transaction")?;
        let mut raw = tx.raw_data.take().context("node returned no raw_data")?;
        raw.fee_limit = self.fee_limit_sun;

        let raw_bytes = raw.encode_to_vec();
        let txid = Sha256::digest(&raw_bytes);

        let (rec_sig, recid) = self
            .key
            .clone()
            .sign_digest_recoverable(Sha256::new_with_prefix(&raw_bytes))
            .context("sign Tron tx")?;

        let mut sig65 = rec_sig.to_bytes().to_vec();
        sig65.push(recid.to_byte() + 27);

        let signed = Transaction {
            raw_data: Some(raw),
            signature: vec![sig65],
            ret: tx.ret,
        };

        let ret = grpc
            .broadcast_transaction(signed)
            .await
            .context("broadcast_transaction")?;

        if !ret.result {
            anyhow::bail!(
                "broadcast failed: {}",
                String::from_utf8_lossy(&ret.message)
            );
        }

        let mut out = [0u8; 32];
        out.copy_from_slice(&txid);
        Ok(out)
    }
}

fn tron_address_from_signing_key(key: &SigningKey) -> TronAddress {
    let public_key = key.verifying_key().to_encoded_point(false);
    let public_key_bytes = public_key.as_bytes();
    let hash = keccak256(&public_key_bytes[1..]);
    let addr20 = Address::from_slice(&hash[12..]);
    TronAddress::from_evm(addr20)
}

// ===== ABI helpers (EVM ABI, used by Tron TriggerSmartContract) =====

pub async fn trc20_balance_of(
    grpc: &mut TronGrpc,
    token_contract: TronAddress,
    owner: TronAddress,
    caller: TronAddress,
) -> Result<U256> {
    let selector = keccak256("balanceOf(address)".as_bytes());
    let mut data = Vec::with_capacity(4 + 32);
    data.extend_from_slice(&selector[..4]);
    data.extend_from_slice(&encode_address(owner.evm()));

    let tx_ext = grpc
        .trigger_constant_contract(TriggerSmartContract {
            owner_address: caller.prefixed_bytes().to_vec(),
            contract_address: token_contract.prefixed_bytes().to_vec(),
            call_value: 0,
            data,
            call_token_value: 0,
            token_id: 0,
        })
        .await
        .context("trigger_constant_contract(balanceOf)")?;

    let out = tx_ext
        .constant_result
        .first()
        .context("missing constant_result")?;
    if out.len() != 32 {
        anyhow::bail!("unexpected balanceOf output length: {}", out.len());
    }
    Ok(U256::from_be_slice(out))
}

pub fn encode_is_event_chain_tip(tip: FixedBytes<32>) -> Vec<u8> {
    let selector = keccak256("isEventChainTip(bytes32)".as_bytes());
    let mut out = Vec::with_capacity(4 + 32);
    out.extend_from_slice(&selector[..4]);
    out.extend_from_slice(tip.as_slice());
    out
}

pub fn encode_pull_from_receivers(token: Address, receiver_salts: &[FixedBytes<32>]) -> Vec<u8> {
    let selector = keccak256("pullFromReceivers(address,bytes32[])".as_bytes());

    let mut out = Vec::new();
    out.extend_from_slice(&selector[..4]);

    // head: (address, offset)
    out.extend_from_slice(&encode_address(token));
    out.extend_from_slice(&encode_u256(U256::from(64u64))); // dynamic tail starts after 2*32 bytes

    // tail: array
    out.extend_from_slice(&encode_u256(U256::from(receiver_salts.len())));
    for salt in receiver_salts {
        out.extend_from_slice(salt.as_slice());
    }

    out
}

pub fn encode_rebalance_usdt(rebalancer: Address, in_amount: U256) -> Vec<u8> {
    let selector = keccak256("rebalanceUsdt(address,uint256)".as_bytes());
    let mut out = Vec::with_capacity(4 + 32 + 32);
    out.extend_from_slice(&selector[..4]);
    out.extend_from_slice(&encode_address(rebalancer));
    out.extend_from_slice(&encode_u256(in_amount));
    out
}

fn encode_address(addr: Address) -> [u8; 32] {
    let mut out = [0u8; 32];
    out[12..].copy_from_slice(addr.as_slice());
    out
}

fn encode_u256(v: U256) -> [u8; 32] {
    v.to_be_bytes()
}

#[cfg(test)]
mod tests {
    use super::*;
    use k256::ecdsa::signature::DigestVerifier;
    use k256::ecdsa::{RecoveryId, Signature, VerifyingKey};
    use prost::Message;

    #[test]
    fn encode_is_event_chain_tip_layout() {
        let tip = FixedBytes::from_slice(&[0x11u8; 32]);
        let out = encode_is_event_chain_tip(tip);

        let selector = keccak256("isEventChainTip(bytes32)".as_bytes());
        assert_eq!(&out[..4], &selector[..4]);
        assert_eq!(&out[4..], tip.as_slice());
    }

    #[test]
    fn encode_rebalance_usdt_layout() {
        let rebalancer = Address::from_slice(&[0x22u8; 20]);
        let amount = U256::from(123_456_789u64);
        let out = encode_rebalance_usdt(rebalancer, amount);

        let selector = keccak256("rebalanceUsdt(address,uint256)".as_bytes());
        assert_eq!(&out[..4], &selector[..4]);

        let mut addr_word = [0u8; 32];
        addr_word[12..].copy_from_slice(rebalancer.as_slice());
        assert_eq!(&out[4..36], &addr_word);
        let amt_word: [u8; 32] = amount.to_be_bytes();
        assert_eq!(&out[36..68], &amt_word);
    }

    #[test]
    fn encode_pull_from_receivers_layout() {
        let token = Address::from_slice(&[0x44u8; 20]);
        let s1 = FixedBytes::from_slice(&[0x01u8; 32]);
        let s2 = FixedBytes::from_slice(&[0x02u8; 32]);

        let out = encode_pull_from_receivers(token, &[s1, s2]);

        let selector = keccak256("pullFromReceivers(address,bytes32[])".as_bytes());
        assert_eq!(&out[..4], &selector[..4]);

        let mut token_word = [0u8; 32];
        token_word[12..].copy_from_slice(token.as_slice());
        assert_eq!(&out[4..36], &token_word);

        let mut offset_word = [0u8; 32];
        offset_word[31] = 64;
        assert_eq!(&out[36..68], &offset_word);

        let mut len_word = [0u8; 32];
        len_word[31] = 2;
        assert_eq!(&out[68..100], &len_word);
        assert_eq!(&out[100..132], s1.as_slice());
        assert_eq!(&out[132..164], s2.as_slice());
        assert_eq!(out.len(), 164);
    }

    #[test]
    fn tx_signing_is_over_raw_data_sha256() {
        let private_key = [0x11u8; 32];
        let key = SigningKey::from_slice(&private_key).unwrap();

        // Build a minimal-but-non-empty raw tx so encoding is deterministic.
        let raw = crate::protocol::transaction::Raw {
            timestamp: 1,
            expiration: 2,
            fee_limit: 3,
            ..Default::default()
        };
        let raw_bytes = raw.encode_to_vec();
        let digest = Sha256::new_with_prefix(&raw_bytes);

        let (rec_sig, recid) = key.sign_digest_recoverable(digest.clone()).unwrap();
        let mut sig65 = rec_sig.to_bytes().to_vec();
        sig65.push(recid.to_byte() + 27);

        // txId is sha256(raw_data bytes)
        let txid = Sha256::digest(&raw_bytes);
        assert_eq!(txid.as_slice().len(), 32);

        // Verify/recover.
        let sig = Signature::try_from(&sig65[..64]).unwrap();
        let v = sig65[64] - 27;
        let recid2 = RecoveryId::try_from(v).unwrap();
        let recovered = VerifyingKey::recover_from_digest(digest.clone(), &sig, recid2).unwrap();
        assert_eq!(recovered, *key.verifying_key(), "recovered key mismatch");
        recovered.verify_digest(digest, &sig).unwrap();
    }
}

================
File: testdata/fixtures/trc20_tx_78115149.sample.json
================
{
  "network": "tron-mainnet",
  "blockNumber": "78115149",
  "tx": {
    "index": 13,
    "txId": "0x11a639f9a7276f799a7e458e96a2c3452555ac053b88b1020e0e30409eda153f",
    "txLeaf": "0xbdb308da10299256de32e738b49e3465b69c1412a4337da20adfd5068989d20e",
    "encodedTx": "0x0ad3010a02f139220878c7302743bd69de40c8d09395af335aae01081f12a9010a31747970652e676f6f676c65617069732e636f6d2f70726f746f636f6c2e54726967676572536d617274436f6e747261637412740a154183f9daeee05fbbc232e5281bb632e4a6b3d4d9c8121541a614f803b6fd780986a42c78ec9c7f77e6ded13c2244a9059cbb0000000000000000000000412b32a481528cbd4c685e301fecaaa89f3a9b3fb9000000000000000000000000000000000000000000000000000000005367b9b570f5988e95af33900180e1eb17124112ee0f68157fb820f28f8a750a9fd8451d5b6a19c24921858ce417fa718496f13f608812461619072f043eafc387157549a71eddf90df7d524a91b7dcc0d34581b2a021801",
    "tronTokenEvm": "0xa614f803b6fd780986a42c78ec9c7f77e6ded13c",
    "fromTron": "0x4183f9daeee05fbbc232e5281bb632e4a6b3d4d9c8",
    "toTron": "0x412b32a481528cbd4c685e301fecaaa89f3a9b3fb9",
    "amount": "1399306677",
    "isTransferFrom": false,
    "success": true,
    "selector": "0xa9059cbb"
  }
}

================
File: testdata/fixtures/tron_headers_78000000_78000099.sample.json
================
{
  "network": "tron-mainnet",
  "indices": [0, 1, 50, 99],
  "blockNumbers": ["78000000", "78000001", "78000050", "78000099"],
  "blockHeaderRawBytes": [
    "0x08e895acf0ad3312200b430fa64cddae5fd6519c88e1798e7a5a4b8af2d7f8cc2fd036bd53a867dfea1a200000000004a62f7ff962ed2e74133875d00c82bb3d817026f5fc9542ff37f0803880df98254a1541c189fa6fc9ed7a3580c3fe291915d5c6a6259be75020",
    "0x08a0adacf0ad331220b523cdae5dc9bb9c3391f8621195ce172f139ed35fdffdbb3aea55626f7334e81a200000000004a62f80ea298b0e6cb1b59ef44234dee436a904127b5a412c5a43413881df98254a154167e39013be3cdd3814bed152d7439fb5b67914095020",
    "0x08d8a9b5f0ad331220fea67390102e5397ef7632b15201ac075558ea7d12ced1757ae9cfa432c708291a200000000004a62fb1fc09320dc9c9ea686fb83a37a5b30861362c99f203a917e838b2df98254a154114f2c09d3de3fe82a71960da65d4935a30b24e1f5020",
    "0x0890a6bef0ad331220fdcb3cf4bda042c220821c2e2ac405287d91186527e6dd9e83cefd4291fd9c421a200000000004a62fe22a49e6060b554b5847f75f5450b2d154e89c15208f9a98e038e3df98254a1541b3aa61148f308db8c010efeeeab52003a84bfb195020"
  ],
  "witnessSignatures": [
    "0x8ba57be59528c78c29cf986e2170013daabb457400bbf7982a801c5235f1e0b5052d674fe44487077c7317bd35beccf0927d441face13769203cac648711535901",
    "0x11e67d3f52624a4c0cc3c1d5ff1c72f12a54390ddd2ddc5429a4fd62edde59b016d285eb4c796b7d7114c4aa599ffee65a72647c87c7b0ecfed7463b59c40c7301",
    "0xca0bf3253d40cb209d9f7765008199d5837ac0933c7f9885a12128831e0726677781923fd4c691badd2d717abe75bed9bbc9ed7188c024b68241eb98c834310c01",
    "0x6fc7c8099f64deaf95feb58126a5de4f4562e70bbfeb691640c76a2fff766cee22e7f8a11dce797ee704ba76f79576839098f793d73ddf3616b5ce1d6ab8440601"
  ]
}

================
File: testdata/fixtures/tron_tx_proof_78812179_1d649769f0ecf78bd6812226d067144bca18b4d01fb34cfdb260fd51cc3072db.json
================
{
  "network": "tron-mainnet",
  "blockNumber": "78812179",
  "txId": "0x1d649769f0ecf78bd6812226d067144bca18b4d01fb34cfdb260fd51cc3072db",
  "targetIndex": 335,
  "encodedTx": "0x0ad6020a0293fb22081f550a3106e02ce74080b4d7fab6335ab002081f12ab020a31747970652e676f6f676c65617069732e636f6d2f70726f746f636f6c2e54726967676572536d617274436f6e747261637412f5010a1541ecb28bd5d75a281092d939aa69177fdf42ec3034121541f77eac12837d07ab41ecc1a7779e1dea7d1e096e22c401cb30c7ff00000000000000000000000015571cd1f1485d7f671ee7584fe70e1fe2741245000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000600000000000000000000000003a08f76772e200653bb55c2a92998daca62e0e97000000000000000000000000000000000000000000000000000000000000759e0000000000000000000000007e2f07221f1362884bcba7b04383f793584ac43870e7f4d3fab633900180a8d6b9071241dfed77d4b4af5ca6a95edc149b87d7b217e87717258d8cc4d3f9134afe52eada7b0b84f07c5503e6c10bc2ba87d36c8ecac88de19708930e7ce8e3acb741140f1b2a021801",
  "txIdFromRawData": "0x1d649769f0ecf78bd6812226d067144bca18b4d01fb34cfdb260fd51cc3072db",
  "txLeaf": "0xbe21f82ce97ff196af215d95c31bace42f99ec3e5d3abdfb6554964cf1c00729",
  "headerTxTrieRoot": "0x97f0a622086121549f853684b3bb02f901603078a4b0251425dc7c62a7a0ac6e",
  "leaves": [
    "0x2f945a4bbebc1bf82f27e7296d6906100698340342b5a5df41f350c830081e87",
    "0xf7b49cb181903e695b774e1392c91d511f8eebb5692243a0ff41ac483b6feb36",
    "0x37ebb710ba6f8da55cd3ccd5ea475356267f9c0bea6f89b8ee966182e280801c",
    "0x6b0f9a821994d9a5decf5c618f4c40d005734702c0b5b4e0143242dfa098a706",
    "0xe79e49565a6d66c676279b639f9d7d8feef3c16b3ccf6e34e79e82f0abb3f174",
    "0x2223eee2238af787bc3f969b6f29387ac665e3367d5e116870d1015ca2818da0",
    "0x0d073c08e43e09d2f0c80cd08554dd354557097c9347b58472e8630da960faad",
    "0x3e1ccaba1cffe431faee682b91ebf311215e0e09966b25173c60ce4f29683ed6",
    "0xda7792ec428150f764499320ef020968d623c693eacec69cdc5978099348b83c",
    "0x69e45c808d9d6bafde63e60c95d38c05ca3169ead188d4288a35a6d35fbfab91",
    "0x23776c48edc0f086529620dea0431d1eee2d1c894f15a65a05089d45e6024a71",
    "0xa399a79d82584a49c01b43cbcba32a84bdac8c87d631c37ba759a14a82929afc",
    "0xd1b9cae3b254c375d5a4be520090b6b9ccfb8691121f34e6bc9c78d23cdac819",
    "0xcd7fd43b4405b79529a12472346e71c926a9a9e2b2d89542f2599d759975b363",
    "0x926e69401ad2b40f64010733cb8592f63937c2c31e4c69cc04892f9c0c6bda0d",
    "0x5d49d12ad90a9eb72aee2c2f753b693603dffb2cdfbb07b1ed6774f22556affd",
    "0xbce1bf658c6dc115c62f6ffcb0606649912480698af623dd32a7c119ea04f889",
    "0xfc6110ec07fa4b90f85b7901b402a406fa96670ffb8d4f7b02412dcb6b21d73e",
    "0x49ec17a37438da29c1fd3a372bd11d6a010c5b8256b5272d4d37415fbe815b03",
    "0x450186666577494e4df71f4819de7be3becdb352ff9a20c9ccea05604a87a534",
    "0xaf6896f0c74f7789697e0332a1a3a4921787aefa611673c88a51487a934d645d",
    "0xc5a579fe82cd95c85cbc61008c2fdb14fedc65e043536ae9428d1f7b3645b03d",
    "0xa8cfcf5e897d221f3d3f7989a9f7a88d3e02ae184156068e009111c4761621f2",
    "0xd81fdfecde8535fe3518ae49767b855f2547a535bb7d8ad53c50280d0e39c7c4",
    "0x879b771f8c9de8df0966aaed5790815cc780fbfd2f974784501e72f50f5001b8",
    "0x82e31a91c6338f8ec7f73423a9ff9acf285d150a3f4fa4840b4ac9e54ab3b908",
    "0x976f1205253c3d2f635f867e7be2a4dbf981404596cbdc248711ea382e1dc222",
    "0xe51b5df14cd4301b68d0b991f033073d1aa4817c3302d993a8e99115037ca9ce",
    "0x9bf43f575cf0518380846d4068ba22e9d5ad30cc7c22457c18d129799812309d",
    "0x5da6c29fecce405a9d680a9f715a8f9d0c0997d434929724157616b0f030abfa",
    "0xa5097c7b350345eb121fb9a8d98e49ce92bb153b06fa123410279de4fc10faa8",
    "0x6585a3b1f78fca446168ba5c645ae5e1ba41e5b4aaa3c9de8efd82d2bcaf996b",
    "0x2bdf42cad6df39e45829acf9fedc5b0590fc18356e1677cd96be0d59b87fc118",
    "0xd6524b4301ab17880a0f6baa8d94958b2e5774518ca54dca131119906e3264af",
    "0x5758a878b7528bac8651346eb451f35a31480eb0526614790220dbf3cd8e1cc8",
    "0x9ed350cc00c1d820c122d305f555396c51e4ccf4833e50d8e5fe65e8d724a9e7",
    "0xccf99461f5088f25618ffd4e6fb76e8a529cb53bc847e85d7cf7925ce9551032",
    "0x789ba87d56f2caf27137c6f606ffea685735e09414ecf6ab85b73addaa035d6e",
    "0xcb6d9abf9db96dfb1a45348380ee1a9e7ed7c7ef2e06ac1b2532648284e98086",
    "0x861dbdb8a7fff6d5afebcf2c3037863c79de42764ad8b65b329650309dd49177",
    "0x227247f9b0ac34f34569f0f88b56a0bdecd0b1ed52a7996986e026816dd4240d",
    "0xcb077f1eda2586ce377e7f4e4b8177f4fbc10117f874d4392b66876bb5ed449b",
    "0xfe6f47c7c4f1f2c99680ce2f9010a8879ac5caa63900e22f995c6f455c6ad72e",
    "0x8b8fc591094801dee72f62b8fa5bde7258017818c7c8f21b625b89d811edcd0d",
    "0x5df3a4551b7c282b63a937c269dd586ccb8531512dcd03a1d42c80f561309d15",
    "0xd17363682cccc5876b1ad2f4f900be45b910fb9b12c57eedb31efa80d2b65451",
    "0xbea731071fca3886e603c322fef3b667b7d576578442a9a6e9632a72076ecb61",
    "0xf1bd3f02f7d562a45da5cfa128460b8d51894dfb8deecf243cedde3cdc7091e6",
    "0xf93fb0bf863bcfde03294472b181f7c68020b9db7ecf42911d0e93b59a13c18b",
    "0x49b65486543f1e838f3b5ab4eb1bbfcfca0ad6828115a3a7d7d488e821147c62",
    "0xef28b311973cf0f1494fb8553d77f2bfff5e2aa4a5ff48eac1f5c722adb1b144",
    "0x330220574b28d4f36405fa30ec720501a17d5acc95afc029c201fc88dd6c1430",
    "0xb1dcad4588490de23f8fb2f946c89adb9e7b489957198232228649a9cf572ae7",
    "0x445c82dca4b81e54e04fbe91b0d8f063114952e0970377f1f03bed51ee9c7efb",
    "0x56aacf53fc3d133abedd9e474bf74f575259048e7b6a5bf131bc9dd388f96cef",
    "0x1e23f1f4bc68669bce48f386c94cb021e639d6094ccfbc5ef169bc3237c4ec05",
    "0x9c2ff970decf08fe3c36200f73ea9e9eb7690a84da0ef7a0b53334d29e379b5d",
    "0x347f35b79da2c71d28c6f9eb57b82028ce4de09cace8752342ff5dbc30fe0db4",
    "0x1025ba634d716a497010bc4acd4666bb8c6323ae22f2e3cf5d0e36758d4b0419",
    "0xf5caca06014f112e1a38a6542740556d75fd716c40cfaf47c68d5b67f5ba9eb8",
    "0xdd2fb07ef51f64793a4f194bc4f5f51f3c316263b7de2893482e6058fa72103d",
    "0xc227764782760a2c4401f175321341fdda3a971f25dd834e94f831fdc798653c",
    "0x0f81406985fbee468bbce75063ba49696c7f7e9a22a940091bcae865bc6d1cad",
    "0x9ee610fcf827a2689841f6c5ce09b5b3785c7f1ed47aa4c8f8a028c17aadde9d",
    "0x46f0750f848990302dfb4cec392ae805f7221c9049e7efe02041a51a8df5a9d4",
    "0x3559cdf69bd2d611fbd093e2290c2214d52034b3d4191e83c2cf956a0e495617",
    "0x8c82162b952aaf376f8bd9c386c9ae5c65c4e32cf2119d853f43e8584a6a9c8c",
    "0xa391aeb80c9d967f3c9b22641730e778c627b6d279ad71c4370e872dacb62ce2",
    "0xcf73779c56656c6ccdc18637dd38f418cd403424d408cdd058d2948f54a1aeda",
    "0xd4b2a18af3ce0fc58435e9ecdb85c965128144974839d93458ce4391ed8762f7",
    "0xc79803146fd0e0800bfdb5ecca31f2273ddad485d82bad76bc98eb8e1f9a4a09",
    "0x84766139b868b3bda3ab15cb6dddfecb88484e90d0072c11b6aa38314a8be60e",
    "0xd0ead0cde193819974d808a822f71c8082fb9da8ff7304b0c2e3c86de752a7d4",
    "0xc9ad8dbb5d7d157d8171ed15103016e46ede55adf6089f0581007d711c594290",
    "0x54900549dc912527b5ee392ec61d768540912982cd84bb7409048da4b67e50d7",
    "0xdf8d108a31ab099a63661437a29cef0119890b3394003565b0ee41fa874f4951",
    "0x8442c03a661df81560d6278d1ed7934c251b279853727a4b784136ed1c21bd09",
    "0xa7f7bb18a167ae838450226d7706961a963aaa73171c7e2aa2d7dd7d0806ac6a",
    "0xcd1dcf943167f21ebcb15a96e5e7bf16d9281d504f0dbc6064dd36043a2ed584",
    "0x96a7a9b34dc79b87df7da1ecd5ac41486c0ffea87598976d2649b3e163154c7b",
    "0x485a7c3d3f1ff5a7249b9eae0fea5384a9b69fab41a5f88bd4060346f18924e6",
    "0xd0abe7a1f2f6cb500f9d5e5f1cad2855b17103856a1826416072222a7b4d9b62",
    "0xa79335b8a4c52c3908cdf7925ffce00853290cd7f12df385ad4d509898759857",
    "0x0c3652d68165e4d2fa3c5f049202622f5d944c1727102e2dcbd679a356dc8e6a",
    "0x42a661cb18c1cfa0ed40b3f3370ef6261a737234bb0d465338dad2e7e73b3960",
    "0xd0521154a0e3e3c17d151f55d5f3a2b1583cf6e31601c8faa4cc5af726e948e2",
    "0xb1d6a627dcc6df32b24320a5e77d3b0d1f18525b250ba5c93c9bb6a676b356b0",
    "0x6dcf8fd8bf980d1a805449bb5ab07211f17c9bea5ba67e887bd833d32feb65a5",
    "0x196d61bdb43b7ff5690a2269c8725eeda1deac9252f5ed296145758b11741d40",
    "0xccf09bfaa92d876480f362a87fc67de569ac2c9de941addd48cc1f4fad143952",
    "0x96f9c9baba8540a95b5c96e1913e995fa888f6638bc03b3449bc8ef69b0e8de4",
    "0x04687ae45095f4357fdb2c9324285f96ed27a5a6d7a47172a10846aea162d1ce",
    "0x1adad83c3b1b1151defc6c3d74f0f4c3f7eef57d26132a1af84d685bf00f380b",
    "0xc4e497015ee82b58dec7e59ff626bfd4ceb41daf56e16a0cdb84fd808f58d26b",
    "0x267dd9baf9e5105e865b10a2fd803f4fccf0ecfb97428a9c051676f4b114eee5",
    "0xe884bd5e5e488478df8b7415d8e68bb07b2ebda354cac1b997efc6c7e9022389",
    "0x031cc0ad5c86e49e2941d73ad94e495d01ec239cbf40127fc728d357fd8fe33c",
    "0x10559c6a43aab81cadb5c135d54fe2bf5ee2a5785649a2db2fbfaff923f3d591",
    "0x920ca6a146f617d262afb4f12a83119caa593b1a753f27097d36d1b150babad6",
    "0x25f2adee456192ab54efdcef7465af3016e0a2ec845d406c7265053124275315",
    "0x72ce39c868574d112f95fc5498d808b15bd4a46444b7454cdb38bb0f29c8cce1",
    "0x5fd9a877a9db0d9e18aefbe4edcc014933a220d9635c6e716df1b8a9c8842b03",
    "0xb1c7bfcf0f2d9f99fbc7ea77c34128ba18fbd08a063490b2e1e4a6e14adcf35e",
    "0x21a92f7a1df991dabf3e247dd898340b2dbe442561020a85fa61232da517d17f",
    "0x4a4e7477e73d11b40c5c9289da7e92f0a4b1dda515850135fd396b08dab6a1da",
    "0x0e83a80163ea783bda43aa890d136b243c3e8075f8f2dfa2c9d6ecc3eb28c60d",
    "0x871eb7423c2e2ae4f7164ddbd87796a8eb695490c7a6f9498eccfd75e7afe50b",
    "0xb8f8f5e867581abbdb7753a33d493ccd6888830b42b7d92f2b13f54bc25fd741",
    "0x6b21961fe8cd89b090eddee6637c2a88d319fd331e45460fc219bf26469f6355",
    "0x789171949953e53f7fda229b5a45fb4fa34755ab2a916ea22367647efebd93e2",
    "0xe3cd3a439347c63d84e3c91243d3f1ffc8326a9b118ff005d3a6a09f9eaa8596",
    "0x9c811edb05ba228903655db5a563abfe16605548faea773d1285d8ed4ca47d14",
    "0x80808bb43b7885180746c0dcdcc5f1180fba13c2761c396ddde331c38e263a9b",
    "0x5f7e3744eec944e69fa4e5c25d76199945b5a72960204046716da6ef6e8deff9",
    "0x91fea9842e7c27462d8db03ae27f1a9430de7314c7536954572aa837ce6d7ee9",
    "0x1da4468782928dea7ecbb56d79229eea99e1a9e74171c205d6556446da494484",
    "0x7a4dd25d0aec631f884ee287dd1562a1181af6868e6c4ba95a499fd8bb00b174",
    "0x76c421ae8810906d1380f60973330a677fba3e3c0de58ef85c4ee03a1ddf8bb2",
    "0xd788072d607632d5516bb4af9ffd8ffc56fd2c85b53882c80f15d29e933915e2",
    "0x98db5840001aa47727f999604c4178993b9ceba575a6e9cfbfa5f377e70e2852",
    "0xb523e087bc0d5432041431edc817b2e403a4e11bc78f5b27d9b8c731f334c993",
    "0x30f7d0ce47acf72054d33f23f180bc95cbcf9835b50354963ba3246a34d53d34",
    "0x4a366dce8ca4583e423ce7160381d7fe064fb816f86de13ce187ffa90cae726d",
    "0x9275158b4c67aa0dbf6f0c3ab32e05ec8f86646633db952d09db932026d3f3c2",
    "0xbdf8e16cb15ad0ee94595a19faf5b11babe258b54d2d26aceb65d2d307a314c5",
    "0xa26fb742b7f4756f637b33742364b7b936c0108e542521b8dae142ab4ab70f55",
    "0x89b0dc499b19a853d3bcab42da6f569323e2597568283357e2dee72a91a665ea",
    "0x5b77d36c363f1ce40ddaaadb5550267cff1e3ae0dbcaeadfd6c22ab6b77cb9de",
    "0x4fa244f02098577a09c9b77d50500ff9d4cb254dac3798956931daf2a0e3ad14",
    "0x27639b458a872aa59030df201a81645396a1b3805207954be95f5d8f85f0639f",
    "0xa306be432ae2824e3a13ee426ac19d7610b4e0bae3567026bad9c8c046ef915a",
    "0xb5e525fedbf91c590ef2217d2ca9a844fd05d91dd019d8102cb7e4f45db0273f",
    "0x9709aa3619dd6831f55cd181e1e6c655f9bf47b99fa737fcfe2a250961564c7e",
    "0x83f57db5ae5bf43a91b76313d3aae721e8715e59a3a3e9801af4c6adb53886ee",
    "0x35acf3b4eda6e2fb607e1547a2264fd2612482ac2da3fa797f03a0c2184afcca",
    "0xe567ae6def4d1ea9560cb1caed87845574c71690f388c30ce6d6c32121452e5b",
    "0xfee58227fb6e22d71aa268b7d72142e413502bb3895e7bb0aa62a86733f225ab",
    "0x6965f4161cfe64f01723f07dd3e625fa5e30016f4c5931f69530016e0e383648",
    "0xa9c26af7eef227aaa72f81e5f19f60cfd70d6ed706c3545b72070560f6f5711b",
    "0x52020199cf5a3d4b00f91526bf3db901fd1371de666b5ea714bda5ee67b7ef00",
    "0x4f0a293683cf496cc9fe4aff326c5909050db07b449d71eab3229bf7f0da4876",
    "0xf8ef4fcaadc815c0c958958bc32555a9f43d35010ae62ca68f085088a32c9402",
    "0x5dbee3b14ce693d5a12cbb596c70a9b89496905538e326469445170733f19dd6",
    "0x5b327a547b991f3bed77a6263193ffbdba413c096f47ea7c8921e83b27017296",
    "0x92269c5a6b781e794b2affd64ece721e158e42a3cfe4668d98de95ea1c83d9f1",
    "0xe1b536129e7c372d2471f62742690517378acf26cdc0616fc447dc14c81ac1da",
    "0xf8e59419b1e805e90a52f944f328feadf4e2b8ec83b2a36f4f9e47976ffde920",
    "0x0b4e60c33e03c8873c7ad78f562145274dcb86118d8b02d0e9db9bd70bb9568a",
    "0x6c0051f80f46692c21b87fc4ce7a64272822a7beacfdd2bced37dfdcc4a741d7",
    "0xd07bcf149c6d60677bc02e28feb8df10c167ff232b7ffcbea6f42f618ae95af8",
    "0xd237537ce6d8beb16e117019c887839721d521782babdb278f64b68a1c173e44",
    "0xf530a8d821d3e884ee40ae67e6935bb7a38ab76d54d5b85a41d4090c5f8703fb",
    "0x4b9f0d3585b82c4bfc662fd9c72e89380b4a8c3d2b9b5991c0fd32642fcbf666",
    "0x8c3db4ed536a8c0072a3993a9f2447dff562c63747b649c76aa81faff8ab840d",
    "0x6dc21c579d059c4aad36b05006d39859aa796d4eda279170aaca51b32e062535",
    "0xb7994020ef369216cbecd56d4b096ce14f31c769f969d0e576ec6e05f66581f3",
    "0x5c420ebc0ab905b6731dc79d4ec0a6ffb30604fc6a9a2f421b4909448b5e38f1",
    "0x242f06c6ccd332c717fb4da4ef97875b8b6704d15e16a123dbb36d88c68674b6",
    "0x08c32b303d2d1e98b824c7c9a598d5c846f9332018b3e18777c83134a0bc71d9",
    "0x2f5991fe9aff00de447b4da547e149205fa70659c41a9fca4c731eadd2bd156d",
    "0xd36b5128b17c70e79f83ad7bbecfd2ef9fca4a67ec4185e44a36ae7526655ebe",
    "0x9fa4841b7449e48b7936f0392bd63c282466dfd86b546d9b3ebb6b37027db968",
    "0x2fcf96bf87705c182c432f9f3f029dc9eb3f2c7377bfc3348f97fa43a32152cf",
    "0x66bf98b142b96b28380d1e5620d0fe34930fce4a6d0ad7556c965604747fc51c",
    "0x9e087c8e294f39598d7127146bfee3b21004299dcab078b47a3ff0be548d7772",
    "0x575eb97f427edd907c9a42527c5ddf1b05490fe2ace4b317c0b993b485fa5293",
    "0xb556a4bf1c83c7e3c8f2ea9dcdc8c8052f140515a7be7ed1c56ed5767d64a8d8",
    "0x883f70c7d23d4e1e84ead2174597a2481340dbe4a7a8ee2ad7f41a04783a3a10",
    "0xed31ad54ff9e3496c3af96db35034dabb09f149f26a545dbed89be095dee8228",
    "0xdeb74efc389abb6d62fdfd8abf163f83ecde28a77c75e6dc46439f8dfd62c9bd",
    "0x8305520614e246c83e5e5420c4319fb3ae9eb4814c1f645b11bfd4bd21ca20e9",
    "0xd363f9ab7b9518ae5e2d93ac79e2b561bb72afe9c480d6ded7b9ff25180c5fe9",
    "0x86775c12e7bf365a2e1e35804972adb948269df5dd9aab1f198a49ab64124541",
    "0x9d4ae5d10f2c9a47d3e207f77cf44b437061cbcf49084674a50f4db9867c42c3",
    "0x45059da4084fd8e630bde25cc89cbac9c679c698c7e7aac2552a1196a162b5df",
    "0xac839d79771548d016ca2adf8d7d55933a40cea64c4a3a38da6d7ace006fc95e",
    "0x222f0c428959d5a7edb554ef67f26a8f68a497a2a8903ab8bb435ddbc4557e8b",
    "0xcf4e538331f70ce6dc5d8c5b150e9c1861fffc1f35d66c2a3fd02c9906ac6d96",
    "0xb03c77d9f3b6d0944338f24c9d9996dd10b25e2dc44218b64246ea980a5e605c",
    "0xbae4539bd9f784d4717d78fd6c823efade4c977d88e7254c9a2cd08ee7c10697",
    "0x717111cc1866109c80f7c8845b14e482aa9e4463a2b63f0133ed4e470f6cb255",
    "0xc800c574e9f142e2df2955a2267a64e95b17719e4f713eae6bf7c020e9d7c39a",
    "0x0333c26111bfe453ff768855250e0a73945391d935531127d44b4a4fd56ad87d",
    "0xbdf9484e1cb3808d361faf1ed0b565c6304c7f89fa0d918ff643a1372fb7aaed",
    "0x02eeda2910b89f2e6fd7a2391ad634af7be76cd95147dad5b44c892fa77b7f12",
    "0x38661f90148295f9657e28e11d86b6c23b3d3b572bf57bffb7205769e84b9a42",
    "0x4ae43a22b5d4945dd8c03c3d7bde4e92f9140b462b1c6750f262672d67f5ceb9",
    "0x6ba465565b133ff07cb221edc53d70e2f5a10c8f1f81e7bf76ef62467d98ca7b",
    "0xfa4c0d5b8edf386ff4233276cdc0f4cab4bcca5c7797ee7afde4e24e5e236812",
    "0x5e2f176d37986d2053cd1229190eeb6b3d72b17cd743232980e10dfff8e5f4ff",
    "0x6faa5ace7c42cbf295b1898959a103a220c99fb9139a34fa9caf136707fcbbfe",
    "0x408e6a72091e1134009456d83f8e5a69c7be488a426f95b7bc7fab200e173cfb",
    "0x2c953b8b4d13968104b30c398b80e30212b1f70e6e43224648c2dadc7d0cc4b8",
    "0xd69cb230a31e43b6fde313b743ff1ec898c5b708dd9980165ba0627f73854d72",
    "0x96a6541e2108478849cbf012d0478baa363581dfaf08189848c36525f696e554",
    "0x2da4f7c9f6ab7801ff42454015143f26ad62c0e56856a2e8aa8980b4eb9d6ab2",
    "0x0af427c9c56d5ce2b3b9bdfacff897718858b891b7a27bce30a491c1d78f34d3",
    "0x2a80b86b8e2744f7a03bc9c87149d8ef497ec6c3638a50dd4e67b7d0d2398553",
    "0x2dfe23419e8c832fbef43c553e95beea0ee13b8e08e4518c5e5c450619184ad8",
    "0x89b2f10e3f85408f86cda88354af9dcf97a5604c443b6ee4c40dfeba7a654613",
    "0x919e8eb347050596093edd11ce846af5ac5e815a276689690fe90fd583785313",
    "0x3417cd6e33eaea1921a627f9bb855fa2df60a93d4fb0b17d89138a42e62f1d9c",
    "0x08ef3bd18a3b9947f74796283bde898e84499f236ed9f73b01220b3b7ff76e21",
    "0x9c511e742c2710b4e6609f84eecb7a8158e19588b8c884d38da6123eb00bed1e",
    "0x7208898a26b18f41544d2007a40c49d31abbbe8c6bb7d2f9fa769abfc74c2817",
    "0x34bd1e0bd3441638f6baf993a6ea7f294b4d0787685d5b4776e94269e7228b43",
    "0xe93c7fe27afe00310bce55aaa469e1a854252435b095183a2039ce5a2d760a9d",
    "0xb75902b54c1eea9e11f2e8b5358decfb61a20bc69a29907a53914f498ea8e450",
    "0x9197a2e1cd4a787987600a40dc985e958fb0d7715643b05167085636e064afa6",
    "0xd64dd6a01a9cfbde31247ba222e7e7b7ad0fb882cc5d1e6d25443510df96a0a7",
    "0x85cb24d7ad89dd3dfd1865cbf1f64c696df24bf01f4c509c682a301424409ce1",
    "0x27defb34835ed32b99ea3224d6f2da4464f1b5a02a982c88159884b4341e42bd",
    "0x368f0839aa60c611cc82d054ff3ea7191641a7779d17b49a28908d00ac7ef84e",
    "0x839bc0402deb594c194b0fb902e4658f22a5f5b1c10ec01ca6d35ab9e98e2e24",
    "0x5ea434c07b0c8cdd116f7c8712eb9547106e6b7523d84ef22333011359fe2c75",
    "0x801e8f0153d3c22b3ef5b2ef6d614da3e6b00e73579eae220c8e346a3f28fa96",
    "0x0a4664b4a868fac85db917f9ca7726ce08937f97973848b9d8b155c8c2fbe106",
    "0x7ced0c4ab1338d409c7aae9a7f3ce9fe88f33f7f7d30db2b5b572a29879f9f5e",
    "0x690e022ffb63b697af9b63a82e48c1fa0c3f62811a8298781591c0e7df369ab9",
    "0xd94e0d6c6d1fd8c413a48cb5bcff41e079a5a4f8fbcde819df93d3515057ca09",
    "0x1a8e1f9defb37529482be01f9b5d25fe54c01135a68363206c65277d7a50a7be",
    "0xfee3ed66431dcdf044a405efd939daf9968159ae1e94fb0c194f0b787a984ea5",
    "0x75226bca721adde83144e47fc0969916cd17da51877fa37b62e1095cd4c9f8ee",
    "0x35ec399ed7692c59033ed756039b00817c8c385d5d5eb2314cbe8ebf4d84632f",
    "0xd0b675b4177f3516a8b0d8ccb0b4d4ba9a907939ba3aa8ad4364104c74708eb8",
    "0x709c47adeb06bcb9a34a58302168cc039216fcc0cb5e9089e8e241e1fec3da33",
    "0x377d4a422f6b21f00b730d484a880c1376321ca4ace2b500a0ff568e918dff16",
    "0x6ae9e1520b702f64159966239d235a7171ac6c7292fc7e9ceeceaf48e1c19bee",
    "0x921767ba98db40b33922d7878209fa4e81514f5d41440b34955977d85b008b42",
    "0xf3a5e4d22ab6a52d941b324f324a6d15277b0d5ac1da5bd0c8de6ea53a98b042",
    "0x0406ad914b36d8c789e61d06de714d32cf3958721474a7d0ff99ac11eade5fec",
    "0xb50447ce4bc895531a7dcb4afcda68c9cb5d6e21c423d2c9c98b5a880e8c1c9c",
    "0x0961a72fd5d452e1959928dce593c0eb0ad2fc9d0a212f183a008c31910bd7ac",
    "0x89b24a46a689c67ab283d566e3e0d84821ad480405165ae4a0fd2ff5bada365e",
    "0x3f54772062a59d1242744417ea09079070cd657ee9a2f6dc725343a02d08faa7",
    "0x6e3d2ab0453950e73bd2731b82a78986bbaf211d86d711b7ac107b018c7ec611",
    "0x07dac7cba8f0b3788697a33667d64c6649b2e647e66195bd6a745d834181b700",
    "0xfcecd20e0a84988d64297caaf9667a6d85da28719db1b3a3b72e2b199ea17a8a",
    "0x87bbe24bdfcacc7a2432bd6043cc8749806b599fcc30df1bb43429ad4ac0a7f9",
    "0xb6ea49ae981ce1f1d568dc1b74b42ed4bf45d3c8a7bdbb565c03d18550e223ab",
    "0x8acb0daa859a59f6fc6679e4402397a5d1306a475734d27c479bdb24ead04814",
    "0x88772b252829ec5d01e5525cfd20452ae38facd3f041ed3dc46f36e5a4b9179b",
    "0xbb4cb99565363162a36f877b6d338932fba5bb4fb5f10e2dc49b0d91270fbf16",
    "0xd2e09e3f9fc3bf0084a6a356c44bf643cd497f539e943b8d4e7ec0598faec490",
    "0xee9715a9d3b15ed59222c1de609ed9065a53b1fd4284e25e859d1f73c93fe435",
    "0xc6b1b9f5934a48649d1db792499110c73fec2d1888e3f1eab0cd5f33ca6c1acf",
    "0x0552e988ba548846ad73328a2026ebe885aa1a00ad9c6cf9b15f4be58d2055c8",
    "0x41c9dddc65030cb9295e7a927b1aff7be1b36297ce01c98f5b8cddc404cf3de5",
    "0xfddb8a1eb5483b9c990be29c3f10c8b0ee32816adb0dd73a4dd146d3c7aac13c",
    "0xf6b971650a95284e32e4a9b2f708aa79c55ab5c338a65eed4dd638df80bac1ff",
    "0xc619e1625d66a42bafbc9fce180af7ac8a250e2e40b21fe72962a00a95ee5d97",
    "0x45afc069c2709b2221750d3e573f846e8df9c7e5b24b075fc6e52592764270eb",
    "0xd5c97c4704f8c7be28736813d50507383db7e71aa2da6fa89137ffe9d4b1998d",
    "0x8983bf84e65699307ab85b2c467dbc2c5cc794cb796c68f4c064af09bce92233",
    "0x0c9a8d35cc31c915f523906ab075abe78997e4afd77a203cc6ab5fddf3879fd4",
    "0xbd4c2f03a237c2eaa9528817fd180ca4c7e42feee38e7a3308a76f5f679cd953",
    "0x5b9be204a960b4da0d44bbbddee7e4f3a1a722309ae32764be50d8e0e2c46159",
    "0xae969464aa37403966c98908ba19bb6b4bff96e3e8c023773f603768a70f7c1c",
    "0x78e20a7de104df9cc1b247b130ec5c1e8546c189c768057d3fe8e188c79e2390",
    "0xe06684461359da3d4976f5e33db3431313f2ca551f02c83cb57cb2a3e95bc269",
    "0x3cf756506b41ec5c2e7f299f2d99cd9c939a5e9e906c37926d12f95fa2d8b771",
    "0x79ccd0a1903fcde38e03f0e2402b521ae23d70485bd2ea0375ea4aeca5a790b5",
    "0xcc49cd71e9c0ceeb0ac305f94d33aa0f9f1eeaf723513d72826385e4b6eec640",
    "0xef5e465e21a26b6c4360c2fbf1cb04e903d5be93b9a8e1948217cd2564d4961e",
    "0x02e75e4e11d69bd5c54ab1c314a9031ff0b20a6b5e28e2c033e3c1bf6be42f65",
    "0xf18a74bc78eaeefbfc32419e5446dd3431841ea8961fb0b8891e4d52e4ec0b6f",
    "0x08d23d78bf0bbbe911fa2d05961cc441223ab56ba894f078ba22829a28b05883",
    "0xf54d48f4acb665914c795d8328d63066eb8c298092129a43c7b6ce8052befe56",
    "0xc90bdf5de9f9e1dda6e455f6d45cb8d361d050e98a56e4b5a84dbbc723c1ade7",
    "0x0385ea6093f3ba1e59968aeb6fb7b790e7a65a2072541ab5e54869262969548c",
    "0xd0a355985a2535855bd4b13f6e7309ccd7fe80e45542c4b8d0562e6e325f84a7",
    "0xe8e4c9462b70242705a34a321ac454dff0d4029ae6cc4ca4b335e75cc82dae39",
    "0x2a48094f8b784d0be73df7356d27d52ecceb249a5b792dccb704cc2f662dcb82",
    "0x7232fe0b7511c6c1a3f009237e4c377d3ab0e544bd2745f977f60111f29e6fb9",
    "0xdbfb47b283b8635dd96121623823cca117f63dca969a9f9c6d51d96b0a6da54e",
    "0x58f87e930001724d52eb10c7536241e2c453aa371b04d44290d32004bc0b4950",
    "0xe612decc889608687a49833ace626272e2b6d75bc79751b909f1f2544816e6ba",
    "0x97f298ebe6543aa60fdad474dc8616a3f9c7fc334a9bd3bc24e7324e845d3410",
    "0x24afc8a28b6185d428f3e86f4426dece249c6e9b30fa6ab774c1ad8bfea9f0c4",
    "0x0d65531094f2493dbe7b7fdca097a4ab33c7baa47aecbf227601aeb9f8d261f5",
    "0x405d7baff60322499f59283a81b7af569bc1403bcb0a931c42800cdb52cea9ba",
    "0x5e66dc38c9fccdcc77567d0eaef91f74ebf698a661a6aeda4ec9ee2cc1276804",
    "0xcdadd927993e6ea167e51bed745c213cb8f503102f2684dc074e28061e77fc58",
    "0x88792ef1cdf3a3e7f858d9c1ef5131501b224b90d1c521b72108fc8f94cb7bf9",
    "0x1e31d3e675eb469fb5652482e93559f9aaf9b1e09323f4eb1cbc0ae1e045f85e",
    "0xff173ff346fbb2218731558b5f84b6c35edd92a778e7432b2c59b07616aaa48c",
    "0x0e137696a63a4a91b63dd482f56894f886036aed2109435793b64e00b3d06d89",
    "0xfba367f12b9977d8e17aa66a1c677b38e8a4b0f5d9442f696f9403256f1bb85a",
    "0x7811df128bc66c6e096dd5b8079966fbb8d06d613ac3324df397e64956884cc8",
    "0x8753959f96d48a61c34283a7c858e2aed061d2572a6c53ec7d4c736a378b0559",
    "0x2b1b1d7a928f9eaca97fcb01ec834e7f214d4bc6cc87c17a899762c350574f4f",
    "0x2111fa23b82fb7f443d6315d34fc0c81d5a28eadb5d08a8e3a6b42afc70ed403",
    "0xcdf8ea96533d072f66a53464e8b68befd019dbc4124e7cce866b5d5a7ed3b10d",
    "0x961b80662dc31ffdc44612051f6717d1b423004d450cb43c20afeb69e63c8b9b",
    "0x0a8682fdf6c8f32fd811ee28ba83d32b183897f259eb433d484a0e2105aa1c30",
    "0xe9440129d4f6d471078907cfa035e8c4c0f2e91555e6f616a8023de0ebcaae9c",
    "0x86567ffc7f6f5c8e80172395d2443ba985e535cf8e9b5cc8fa050559053fb35c",
    "0x8eb4f0612200860b791fa342825a854282b3498ae79173ac26b77e00f0cdfae1",
    "0xa10f42db09db637f273d410f124dae931cffe7240610ed34b28eb7e32309c0d7",
    "0x723878b414fa31a91afcb54c27b1989e8a58a9c7cd8aa4ff5841a603e6257928",
    "0x78a769f2da34a58da38ae9346669bb63babdf0358c4ed7ff5759921cd2554777",
    "0x90047249e29643051c11a7a9d30bf6d79350c5b59f73e63dd339bcaaacae3e7e",
    "0x3527d7ef0795cbf1c6378242eb9f1033af3cf962b38e45ae28912d6a856ab22b",
    "0x624d38a00f9b6d57ae26f5aaa89488875c1f34c3af02b4009ed0855a73042a93",
    "0xb2c8e57ac9b0b53f4797d446e2544a317263ca5dcc891d903f56b410bb8951a8",
    "0x2fc9807c705d9311071119b544933d86744d6a35cdbd63e2bc6e4752edba8812",
    "0xc8b0c2146b0d5ffa9b99eceaa4d12d3b0dde4a616625dbe1db98a30e6622aaa9",
    "0x2e20b859ab671af7e603e894f7148adfca0607b764499378158114e0619f5a75",
    "0x4cefb0015ee2624255d6da2ebd1bad6ab405e9f1de48aa8f4baed36148d48b16",
    "0x3a2c2f710ba195b147ed52a0c24f1a50d2c39588063fe78810a6b46f7da4b8db",
    "0x9cd076d240ded3191fb16fd05bb1a300ade1ed2b420e9f4301c5e8f9b34693cf",
    "0xf3a2c87c9de84ca7f011847ac904fbac5e645975b9e1e52a68df16e372cfd419",
    "0xda2c1d2805b2948c50d0da414bbd2738e00a2e16b7988da817e764449fc795eb",
    "0x26ef726ada0b8ea6bbe7523c777fc21836a39db94bc910d0bab456a5473733d8",
    "0x223e148d30607f9557ee695b8afd10dc8f0d8578724679f86de1f639c382c14f",
    "0x0dd3d7c63c1dd6e4ee3cf5ccb6526fc03fa008055535281009e1becd11328586",
    "0xd960e8e4c3895c5da18745b8e2eb56ec425500ed21f488e7b830793a43f9130d",
    "0xa7f0d437d8e54308368809bc5a5c3f6b54a9c8e9c94c239b9541a5fd2365fef9",
    "0x8454decfd9d43a24ced6bb74ae2583532b34360f28fd370ac01fea14da37e6bc",
    "0xd1b9ee5a4a99e2398adb5e92cbd35360d770fc92415f1343693519d8a953f692",
    "0x142a12f60881e9d8a5f6dab99e0bad11cb0d524f1fb5d5a148adce8f53824624",
    "0x97419e325679247d0406741fa88526ef4ecfd2e0bad3b4b682c76b66b61feb0e",
    "0xa1e917238b847b4bf0b4eac2b0875791ff7a1b3128bd28b385713271dd047baf",
    "0xdbb913c45285ff3ad6b9819014f05c987068d8f5bcd469b910c37e08f6e8b856",
    "0x5117225decc6c34a2a7e3c0477162f2165ff91c001923783901eda1e43dab24d",
    "0x09737db7826eeb6212e0fe3ce70c8efcbfba1008296544c2d0cc37c4f9619206",
    "0x682ba7186958abb282aeb254496f74fdd342f51d63f88540c02734962b6dcda7",
    "0x2215ed3e53a3884b6d29ca0c86cc72482b612948f74c4a63173e83d0b5239475",
    "0xbcc37e4f67dc904fb6d97fab92a7f6794740f2b9e162aac2bebc8820bbd9b5fc",
    "0xe4e0a21c95bd648af89f2017e0c8379070ce8d9baa46102cb5c8c25115d16a46",
    "0x77077b7088800e5d1a448c63a09ec405a11e05661a5ed20fdb4807a6151f5444",
    "0x26e374095be9a55f1fa04cdf52c1ec696bbd0f47f67bf4039eacff2fd67331a3",
    "0x620b93a8e17758348eb6406d722a58ab43338ceeaa43956ca71d32e660ad2e43",
    "0xb31bc85c44fcac62d15a7de64cf03abed61eb69d70884b236a9e2c105250e2fd",
    "0x096e12e23d05f14f49c8a795d12c962087aadb552c47e66f03ac3f1816bd043e",
    "0xbe21f82ce97ff196af215d95c31bace42f99ec3e5d3abdfb6554964cf1c00729",
    "0x20a6363d077c8fdba7ca2ddbb9f191e1eec6547c86d6121296457fa929e96ac9",
    "0x8f1e98b89bdfaf2d276b2cb147f51d5b2ffdb857a13a015768084af037860694",
    "0x65772e0cadd8ffad6ff29f130194b52089cda3779a20b23084ffc1b39f1c9829",
    "0xf8eb52971208442adcf916aef27b6dcb13daf8c22bc5ba108e675baf51d342da",
    "0xf48d7b35420b56ef89baeac7d7d273d3fa74d9b2808e545042e8b5c259cecef9",
    "0x7fe82a80f82f1f441cda550e86dca2a422950e3e69a246fce5212f5cd8a318cf",
    "0x6148edaa38467118441697af30a76d487533efdbbe7763de4b27a3d01f8309ed",
    "0x05d4547ee91e2848d90f8db0c0400de887ef30cbbe35be2cd72e78ab56c75aec",
    "0x157dc177c784fc52ffc7b5a03760f3daaf2a44333fbb8f76289760161588de77",
    "0x32c8dd074eca6f60c540d1c3061c93bc695dc7034d42fe18a533c03e1edbf8e0",
    "0xa501aff9aca1707ce5d284b16cf2e08bb88409057d07e56e6adef406dcaf2061",
    "0x42620a03767b7bb110a7727afc133cafdfe432eb9ad91b8a63366848460992c9",
    "0x87943ca7591650f919e2461413804c8c152e5982bda6136c12f10c805b45c41d",
    "0xdd2d2f87330ba3ab3bf5d1bc801f88bf7c8d1fd432b9f7154f0b7b4126a1c507",
    "0x23091e945d2721a2a31c2e1b3304be067f283c087fd0f06365ce709d58f0d965",
    "0xc9637ed22070a634f718edf9e648b815fc9a0cf507446617d0626a1c6a71cf77",
    "0x2a0b9d07f6fb1689f4afec52eda8dfa34bb5e632b596491c60dc38712b4d5c02",
    "0xe6b9c47e017565f464b36d91f71a6d6cdb9140d966f9c8731874bdfcd91df2c7",
    "0xa70cada5928a6e0cd7ecad23420e7b81d74e35e248cb09fdb535b18e37166e73",
    "0xa8d886663aa84fb0d5647ed594e9dc70f507fe446b7025651e70671a90b65502",
    "0x29d6cb791e2c078098e9f4623d3d0e8d7cc81122475a6cfa679cffd63021ae29",
    "0x3513504f5647515db11e2c966fd11ab46dddb638b64f7ba7f258f840d07a1753",
    "0x926a4afb8d3f951f44ebc9d487be3ae56aecd932e188aad431b3be826745841a",
    "0xb52a338bab50b87cbe88d2ef7b817ec957d6e2690c2d6704806f5844c3659124",
    "0xaede1e29b14e9d37beb3cc661eb611628838be901431cef686895c2070cc6788",
    "0xbf5b952784c789a6717535e828fd74d354ce7338363291a19e2722ca6f6930ff",
    "0x1f8216d037b964e07b337fc9c16f5b95cc3e41ac199f708dfe2a7ecb1825d9ba",
    "0xdb2a009d09ece19390685baab716da260096e5cf96ac4164225249727a9dae0a",
    "0x3cca047252196fe720a7345ef65de6b36257c0c43b68b36f6ef2046e506133c7",
    "0x455aee125c9a28a28814b09783a28289c223a31a50fbc6449010c2a74649eba5",
    "0x0c7cf2a5053d0a2c08f497edb06f12a9d659b244288b2011e316643d35d38c46",
    "0x1eb31cd66dd15062581a3b5c5871786a2eab78f74e481f0139b95171f02047af",
    "0x8f39dff3e3bb8e26650c294d303b9f98c8aa7a1133309af06243e9979e062ee7",
    "0x002e4e7915703fce0ca643d26e18d5ecdd7396dc0ff31bb1efec994a9a7c85ab",
    "0x638dc8da68b6fb9578823601bb09b44b1d1087e210b1a8e8ec60cbac647059fb",
    "0x2a0e189e8f5666e1e07d66f7b878c04375601d462b04f593f92eefd2116bac9e",
    "0x1e6bcbff86d3957b1e54df35eee782f8de23c044770e8862410144c3ddbd1f60",
    "0x2b30c89b124c95db7206a62a03572e9416778e19e6e1aa3dde61d7bc1c94f71c",
    "0x2a98b3f3956dbde49a5550ad69d316e92076f8036ac7de04664e9ebdefa75c12",
    "0xe4b57026b1197becf64a25a775a8133c36c4b85815b2997e8b782a8a28431c8a",
    "0x835463bda5acf05983e0baae12edfed69e6297f623766d942f836a83c45be579",
    "0x5ca6d10fdbd57bdb41d1dbc53cbba89a57678d70dd97c2d54f3e4ebf5134a847",
    "0xf1eaacbab54077aaa66efba024284932fb4246aa3287014ae06bb746fb4b5417",
    "0xaec237007ac7910e3a6e76ebfdb8b3dd55e716975e1ea7c10661f70c48f513a7",
    "0x02467c0c38247492f075dc6fea76a7f3c249faf5652629e92c6fe72411c5460c",
    "0x683986b0951a7b6a42b8912e7e17fa934a9e7c74beed6e738a1227bfc422377e",
    "0x28a434813eb0b0ee01a632d51abd721689d060f86f6b9a78913f75b9dcbdc77c",
    "0x2186d81d1de3f18cb190b22adf1f8699ed88ab3c7e6ece443a4260ccff585848",
    "0xa9f845549a4365e3334ca8c55fcf6dca33fc8c757cee746ca79fd260cb579be3",
    "0x5115c44cf365ef97f65a83005da3ec899da89ebb53997003b877381099623bfd",
    "0xfd820fad5f80e08400af6759ead48bff5f3d6b4324bcc99427df83042c762e61",
    "0x0baf4a33ff6ccd71ded878ae5499162be75ddb3d2e5843f4a4fd0edde1d4eb95",
    "0xe4dbdee72bebb6f86f8ecefee5270e03641ae966803cc720ad92537a9913f173",
    "0x5dc02cff1451b4a273d5e6273756364467af2077828133c91204803c935fd3f8",
    "0x66c53f3d28deeab70cb691044b801e40fb0d52efb4f9eff7ccbfe8fd779d9494",
    "0x41ad2338da59b8da777fc20c8ab4a13da049d2e65b9f28f265db18ba990e59ca",
    "0x158676ff11028e70f6f86d7e4aa95672b65a3fe1a3c0484d07e1b0eea97ab347",
    "0x101ea1eb0ea7052c49bfc9f21cd8838f0e5f7b2062d8cdba74be75a2ad503c5a",
    "0xb6e095a2a66cb67cd045e286959275ba6fb0906874a2e927a1b41ceb547fbcef",
    "0xd4abac9946432a38e1931e20cc34904349055cd8c6656fbf8cbd797f32889999",
    "0x8e288644d35b2497dd257853e1181e67daefa9ff8b52f9b8de515de0694328fb",
    "0x39f6203a970692031c219a4dd89edc710684090f67ba3cc65df3ade4b161cfa8",
    "0x2fe1bb53b493788b2eaeec69d73cf08ccb8957b733526ee70f3f6320de0f4931",
    "0x7028c6554bcbd9f4ac4f27df43dbdd8a22634e37f9c84c84613612d8770f793d",
    "0x8de4207ef6505a117cf3ed651abb3b37ad79da93d8d4b8c300bf0328fe8a6823",
    "0xdb9180021ead66f9bc28cfaa7bb67f963b4f55b10f2b7f7ccfb486c27cc6bddd",
    "0x3ca3f821243aafc11c1c80fab3f046b5c1feed7204ff2b98b4fe20bdb0130e9c",
    "0x6f9eeeeea6c7f18d79f887a96e6dc657a9af0dc9ab19c2e5313b6d93ddae3e62",
    "0xcbb0ef6ec147472a891379ea237728c87dd8a1d46fe02760c029e4bfbefc8dd4",
    "0xcaae53fdcb8216b9236a5968c3126eacdbabea891a0c748f6862a9d62f0a333c",
    "0x6b117c7f419a9eb26053753e02b87a6d27bf5a1ee9d2090fda9fd5510caac05c",
    "0xd237a70d7a074e9447f5ea4fb11b8b8b78f8fbfc4a97daa42c57bf6ee33415f2",
    "0x1583221fa8cc91d10a4796b34a42910e6b9a57cf2d6883f53eb372c5399c86da",
    "0xabed609078ab5d5eb1274c631d51b0239c42aa2ec236900533a8e7541f443892",
    "0x535d028a864a249863ebb2fdbb815a9ec19adcbd26af5c854ddfe3907a2739b2",
    "0x1cd8ce0de59aff32e2bdf01921c26aba095021058b22a5f7b9543a0c6bc8c71e",
    "0xd2bfef0fb8e4b7db77b098609285144751902b241111091a7c54fde3c1f58458",
    "0xe8b563f6684ee735f95aed8873fe34c2b0cba48a5efd6d547f6ec23bdd30354c",
    "0x712bcbfa7aa9852cf1941629f4a7bd17b565be385224a9ef010ddd7e29d1fd15",
    "0x34ecbadfabf2b0690e5ba74ac5b21ae68d52046492e74970ff0e9bf3f5b8722f",
    "0x40ed3b4f0f5100287fcfb2f0067316b30f14d6e78cb971a963874db4e0493b88",
    "0xf6c95eb030d2021e6970f183d1f1e1b31434e9237bd1c6dc7e3a7bffc5be5b75",
    "0x325f084c18007fae52b92b1b59fee442afc9655e2a6978c3eb2ff3f7b53e769b",
    "0xa4b14bc7609cece6b8be0db6a64994884bba4a3ac8d61033da642cd92c8cf22c",
    "0xa54d84117bf6a9ebe6e29cc709463bbe3a9b6a338477ae3a179f4f9c1c2ce2eb",
    "0x73b6880079fccf38d82133ec1cd0cadd249ccc91979966a7fd05401096ec466f",
    "0x189886d0051e1b55ce12812b05ddf636cf90519183e083752fda14f08cdc3c9c",
    "0x488746327d457e2cc42d0abed76d8ce89b139e1de7877352c43957be3143b4bc",
    "0x8e2056d02817b7de854e45595ea749d51264a01710a571206680249809fc8efc",
    "0x6eaab8a65ce1191c08dfeba7cee12f2062dcf5104a428f789841a501da34b9e4",
    "0xe12f062ac56ddaa1375aec325fe3d70e7b5c13be0dee5d1ce1fbcfee06f07811",
    "0xadf7bd1df176a3208b2fd430f5f892b2d391341333829b9f36143f2c6578b4ec",
    "0xe0c26a5d754062850b29df2cab581ceca5373b396ec089d898e14805798b1fa0",
    "0x68b8b57f3f17573a3ed39a4db25663972ca022098c769eb8308561df13db1752",
    "0x94146d502d0307071f30e78ccdd4fb01e1d50a248ec8df114226753bf5e02334",
    "0x4e1f79aec07f1499453b72411806ed54710a467af79ec204c1463f85e9116ba0",
    "0xa747967fa4627cf31858bfff3c7ebf6a5b68957aa64304419140dc63c32054a4",
    "0x72f73ffa043e46d2845a68c6146babdfe0bc007eace311f5a7777892b40de072",
    "0x75d184fbe949e5da478980e844d867066f2916bf68d7c7a51b4d0a79efb8213a",
    "0x0c40589ac33008e28f4beb7a7df74fd21fc7a9e28bac2c0d2939ec4aba743778",
    "0x786eabb7ad46babfed5ac93b8450bdf213a5b414c5eb0fc856790ca5eef2950b",
    "0x9499d1ee59bbd1e72b26ca1d4609f64456b9666f51aa492257cac8fc6cd4b67a",
    "0x1b5c871e0739317ad5b415496c464f9f0add92d0f8e89fec167ff6f2a27fc923",
    "0x009e8cbce2b2d621aab7a020583a30daf463e335c8ad69ca9630c9462d574765",
    "0x9345a880c190b175afcfbad8b007072c4e2819ce81407a6031f68e39850d09da",
    "0x14f1fb317c3de71365f89daab92cb03a1788dbe9938919d84223934afed3e7f0",
    "0x2e0888034452ffce8ae64ed3a4cc1af45bce6ad059b3922ae4323dd71da51900",
    "0x955133cf920871a3360f45a888ca109798d08a1b1dc1c435649532655ecfc07c",
    "0x9b5a3a3a0f416b2a54373b64d5327e82997474bc363e359d012d7d60787d2c3d",
    "0x927242c44dc4f613f28cc1f2faf29d7ce8b5036e7a47bfbf91f4f51dcd2351b2"
  ],
  "proof": [
    "0x096e12e23d05f14f49c8a795d12c962087aadb552c47e66f03ac3f1816bd043e",
    "0xad6d479996682dadb5f54feb1610a66ced881616ef5b23ba0bd48aa3444f1bc9",
    "0xd93717564b69f9009fada5b67a321e27cb17d17001b793a5b0878a34aeaf047c",
    "0x0591ae2178271338461ab6468589f8c51af4f09b4c3f1f1c0f8557afbfe8e435",
    "0x6c7a3ca2b95b453fa64ad1c40b3a33108030048bfd99abfb686b87622ec6ba9f",
    "0x8293d5857b0d99f3c23d57d335adc7926b7b04f1a138cbcc7b4861c35483fe92",
    "0x14495edc295d0d705b87ab7b6555ad35c3de686ba7059442e0c998cc54477331",
    "0xd3d88031f86881ecdd92cb73fdf9184298b27b475a88988598568f89ae4be7f6",
    "0xd062265527539b2e875bbd8c33f4d9d42e661d9323626fb3653b504332d81324"
  ],
  "indexBits": "335",
  "root": "0x97f0a622086121549f853684b3bb02f901603078a4b0251425dc7c62a7a0ac6e",
  "blocks": [
    "0x0a6908f0ebd4fab633122097f0a622086121549f853684b3bb02f901603078a4b0251425dc7c62a7a0ac6e1a200000000004b294121fe806112f3c228daca1bf731ed8d6f00c07e5e5dc7b85373893a8ca254a154178c842ee63b253f8f0d2955bbc582c661a078c9d502012412b90c32d308cd0df70be37b84a82d3f6f093e2da061b326f4ac03db286ba38f90a59f168165689eb56e03422b63d9c2f8eaf177a98bdba16222ed9f962688a0600",
    "0x0a6908a883d5fab63312206af62fcf57a2ef6d284cdb2d3263c887136e53346f7f9a79fd713cd2d8a81ed41a200000000004b2941332abc391c34010a9734cc1eb96624888765a1f4caf193db13894a8ca254a1541456798cb4ab28109d8cc643cd7da7bd6069ceae9502012415b024216a6c564ffc4385bf71ef84290a197036dc95a002c7de2b0a87781401359e7987ca3f73e6c83916040273ddb16d60ec8361e0a1c675974137345c2d88401",
    "0x0a6908e09ad5fab633122041c63461279d1d2eea677e77116c7b749fa7393fde5173ce06b8b922dd1ee51f1a200000000004b29414bb290cd3b524111b4f50db5762b0a371f138f71b3de81cd33895a8ca254a1541022939a4a06cbc7b384096c1af8657ec435173af50201241280a97e6d8832d6016260f1e8b4c566015abe42fd5090e4547def173226199634df449149018858100e8c03dcb20600877dcb9ab643c322452912d93252b2aea01",
    "0x0a690898b2d5fab6331220ebbdb927455def85235009c866979e905525a7679e1b9d1a57b0b232a6adbc641a200000000004b29415437faa53ac6d0a67d06b99977d9e59f1d9b0f825545cd5ec3896a8ca254a15412a4d700c196a78f8ff7f0bf17d93fe6018396d2e50201241d1a23c003f13d613327ff636f71e902bdeac3d20d0ca92e9921c05ebdcd905a31413d0ca0fb2dc27fc4b6ff429d7394e77a1318613e8a929ad5f52f6d20dd8f601",
    "0x0a6908d0c9d5fab633122005d74b9650872f1dda8afc8ab61c00aa61efbb609fc914c55936845153a0663f1a200000000004b29416b6dbe5d35fe2e41e0c131a276aa6fd2f548a229918a5972a3897a8ca254a1541b3aa61148f308db8c010efeeeab52003a84bfb19502012414159c4d4d995009efe36c07977b02e0e23d180c17ec598740ef82b295741410333437ceb2eb82a9fd8a82f366cbd9a3ec14da4221df2498da895b168cc362d8100",
    "0x0a690888e1d5fab6331220f4d352577380dffa2fd48a36a72ba8cdae5be9f175d8ca4409cf79cc42d5d4941a200000000004b2941755e109031dd4e318e3d842826349a9f225386ffc1b74543b3898a8ca254a15411761716b76c6a3d885299c366826046c09b08d2650201241b0c4cf410ecfc9ac23782c8e66d96192f816b7022374b340d7f82989f352266b6703877c58bcb3ea73483c907e2ea1892746d609d30125ac3ec00db825f3ba2201",
    "0x0a6908c0f8d5fab6331220ba07941dc741dbd540b6d9e8c71b52cbf2a89bb16b91d1ed55a4274a17823fb21a200000000004b294185c4ac216491ae546713bcfa5cd77fbc605c43295c7ce0f903899a8ca254a15415a27141dbd202aa1344c042b51ae541262eebfb75020124126cc3143507417225609675380be4d9c3915e01b14180468b47007c886ab4d7e7ac091c786e177f8dd8b55c60df64e5f035fc16072a73ccd99d908d0ce79248f00",
    "0x0a6908f88fd6fab6331220ad896213dbd87a00cd4313b6abf943ba0ba7ab850764c8a01b005e83ab7873761a200000000004b294199c3f8194e2c62e23b1c0dbd09bbe0a76dfd4fe15d811f416389aa8ca254a15418440ffd578f7a5abf3537b5f46a6980d382db58150201241325e0577ae4f650449634f0d26fb7bb5421da5df3ce5717940a9af8fe078d2700e3ccf91f0014d8d083b90beaf3363a0d4d9f8fb75920cf858ca89cac29b41c600",
    "0x0a6908b0a7d6fab6331220f74daf442df0b0c2d95edc84e27358b6748367469916f20019a0011138e7f2851a200000000004b2941a1448fec1a307d7d60f670ed3ca48d102d499c61dfede82dd389ba8ca254a15419a96c8003a1e3a6866c08acff9f629e2a6ef062b50201241cc412cd6cbde7f931ea3332a499ab94c05e3281ea060168af4db524f903ecc09258159a9ac97273b316daa2099db8ce7a9c06f15f85ed2dc32ba0e0eef44038300",
    "0x0a6908e8bed6fab63312202e17b55802dc548ff12c07efd31c1241ac445e06137f4254679bcada72a8a3c61a200000000004b2941b07ed448ef5283e39ec1ea615ee5db9599ccc7e798ceadaa3389ca8ca254a1541d376d829440505ea13c9d1c455317d51b62e4ab650201241db99e8d6902d3a2a04ed65a9cfb5d2bccf5fe53c64642790b670f4f585ca228d3b5290bb855cd549c6394940daf96cc8e8f2554d50aaf1c647a9b4ce51d97f9f00",
    "0x0a6908a0d6d6fab633122072d423f42f9312c5389b8197bf723e8f4ff51482ea7262189cee12b47f05b7291a200000000004b2941c262e0387f115acbd660e610d159d1e258b1a19c72e831578389da8ca254a15417f5e5aca5332ce5e18414d7f85bb62097cefa4535020124114efe4d6cd7efb07c6af81c3252fc7ce7aeae05ee9d792c5c35f0ef0bbf071ae548dd431c9fa46f200cd7103ff445fd0b76bae2e8430b9c920420992a3dc4a0b01",
    "0x0a6908d8edd6fab6331220429e70c4c8141f262233056387f9aed782fe3c36266eadd93a1c1ded881607ab1a200000000004b2941d8eb7c459982312e9d4252c5cd7c45dbdd77d9d4afa178c97389ea8ca254a1541a2c342b17aa0ae86abc8191498cd4633aa33a8215020124112c9f04c0ff1b308017432949ed0184220edab819be6376761adcbae1f82340a48c4b933079ec998f2b0ab852c0c52e62aff755a9ff3b851258b925c04576dd100",
    "0x0a69089085d7fab63312208b42a9746aad8957ba122b3e96daf13f287e931630e4dd0a165cd3854aea10cd1a200000000004b2941ef059918fd8702ea25d8a7669bada954956e5ff6c1cfff79c389fa8ca254a15414ce8225c8ea6c8e1e0a483132211610c765fc6df50201241de38a83a3989beb38202b89b1836d5e11dfbdd6251dc51420fadaf488001388931f5d519053189c8998784855fd5821f8c5e9ba9377bc70b3a77e8d83289554800",
    "0x0a6908c89cd7fab633122003afc0678c072b8a648d2dcb168a009c580d5830fa281faf4042af6a7509eb1d1a200000000004b2941fb5de94664bc123ade378a7e0e74142a4fee0131b8e4a148e38a0a8ca254a1541c5614f3ebf88785fedf9d69bd82aac1353f8b431502012412001b9ffcf08277f107a88b23e7175207bd98187ac634d1c525fa6f8503c6553244cdc546af04f706f40c4ec8b3948d1807b7b99ad9af8369ba9857b1487921501",
    "0x0a690880b4d7fab633122062fc03a1a33207956b6ff6583082446218b69957c1422c9e6398e4f3d7d9912c1a200000000004b2942046747455205e538e56e0bceea016df359a79e4e4c399cdc238a1a8ca254a1541a4ce68cfcdd27884bde52cec653354048e0aa98950201241b83ac71713ba86b239761eafe6eca721a40b7b6499654fa637521f4848d09bfa2c83bb9c303c4210c6c4b7caffa5993b171807481cf4e4f48368f7f56723f6b401",
    "0x0a6908b8cbd7fab63312205dfa3f784cb36fbfd393ba649685fcd712e5015ae92514dd630f0c1b94ea38211a200000000004b294217ece19bd3b7dc6bbbc03dc81e3190ce6d827d182d4f2870c38a2a8ca254a154114f2c09d3de3fe82a71960da65d4935a30b24e1f5020124109dc5151cf90ed11fc7c76c6e9832454fb0f0830c64a2c4a0123abdb4b45e51961b4e8bdc2020cf48554f5cd86c22d078e0c803729d7bb0a8defa96bc16e62af00",
    "0x0a6908f0e2d7fab6331220364e85c51b0f9c2f9958b2ea633b360608bd038777e454c075097f042e9823761a200000000004b29422a39c32d9906e7eec3ffef3edae53cf4de50bd12c5a1a8f0e38a3a8ca254a15414e4e68d51df137837ffda057af5efc587e01aac050201241c00da1ea9580e90e3c11c8c6e3d644c7c16b980acaeed2e05b82756dd162fcd83f827717977aa86f5d0e3a58c193d6f063ca02fa7cdb33c68aea45537ca0020d01",
    "0x0a6908a8fad7fab6331220a90e511b62157913fab9fc32285aa6d2103b8f1054e53f2fd105cf9b062cc79b1a200000000004b2942363a4e02704a2039fcbb9d1edadf1e554250011072db420d938a4a8ca254a1541beab998551416b02f6721129bb01b51fceceba0850201241089c48927f433b809251a3781943f0a3bee98657b5e9c528036ff0f2b90d2ff95b8658c39b12f6678e271c36518a119a6abd92c6ded92e89e9dde2b5c7dc8fa800",
    "0x0a6908e091d8fab6331220df12c058eece6b33333475c87bbbc88f1b54694e2a0dea5a45a024760b0331f31a200000000004b29424d176315682c3f2e7fe1e4a177f5f9f3fcf03eeb105f3b1bf38a5a8ca254a1541a1a508ce5762ffd3f16bd6af93808d26d57f01eb5020124119afced897f15273f8c918269321f1a3bdbad112fe9355aab063fad6757156b5241b0d437dafd9e6800ca4f4f7e1dfb04e59c2604e4092a3d6655433542a313e01",
    "0x0a690898a9d8fab6331220183a5c27f141287609f8afac182f3d3992116338f33c7a437c79cb6cf4e42c7c1a200000000004b294257ecd5ff0b97df34fa87269947a1f5117c268571f99f61b4638a6a8ca254a1541c189fa6fc9ed7a3580c3fe291915d5c6a6259be750201241701a2fb799942e33192b8ece2437fdf911d84d0d7157322eb8dc663e02b65e0a199fe4259ae3869015ca85b2dd14674f6ac44ef194afe50c91270059b476192e00"
  ]
}

================
File: build.rs
================
fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-changed=protos");

    tonic_prost_build::configure()
        .build_server(false)
        .boxed("BlockExtention")
        .compile_protos(&["protos/api/api.proto"], &["protos"])?;

    Ok(())
}

================
File: Cargo.toml
================
[package]
name = "tron"
version = "0.1.0"
edition = "2024"

[dependencies]
alloy = { version = "1.2.1", features = ["full"] }
anyhow = "1.0.100"
bs58 = { version = "0.5.1", features = ["check"] }
hex = "0.4.3"
k256 = "0.13.4"
prost = "0.14.1"
prost-types = "0.14.1"
sha2 = "0.10.9"
tonic = "0.14.2"
tonic-prost = "0.14.2"

[build-dependencies]
tonic-prost-build = "0.14.2"

[dev-dependencies]
serde = { version = "1.0.217", features = ["derive"] }
serde_json = "1.0.138"



================================================================
End of Codebase
================================================================
